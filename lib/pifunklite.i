# 1 "pifunk.c"
# 1 "/home/pi/PiFunk//"
# 1 "<built-in>"
#define __STDC__ 1
#define __STDC_VERSION__ 199901L
#define __STDC_HOSTED__ 1
#define __GNUC__ 6
#define __GNUC_MINOR__ 3
#define __GNUC_PATCHLEVEL__ 0
#define __VERSION__ "6.3.0 20170516"
#define __ATOMIC_RELAXED 0
#define __ATOMIC_SEQ_CST 5
#define __ATOMIC_ACQUIRE 2
#define __ATOMIC_RELEASE 3
#define __ATOMIC_ACQ_REL 4
#define __ATOMIC_CONSUME 1
#define __pic__ 2
#define __PIC__ 2
#define __OPTIMIZE__ 1
#define __FAST_MATH__ 1
#define __NO_MATH_ERRNO__ 1
#define __FINITE_MATH_ONLY__ 1
#define __SIZEOF_INT__ 4
#define __SIZEOF_LONG__ 4
#define __SIZEOF_LONG_LONG__ 8
#define __SIZEOF_SHORT__ 2
#define __SIZEOF_FLOAT__ 4
#define __SIZEOF_DOUBLE__ 8
#define __SIZEOF_LONG_DOUBLE__ 8
#define __SIZEOF_SIZE_T__ 4
#define __CHAR_BIT__ 8
#define __BIGGEST_ALIGNMENT__ 8
#define __ORDER_LITTLE_ENDIAN__ 1234
#define __ORDER_BIG_ENDIAN__ 4321
#define __ORDER_PDP_ENDIAN__ 3412
#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __SIZEOF_POINTER__ 4
#define __SIZE_TYPE__ unsigned int
#define __PTRDIFF_TYPE__ int
#define __WCHAR_TYPE__ unsigned int
#define __WINT_TYPE__ unsigned int
#define __INTMAX_TYPE__ long long int
#define __UINTMAX_TYPE__ long long unsigned int
#define __CHAR16_TYPE__ short unsigned int
#define __CHAR32_TYPE__ unsigned int
#define __SIG_ATOMIC_TYPE__ int
#define __INT8_TYPE__ signed char
#define __INT16_TYPE__ short int
#define __INT32_TYPE__ int
#define __INT64_TYPE__ long long int
#define __UINT8_TYPE__ unsigned char
#define __UINT16_TYPE__ short unsigned int
#define __UINT32_TYPE__ unsigned int
#define __UINT64_TYPE__ long long unsigned int
#define __INT_LEAST8_TYPE__ signed char
#define __INT_LEAST16_TYPE__ short int
#define __INT_LEAST32_TYPE__ int
#define __INT_LEAST64_TYPE__ long long int
#define __UINT_LEAST8_TYPE__ unsigned char
#define __UINT_LEAST16_TYPE__ short unsigned int
#define __UINT_LEAST32_TYPE__ unsigned int
#define __UINT_LEAST64_TYPE__ long long unsigned int
#define __INT_FAST8_TYPE__ signed char
#define __INT_FAST16_TYPE__ int
#define __INT_FAST32_TYPE__ int
#define __INT_FAST64_TYPE__ long long int
#define __UINT_FAST8_TYPE__ unsigned char
#define __UINT_FAST16_TYPE__ unsigned int
#define __UINT_FAST32_TYPE__ unsigned int
#define __UINT_FAST64_TYPE__ long long unsigned int
#define __INTPTR_TYPE__ int
#define __UINTPTR_TYPE__ unsigned int
#define __has_include(STR) __has_include__(STR)
#define __has_include_next(STR) __has_include_next__(STR)
#define __GXX_ABI_VERSION 1010
#define __SCHAR_MAX__ 0x7f
#define __SHRT_MAX__ 0x7fff
#define __INT_MAX__ 0x7fffffff
#define __LONG_MAX__ 0x7fffffffL
#define __LONG_LONG_MAX__ 0x7fffffffffffffffLL
#define __WCHAR_MAX__ 0xffffffffU
#define __WCHAR_MIN__ 0U
#define __WINT_MAX__ 0xffffffffU
#define __WINT_MIN__ 0U
#define __PTRDIFF_MAX__ 0x7fffffff
#define __SIZE_MAX__ 0xffffffffU
#define __INTMAX_MAX__ 0x7fffffffffffffffLL
#define __INTMAX_C(c) c ## LL
#define __UINTMAX_MAX__ 0xffffffffffffffffULL
#define __UINTMAX_C(c) c ## ULL
#define __SIG_ATOMIC_MAX__ 0x7fffffff
#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)
#define __INT8_MAX__ 0x7f
#define __INT16_MAX__ 0x7fff
#define __INT32_MAX__ 0x7fffffff
#define __INT64_MAX__ 0x7fffffffffffffffLL
#define __UINT8_MAX__ 0xff
#define __UINT16_MAX__ 0xffff
#define __UINT32_MAX__ 0xffffffffU
#define __UINT64_MAX__ 0xffffffffffffffffULL
#define __INT_LEAST8_MAX__ 0x7f
#define __INT8_C(c) c
#define __INT_LEAST16_MAX__ 0x7fff
#define __INT16_C(c) c
#define __INT_LEAST32_MAX__ 0x7fffffff
#define __INT32_C(c) c
#define __INT_LEAST64_MAX__ 0x7fffffffffffffffLL
#define __INT64_C(c) c ## LL
#define __UINT_LEAST8_MAX__ 0xff
#define __UINT8_C(c) c
#define __UINT_LEAST16_MAX__ 0xffff
#define __UINT16_C(c) c
#define __UINT_LEAST32_MAX__ 0xffffffffU
#define __UINT32_C(c) c ## U
#define __UINT_LEAST64_MAX__ 0xffffffffffffffffULL
#define __UINT64_C(c) c ## ULL
#define __INT_FAST8_MAX__ 0x7f
#define __INT_FAST16_MAX__ 0x7fffffff
#define __INT_FAST32_MAX__ 0x7fffffff
#define __INT_FAST64_MAX__ 0x7fffffffffffffffLL
#define __UINT_FAST8_MAX__ 0xff
#define __UINT_FAST16_MAX__ 0xffffffffU
#define __UINT_FAST32_MAX__ 0xffffffffU
#define __UINT_FAST64_MAX__ 0xffffffffffffffffULL
#define __INTPTR_MAX__ 0x7fffffff
#define __UINTPTR_MAX__ 0xffffffffU
#define __GCC_IEC_559 0
#define __GCC_IEC_559_COMPLEX 0
#define __FLT_EVAL_METHOD__ 0
#define __DEC_EVAL_METHOD__ 2
#define __FLT_RADIX__ 2
#define __FLT_MANT_DIG__ 24
#define __FLT_DIG__ 6
#define __FLT_MIN_EXP__ (-125)
#define __FLT_MIN_10_EXP__ (-37)
#define __FLT_MAX_EXP__ 128
#define __FLT_MAX_10_EXP__ 38
#define __FLT_DECIMAL_DIG__ 9
#define __FLT_MAX__ 3.4028234663852886e+38F
#define __FLT_MIN__ 1.1754943508222875e-38F
#define __FLT_EPSILON__ 1.1920928955078125e-7F
#define __FLT_DENORM_MIN__ 1.4012984643248171e-45F
#define __FLT_HAS_DENORM__ 1
#define __FLT_HAS_INFINITY__ 1
#define __FLT_HAS_QUIET_NAN__ 1
#define __DBL_MANT_DIG__ 53
#define __DBL_DIG__ 15
#define __DBL_MIN_EXP__ (-1021)
#define __DBL_MIN_10_EXP__ (-307)
#define __DBL_MAX_EXP__ 1024
#define __DBL_MAX_10_EXP__ 308
#define __DBL_DECIMAL_DIG__ 17
#define __DBL_MAX__ ((double)1.7976931348623157e+308L)
#define __DBL_MIN__ ((double)2.2250738585072014e-308L)
#define __DBL_EPSILON__ ((double)2.2204460492503131e-16L)
#define __DBL_DENORM_MIN__ ((double)4.9406564584124654e-324L)
#define __DBL_HAS_DENORM__ 1
#define __DBL_HAS_INFINITY__ 1
#define __DBL_HAS_QUIET_NAN__ 1
#define __LDBL_MANT_DIG__ 53
#define __LDBL_DIG__ 15
#define __LDBL_MIN_EXP__ (-1021)
#define __LDBL_MIN_10_EXP__ (-307)
#define __LDBL_MAX_EXP__ 1024
#define __LDBL_MAX_10_EXP__ 308
#define __DECIMAL_DIG__ 17
#define __LDBL_MAX__ 1.7976931348623157e+308L
#define __LDBL_MIN__ 2.2250738585072014e-308L
#define __LDBL_EPSILON__ 2.2204460492503131e-16L
#define __LDBL_DENORM_MIN__ 4.9406564584124654e-324L
#define __LDBL_HAS_DENORM__ 1
#define __LDBL_HAS_INFINITY__ 1
#define __LDBL_HAS_QUIET_NAN__ 1
#define __DEC32_MANT_DIG__ 7
#define __DEC32_MIN_EXP__ (-94)
#define __DEC32_MAX_EXP__ 97
#define __DEC32_MIN__ 1E-95DF
#define __DEC32_MAX__ 9.999999E96DF
#define __DEC32_EPSILON__ 1E-6DF
#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF
#define __DEC64_MANT_DIG__ 16
#define __DEC64_MIN_EXP__ (-382)
#define __DEC64_MAX_EXP__ 385
#define __DEC64_MIN__ 1E-383DD
#define __DEC64_MAX__ 9.999999999999999E384DD
#define __DEC64_EPSILON__ 1E-15DD
#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD
#define __DEC128_MANT_DIG__ 34
#define __DEC128_MIN_EXP__ (-6142)
#define __DEC128_MAX_EXP__ 6145
#define __DEC128_MIN__ 1E-6143DL
#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
#define __DEC128_EPSILON__ 1E-33DL
#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL
#define __SFRACT_FBIT__ 7
#define __SFRACT_IBIT__ 0
#define __SFRACT_MIN__ (-0.5HR-0.5HR)
#define __SFRACT_MAX__ 0X7FP-7HR
#define __SFRACT_EPSILON__ 0x1P-7HR
#define __USFRACT_FBIT__ 8
#define __USFRACT_IBIT__ 0
#define __USFRACT_MIN__ 0.0UHR
#define __USFRACT_MAX__ 0XFFP-8UHR
#define __USFRACT_EPSILON__ 0x1P-8UHR
#define __FRACT_FBIT__ 15
#define __FRACT_IBIT__ 0
#define __FRACT_MIN__ (-0.5R-0.5R)
#define __FRACT_MAX__ 0X7FFFP-15R
#define __FRACT_EPSILON__ 0x1P-15R
#define __UFRACT_FBIT__ 16
#define __UFRACT_IBIT__ 0
#define __UFRACT_MIN__ 0.0UR
#define __UFRACT_MAX__ 0XFFFFP-16UR
#define __UFRACT_EPSILON__ 0x1P-16UR
#define __LFRACT_FBIT__ 31
#define __LFRACT_IBIT__ 0
#define __LFRACT_MIN__ (-0.5LR-0.5LR)
#define __LFRACT_MAX__ 0X7FFFFFFFP-31LR
#define __LFRACT_EPSILON__ 0x1P-31LR
#define __ULFRACT_FBIT__ 32
#define __ULFRACT_IBIT__ 0
#define __ULFRACT_MIN__ 0.0ULR
#define __ULFRACT_MAX__ 0XFFFFFFFFP-32ULR
#define __ULFRACT_EPSILON__ 0x1P-32ULR
#define __LLFRACT_FBIT__ 63
#define __LLFRACT_IBIT__ 0
#define __LLFRACT_MIN__ (-0.5LLR-0.5LLR)
#define __LLFRACT_MAX__ 0X7FFFFFFFFFFFFFFFP-63LLR
#define __LLFRACT_EPSILON__ 0x1P-63LLR
#define __ULLFRACT_FBIT__ 64
#define __ULLFRACT_IBIT__ 0
#define __ULLFRACT_MIN__ 0.0ULLR
#define __ULLFRACT_MAX__ 0XFFFFFFFFFFFFFFFFP-64ULLR
#define __ULLFRACT_EPSILON__ 0x1P-64ULLR
#define __SACCUM_FBIT__ 7
#define __SACCUM_IBIT__ 8
#define __SACCUM_MIN__ (-0X1P7HK-0X1P7HK)
#define __SACCUM_MAX__ 0X7FFFP-7HK
#define __SACCUM_EPSILON__ 0x1P-7HK
#define __USACCUM_FBIT__ 8
#define __USACCUM_IBIT__ 8
#define __USACCUM_MIN__ 0.0UHK
#define __USACCUM_MAX__ 0XFFFFP-8UHK
#define __USACCUM_EPSILON__ 0x1P-8UHK
#define __ACCUM_FBIT__ 15
#define __ACCUM_IBIT__ 16
#define __ACCUM_MIN__ (-0X1P15K-0X1P15K)
#define __ACCUM_MAX__ 0X7FFFFFFFP-15K
#define __ACCUM_EPSILON__ 0x1P-15K
#define __UACCUM_FBIT__ 16
#define __UACCUM_IBIT__ 16
#define __UACCUM_MIN__ 0.0UK
#define __UACCUM_MAX__ 0XFFFFFFFFP-16UK
#define __UACCUM_EPSILON__ 0x1P-16UK
#define __LACCUM_FBIT__ 31
#define __LACCUM_IBIT__ 32
#define __LACCUM_MIN__ (-0X1P31LK-0X1P31LK)
#define __LACCUM_MAX__ 0X7FFFFFFFFFFFFFFFP-31LK
#define __LACCUM_EPSILON__ 0x1P-31LK
#define __ULACCUM_FBIT__ 32
#define __ULACCUM_IBIT__ 32
#define __ULACCUM_MIN__ 0.0ULK
#define __ULACCUM_MAX__ 0XFFFFFFFFFFFFFFFFP-32ULK
#define __ULACCUM_EPSILON__ 0x1P-32ULK
#define __LLACCUM_FBIT__ 31
#define __LLACCUM_IBIT__ 32
#define __LLACCUM_MIN__ (-0X1P31LLK-0X1P31LLK)
#define __LLACCUM_MAX__ 0X7FFFFFFFFFFFFFFFP-31LLK
#define __LLACCUM_EPSILON__ 0x1P-31LLK
#define __ULLACCUM_FBIT__ 32
#define __ULLACCUM_IBIT__ 32
#define __ULLACCUM_MIN__ 0.0ULLK
#define __ULLACCUM_MAX__ 0XFFFFFFFFFFFFFFFFP-32ULLK
#define __ULLACCUM_EPSILON__ 0x1P-32ULLK
#define __QQ_FBIT__ 7
#define __QQ_IBIT__ 0
#define __HQ_FBIT__ 15
#define __HQ_IBIT__ 0
#define __SQ_FBIT__ 31
#define __SQ_IBIT__ 0
#define __DQ_FBIT__ 63
#define __DQ_IBIT__ 0
#define __TQ_FBIT__ 127
#define __TQ_IBIT__ 0
#define __UQQ_FBIT__ 8
#define __UQQ_IBIT__ 0
#define __UHQ_FBIT__ 16
#define __UHQ_IBIT__ 0
#define __USQ_FBIT__ 32
#define __USQ_IBIT__ 0
#define __UDQ_FBIT__ 64
#define __UDQ_IBIT__ 0
#define __UTQ_FBIT__ 128
#define __UTQ_IBIT__ 0
#define __HA_FBIT__ 7
#define __HA_IBIT__ 8
#define __SA_FBIT__ 15
#define __SA_IBIT__ 16
#define __DA_FBIT__ 31
#define __DA_IBIT__ 32
#define __TA_FBIT__ 63
#define __TA_IBIT__ 64
#define __UHA_FBIT__ 8
#define __UHA_IBIT__ 8
#define __USA_FBIT__ 16
#define __USA_IBIT__ 16
#define __UDA_FBIT__ 32
#define __UDA_IBIT__ 32
#define __UTA_FBIT__ 64
#define __UTA_IBIT__ 64
#define __REGISTER_PREFIX__ 
#define __USER_LABEL_PREFIX__ 
#define __GNUC_STDC_INLINE__ 1
#define __STRICT_ANSI__ 1
#define __CHAR_UNSIGNED__ 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
#define __GCC_ATOMIC_BOOL_LOCK_FREE 1
#define __GCC_ATOMIC_CHAR_LOCK_FREE 1
#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 1
#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2
#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2
#define __GCC_ATOMIC_SHORT_LOCK_FREE 1
#define __GCC_ATOMIC_INT_LOCK_FREE 2
#define __GCC_ATOMIC_LONG_LOCK_FREE 2
#define __GCC_ATOMIC_LLONG_LOCK_FREE 1
#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1
#define __GCC_ATOMIC_POINTER_LOCK_FREE 2
#define __GCC_HAVE_DWARF2_CFI_ASM 1
#define __PRAGMA_REDEFINE_EXTNAME 1
#define __SIZEOF_WCHAR_T__ 4
#define __SIZEOF_WINT_T__ 4
#define __SIZEOF_PTRDIFF_T__ 4
#define __ARM_FEATURE_DSP 1
#define __ARM_FEATURE_QBIT 1
#define __ARM_FEATURE_SAT 1
#undef __ARM_FEATURE_CRYPTO
# 1 "<built-in>"
#define __ARM_FEATURE_UNALIGNED 1
#undef __ARM_FEATURE_QRDMX
# 1 "<built-in>"
#define __ARM_32BIT_STATE 1
#define __ARM_FEATURE_LDREX 4
#define __ARM_FEATURE_CLZ 1
#define __ARM_FEATURE_SIMD32 1
#define __ARM_SIZEOF_MINIMAL_ENUM 4
#define __ARM_SIZEOF_WCHAR_T 4
#define __arm__ 1
#define __ARM_ARCH 6
#define __ARM_ARCH_ISA_ARM 1
#define __APCS_32__ 1
#undef __thumb__
# 1 "<built-in>"
#undef __thumb2__
# 1 "<built-in>"
#undef __THUMBEL__
# 1 "<built-in>"
#define __ARM_ARCH_ISA_THUMB 1
#define __ARMEL__ 1
#define __VFP_FP__ 1
#define __ARM_FP 12
#undef __ARM_FEATURE_FMA
# 1 "<built-in>"
#undef __ARM_NEON__
# 1 "<built-in>"
#undef __ARM_NEON
# 1 "<built-in>"
#undef __ARM_NEON_FP
# 1 "<built-in>"
#define __THUMB_INTERWORK__ 1
#define __ARM_ARCH_6__ 1
#define __ARM_PCS_VFP 1
#define __ARM_EABI__ 1
#undef __ARM_ARCH_EXT_IDIV__
# 1 "<built-in>"
#undef __ARM_FEATURE_IDIV
# 1 "<built-in>"
#undef __ARM_ASM_SYNTAX_UNIFIED__
# 1 "<built-in>"
#define __GXX_TYPEINFO_EQUALITY_INLINE 0
#define __gnu_linux__ 1
#define __linux 1
#define __linux__ 1
#define __unix 1
#define __unix__ 1
#define __ELF__ 1
# 1 "<command-line>"
#define _USE_MATH_DEFINES 1
#define _GNU_SOURCE 1
#define _POSIX_C_SOURCE 200809L
#define RASPI1 1
# 1 "/usr/include/stdc-predef.h" 1 3 4

# 1 "/usr/include/stdc-predef.h" 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _STDC_PREDEF_H 1

/* This header is separate from features.h so that the compiler can
   include it implicitly at the start of every compilation.  It must
   not itself include <features.h> or any other header that includes
   <features.h> because the implicit include comes before any feature
   test macros that may be defined in a source file before it first
   explicitly includes a system header.  GCC knows the name of this
   header in order to preinclude it.  */

/* glibc's intent is to support the IEC 559 math functionality, real
   and complex.  If the GCC (4.9 and later) predefined macros
   specifying compiler intent are available, use them to determine
   whether the overall intent is to support these features; otherwise,
   presume an older compiler has intent to support these features and
   define these macros by default.  */
# 52 "/usr/include/stdc-predef.h" 3 4
/* wchar_t uses Unicode 9.0.0.  Version 9.0 of the Unicode Standard is
   synchronized with ISO/IEC 10646:2014, fourth edition, plus
   Amd. 1  and Amd. 2 and 273 characters from forthcoming  10646, fifth edition.
   (Amd. 2 was published 2016-05-01,
   see https://www.iso.org/obp/ui/#iso:std:iso-iec:10646:ed-4:v1:amd:2:v1:en) */
#define __STDC_ISO_10646__ 201605L

/* We do not support C11 <threads.h>.  */
#define __STDC_NO_THREADS__ 1
# 1 "<command-line>" 2
# 1 "pifunk.c"

# 1 "pifunk.c"
/* PiFunk (C) 2018-2019 silicator a.k.a wiesel

OS: raspbian (stretch) incl. desktop & recommended software v4.14 (8. April 2019) based on debian
SHA-256:a3ced697ca0481bb0ab3b1bd42c93eb24de6264f4b70ea0f7b6ecd74b33d83eb
-> get it here https://www.raspberrypi.org/downloads/raspbian/
-> or direct link https://downloads.raspberrypi.org/raspbian_full_latest => 2019-04-08-raspbian-stretch-full.zip
gcc 5.4.1 compiler or g++ 5.4.1 c++11/14
gdb 7.11.1 debugger

->get project:
 git clone https://github.com/silicator/PiFunk
->instructions:
 You will need alsa library for this:
sudo apt-get install libsndfile1-dev

sudo apt-get install libraspberrypi-dev raspberrypi-kernel-headers
 -lbcm_host //firmware v1.20190718 located in /opt/vc/include/

cd PiFunk // goto path

->lm flag for math lib (obligatory), -g3 for debugger, -c for not linkin to library
=>compile with admin/root permissions!!
 sudo gcc -g3 -std=c99 -lm -Iinclude -Llib -lsndfile -D_USE_MATH_DEFINES -D_GNU_C_SOURCE -D_POSIX_C_SOURCE=199309L -L/opt/vc/lib -lbcm_host -fPIC pifunk.c -shared  -O3 -o include/pifunk.i lib/pifunk.s lib/pifunk.o lib/pifunk.a lib/pifunk.so lib/pifunk.lib
 sudo gcc -g3 -std=c99 -lm -Iinclude -Llib -lsndfile -D_USE_MATH_DEFINES -D_GNU_SOURCE -D_POSIX_C_SOURCE=199309L -L/opt/vc/lib -lbcm_host -fPIC pifunk.c -shared  -O3 -o bin/pifunk bin/pifunk.out
 or do make (compile flags in make included)
 -std=c99 is the same as -std=iso9899:1999 or =gnu99 or -std=c++17 (11/14)
 -E tells to stop after preprocessing stage
 -v verbose



-> real gpio hardware can't be simulated by c or py code! must be executed and compiled on linux
virtual maschine possible with qemu or alternative with everpad: nor sure about this, rather not using it
 wget -o -http://beta.etherpad.org/p/pihackfm/export/txt >/dev/null | gcc -std=c99 -g -lm -x c && ./pifunk.out sound.wav

LICENSE: GPLv2/3 !!
!!!!!!! program needs more testing on real pi !!!!!!!

-----Disclaimer-----
Rewritten for own purposes!
no guarantee, warranty for anything! Usage at own risk!
you should ground your antenna, eventually diode or 10uF-caps
at least use dummyloads 50 ohm @ max. 4 watts (S = 0-level) and compare signals with swr/pwr-meter!
do not shortout or do overstress it with more than 3.3V! it may cause damages
more infs about GPIO electronics https://de.scribd.com/doc/101830961/GPIO-Pads-Control2
Access on ARM-System !!! Running Linux, mostly on Raspberry Pi (me B+ rev.2)
used python 3.7.x on original Raspbian
-----------------------
don't forget to apt-get upgrade and update

1) Pi-FM version - frequency modulation direction left/right ← , →
2) Pi-AM version - amplitude modulation direction up/down ↑ , ↓
--> 700 MHz system clock of the pi1 -> please use heatsink + fan

todo:
memory-stuff
pointer & address corrections
tone generator for ctss (sin?)
make compatible arguments/funcs for py/shell scripts
*/

//std includes
# 1 "/usr/include/stdio.h" 1 3 4

# 1 "/usr/include/stdio.h" 3 4
/* Define ISO C stdio on top of C++ iostreams.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.19 Input/output	<stdio.h>
 */




#define _STDIO_H 1
# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _FEATURES_H 1

/* These are defined by the user (or the compiler)
   to specify the desired environment:

   __STRICT_ANSI__	ISO Standard C.
   _ISOC99_SOURCE	Extensions to ISO C89 from ISO C99.
   _ISOC11_SOURCE	Extensions to ISO C99 from ISO C11.
   _POSIX_SOURCE	IEEE Std 1003.1.
   _POSIX_C_SOURCE	If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2;
			if >=199309L, add IEEE Std 1003.1b-1993;
			if >=199506L, add IEEE Std 1003.1c-1995;
			if >=200112L, all of IEEE 1003.1-2004
			if >=200809L, all of IEEE 1003.1-2008
   _XOPEN_SOURCE	Includes POSIX and XPG things.  Set to 500 if
			Single Unix conformance is wanted, to 600 for the
			sixth revision, to 700 for the seventh revision.
   _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.
   _LARGEFILE_SOURCE	Some more functions for correct standard I/O.
   _LARGEFILE64_SOURCE	Additional functionality from LFS for large files.
   _FILE_OFFSET_BITS=N	Select default filesystem interface.
   _ATFILE_SOURCE	Additional *at interfaces.
   _GNU_SOURCE		All of the above, plus GNU extensions.
   _DEFAULT_SOURCE	The default set of features (taking precedence over
			__STRICT_ANSI__).
   _REENTRANT		Select additionally reentrant object.
   _THREAD_SAFE		Same as _REENTRANT, often used by other systems.
   _FORTIFY_SOURCE	If set to numeric value > 0 additional security
			measures are defined, according to level.

   The `-ansi' switch to the GNU C compiler, and standards conformance
   options such as `-std=c99', define __STRICT_ANSI__.  If none of
   these are defined, or if _DEFAULT_SOURCE is defined, the default is
   to have _POSIX_SOURCE set to one and _POSIX_C_SOURCE set to
   200809L, as well as enabling miscellaneous functions from BSD and
   SVID.  If more than one of these are defined, they accumulate.  For
   example __STRICT_ANSI__, _POSIX_SOURCE and _POSIX_C_SOURCE together
   give you ISO C, 1003.1, and 1003.2, but nothing else.

   These are defined by this file and are used by the
   header files to decide what to declare or define:

   __USE_ISOC11		Define ISO C11 things.
   __USE_ISOC99		Define ISO C99 things.
   __USE_ISOC95		Define ISO C90 AMD1 (C95) things.
   __USE_POSIX		Define IEEE Std 1003.1 things.
   __USE_POSIX2		Define IEEE Std 1003.2 things.
   __USE_POSIX199309	Define IEEE Std 1003.1, and .1b things.
   __USE_POSIX199506	Define IEEE Std 1003.1, .1b, .1c and .1i things.
   __USE_XOPEN		Define XPG things.
   __USE_XOPEN_EXTENDED	Define X/Open Unix things.
   __USE_UNIX98		Define Single Unix V2 things.
   __USE_XOPEN2K        Define XPG6 things.
   __USE_XOPEN2KXSI     Define XPG6 XSI things.
   __USE_XOPEN2K8       Define XPG7 things.
   __USE_XOPEN2K8XSI    Define XPG7 XSI things.
   __USE_LARGEFILE	Define correct standard I/O things.
   __USE_LARGEFILE64	Define LFS things with separate names.
   __USE_FILE_OFFSET64	Define 64bit interface as default.
   __USE_MISC		Define things from 4.3BSD or System V Unix.
   __USE_ATFILE		Define *at interfaces and AT_* constants for them.
   __USE_GNU		Define GNU extensions.
   __USE_REENTRANT	Define reentrant/thread-safe *_r functions.
   __USE_FORTIFY_LEVEL	Additional security measures used, according to level.

   The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are
   defined by this file unconditionally.  `__GNU_LIBRARY__' is provided
   only for compatibility.  All new code should use the other symbols
   to test for features.

   All macros listed above as possibly being defined by this file are
   explicitly undefined if they are not explicitly defined.
   Feature-test macros that are not defined by the user or compiler
   but are implied by the other feature-test macros defined (or by the
   lack of any definitions) are defined by the file.  */


/* Undefine everything, so we get a clean slate.  */
#undef __USE_ISOC11
#undef __USE_ISOC99
#undef __USE_ISOC95
#undef __USE_ISOCXX11
#undef __USE_POSIX
#undef __USE_POSIX2
#undef __USE_POSIX199309
#undef __USE_POSIX199506
#undef __USE_XOPEN
#undef __USE_XOPEN_EXTENDED
#undef __USE_UNIX98
#undef __USE_XOPEN2K
#undef __USE_XOPEN2KXSI
#undef __USE_XOPEN2K8
#undef __USE_XOPEN2K8XSI
#undef __USE_LARGEFILE
#undef __USE_LARGEFILE64
#undef __USE_FILE_OFFSET64
#undef __USE_MISC
#undef __USE_ATFILE
#undef __USE_GNU
#undef __USE_REENTRANT
#undef __USE_FORTIFY_LEVEL
#undef __KERNEL_STRICT_NAMES

/* Suppress kernel-name space pollution unless user expressedly asks
   for it.  */

#define __KERNEL_STRICT_NAMES 


/* Convenience macros to test the versions of glibc and gcc.
   Use them like this:
   #if __GNUC_PREREQ (2,8)
   ... code requiring gcc 2.8 or later ...
   #endif
   Note - they won't work for gcc1 or glibc1, since the _MINOR macros
   were not defined then.  */

#define __GNUC_PREREQ(maj,min) ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))





/* _BSD_SOURCE and _SVID_SOURCE are deprecated aliases for
   _DEFAULT_SOURCE.  If _DEFAULT_SOURCE is present we do not
   issue a warning; the expectation is that the source is being
   transitioned to use the new macro.  */







/* If _GNU_SOURCE was defined by the user, turn on all the other features.  */

#undef _ISOC95_SOURCE
#define _ISOC95_SOURCE 1
#undef _ISOC99_SOURCE
#define _ISOC99_SOURCE 1
#undef _ISOC11_SOURCE
#define _ISOC11_SOURCE 1
#undef _POSIX_SOURCE
#define _POSIX_SOURCE 1
#undef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 200809L
#undef _XOPEN_SOURCE
#define _XOPEN_SOURCE 700
#undef _XOPEN_SOURCE_EXTENDED
#define _XOPEN_SOURCE_EXTENDED 1
#undef _LARGEFILE64_SOURCE
#define _LARGEFILE64_SOURCE 1
#undef _DEFAULT_SOURCE
#define _DEFAULT_SOURCE 1
#undef _ATFILE_SOURCE
#define _ATFILE_SOURCE 1


/* If nothing (other than _GNU_SOURCE and _DEFAULT_SOURCE) is defined,
   define _DEFAULT_SOURCE.  */





#undef _DEFAULT_SOURCE
#define _DEFAULT_SOURCE 1


/* This is to enable the ISO C11 extension.  */


#define __USE_ISOC11 1


/* This is to enable the ISO C99 extension.  */


#define __USE_ISOC99 1


/* This is to enable the ISO C90 Amendment 1:1995 extension.  */


#define __USE_ISOC95 1


/* This is to enable compatibility for ISO C++11.

   So far g++ does not provide a macro.  Check the temporary macro for
   now, too.  */





/* If none of the ANSI/POSIX macros are defined, or if _DEFAULT_SOURCE
   is defined, use POSIX.1-2008 (or another version depending on
   _XOPEN_SOURCE).  */




#undef _POSIX_SOURCE
#define _POSIX_SOURCE 1
#undef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 200809L
# 246 "/usr/include/features.h" 3 4
#define __USE_POSIX 1



#define __USE_POSIX2 1



#define __USE_POSIX199309 1



#define __USE_POSIX199506 1



#define __USE_XOPEN2K 1
#undef __USE_ISOC95
#define __USE_ISOC95 1
#undef __USE_ISOC99
#define __USE_ISOC99 1



#define __USE_XOPEN2K8 1
#undef _ATFILE_SOURCE
#define _ATFILE_SOURCE 1



#define __USE_XOPEN 1

#define __USE_XOPEN_EXTENDED 1
#define __USE_UNIX98 1
#undef _LARGEFILE_SOURCE
#define _LARGEFILE_SOURCE 1


#define __USE_XOPEN2K8 1
#define __USE_XOPEN2K8XSI 1

#define __USE_XOPEN2K 1
#define __USE_XOPEN2KXSI 1
#undef __USE_ISOC95
#define __USE_ISOC95 1
#undef __USE_ISOC99
#define __USE_ISOC99 1
# 302 "/usr/include/features.h" 3 4
#define __USE_LARGEFILE 1



#define __USE_LARGEFILE64 1







#define __USE_MISC 1



#define __USE_ATFILE 1



#define __USE_GNU 1
# 337 "/usr/include/features.h" 3 4
#define __USE_FORTIFY_LEVEL 0


/* Get definitions of __STDC_* predefined macros, if the compiler has
   not preincluded this header automatically.  */
# 1 "/usr/include/stdc-predef.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 343 "/usr/include/features.h" 2 3 4

/* This macro indicates that the installed library is the GNU C Library.
   For historic reasons the value now is 6 and this will stay from now
   on.  The use of this variable is deprecated.  Use __GLIBC__ and
   __GLIBC_MINOR__ now (see below) when you want to test for a specific
   GNU C library version and use the values in <gnu/lib-names.h> to get
   the sonames of the shared libraries.  */
#undef __GNU_LIBRARY__
#define __GNU_LIBRARY__ 6

/* Major and minor version number of the GNU C library package.  Use
   these macros to test for features in specific releases.  */
#define __GLIBC__ 2
#define __GLIBC_MINOR__ 24

#define __GLIBC_PREREQ(maj,min) ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= ((maj) << 16) + (min))


/* This is here only because every header file already includes this one.  */


# 1 "/usr/include/arm-linux-gnueabihf/sys/cdefs.h" 1 3 4
/* Copyright (C) 1992-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _SYS_CDEFS_H 1

/* We are almost always included from features.h. */




/* The GNU libc does not support any K&R compilers or the traditional mode
   of ISO C compilers anymore.  Check for some of the combinations not
   anymore supported.  */




/* Some user header file might have defined this before.  */
#undef __P
#undef __PMT



/* All functions, except those with callbacks or those that
   synchronize memory, are leaf functions.  */

#define __LEAF , __leaf__
#define __LEAF_ATTR __attribute__ ((__leaf__))





/* GCC can always grok prototypes.  For C++ programs we add throw()
   to help it optimize the function calls.  But this works only with
   gcc 2.8.x and egcs.  For gcc 3.2 and up we even mark C functions
   as non-throwing using a function attribute since programs can use
   the -fexceptions options for C code as well.  */

#define __THROW __attribute__ ((__nothrow__ __LEAF))
#define __THROWNL __attribute__ ((__nothrow__))
#define __NTH(fct) __attribute__ ((__nothrow__ __LEAF)) fct
# 80 "/usr/include/arm-linux-gnueabihf/sys/cdefs.h" 3 4
/* These two macros are not used in glibc anymore.  They are kept here
   only because some other projects expect the macros to be defined.  */
#define __P(args) args
#define __PMT(args) args

/* For these things, GCC behaves the ANSI way normally,
   and the non-ANSI way under -traditional.  */

#define __CONCAT(x,y) x ## y
#define __STRING(x) #x

/* This is not a typedef so `const __ptr_t' does the right thing.  */
#define __ptr_t void *
#define __long_double_t long double


/* C++ needs to know that types and declarations are C, not C++.  */




#define __BEGIN_DECLS 
#define __END_DECLS 



/* The standard library needs the functions from the ISO C90 standard
   in the std namespace.  At the same time we want to be safe for
   future changes and we include the ISO C99 code in the non-standard
   namespace __c99.  The C++ wrapper header take case of adding the
   definitions to the global namespace.  */
# 119 "/usr/include/arm-linux-gnueabihf/sys/cdefs.h" 3 4
/* For compatibility we do not add the declarations into any
   namespace.  They will end up in the global namespace which is what
   old code expects.  */
#define __BEGIN_NAMESPACE_STD 
#define __END_NAMESPACE_STD 
#define __USING_NAMESPACE_STD(name) 
#define __BEGIN_NAMESPACE_C99 
#define __END_NAMESPACE_C99 
#define __USING_NAMESPACE_C99(name) 



/* Fortify support.  */
#define __bos(ptr) __builtin_object_size (ptr, __USE_FORTIFY_LEVEL > 1)
#define __bos0(ptr) __builtin_object_size (ptr, 0)


#define __warndecl(name,msg) extern void name (void) __attribute__((__warning__ (msg)))

#define __warnattr(msg) __attribute__((__warning__ (msg)))
#define __errordecl(name,msg) extern void name (void) __attribute__((__error__ (msg)))







/* Support for flexible arrays.  */

/* GCC 2.97 supports C99 flexible array members.  */
#define __flexarr []
# 165 "/usr/include/arm-linux-gnueabihf/sys/cdefs.h" 3 4
/* __asm__ ("xyz") is used throughout the headers to rename functions
   at the assembly language level.  This is wrapped by the __REDIRECT
   macro, in order to support compilers that can do this some other
   way.  When compilers don't support asm-names at all, we have to do
   preprocessor tricks instead (which don't have exactly the right
   semantics, but it's the best we can do).

   Example:
   int __REDIRECT(setpgrp, (__pid_t pid, __pid_t pgrp), setpgid); */



#define __REDIRECT(name,proto,alias) name proto __asm__ (__ASMNAME (#alias))






#define __REDIRECT_NTH(name,proto,alias) name proto __asm__ (__ASMNAME (#alias)) __THROW

#define __REDIRECT_NTHNL(name,proto,alias) name proto __asm__ (__ASMNAME (#alias)) __THROWNL


#define __ASMNAME(cname) __ASMNAME2 (__USER_LABEL_PREFIX__, cname)
#define __ASMNAME2(prefix,cname) __STRING (prefix) cname

/*
#elif __SOME_OTHER_COMPILER__

# define __REDIRECT(name, proto, alias) name proto; 	_Pragma("let " #name " = " #alias)
)
*/


/* GCC has various useful declarations that can be made with the
   `__attribute__' syntax.  All of the ways we use this do fine if
   they are omitted for compilers that don't understand it. */




/* At some point during the gcc 2.96 development the `malloc' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  */

#define __attribute_malloc__ __attribute__ ((__malloc__))




/* Tell the compiler which arguments to an allocation function
   indicate the size of the allocation.  */

#define __attribute_alloc_size__(params) __attribute__ ((__alloc_size__ params))





/* At some point during the gcc 2.96 development the `pure' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  */

#define __attribute_pure__ __attribute__ ((__pure__))




/* This declaration tells the compiler that the value is constant.  */

#define __attribute_const__ __attribute__ ((__const__))




/* At some point during the gcc 3.1 development the `used' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  */

#define __attribute_used__ __attribute__ ((__used__))
#define __attribute_noinline__ __attribute__ ((__noinline__))





/* gcc allows marking deprecated functions.  */

#define __attribute_deprecated__ __attribute__ ((__deprecated__))




/* At some point during the gcc 2.8 development the `format_arg' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.
   If several `format_arg' attributes are given for the same function, in
   gcc-3.0 and older, all but the last one are ignored.  In newer gccs,
   all designated arguments are considered.  */

#define __attribute_format_arg__(x) __attribute__ ((__format_arg__ (x)))




/* At some point during the gcc 2.97 development the `strfmon' format
   attribute for functions was introduced.  We don't want to use it
   unconditionally (although this would be possible) since it
   generates warnings.  */

#define __attribute_format_strfmon__(a,b) __attribute__ ((__format__ (__strfmon__, a, b)))





/* The nonull function attribute allows to mark pointer parameters which
   must not be NULL.  */

#define __nonnull(params) __attribute__ ((__nonnull__ params))




/* If fortification mode, we warn about unused results of certain
   function calls which can lead to problems.  */

#define __attribute_warn_unused_result__ __attribute__ ((__warn_unused_result__))
# 302 "/usr/include/arm-linux-gnueabihf/sys/cdefs.h" 3 4
#define __wur 


/* Forces a function to be always inlined.  */

/* The Linux kernel defines __always_inline in stddef.h (283d7573), and
   it conflicts with this definition.  Therefore undefine it first to
   allow either header to be included first.  */
#undef __always_inline
#define __always_inline __inline __attribute__ ((__always_inline__))





/* Associate error messages with the source location of the call site rather
   than with the source location inside the function.  */

#define __attribute_artificial__ __attribute__ ((__artificial__))




/* GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
   inline semantics, unless -fgnu89-inline is used.  Using __GNUC_STDC_INLINE__
   or __GNUC_GNU_INLINE is not a good enough check for gcc because gcc versions
   older than 4.3 may define these macros and still not guarantee GNU inlining
   semantics.

   clang++ identifies itself as gcc-4.2, but has support for GNU inlining
   semantics, that can be checked fot by using the __GNUC_STDC_INLINE_ and
   __GNUC_GNU_INLINE__ macro definitions.  */




#define __extern_inline extern __inline __attribute__ ((__gnu_inline__))
#define __extern_always_inline extern __always_inline __attribute__ ((__gnu_inline__))
# 348 "/usr/include/arm-linux-gnueabihf/sys/cdefs.h" 3 4
#define __fortify_function __extern_always_inline __attribute_artificial__


/* GCC 4.3 and above allow passing all anonymous arguments of an
   __extern_always_inline function to some other vararg function.  */

#define __va_arg_pack() __builtin_va_arg_pack ()
#define __va_arg_pack_len() __builtin_va_arg_pack_len ()


/* It is possible to compile containing GCC extensions even if GCC is
   run in pedantic mode if the uses are carefully marked using the
   `__extension__' keyword.  But this is not generally available before
   version 2.8.  */




/* __restrict is known in EGCS 1.2 and above. */




/* ISO C99 also allows to declare arrays as non-overlapping.  The syntax is
     array_name[restrict]
   GCC 3.1 supports this.  */

#define __restrict_arr __restrict
# 390 "/usr/include/arm-linux-gnueabihf/sys/cdefs.h" 3 4
#define __glibc_unlikely(cond) __builtin_expect ((cond), 0)
#define __glibc_likely(cond) __builtin_expect ((cond), 1)
# 410 "/usr/include/arm-linux-gnueabihf/sys/cdefs.h" 3 4
#define _Static_assert(expr,diagnostic) extern int (*__Static_assert_function (void)) [!!sizeof (struct { int __error_if_negative: (expr) ? 2 : -1; })]




# 1 "/usr/include/arm-linux-gnueabihf/bits/wordsize.h" 1 3 4
/* Copyright (C) 1999-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#define __WORDSIZE 32
# 416 "/usr/include/arm-linux-gnueabihf/sys/cdefs.h" 2 3 4
# 437 "/usr/include/arm-linux-gnueabihf/sys/cdefs.h" 3 4
#define __LDBL_REDIR1(name,proto,alias) name proto
#define __LDBL_REDIR(name,proto) name proto
#define __LDBL_REDIR1_NTH(name,proto,alias) name proto __THROW
#define __LDBL_REDIR_NTH(name,proto) name proto __THROW
#define __LDBL_REDIR_DECL(name) 

#define __REDIRECT_LDBL(name,proto,alias) __REDIRECT (name, proto, alias)
#define __REDIRECT_NTH_LDBL(name,proto,alias) __REDIRECT_NTH (name, proto, alias)
# 365 "/usr/include/features.h" 2 3 4


/* If we don't have __REDIRECT, prototypes will be missing if
   __USE_FILE_OFFSET64 but not __USE_LARGEFILE[64]. */







/* Decide whether we can define 'extern inline' functions in headers.  */



#define __USE_EXTERN_INLINES 1



/* This is here only because every header file already includes this one.
   Get the definitions of all the appropriate `__stub_FUNCTION' symbols.
   <gnu/stubs.h> contains `#define __stub_FUNCTION' when FUNCTION is a stub
   that will always return failure (and set errno to ENOSYS).  */
# 1 "/usr/include/arm-linux-gnueabihf/gnu/stubs.h" 1 3 4
/* This file is automatically generated.
   This file selects the right generated file of `__stub_FUNCTION' macros
   based on the architecture being compiled for.  */






# 1 "/usr/include/arm-linux-gnueabihf/gnu/stubs-hard.h" 1 3 4
/* This file is automatically generated.
   It defines a symbol `__stub_FUNCTION' for each function
   in the C library which is a stub, meaning it will fail
   every time called, usually setting errno to ENOSYS.  */





#define __stub___compat_create_module 
#define __stub___compat_get_kernel_syms 
#define __stub___compat_query_module 
#define __stub_chflags 
#define __stub_fattach 
#define __stub_fchflags 
#define __stub_fdetach 
#define __stub_getmsg 
#define __stub_getpmsg 
#define __stub_gtty 
#define __stub_lchmod 
#define __stub_putmsg 
#define __stub_putpmsg 
#define __stub_revoke 
#define __stub_setlogin 
#define __stub_sigreturn 
#define __stub_sstk 
#define __stub_stty 
# 11 "/usr/include/arm-linux-gnueabihf/gnu/stubs.h" 2 3 4
# 389 "/usr/include/features.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4



#define __need_size_t 
#define __need_NULL 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 165 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 187 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#define __size_t__ 
#define __SIZE_T__ 
#define _SIZE_T 
#define _SYS_SIZE_T_H 
#define _T_SIZE_ 
#define _T_SIZE 
#define __SIZE_T 
#define _SIZE_T_ 
#define _BSD_SIZE_T_ 
#define _SIZE_T_DEFINED_ 
#define _SIZE_T_DEFINED 
#define _BSD_SIZE_T_DEFINED_ 
#define _SIZE_T_DECLARED 
#define ___int_size_t_h 
#define _GCC_SIZE_T 
#define _SIZET_ 







#define __size_t 





typedef unsigned int size_t;
# 238 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 362 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL
# 34 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */


#define _BITS_TYPES_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 27 "/usr/include/arm-linux-gnueabihf/bits/types.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/wordsize.h" 1 3 4
/* Copyright (C) 1999-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#define __WORDSIZE 32
# 28 "/usr/include/arm-linux-gnueabihf/bits/types.h" 2 3 4

/* Convenience types.  */
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;

/* Fixed-size types, underlying types depend on word size and compiler.  */
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;




__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;


/* quad_t is also 64 bits.  */




__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;



/* The machine-dependent file <bits/typesizes.h> defines __*_T_TYPE
   macros for each of the OS types we define below.  The definitions
   of those macros must use the following macros for underlying types.
   We define __S<SIZE>_TYPE and __U<SIZE>_TYPE for the signed and unsigned
   variants of each of the following integer types on this machine.

	16		-- "natural" 16-bit type (always short)
	32		-- "natural" 32-bit type (always int)
	64		-- "natural" 64-bit type (long or long long)
	LONG32		-- 32-bit type, traditionally long
	QUAD		-- 64-bit type, always long long
	WORD		-- natural type of __WORDSIZE bits (int or long)
	LONGWORD	-- type of __WORDSIZE bits, traditionally long

   We distinguish WORD/LONGWORD, 32/LONG32, and 64/QUAD so that the
   conventional uses of `long' or `long long' type modifiers match the
   types we define, even when a less-adorned type would be the same size.
   This matters for (somewhat) portably writing printf/scanf formats for
   these types, where using the appropriate l or ll format modifiers can
   make the typedefs and the formats match up across all GNU platforms.  If
   we used `long' when it's 64 bits where `long long' is expected, then the
   compiler would warn about the formats not matching the argument types,
   and the programmer changing them to shut up the compiler would break the
   program's portability.

   Here we assume what is presently the case in all the GCC configurations
   we support: long long is always 64 bits, long is always word/address size,
   and int is always 32 bits.  */

#define __S16_TYPE short int
#define __U16_TYPE unsigned short int
#define __S32_TYPE int
#define __U32_TYPE unsigned int
#define __SLONGWORD_TYPE long int
#define __ULONGWORD_TYPE unsigned long int

#define __SQUAD_TYPE __quad_t
#define __UQUAD_TYPE __u_quad_t
#define __SWORD_TYPE int
#define __UWORD_TYPE unsigned int
#define __SLONG32_TYPE long int
#define __ULONG32_TYPE unsigned long int
#define __S64_TYPE __quad_t
#define __U64_TYPE __u_quad_t
/* We want __extension__ before typedef's that use nonstandard base types
   such as `long long' in C89 mode.  */
#define __STD_TYPE __extension__ typedef
# 121 "/usr/include/arm-linux-gnueabihf/bits/types.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/typesizes.h" 1 3 4
/* bits/typesizes.h -- underlying types for *_t.  Generic version.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






#define _BITS_TYPESIZES_H 1

/* See <bits/types.h> for the meaning of these macros.  This file exists so
   that <bits/types.h> need not vary across different GNU platforms.  */

#define __DEV_T_TYPE __UQUAD_TYPE
#define __UID_T_TYPE __U32_TYPE
#define __GID_T_TYPE __U32_TYPE
#define __INO_T_TYPE __ULONGWORD_TYPE
#define __INO64_T_TYPE __UQUAD_TYPE
#define __MODE_T_TYPE __U32_TYPE
#define __NLINK_T_TYPE __UWORD_TYPE
#define __OFF_T_TYPE __SLONGWORD_TYPE
#define __OFF64_T_TYPE __SQUAD_TYPE
#define __PID_T_TYPE __S32_TYPE
#define __RLIM_T_TYPE __ULONGWORD_TYPE
#define __RLIM64_T_TYPE __UQUAD_TYPE
#define __BLKCNT_T_TYPE __SLONGWORD_TYPE
#define __BLKCNT64_T_TYPE __SQUAD_TYPE
#define __FSBLKCNT_T_TYPE __ULONGWORD_TYPE
#define __FSBLKCNT64_T_TYPE __UQUAD_TYPE
#define __FSFILCNT_T_TYPE __ULONGWORD_TYPE
#define __FSFILCNT64_T_TYPE __UQUAD_TYPE
#define __FSWORD_T_TYPE __SWORD_TYPE
#define __ID_T_TYPE __U32_TYPE
#define __CLOCK_T_TYPE __SLONGWORD_TYPE
#define __TIME_T_TYPE __SLONGWORD_TYPE
#define __USECONDS_T_TYPE __U32_TYPE
#define __SUSECONDS_T_TYPE __SLONGWORD_TYPE
#define __DADDR_T_TYPE __S32_TYPE
#define __KEY_T_TYPE __S32_TYPE
#define __CLOCKID_T_TYPE __S32_TYPE
#define __TIMER_T_TYPE void *
#define __BLKSIZE_T_TYPE __SLONGWORD_TYPE
#define __FSID_T_TYPE struct { int __val[2]; }
#define __SSIZE_T_TYPE __SWORD_TYPE
#define __SYSCALL_SLONG_TYPE __SLONGWORD_TYPE
#define __SYSCALL_ULONG_TYPE __ULONGWORD_TYPE
#define __CPU_MASK_TYPE __ULONGWORD_TYPE
# 74 "/usr/include/arm-linux-gnueabihf/bits/typesizes.h" 3 4
/* Number of descriptors that can fit in an `fd_set'.  */
#define __FD_SETSIZE 1024
# 122 "/usr/include/arm-linux-gnueabihf/bits/types.h" 2 3 4


__extension__ typedef __u_quad_t __dev_t; /* Type of device numbers.  */
__extension__ typedef unsigned int __uid_t; /* Type of user identifications.  */
__extension__ typedef unsigned int __gid_t; /* Type of group identifications.  */
__extension__ typedef unsigned long int __ino_t; /* Type of file serial numbers.  */
__extension__ typedef __u_quad_t __ino64_t; /* Type of file serial numbers (LFS).*/
__extension__ typedef unsigned int __mode_t; /* Type of file attribute bitmasks.  */
__extension__ typedef unsigned int __nlink_t; /* Type of file link counts.  */
__extension__ typedef long int __off_t; /* Type of file sizes and offsets.  */
__extension__ typedef __quad_t __off64_t; /* Type of file sizes and offsets (LFS).  */
__extension__ typedef int __pid_t; /* Type of process identifications.  */
__extension__ typedef struct { int __val[2]; } __fsid_t; /* Type of file system IDs.  */
__extension__ typedef long int __clock_t; /* Type of CPU usage counts.  */
__extension__ typedef unsigned long int __rlim_t; /* Type for resource measurement.  */
__extension__ typedef __u_quad_t __rlim64_t; /* Type for resource measurement (LFS).  */
__extension__ typedef unsigned int __id_t; /* General type for IDs.  */
__extension__ typedef long int __time_t; /* Seconds since the Epoch.  */
__extension__ typedef unsigned int __useconds_t; /* Count of microseconds.  */
__extension__ typedef long int __suseconds_t; /* Signed count of microseconds.  */

__extension__ typedef int __daddr_t; /* The type of a disk address.  */
__extension__ typedef int __key_t; /* Type of an IPC key.  */

/* Clock ID used in clock and timer functions.  */
__extension__ typedef int __clockid_t;

/* Timer ID returned by `timer_create'.  */
__extension__ typedef void * __timer_t;

/* Type to represent block size.  */
__extension__ typedef long int __blksize_t;

/* Types from the Large File Support interface.  */

/* Type to count number of disk blocks.  */
__extension__ typedef long int __blkcnt_t;
__extension__ typedef __quad_t __blkcnt64_t;

/* Type to count file system blocks.  */
__extension__ typedef unsigned long int __fsblkcnt_t;
__extension__ typedef __u_quad_t __fsblkcnt64_t;

/* Type to count file system nodes.  */
__extension__ typedef unsigned long int __fsfilcnt_t;
__extension__ typedef __u_quad_t __fsfilcnt64_t;

/* Type of miscellaneous file system fields.  */
__extension__ typedef int __fsword_t;

__extension__ typedef int __ssize_t; /* Type of a byte count, or error.  */

/* Signed long type used in system calls.  */
__extension__ typedef long int __syscall_slong_t;
/* Unsigned long type used in system calls.  */
__extension__ typedef unsigned long int __syscall_ulong_t;

/* These few don't really vary by system, they always correspond
   to one of the other defined types.  */
typedef __off64_t __loff_t; /* Type of file sizes and offsets (LFS).  */
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;

/* Duplicates info from stdint.h but this is used in unistd.h.  */
__extension__ typedef int __intptr_t;

/* Duplicate info from sys/socket.h.  */
__extension__ typedef unsigned int __socklen_t;


#undef __STD_TYPE
# 36 "/usr/include/stdio.h" 2 3 4
#define __need_FILE 
#define __need___FILE 





/* Define outside of namespace so the C++ is happy.  */
struct _IO_FILE;


/* The opaque type of streams.  This is the definition used elsewhere.  */
typedef struct _IO_FILE FILE;







#define __FILE_defined 1

#undef __need_FILE




/* The opaque type of streams.  This is the definition used elsewhere.  */
typedef struct _IO_FILE __FILE;

#define ____FILE_defined 1

#undef __need___FILE



#define _STDIO_USES_IOSTREAM 

# 1 "/usr/include/libio.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Written by Per Bothner <bothner@cygnus.com>.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.

   As a special exception, if you link the code in this file with
   files compiled with a GNU compiler to produce an executable,
   that does not cause the resulting executable to be covered by
   the GNU Lesser General Public License.  This exception does not
   however invalidate any other reasons why the executable file
   might be covered by the GNU Lesser General Public License.
   This exception applies to code released by its copyright holders
   in files containing the exception.  */


#define _IO_STDIO_H 

# 1 "/usr/include/_G_config.h" 1 3 4
/* This file is needed by libio to define various configuration parameters.
   These are always the same in the GNU C library.  */


#define _G_config_h 1

/* Define types for libio in terms of the standard internal type names.  */

# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 10 "/usr/include/_G_config.h" 2 3 4
#define __need_size_t 



#define __need_NULL 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 165 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 362 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL
# 16 "/usr/include/_G_config.h" 2 3 4
#define __need_mbstate_t 



# 1 "/usr/include/wchar.h" 1 3 4
/* Copyright (C) 1995-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *      ISO C99 Standard: 7.24
 *	Extended multibyte and wide character utilities	<wchar.h>
 */
# 80 "/usr/include/wchar.h" 3 4
#define ____mbstate_t_defined 1
/* Conversion state information.  */
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value; /* Value so far.  */
} __mbstate_t;

#undef __need_mbstate_t


/* The rest of the file is only used if used if __need_mbstate_t is not
   defined.  */
# 900 "/usr/include/wchar.h" 3 4
/* Undefine all __need_* constants in case we are included to get those
   constants but the whole file was already read.  */
#undef __need_mbstate_t
#undef __need_wint_t
# 21 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 45 "/usr/include/_G_config.h" 3 4
/* These library features are always available in the GNU C library.  */
#define _G_va_list __gnuc_va_list

#define _G_HAVE_MMAP 1
#define _G_HAVE_MREMAP 1

#define _G_IO_IO_FILE_VERSION 0x20001

/* This is defined by <bits/stat.h> if `st_blksize' exists.  */
#define _G_HAVE_ST_BLKSIZE defined (_STATBUF_ST_BLKSIZE)

#define _G_BUFSIZ 8192
# 32 "/usr/include/libio.h" 2 3 4
/* ALL of these should be defined in _G_config.h */
#define _IO_fpos_t _G_fpos_t
#define _IO_fpos64_t _G_fpos64_t
#define _IO_size_t size_t
#define _IO_ssize_t __ssize_t
#define _IO_off_t __off_t
#define _IO_off64_t __off64_t
#define _IO_pid_t __pid_t
#define _IO_uid_t __uid_t
#define _IO_iconv_t _G_iconv_t
#define _IO_HAVE_ST_BLKSIZE _G_HAVE_ST_BLKSIZE
#define _IO_BUFSIZ _G_BUFSIZ
#define _IO_va_list _G_va_list
#define _IO_wint_t wint_t

/* This define avoids name pollution if we're using GNU stdarg.h */
#define __need___va_list 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stdarg.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */







#undef __need___va_list

/* Define __gnuc_va_list.  */


#define __GNUC_VA_LIST 
typedef __builtin_va_list __gnuc_va_list;


/* Define the standard macros for the user,
   if this invocation was from the user program.  */
# 50 "/usr/include/libio.h" 2 3 4

#undef _IO_va_list
#define _IO_va_list __gnuc_va_list






#define _IO_UNIFIED_JUMPTABLES 1


#define EOF (-1)
# 77 "/usr/include/libio.h" 3 4
#define _IOS_INPUT 1
#define _IOS_OUTPUT 2
#define _IOS_ATEND 4
#define _IOS_APPEND 8
#define _IOS_TRUNC 16
#define _IOS_NOCREATE 32
#define _IOS_NOREPLACE 64
#define _IOS_BIN 128

/* Magic numbers and bits for the _flags field.
   The magic numbers use the high-order bits of _flags;
   the remaining bits are available for variable flags.
   Note: The magic numbers must all be negative if stdio
   emulation is desired. */

#define _IO_MAGIC 0xFBAD0000
#define _OLD_STDIO_MAGIC 0xFABC0000
#define _IO_MAGIC_MASK 0xFFFF0000
#define _IO_USER_BUF 1
#define _IO_UNBUFFERED 2
#define _IO_NO_READS 4
#define _IO_NO_WRITES 8
#define _IO_EOF_SEEN 0x10
#define _IO_ERR_SEEN 0x20
#define _IO_DELETE_DONT_CLOSE 0x40
#define _IO_LINKED 0x80
#define _IO_IN_BACKUP 0x100
#define _IO_LINE_BUF 0x200
#define _IO_TIED_PUT_GET 0x400
#define _IO_CURRENTLY_PUTTING 0x800
#define _IO_IS_APPENDING 0x1000
#define _IO_IS_FILEBUF 0x2000
#define _IO_BAD_SEEN 0x4000
#define _IO_USER_LOCK 0x8000

#define _IO_FLAGS2_MMAP 1
#define _IO_FLAGS2_NOTCANCEL 2



#define _IO_FLAGS2_USER_WBUF 8






/* These are "formatting flags" matching the iostream fmtflags enum values. */
#define _IO_SKIPWS 01
#define _IO_LEFT 02
#define _IO_RIGHT 04
#define _IO_INTERNAL 010
#define _IO_DEC 020
#define _IO_OCT 040
#define _IO_HEX 0100
#define _IO_SHOWBASE 0200
#define _IO_SHOWPOINT 0400
#define _IO_UPPERCASE 01000
#define _IO_SHOWPOS 02000
#define _IO_SCIENTIFIC 04000
#define _IO_FIXED 010000
#define _IO_UNITBUF 020000
#define _IO_STDIO 040000
#define _IO_DONT_CLOSE 0100000
#define _IO_BOOLALPHA 0200000


struct _IO_jump_t; struct _IO_FILE;

/* Handle lock.  */



typedef void _IO_lock_t;



/* A streammarker remembers a position in a buffer. */

struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;
  /* If _pos >= 0
 it points to _buf->Gbase()+_pos. FIXME comment */
  /* if _pos < 0, it points to _buf->eBptr()+_pos. FIXME comment */
  int _pos;
# 173 "/usr/include/libio.h" 3 4
};

/* This is the structure from the libstdc++ codecvt class.  */
enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 241 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags; /* High-order word is _IO_MAGIC; rest is flags. */
#define _IO_file_flags _flags

  /* The following pointers correspond to the C++ streambuf protocol. */
  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
  char* _IO_read_ptr; /* Current read pointer */
  char* _IO_read_end; /* End of get area. */
  char* _IO_read_base; /* Start of putback+get area. */
  char* _IO_write_base; /* Start of put area. */
  char* _IO_write_ptr; /* Current put pointer. */
  char* _IO_write_end; /* End of put area. */
  char* _IO_buf_base; /* Start of reserve area. */
  char* _IO_buf_end; /* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base; /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset; /* This used to be _offset but it's too small.  */

#define __HAVE_COLUMN 
  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  /*  char* _save_gptr;  char* _save_egptr; */

  _IO_lock_t *_lock;
# 289 "/usr/include/libio.h" 3 4
  __off64_t _offset;







  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;

  size_t __pad5;
  int _mode;
  /* Make sure we don't get into trouble again.  */
  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;

#define _IO_stdin ((_IO_FILE*)(&_IO_2_1_stdin_))
#define _IO_stdout ((_IO_FILE*)(&_IO_2_1_stdout_))
#define _IO_stderr ((_IO_FILE*)(&_IO_2_1_stderr_))







/* Functions to do I/O and file management for a stream.  */

/* Read NBYTES bytes from COOKIE into a buffer pointed to by BUF.
   Return number of bytes read.  */
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);

/* Write N bytes pointed to by BUF to COOKIE.  Write all N bytes
   unless there is an error.  Return number of bytes written.  If
   there is an error, return 0 and do not write anything.  If the file
   has been opened for append (__mode.__append set), then set the file
   pointer to the end of the file and then do the write; if not, just
   write at the current file pointer.  */
typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);

/* Move COOKIE's file position to *POS bytes from the
   beginning of the file (if W is SEEK_SET),
   the current position (if W is SEEK_CUR),
   or the end of the file (if W is SEEK_END).
   Set *POS to the new file position.
   Returns zero if successful, nonzero if not.  */
typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);

/* Close COOKIE.  */
typedef int __io_close_fn (void *__cookie);



/* User-visible names for the above.  */
typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;

/* The structure with the cookie function pointers.  */
typedef struct
{
  __io_read_fn *read; /* Read bytes.  */
  __io_write_fn *write; /* Write bytes.  */
  __io_seek_fn *seek; /* Seek/tell file position.  */
  __io_close_fn *close; /* Close file.  */
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;

/* Initialize one of those.  */
extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);







extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);







#define _IO_BE(expr,res) __builtin_expect ((expr), res)




#define _IO_getc_unlocked(_fp) (_IO_BE ((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end, 0) ? __uflow (_fp) : *(unsigned char *) (_fp)->_IO_read_ptr++)


#define _IO_peekc_unlocked(_fp) (_IO_BE ((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end, 0) && __underflow (_fp) == EOF ? EOF : *(unsigned char *) (_fp)->_IO_read_ptr)



#define _IO_putc_unlocked(_ch,_fp) (_IO_BE ((_fp)->_IO_write_ptr >= (_fp)->_IO_write_end, 0) ? __overflow (_fp, (unsigned char) (_ch)) : (unsigned char) (*(_fp)->_IO_write_ptr++ = (_ch)))
# 426 "/usr/include/libio.h" 3 4
#define _IO_feof_unlocked(__fp) (((__fp)->_flags & _IO_EOF_SEEN) != 0)
#define _IO_ferror_unlocked(__fp) (((__fp)->_flags & _IO_ERR_SEEN) != 0)

extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));

extern int _IO_peekc_locked (_IO_FILE *__fp);

/* This one is for Emacs. */
#define _IO_PENDING_OUTPUT_COUNT(_fp) ((_fp)->_IO_write_ptr - (_fp)->_IO_write_base)


extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 451 "/usr/include/libio.h" 3 4
#define _IO_peekc(_fp) _IO_peekc_unlocked (_fp)
#define _IO_flockfile(_fp) 
#define _IO_funlockfile(_fp) 
#define _IO_ftrylockfile(_fp) 
#define _IO_cleanup_region_start(_fct,_fp) 
#define _IO_cleanup_region_end(_Doit) 


extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 75 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
#define _VA_LIST_DEFINED 
# 90 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;



#define __off_t_defined 


typedef __off64_t off64_t;
#define __off64_t_defined 





typedef __ssize_t ssize_t;
#define __ssize_t_defined 



/* The type of the second argument to `fgetpos' and `fsetpos'.  */


typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;


/* The possibilities for the third argument to `setvbuf'.  */
#define _IOFBF 0
#define _IOLBF 1
#define _IONBF 2


/* Default buffer size.  */

#define BUFSIZ _IO_BUFSIZ



/* End of file character.
   Some things throughout the library rely on this being -1.  */





/* The possibilities for the third argument to `fseek'.
   These values should not be changed.  */
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2

#define SEEK_DATA 3
#define SEEK_HOLE 4




/* Default path prefix for `tempnam' and `tmpnam'.  */
#define P_tmpdir "/tmp"



/* Get the values:
   L_tmpnam	How long an array of chars must be to be passed to `tmpnam'.
   TMP_MAX	The minimum number of unique filenames generated by tmpnam
		(and tempnam when it uses tmpnam's name space),
		or tempnam (the two are separate).
   L_ctermid	How long an array to pass to `ctermid'.
   L_cuserid	How long an array to pass to `cuserid'.
   FOPEN_MAX	Minimum number of files that can be open at once.
   FILENAME_MAX	Maximum length of a filename.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/stdio_lim.h" 1 3 4
/* Copyright (C) 1994-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






#define L_tmpnam 20
#define TMP_MAX 238328
#define FILENAME_MAX 4096


#define L_ctermid 9

#define L_cuserid 9





#undef FOPEN_MAX
#define FOPEN_MAX 16
# 167 "/usr/include/stdio.h" 2 3 4


/* Standard streams.  */
extern struct _IO_FILE *stdin; /* Standard input stream.  */
extern struct _IO_FILE *stdout; /* Standard output stream.  */
extern struct _IO_FILE *stderr; /* Standard error output stream.  */
/* C89/C99 say they're macros.  Make them happy.  */
#define stdin stdin
#define stdout stdout
#define stderr stderr


/* Remove file FILENAME.  */
extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));
/* Rename file OLD to NEW.  */
extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));



/* Rename file OLD relative to OLDFD to NEW relative to NEWFD.  */
extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));



/* Create a temporary file and open it read/write.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern FILE *tmpfile (void) ;
# 207 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;


/* Generate a temporary filename.  */
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;



/* This is the reentrant variant of `tmpnam'.  The only difference is
   that it does not allow S to be NULL.  */
extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;




/* Generate a unique temporary filename using up to five characters of PFX
   if it is not NULL.  The directory to put this file in is searched for
   as follows: First the environment variable "TMPDIR" is checked.
   If it contains the name of a writable directory, that directory is used.
   If not and if DIR is not NULL, that value is checked.  If that fails,
   P_tmpdir is tried and finally "/tmp".  The storage for the filename
   is allocated by `malloc'.  */
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;




/* Close STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fclose (FILE *__stream);
/* Flush STREAM, or all streams if STREAM is NULL.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fflush (FILE *__stream);



/* Faster versions when locking is not required.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fflush_unlocked (FILE *__stream);



/* Close all streams.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fcloseall (void);





/* Open a file and create a new stream for it.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;
/* Open a file, replacing an existing stream with it.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 297 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;



/* Create a new stream that refers to an existing system file descriptor.  */
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;



/* Create a new stream that refers to the given magic cookie,
   and uses the given functions for input and output.  */
extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__ , __leaf__)) ;



/* Create a new stream that refers to a memory buffer.  */
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;

/* Open a stream that writes into a malloc'd buffer that is expanded as
   necessary.  *BUFLOC and *SIZELOC are updated with the buffer's location
   and the number of characters written on fflush or fclose.  */
extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;




/* If BUF is NULL, make STREAM unbuffered.
   Else make it use buffer BUF, of size BUFSIZ.  */
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));
/* Make STREAM use buffering mode MODE.
   If BUF is not NULL, use N bytes of it for buffering;
   else allocate an internal buffer N bytes long.  */
extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));



/* If BUF is NULL, make STREAM unbuffered.
   Else make it use SIZE bytes of BUF for buffering.  */
extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));

/* Make STREAM line-buffered.  */
extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));




/* Write formatted output to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);
/* Write formatted output to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int printf (const char *__restrict __format, ...);
/* Write formatted output to S.  */
extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));

/* Write formatted output to S from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);
/* Write formatted output to stdout from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);
/* Write formatted output to S from argument list ARG.  */
extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));




/* Maximum chars of output to write in MAXLEN.  */
extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));




/* Write formatted output to a string dynamically allocated with `malloc'.
   Store the address of the string in *PTR.  */
extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;



/* Write formatted output to a file descriptor.  */
extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));




/* Read formatted input from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;
/* Read formatted input from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int scanf (const char *__restrict __format, ...) ;
/* Read formatted input from S.  */
extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
# 465 "/usr/include/stdio.h" 3 4




/* Read formatted input from S into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;

/* Read formatted input from stdin into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;

/* Read formatted input from S into argument list ARG.  */
extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 524 "/usr/include/stdio.h" 3 4





/* Read a character from STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);

/* Read a character from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int getchar (void);


/* The C standard explicitly says this is a macro, so we always do the
   optimization for it.  */
#define getc(_fp) _IO_getc (_fp)


/* These are defined in POSIX.1:1996.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);



/* Faster version when locking is not necessary.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fgetc_unlocked (FILE *__stream);




/* Write a character to STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.

   These functions is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);

/* Write a character to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int putchar (int __c);


/* The C standard explicitly says this can be a macro,
   so we always do the optimization for it.  */
#define putc(_ch,_fp) _IO_putc (_ch, _fp)


/* Faster version when locking is not necessary.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fputc_unlocked (int __c, FILE *__stream);



/* These are defined in POSIX.1:1996.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);





/* Get a word (int) from STREAM.  */
extern int getw (FILE *__stream);

/* Write a word (int) to STREAM.  */
extern int putw (int __w, FILE *__stream);




/* Get a newline-terminated string of finite length from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 642 "/usr/include/stdio.h" 3 4



/* This function does the same as `fgets' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;




/* Read up to (and including) a DELIMITER from STREAM into *LINEPTR
   (and null-terminate it). *LINEPTR is a pointer returned from malloc (or
   NULL), pointing to *N characters of space.  It is realloc'd as
   necessary.  Returns the number of characters read (not including the
   null terminator), or -1 on error or EOF.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;

/* Like `getdelim', but reads up to a newline.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;




/* Write a string to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fputs (const char *__restrict __s, FILE *__restrict __stream);

/* Write a string, followed by a newline, to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int puts (const char *__s);


/* Push a character back onto the input buffer of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int ungetc (int __c, FILE *__stream);


/* Read chunks of generic data from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;
/* Write chunks of generic data to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);



/* This function does the same as `fputs' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);



/* Faster versions when locking is not necessary.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);




/* Seek to a certain position on STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fseek (FILE *__stream, long int __off, int __whence);
/* Return the current position of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern long int ftell (FILE *__stream) ;
/* Rewind to the beginning of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void rewind (FILE *__stream);


/* The Single Unix Specification, Version 2, specifies an alternative,
   more adequate interface for the two functions above which deal with
   file offset.  `long int' is not the right type.  These definitions
   are originally defined in the Large File Support API.  */



/* Seek to a certain position on STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fseeko (FILE *__stream, __off_t __off, int __whence);
/* Return the current position of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern __off_t ftello (FILE *__stream) ;
# 794 "/usr/include/stdio.h" 3 4


/* Get STREAM's position.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);
/* Set STREAM's position.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 817 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



/* Clear the error and EOF indicators for STREAM.  */
extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
/* Return the EOF indicator for STREAM.  */
extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
/* Return the error indicator for STREAM.  */
extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;



/* Faster versions when locking is not required.  */
extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




/* Print a message describing the meaning of the value of errno.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void perror (const char *__s);


/* Provide the declarations for `sys_errlist' and `sys_nerr' if they
   are available on this system.  Even if available, these variables
   should not be used directly.  The `strerror' function provides
   all the necessary functionality.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/sys_errlist.h" 1 3 4
/* Declare sys_errlist and sys_nerr, or don't.  Compatibility (do) version.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* sys_errlist and sys_nerr are deprecated.  Use strerror instead.  */


extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 856 "/usr/include/stdio.h" 2 3 4



/* Return the system file descriptor for STREAM.  */
extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;



/* Faster version when locking is not required.  */
extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




/* Create a new stream connected to a pipe running the given command.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern FILE *popen (const char *__command, const char *__modes) ;

/* Close a stream opened by popen and return the status of its child.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int pclose (FILE *__stream);




/* Return the name of the controlling terminal.  */
extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));




/* Return the name of the current user.  */
extern char *cuserid (char *__s);




struct obstack; /* See <obstack.h>.  */

/* Write formatted output to an obstack.  */
extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));




/* These are defined in POSIX.1:1996.  */

/* Acquire ownership of STREAM.  */
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

/* Try to acquire ownership of STREAM but do not block if it is not
   possible.  */
extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

/* Relinquish the ownership granted for STREAM.  */
extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 932 "/usr/include/stdio.h" 3 4
/* If we are compiling with optimizing read this file.  It contains
   several optimizing inline functions and macros.  */

# 1 "/usr/include/arm-linux-gnueabihf/bits/stdio.h" 1 3 4
/* Optimizing macros and inline functions for stdio functions.
   Copyright (C) 1998-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/arm-linux-gnueabihf/bits/stdio.h" 3 4
#define __STDIO_INLINE __extern_inline




/* For -D_FORTIFY_SOURCE{,=2} bits/stdio2.h will define a different
   inline.  */

/* Write formatted output to stdout from argument list ARG.  */
extern __inline __attribute__ ((__gnu_inline__)) int
vprintf (const char *__restrict __fmt, __gnuc_va_list __arg)
{
  return vfprintf (stdout, __fmt, __arg);
}


/* Read a character from stdin.  */
extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return _IO_getc (stdin);
}



/* Faster version when locking is not necessary.  */
extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}




/* This is defined in POSIX.1:1996.  */
extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}

/* This is defined in POSIX.1:1996.  */
extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}



/* Write a character to stdout.  */
extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return _IO_putc (__c, stdout);
}



/* Faster version when locking is not necessary.  */
extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}




/* This is defined in POSIX.1:1996.  */
extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}

/* This is defined in POSIX.1:1996.  */
extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}




/* Like `getdelim', but reads up to a newline.  */
extern __inline __attribute__ ((__gnu_inline__)) __ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
{
  return __getdelim (__lineptr, __n, '\n', __stream);
}




/* Faster versions when locking is not required.  */
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) feof_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x10) != 0);
}

/* Faster versions when locking is not required.  */
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) ferror_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x20) != 0);
}







/* Perform some simple optimizations.  */
#define fread_unlocked(ptr,size,n,stream) (__extension__ ((__builtin_constant_p (size) && __builtin_constant_p (n) && (size_t) (size) * (size_t) (n) <= 8 && (size_t) (size) != 0) ? ({ char *__ptr = (char *) (ptr); FILE *__stream = (stream); size_t __cnt; for (__cnt = (size_t) (size) * (size_t) (n); __cnt > 0; --__cnt) { int __c = _IO_getc_unlocked (__stream); if (__c == EOF) break; *__ptr++ = __c; } ((size_t) (size) * (size_t) (n) - __cnt) / (size_t) (size); }) : (((__builtin_constant_p (size) && (size_t) (size) == 0) || (__builtin_constant_p (n) && (size_t) (n) == 0)) ? ((void) (ptr), (void) (stream), (void) (size), (void) (n), (size_t) 0) : fread_unlocked (ptr, size, n, stream))))
# 168 "/usr/include/arm-linux-gnueabihf/bits/stdio.h" 3 4
#define fwrite_unlocked(ptr,size,n,stream) (__extension__ ((__builtin_constant_p (size) && __builtin_constant_p (n) && (size_t) (size) * (size_t) (n) <= 8 && (size_t) (size) != 0) ? ({ const char *__ptr = (const char *) (ptr); FILE *__stream = (stream); size_t __cnt; for (__cnt = (size_t) (size) * (size_t) (n); __cnt > 0; --__cnt) if (_IO_putc_unlocked (*__ptr++, __stream) == EOF) break; ((size_t) (size) * (size_t) (n) - __cnt) / (size_t) (size); }) : (((__builtin_constant_p (size) && (size_t) (size) == 0) || (__builtin_constant_p (n) && (size_t) (n) == 0)) ? ((void) (ptr), (void) (stream), (void) (size), (void) (n), (size_t) 0) : fwrite_unlocked (ptr, size, n, stream))))
# 189 "/usr/include/arm-linux-gnueabihf/bits/stdio.h" 3 4
/* Define helper macro.  */
#undef __STDIO_INLINE
# 936 "/usr/include/stdio.h" 2 3 4
# 944 "/usr/include/stdio.h" 3 4

# 64 "pifunk.c" 2
# 1 "/usr/include/stdlib.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.20 General utilities	<stdlib.h>
 */



# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 25 "/usr/include/stdlib.h" 2 3 4

/* Get size_t, wchar_t and NULL from <stddef.h>.  */
#define __need_size_t 

#define __need_wchar_t 
#define __need_NULL 

# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 165 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 267 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#define __wchar_t__ 
#define __WCHAR_T__ 
#define _WCHAR_T 
#define _T_WCHAR_ 
#define _T_WCHAR 
#define __WCHAR_T 
#define _WCHAR_T_ 
#define _BSD_WCHAR_T_ 
#define _WCHAR_T_DEFINED_ 
#define _WCHAR_T_DEFINED 
#define _WCHAR_T_H 
#define ___int_wchar_t_h 
#define __INT_WCHAR_T_H 
#define _GCC_WCHAR_T 
#define _WCHAR_T_DECLARED 

/* On BSD/386 1.1, at least, machine/ansi.h defines _BSD_WCHAR_T_
   instead of _WCHAR_T_, and _BSD_RUNE_T_ (which, unlike the other
   symbols in the _FOO_T_ family, stays defined even after its
   corresponding type is defined).  If we define wchar_t, then we
   must undef _WCHAR_T_; for BSD/386 1.1 (and perhaps others), if
   we undef _WCHAR_T_, then we must also define rune_t, since 
   headers like runetype.h assume that if machine/ansi.h is included,
   and _BSD_WCHAR_T_ is not defined, then rune_t is available.
   machine/ansi.h says, "Note that _WCHAR_T_ and _RUNE_T_ must be of
   the same type." */

#undef _BSD_WCHAR_T_
# 310 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* FreeBSD 5 can't be handled well using "traditional" logic above
   since it no longer defines _BSD_RUNE_T_ yet still desires to export
   rune_t in some cases... */
# 328 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
typedef unsigned int wchar_t;
# 347 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_wchar_t
# 362 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL
# 33 "/usr/include/stdlib.h" 2 3 4




#define _STDLIB_H 1


/* XPG requires a few symbols from <sys/wait.h> being defined.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/waitflags.h" 1 3 4
/* Definitions of flag bits for `waitpid' et al.
   Copyright (C) 1992-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






/* Bits in the third argument to `waitpid'.  */
#define WNOHANG 1
#define WUNTRACED 2

/* Bits in the fourth argument to `waitid'.  */
#define WSTOPPED 2
#define WEXITED 4
#define WCONTINUED 8
#define WNOWAIT 0x01000000

#define __WNOTHREAD 0x20000000

#define __WALL 0x40000000
#define __WCLONE 0x80000000

/* The following values are used by the `waitid' function.  */


#define __ENUM_IDTYPE_T 1

/* The Linux kernel defines these bare, rather than an enum,
   which causes a conflict if the include order is reversed. */
#undef P_ALL
#undef P_PID
#undef P_PGID

typedef enum
{
  P_ALL, /* Wait for any child.  */
  P_PID, /* Wait for specified process.  */
  P_PGID /* Wait for members of process group.  */
} idtype_t;
# 42 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/waitstatus.h" 1 3 4
/* Definitions of status bits for `wait' et al.
   Copyright (C) 1992-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






/* Everything extant so far uses these same bits.  */


/* If WIFEXITED(STATUS), the low-order 8 bits of the status.  */
#define __WEXITSTATUS(status) (((status) & 0xff00) >> 8)

/* If WIFSIGNALED(STATUS), the terminating signal.  */
#define __WTERMSIG(status) ((status) & 0x7f)

/* If WIFSTOPPED(STATUS), the signal that stopped the child.  */
#define __WSTOPSIG(status) __WEXITSTATUS(status)

/* Nonzero if STATUS indicates normal termination.  */
#define __WIFEXITED(status) (__WTERMSIG(status) == 0)

/* Nonzero if STATUS indicates termination by a signal.  */
#define __WIFSIGNALED(status) (((signed char) (((status) & 0x7f) + 1) >> 1) > 0)


/* Nonzero if STATUS indicates the child is stopped.  */
#define __WIFSTOPPED(status) (((status) & 0xff) == 0x7f)

/* Nonzero if STATUS indicates the child continued after a stop.  We only
   define this if <bits/waitflags.h> provides the WCONTINUED flag bit.  */

#define __WIFCONTINUED(status) ((status) == __W_CONTINUED)


/* Nonzero if STATUS indicates the child dumped core.  */
#define __WCOREDUMP(status) ((status) & __WCOREFLAG)

/* Macros for constructing status values.  */
#define __W_EXITCODE(ret,sig) ((ret) << 8 | (sig))
#define __W_STOPCODE(sig) ((sig) << 8 | 0x7f)
#define __W_CONTINUED 0xffff
#define __WCOREFLAG 0x80
# 43 "/usr/include/stdlib.h" 2 3 4

/* Define the macros <sys/wait.h> also would define this way.  */
#define WEXITSTATUS(status) __WEXITSTATUS (status)
#define WTERMSIG(status) __WTERMSIG (status)
#define WSTOPSIG(status) __WSTOPSIG (status)
#define WIFEXITED(status) __WIFEXITED (status)
#define WIFSIGNALED(status) __WIFSIGNALED (status)
#define WIFSTOPPED(status) __WIFSTOPPED (status)

#define WIFCONTINUED(status) __WIFCONTINUED (status)




/* Returned by `div'.  */
typedef struct
  {
    int quot; /* Quotient.  */
    int rem; /* Remainder.  */
  } div_t;

/* Returned by `ldiv'.  */

typedef struct
  {
    long int quot; /* Quotient.  */
    long int rem; /* Remainder.  */
  } ldiv_t;
#define __ldiv_t_defined 1





/* Returned by `lldiv'.  */
__extension__ typedef struct
  {
    long long int quot; /* Quotient.  */
    long long int rem; /* Remainder.  */
  } lldiv_t;
#define __lldiv_t_defined 1




/* The largest number rand will return (same as INT_MAX).  */
#define RAND_MAX 2147483647


/* We define these the same for all machines.
   Changes from this to the outside world should be done in `_exit'.  */
#define EXIT_FAILURE 1
#define EXIT_SUCCESS 0


/* Maximum length of a multibyte character in the current locale.  */
#define MB_CUR_MAX (__ctype_get_mb_cur_max ())
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;



/* Convert a string to a floating-point number.  */
extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
/* Convert a string to an integer.  */
extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
/* Convert a string to a long integer.  */
extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




/* Convert a string to a long long integer.  */
__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




/* Convert a string to a floating-point number.  */
extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




/* Likewise for `float' and `long double' sizes of floating-point numbers.  */
extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




/* Convert a string to a long integer.  */
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
/* Convert a string to an unsigned long integer.  */
extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



/* Convert a string to a quadword integer.  */
__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
/* Convert a string to an unsigned quadword integer.  */
__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




/* Convert a string to a quadword integer.  */
__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
/* Convert a string to an unsigned quadword integer.  */
__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





/* The concept of one static locale per category is not very well
   thought out.  Many applications will need to process its data using
   information from several different locales.  Another problem is
   the implementation of the internationalization handling in the
   ISO C++ standard library.  To support this another set of
   the functions using locale data exist which take an additional
   argument.

   Attention: even though several *_l interfaces are part of POSIX:2008,
   these are not.  */

/* Structure for reentrant locale using functions.  This is an
   (almost) opaque type for the user level programs.  */
# 1 "/usr/include/xlocale.h" 1 3 4
/* Definition of locale datatype.
   Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _XLOCALE_H 1

/* Structure for reentrant locale using functions.  This is an
   (almost) opaque type for the user level programs.  The file and
   this data structure is not standardized.  Don't rely on it.  It can
   go away without warning.  */
typedef struct __locale_struct
{
  /* Note: LC_ALL is not a valid index into this array.  */
  struct __locale_data *__locales[13]; /* 13 = __LC_LAST. */

  /* To increase the speed of this solution we add some special members.  */
  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;

  /* Note: LC_ALL is not a valid index into this array.  */
  const char *__names[13];
} *__locale_t;

/* POSIX 2008 makes locale_t official.  */
typedef __locale_t locale_t;
# 197 "/usr/include/stdlib.h" 2 3 4

/* Special versions of the functions above which take the locale to
   use as an additional parameter.  */
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) atoi (const char *__nptr)
{
  return (int) strtol (__nptr, (char **) ((void *)0), 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
__attribute__ ((__nothrow__ , __leaf__)) atol (const char *__nptr)
{
  return strtol (__nptr, (char **) ((void *)0), 10);
}




__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
__attribute__ ((__nothrow__ , __leaf__)) atoll (const char *__nptr)
{
  return strtoll (__nptr, (char **) ((void *)0), 10);
}






/* Convert N to base 64 using the digits "./0-9A-Za-z", least-significant
   digit first.  Returns a pointer to static storage overwritten by the
   next call.  */
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;

/* Read a number from a string S in base 64 as above.  */
extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/arm-linux-gnueabihf/sys/types.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */


#define _SYS_TYPES_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/arm-linux-gnueabihf/sys/types.h" 2 3 4



# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 30 "/usr/include/arm-linux-gnueabihf/sys/types.h" 2 3 4



typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;
#define __u_char_defined 



typedef __loff_t loff_t;



typedef __ino_t ino_t;



#define __ino_t_defined 


typedef __ino64_t ino64_t;
#define __ino64_t_defined 



typedef __dev_t dev_t;
#define __dev_t_defined 



typedef __gid_t gid_t;
#define __gid_t_defined 



typedef __mode_t mode_t;
#define __mode_t_defined 



typedef __nlink_t nlink_t;
#define __nlink_t_defined 



typedef __uid_t uid_t;
#define __uid_t_defined 
# 98 "/usr/include/arm-linux-gnueabihf/sys/types.h" 3 4
typedef __pid_t pid_t;
#define __pid_t_defined 




typedef __id_t id_t;
#define __id_t_defined 
# 115 "/usr/include/arm-linux-gnueabihf/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;
#define __daddr_t_defined 




typedef __key_t key_t;
#define __key_t_defined 



#define __need_clock_t 

#define __need_time_t 
#define __need_timer_t 
#define __need_clockid_t 
# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 53 "/usr/include/time.h" 3 4
#define __clock_t_defined 1

# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 56 "/usr/include/time.h" 2 3 4


/* Returned by `clock'.  */
typedef __clock_t clock_t;






#undef __need_clock_t


#define __time_t_defined 1

# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 72 "/usr/include/time.h" 2 3 4


/* Returned by `time'.  */
typedef __time_t time_t;






#undef __need_time_t



#define __clockid_t_defined 1

# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 89 "/usr/include/time.h" 2 3 4

/* Clock ID used in clock and timer functions.  */
typedef __clockid_t clockid_t;


#undef __clockid_time_t



#define __timer_t_defined 1

# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 101 "/usr/include/time.h" 2 3 4

/* Timer ID returned by `timer_create'.  */
typedef __timer_t timer_t;


#undef __need_timer_t
# 127 "/usr/include/time.h" 3 4
#undef __need_timespec
# 133 "/usr/include/arm-linux-gnueabihf/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;
#define __useconds_t_defined 


typedef __suseconds_t suseconds_t;
#define __suseconds_t_defined 



#define __need_size_t 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 165 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 362 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* A null pointer constant.  */
# 412 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_NULL
# 147 "/usr/include/arm-linux-gnueabihf/sys/types.h" 2 3 4


/* Old compatibility names for C types.  */
typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;


/* These size-specific names are used by some of the inet code.  */
# 186 "/usr/include/arm-linux-gnueabihf/sys/types.h" 3 4
/* For GCC 2.7 and later, we can use specific type-size attributes.  */
#define __intN_t(N,MODE) typedef int int ##N ##_t __attribute__ ((__mode__ (MODE)))

#define __u_intN_t(N,MODE) typedef unsigned int u_int ##N ##_t __attribute__ ((__mode__ (MODE)))



#define __int8_t_defined 
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));


/* Some code from BIND tests this macro to see if the types above are
   defined.  */

#define __BIT_TYPES_DEFINED__ 1



/* In BSD <sys/types.h> is expected to define BYTE_ORDER.  */
# 1 "/usr/include/endian.h" 1 3 4
/* Copyright (C) 1992-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _ENDIAN_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 22 "/usr/include/endian.h" 2 3 4

/* Definitions for byte order, according to significance of bytes,
   from low addresses to high addresses.  The value is what you get by
   putting '4' in the most significant byte, '3' in the second most
   significant byte, '2' in the second least significant byte, and '1'
   in the least significant byte, and then writing down one digit for
   each byte, starting with the byte at the lowest address at the left,
   and proceeding to the byte with the highest address at the right.  */

#define __LITTLE_ENDIAN 1234
#define __BIG_ENDIAN 4321
#define __PDP_ENDIAN 3412

/* This file defines `__BYTE_ORDER' for the particular machine.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/endian.h" 1 3 4




/* ARM can be either big or little endian.  */



#define __BYTE_ORDER __LITTLE_ENDIAN
# 37 "/usr/include/endian.h" 2 3 4

/* Some machines may need to use a different endianness for floating point
   values.  */

#define __FLOAT_WORD_ORDER __BYTE_ORDER



#define LITTLE_ENDIAN __LITTLE_ENDIAN
#define BIG_ENDIAN __BIG_ENDIAN
#define PDP_ENDIAN __PDP_ENDIAN
#define BYTE_ORDER __BYTE_ORDER



#define __LONG_LONG_PAIR(HI,LO) LO, HI






/* Conversion interfaces.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/byteswap.h" 1 3 4
/* Macros to swap the order of bytes in integer values.
   Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






#define _BITS_BYTESWAP_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 27 "/usr/include/arm-linux-gnueabihf/bits/byteswap.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 28 "/usr/include/arm-linux-gnueabihf/bits/byteswap.h" 2 3 4

/* Swap bytes in 16 bit value.  */
#define __bswap_constant_16(x) ((unsigned short int)((((x) >> 8) & 0xffu) | (((x) & 0xffu) << 8)))


/* Get __bswap_16.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/byteswap-16.h" 1 3 4
/* Macros to swap the order of bytes in 16-bit integer values.
   Copyright (C) 2012-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






#define __bswap_16(x) (__extension__ ({ unsigned short int __bsx = (unsigned short int) (x); __bswap_constant_16 (__bsx); }))
# 35 "/usr/include/arm-linux-gnueabihf/bits/byteswap.h" 2 3 4

/* Swap bytes in 32 bit value.  */
#define __bswap_constant_32(x) ((((x) & 0xff000000u) >> 24) | (((x) & 0x00ff0000u) >> 8) | (((x) & 0x0000ff00u) << 8) | (((x) & 0x000000ffu) << 24))





static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 61 "/usr/include/arm-linux-gnueabihf/bits/byteswap.h" 3 4
/* Swap bytes in 64 bit value.  */

#define __bswap_constant_64(x) (__extension__ ((((x) & 0xff00000000000000ull) >> 56) | (((x) & 0x00ff000000000000ull) >> 40) | (((x) & 0x0000ff0000000000ull) >> 24) | (((x) & 0x000000ff00000000ull) >> 8) | (((x) & 0x00000000ff000000ull) << 8) | (((x) & 0x0000000000ff0000ull) << 24) | (((x) & 0x000000000000ff00ull) << 40) | (((x) & 0x00000000000000ffull) << 56)))
# 74 "/usr/include/arm-linux-gnueabihf/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4


#define htobe16(x) __bswap_16 (x)
#define htole16(x) (x)
#define be16toh(x) __bswap_16 (x)
#define le16toh(x) (x)

#define htobe32(x) __bswap_32 (x)
#define htole32(x) (x)
#define be32toh(x) __bswap_32 (x)
#define le32toh(x) (x)

#define htobe64(x) __bswap_64 (x)
#define htole64(x) (x)
#define be64toh(x) __bswap_64 (x)
#define le64toh(x) (x)
# 217 "/usr/include/arm-linux-gnueabihf/sys/types.h" 2 3 4

/* It also defines `fd_set' and the FD_* macros for `select'.  */
# 1 "/usr/include/arm-linux-gnueabihf/sys/select.h" 1 3 4
/* `fd_set' type and related macros, and `select'/`pselect' declarations.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*	POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>  */


#define _SYS_SELECT_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 25 "/usr/include/arm-linux-gnueabihf/sys/select.h" 2 3 4

/* Get definition of needed basic types.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 28 "/usr/include/arm-linux-gnueabihf/sys/select.h" 2 3 4

/* Get __FD_* definitions.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/select.h" 1 3 4
/* Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






/* We don't use `memset' because this would require a prototype and
   the array isn't too big.  */
#define __FD_ZERO(s) do { unsigned int __i; fd_set *__arr = (s); for (__i = 0; __i < sizeof (fd_set) / sizeof (__fd_mask); ++__i) __FDS_BITS (__arr)[__i] = 0; } while (0)






#define __FD_SET(d,s) ((void) (__FDS_BITS (s)[__FD_ELT(d)] |= __FD_MASK(d)))

#define __FD_CLR(d,s) ((void) (__FDS_BITS (s)[__FD_ELT(d)] &= ~__FD_MASK(d)))

#define __FD_ISSET(d,s) ((__FDS_BITS (s)[__FD_ELT (d)] & __FD_MASK (d)) != 0)
# 31 "/usr/include/arm-linux-gnueabihf/sys/select.h" 2 3 4

/* Get __sigset_t.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/sigset.h" 1 3 4
/* __sig_atomic_t, __sigset_t, and related definitions.  Linux version.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _SIGSET_H_types 1

typedef int __sig_atomic_t;

/* A `sigset_t' has a bit for each signal.  */

#define _SIGSET_NWORDS (1024 / (8 * sizeof (unsigned long int)))
typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;




/* We only want to define these functions if <signal.h> was actually
   included; otherwise we were included just to define the types.  Since we
   are namespace-clean, it wouldn't hurt to define extra macros.  But
   trouble can be caused by functions being defined (e.g., any global
   register vars declared later will cause compilation errors).  */
# 34 "/usr/include/arm-linux-gnueabihf/sys/select.h" 2 3 4


#define __sigset_t_defined 
typedef __sigset_t sigset_t;


/* Get definition of timer specification structures.  */
#define __need_time_t 

#define __need_timespec 

# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 66 "/usr/include/time.h" 3 4
#undef __need_clock_t
# 82 "/usr/include/time.h" 3 4
#undef __need_time_t
# 94 "/usr/include/time.h" 3 4
#undef __clockid_time_t
# 106 "/usr/include/time.h" 3 4
#undef __need_timer_t







#define __timespec_defined 1

# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 117 "/usr/include/time.h" 2 3 4

/* POSIX.1b structure for a time value.  This is like a `struct timeval' but
   has nanoseconds instead of microseconds.  */
struct timespec
  {
    __time_t tv_sec; /* Seconds.  */
    __syscall_slong_t tv_nsec; /* Nanoseconds.  */
  };


#undef __need_timespec
# 46 "/usr/include/arm-linux-gnueabihf/sys/select.h" 2 3 4
#define __need_timeval 
# 1 "/usr/include/arm-linux-gnueabihf/bits/time.h" 1 3 4
/* System-dependent timing definitions.  Linux version.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <time.h> instead.
 */



#define _STRUCT_TIMEVAL 1
# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 27 "/usr/include/arm-linux-gnueabihf/bits/time.h" 2 3 4

/* A time value that is accurate to the nearest
   microsecond but also has a range of years.  */
struct timeval
  {
    __time_t tv_sec; /* Seconds.  */
    __suseconds_t tv_usec; /* Microseconds.  */
  };
# 101 "/usr/include/arm-linux-gnueabihf/bits/time.h" 3 4
#undef __need_timeval
# 48 "/usr/include/arm-linux-gnueabihf/sys/select.h" 2 3 4







/* The fd_set member is required to be an array of longs.  */
typedef long int __fd_mask;

/* Some versions of <linux/posix_types.h> define this macros.  */
#undef __NFDBITS
/* It's easier to assume 8-bit bytes than to get CHAR_BIT.  */
#define __NFDBITS (8 * (int) sizeof (__fd_mask))
#define __FD_ELT(d) ((d) / __NFDBITS)
#define __FD_MASK(d) ((__fd_mask) (1UL << ((d) % __NFDBITS)))

/* fd_set for select and pselect.  */
typedef struct
  {
    /* XPG4.2 requires this member name.  Otherwise avoid the name
       from the global namespace.  */

    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];
#define __FDS_BITS(set) ((set)->fds_bits)




  } fd_set;

/* Maximum number of file descriptors in `fd_set'.  */
#define FD_SETSIZE __FD_SETSIZE


/* Sometimes the fd_set member is assumed to have this type.  */
typedef __fd_mask fd_mask;

/* Number of bits per word of `fd_set' (some code assumes this is 32).  */
#define NFDBITS __NFDBITS



/* Access macros for `fd_set'.  */
#define FD_SET(fd,fdsetp) __FD_SET (fd, fdsetp)
#define FD_CLR(fd,fdsetp) __FD_CLR (fd, fdsetp)
#define FD_ISSET(fd,fdsetp) __FD_ISSET (fd, fdsetp)
#define FD_ZERO(fdsetp) __FD_ZERO (fdsetp)




/* Check the first NFDS descriptors each in READFDS (if not NULL) for read
   readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS
   (if not NULL) for exceptional conditions.  If TIMEOUT is not NULL, time out
   after waiting the interval specified therein.  Returns the number of ready
   descriptors, or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);


/* Same as above only that the TIMEOUT value is given with higher
   resolution and a sigmask which is been set temporarily.  This version
   should be used.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);



/* Define some inlines helping to catch common problems.  */





# 220 "/usr/include/arm-linux-gnueabihf/sys/types.h" 2 3 4

/* BSD defines these symbols, so we follow.  */
# 1 "/usr/include/arm-linux-gnueabihf/sys/sysmacros.h" 1 3 4
/* Definitions of macros to access `dev_t' values.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _SYS_SYSMACROS_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 23 "/usr/include/arm-linux-gnueabihf/sys/sysmacros.h" 2 3 4



__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned int
__attribute__ ((__nothrow__ , __leaf__)) gnu_dev_major (unsigned long long int __dev)
{
  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
}

__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned int
__attribute__ ((__nothrow__ , __leaf__)) gnu_dev_minor (unsigned long long int __dev)
{
  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
}

__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned long long int
__attribute__ ((__nothrow__ , __leaf__)) gnu_dev_makedev (unsigned int __major, unsigned int __minor)
{
  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
   | (((unsigned long long int) (__minor & ~0xff)) << 12)
   | (((unsigned long long int) (__major & ~0xfff)) << 32));
}



/* Access the functions with their traditional names.  */
#define major(dev) gnu_dev_major (dev)
#define minor(dev) gnu_dev_minor (dev)
#define makedev(maj,min) gnu_dev_makedev (maj, min)
# 223 "/usr/include/arm-linux-gnueabihf/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;
#define __blksize_t_defined 


/* Types from the Large File Support interface.  */


typedef __blkcnt_t blkcnt_t; /* Type to count number of disk blocks.  */
#define __blkcnt_t_defined 


typedef __fsblkcnt_t fsblkcnt_t; /* Type to count file system blocks.  */
#define __fsblkcnt_t_defined 


typedef __fsfilcnt_t fsfilcnt_t; /* Type to count file system inodes.  */
#define __fsfilcnt_t_defined 
# 262 "/usr/include/arm-linux-gnueabihf/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t; /* Type to count number of disk blocks. */
typedef __fsblkcnt64_t fsblkcnt64_t; /* Type to count file system blocks.  */
typedef __fsfilcnt64_t fsfilcnt64_t; /* Type to count file system inodes.  */



/* Now add the thread types.  */

# 1 "/usr/include/arm-linux-gnueabihf/bits/pthreadtypes.h" 1 3 4
/* Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */


#define _BITS_PTHREADTYPES_H 1

# 1 "/usr/include/endian.h" 1 3 4
/* Copyright (C) 1992-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 22 "/usr/include/arm-linux-gnueabihf/bits/pthreadtypes.h" 2 3 4

#define __SIZEOF_PTHREAD_ATTR_T 36
#define __SIZEOF_PTHREAD_MUTEX_T 24
#define __SIZEOF_PTHREAD_MUTEXATTR_T 4
#define __SIZEOF_PTHREAD_COND_T 48
#define __SIZEOF_PTHREAD_COND_COMPAT_T 12
#define __SIZEOF_PTHREAD_CONDATTR_T 4
#define __SIZEOF_PTHREAD_RWLOCK_T 32
#define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
#define __SIZEOF_PTHREAD_BARRIER_T 20
#define __SIZEOF_PTHREAD_BARRIERATTR_T 4


/* Thread identifiers.  The structure of the attribute type is not
   exposed on purpose.  */
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[36];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;
#define __have_pthread_attr_t 1



typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;


/* Data structures for mutex handling.  The structure of the attribute
   type is not exposed on purpose.  */
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;
    /* KIND must stay at this position in the structure to maintain
       binary compatibility.  */
    int __kind;
    unsigned int __nusers;
    __extension__ union
    {
      int __spins;
      __pthread_slist_t __list;
    };
  } __data;
  char __size[24];
  long int __align;
} pthread_mutex_t;

/* Mutex __spins initializer used by PTHREAD_MUTEX_INITIALIZER.  */
#define __PTHREAD_SPINS 0

typedef union
{
  char __size[4];
  long int __align;
} pthread_mutexattr_t;


/* Data structure for conditional variable handling.  The structure of
   the attribute type is not exposed on purpose.  */
typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_condattr_t;


/* Keys for thread-specific data */
typedef unsigned int pthread_key_t;


/* Once-only execution */
typedef int pthread_once_t;



/* Data structure for read-write lock variable handling.  The
   structure of the attribute type is not exposed on purpose.  */
typedef union
{
  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
# 145 "/usr/include/arm-linux-gnueabihf/bits/pthreadtypes.h" 3 4
    /* FLAGS must stay at this position in the structure to maintain
       binary compatibility.  */
    unsigned char __flags;
    unsigned char __shared;
    unsigned char __pad1;
    unsigned char __pad2;

    int __writer;
  } __data;
  char __size[32];
  long int __align;
} pthread_rwlock_t;

#define __PTHREAD_RWLOCK_ELISION_EXTRA 0

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;




/* POSIX spinlock data type.  */
typedef volatile int pthread_spinlock_t;


/* POSIX barriers data type.  The structure of the type is
   deliberately not exposed.  */
typedef union
{
  char __size[20];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 271 "/usr/include/arm-linux-gnueabihf/sys/types.h" 2 3 4



# 276 "/usr/include/stdlib.h" 2 3 4

/* These are the functions that actually do things.  The `random', `srandom',
   `initstate' and `setstate' functions are those from BSD Unices.
   The `rand' and `srand' functions are required by the ANSI standard.
   We provide both interfaces to the same random number generator.  */
/* Return a random long integer between 0 and RAND_MAX inclusive.  */
extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));

/* Seed the random number generator with the given number.  */
extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));

/* Initialize the random number generator to use state buffer STATEBUF,
   of length STATELEN, and seed it with SEED.  Optimal lengths are 8, 16,
   32, 64, 128 and 256, the bigger the better; values less than 8 will
   cause an error and values greater than 256 will be rounded down.  */
extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

/* Switch the random number generator to state buffer STATEBUF,
   which should have been previously initialized by `initstate'.  */
extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



/* Reentrant versions of the `random' family of functions.
   These functions all use the following data structure to contain
   state, rather than global state variables.  */

struct random_data
  {
    int32_t *fptr; /* Front pointer.  */
    int32_t *rptr; /* Rear pointer.  */
    int32_t *state; /* Array of state values.  */
    int rand_type; /* Type of random number generator.  */
    int rand_deg; /* Degree of random number generator.  */
    int rand_sep; /* Distance between front and rear.  */
    int32_t *end_ptr; /* Pointer behind state table.  */
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





/* Return a random integer between 0 and RAND_MAX inclusive.  */
extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));
/* Seed the random number generator with the given number.  */
extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));



/* Reentrant interface according to POSIX.1.  */
extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));




/* System V style 48-bit random number generator functions.  */

/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */
extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Return non-negative, long integer in [0,2^31).  */
extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Return signed, long integers in [-2^31,2^31).  */
extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Seed random number generator.  */
extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Data structure for communication with thread safe versions.  This
   type is to be regarded as opaque.  It's only exported because users
   have to allocate objects of this type.  */
struct drand48_data
  {
    unsigned short int __x[3]; /* Current state.  */
    unsigned short int __old_x[3]; /* Old state.  */
    unsigned short int __c; /* Additive const. in congruential formula.  */
    unsigned short int __init; /* Flag for initializing.  */
    __extension__ unsigned long long int __a; /* Factor in congruential
						   formula.  */
  };

/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */
extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Return non-negative, long integer in [0,2^31).  */
extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Return signed, long integers in [-2^31,2^31).  */
extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Seed random number generator.  */
extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






#define __malloc_and_calloc_defined 

/* Allocate SIZE bytes of memory.  */
extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;
/* Allocate NMEMB elements of SIZE bytes each, all initialized to 0.  */
extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;





/* Re-allocate the previously allocated block
   in PTR, making the new block SIZE bytes long.  */
/* __attribute_malloc__ is not used, because if realloc returns
   the same pointer that was passed to it, aliasing needs to be allowed
   between objects pointed by the old and new pointers.  */
extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
/* Free a block allocated by `malloc', `realloc' or `calloc'.  */
extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));



/* Free a block.  An alias for `free'.	(Sun Unices).  */
extern void cfree (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/alloca.h" 1 3 4
/* Copyright (C) 1992-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _ALLOCA_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 22 "/usr/include/alloca.h" 2 3 4

#define __need_size_t 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 165 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 362 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* A null pointer constant.  */
# 412 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_NULL
# 25 "/usr/include/alloca.h" 2 3 4



/* Remove any previous definitions.  */
#undef alloca

/* Allocate a block that will be freed when the calling function exits.  */
extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));


#define alloca(size) __builtin_alloca (size)



# 454 "/usr/include/stdlib.h" 2 3 4




/* Allocate SIZE bytes on a page boundary.  The storage cannot be freed.  */
extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;



/* Allocate memory of SIZE bytes with an alignment of ALIGNMENT.  */
extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



/* ISO C variant of aligned allocation.  */
extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;



/* Abort execution and generate a core-dump.  */
extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));


/* Register a function to be called when `exit' is called.  */
extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Register a function to be called when `quick_exit' is called.  */




extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





/* Register a function to be called with the status
   given to `exit' and the given argument.  */
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



/* Call all functions registered with `atexit' and `on_exit',
   in the reverse of the order in which they were registered,
   perform stdio cleanup, and terminate program execution with STATUS.  */
extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));


/* Call all functions registered with `at_quick_exit' in the reverse
   of the order in which they were registered and terminate program
   execution with STATUS.  */
extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





/* Terminate the program with STATUS without calling any of the
   functions registered with `atexit' or `on_exit'.  */
extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





/* Return the value of envariable NAME, or NULL if it doesn't exist.  */
extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



/* This function is similar to the above but returns NULL if the
   programs is running with SUID or SGID enabled.  */
extern char *secure_getenv (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



/* The SVID says this is in <stdio.h>, but this seems a better place.	*/
/* Put STRING, which is of the form "NAME=VALUE", in the environment.
   If there is no `=', remove NAME from the environment.  */
extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



/* Set NAME to VALUE in the environment.
   If REPLACE is nonzero, overwrite an existing value.  */
extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

/* Remove the variable NAME from the environment.  */
extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



/* The `clearenv' was planned to be added to POSIX.1 but probably
   never made it.  Nevertheless the POSIX.9 standard (POSIX bindings
   for Fortran 77) requires this function.  */
extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));





/* Generate a unique temporary file name from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the file name unique.
   Always returns TEMPLATE, it's either a temporary file name or a null
   string if it cannot get a unique file name.  */
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



/* Generate a unique temporary file name from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the filename unique.
   Returns a file descriptor open on the file for reading and writing,
   or -1 if it cannot create a uniquely-named file.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 590 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;




/* Similar to mkstemp, but the template can have a suffix after the
   XXXXXX.  The length of the suffix is specified in the second
   parameter.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 612 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;




/* Create a unique temporary directory from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the directory name unique.
   Returns TEMPLATE, or a null pointer if it cannot get a unique name.
   The directory is created mode 700.  */
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



/* Generate a unique temporary file name from TEMPLATE similar to
   mkstemp.  But allow the caller to pass additional flags which are
   used in the open call to create the file..

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 644 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;


/* Similar to mkostemp, but the template can have a suffix after the
   XXXXXX.  The length of the suffix is specified in the second
   parameter.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 666 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;





/* Execute the given line as a shell command.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int system (const char *__command) ;




/* Return a malloc'd string containing the canonical absolute name of the
   existing named file.  */
extern char *canonicalize_file_name (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



/* Return the canonical absolute name of file NAME.  If RESOLVED is
   null, the result is malloc'd; otherwise, if the canonical name is
   PATH_MAX chars or more, returns null with `errno' set to
   ENAMETOOLONG; if the name fits in fewer than PATH_MAX chars,
   returns the name in RESOLVED.  */
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;



/* Shorthand for type of comparison functions.  */

#define __COMPAR_FN_T 
typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);



/* Do a binary search for KEY in BASE, which consists of NMEMB elements
   of SIZE bytes each, using COMPAR to perform the comparisons.  */
extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;


# 1 "/usr/include/arm-linux-gnueabihf/bits/stdlib-bsearch.h" 1 3 4
/* Perform binary search - inline version.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

extern __inline __attribute__ ((__gnu_inline__)) void *
bsearch (const void *__key, const void *__base, size_t __nmemb, size_t __size,
  __compar_fn_t __compar)
{
  size_t __l, __u, __idx;
  const void *__p;
  int __comparison;

  __l = 0;
  __u = __nmemb;
  while (__l < __u)
    {
      __idx = (__l + __u) / 2;
      __p = (void *) (((const char *) __base) + (__idx * __size));
      __comparison = (*__compar) (__key, __p);
      if (__comparison < 0)
 __u = __idx;
      else if (__comparison > 0)
 __l = __idx + 1;
      else
 return (void *) __p;
    }

  return ((void *)0);
}
# 721 "/usr/include/stdlib.h" 2 3 4


/* Sort NMEMB elements of BASE, of SIZE bytes each,
   using COMPAR to perform the comparisons.  */
extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));



/* Return the absolute value of X.  */
extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;




/* Return the `div_t', `ldiv_t' or `lldiv_t' representation
   of the value of NUMER over DENOM. */
/* GCC may have built-ins for these someday.  */
extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;






/* Convert floating point numbers to strings.  The returned values are
   valid only until another call to the same function.  */

/* Convert VALUE to a string with NDIGIT digits and return a pointer to
   this.  Set *DECPT with the position of the decimal character and *SIGN
   with the sign of the number.  */
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;

/* Convert VALUE to a string rounded to NDIGIT decimal digits.  Set *DECPT
   with the position of the decimal character and *SIGN with the sign of
   the number.  */
extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;

/* If possible convert VALUE to a string with NDIGIT significant digits.
   Otherwise use exponential representation.  The resulting string will
   be written to BUF.  */
extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;



/* Long double versions of above functions.  */
extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;


/* Reentrant version of the functions above which provide their own
   buffers.  */
extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));




/* Return the length of the multibyte character
   in S, which is no longer than N.  */
extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));
/* Return the length of the given multibyte character,
   putting its `wchar_t' representation in *PWC.  */
extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));
/* Put the multibyte character represented
   by WCHAR in S, returning its length.  */
extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));


/* Convert a multibyte string to a wide char string.  */
extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));
/* Convert a wide char string to multibyte string.  */
extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));




/* Determine whether the string value of RESPONSE matches the affirmation
   or negative response expression as specified by the LC_MESSAGES category
   in the program's current locale.  Returns 1 if affirmative, 0 if
   negative, and -1 if not matching.  */
extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




/* Parse comma separated suboption from *OPTIONP and match against
   strings in TOKENS.  If found return index and set *VALUEP to
   optional value introduced by an equal sign.  If the suboption is
   not part of TOKENS return in *VALUEP beginning of unknown
   suboption.  On exit *OPTIONP is set to the beginning of the next
   token or at the terminating NUL character.  */
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;




/* Setup DES tables according KEY.  */
extern void setkey (const char *__key) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



/* X/Open pseudo terminal handling.  */


/* Return a master pseudo-terminal handle.  */
extern int posix_openpt (int __oflag) ;



/* The next four functions all take a master pseudo-tty fd and
   perform an operation on the associated slave:  */

/* Chown the slave to the calling user.  */
extern int grantpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));

/* Release an internal lock so the slave can be opened.
   Call after grantpt().  */
extern int unlockpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));

/* Return the pathname of the pseudo terminal slave associated with
   the master FD is open on, or NULL on errors.
   The returned storage is good until the next call to this function.  */
extern char *ptsname (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;



/* Store at most BUFLEN characters of the pathname of the slave pseudo
   terminal associated with the master FD is open on in BUF.
   Return 0 on success, otherwise an error number.  */
extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

/* Open a master pseudo terminal and return its file descriptor.  */
extern int getpt (void);



/* Put the 1 minute, 5 minute and 15 minute load averages into the first
   NELEM elements of LOADAVG.  Return the number written (never more than
   three, but may be less than NELEM), or -1 if an error occurred.  */
extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 921 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/stdlib-float.h" 1 3 4
/* Floating-point inline functions for stdlib.h.
   Copyright (C) 2012-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */







extern __inline __attribute__ ((__gnu_inline__)) double
__attribute__ ((__nothrow__ , __leaf__)) atof (const char *__nptr)
{
  return strtod (__nptr, (char **) ((void *)0));
}

# 922 "/usr/include/stdlib.h" 2 3 4

/* Define some macros helping to catch buffer overflows.  */
# 932 "/usr/include/stdlib.h" 3 4
#undef __need_malloc_and_calloc


# 65 "pifunk.c" 2
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stdbool.h" 1 3 4
/* Copyright (C) 1998-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.16  Boolean type and values  <stdbool.h>
 */


#define _STDBOOL_H 



#define bool _Bool
#define true 1
#define false 0
# 51 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stdbool.h" 3 4
/* Signal that all the definitions are present.  */
#define __bool_true_false_are_defined 1
# 66 "pifunk.c" 2
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stdarg.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */




#define _STDARG_H 
#define _ANSI_STDARG_H_ 

#undef __need___va_list

/* Define __gnuc_va_list.  */






/* Define the standard macros for the user,
   if this invocation was from the user program.  */


#define va_start(v,l) __builtin_va_start(v,l)
#define va_end(v) __builtin_va_end(v)
#define va_arg(v,l) __builtin_va_arg(v,l)


#define va_copy(d,s) __builtin_va_copy(d,s)

#define __va_copy(d,s) __builtin_va_copy(d,s)

/* Define va_list, if desired, from __gnuc_va_list. */
/* We deliberately do not define va_list when called from
   stdio.h, because ANSI C says that stdio.h is not supposed to define
   va_list.  stdio.h needs to have access to that data type, 
   but must not use that name.  It should use the name __gnuc_va_list,
   which is safe because it is reserved for the implementation.  */
# 86 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stdarg.h" 3 4
/* The macro _VA_LIST_ is the same thing used by this file in Ultrix.
   But on BSD NET2 we must not test or define or undef it.
   (Note that the comments in NET 2's ansi.h
   are incorrect for _VA_LIST_--see stdio.h!)  */

/* The macro _VA_LIST_DEFINED is used in Windows NT 3.5  */
# 105 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stdarg.h" 3 4
#define _VA_LIST_ 


#define _VA_LIST 





#define _VA_LIST_T_H 


#define __va_list__ 
# 67 "pifunk.c" 2
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
/* Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99: 7.18 Integer types <stdint.h>
 */


#define _STDINT_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/wchar.h" 1 3 4
/* wchar_t type related definitions.
   Copyright (C) 2000-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _BITS_WCHAR_H 1

/* The fallback definitions, for when __WCHAR_MAX__ or __WCHAR_MIN__
   are not defined, give the right value and type as long as both int
   and wchar_t are 32-bit types.  Adding L'\0' to a constant value
   ensures that the type is correct; it is necessary to use (L'\0' +
   0) rather than just L'\0' so that the type in C++ is the promoted
   version of wchar_t rather than the distinct wchar_t type itself.
   Because wchar_t in preprocessor #if expressions is treated as
   intmax_t or uintmax_t, the expression (L'\0' - 1) would have the
   wrong value for WCHAR_MAX in such expressions and so cannot be used
   to define __WCHAR_MAX in the unsigned case.  */


#define __WCHAR_MAX __WCHAR_MAX__







#define __WCHAR_MIN __WCHAR_MIN__
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/wordsize.h" 1 3 4
/* Copyright (C) 1999-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#define __WORDSIZE 32
# 28 "/usr/include/stdint.h" 2 3 4

/* Exact integral types.  */

/* Signed.  */

/* There is some amount of overlap with <sys/types.h> as known by inet code */
# 47 "/usr/include/stdint.h" 3 4
/* Unsigned.  */
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;
#define __uint32_t_defined 




__extension__
typedef unsigned long long int uint64_t;



/* Small types.  */

/* Signed.  */
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;



__extension__
typedef long long int int_least64_t;


/* Unsigned.  */
typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;



__extension__
typedef unsigned long long int uint_least64_t;



/* Fast types.  */

/* Signed.  */
typedef signed char int_fast8_t;





typedef int int_fast16_t;
typedef int int_fast32_t;
__extension__
typedef long long int int_fast64_t;


/* Unsigned.  */
typedef unsigned char uint_fast8_t;





typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
__extension__
typedef unsigned long long int uint_fast64_t;



/* Types for `void *' pointers.  */
# 125 "/usr/include/stdint.h" 3 4
typedef int intptr_t;
#define __intptr_t_defined 

typedef unsigned int uintptr_t;



/* Largest integral types.  */




__extension__
typedef long long int intmax_t;
__extension__
typedef unsigned long long int uintmax_t;







#define __INT64_C(c) c ## LL
#define __UINT64_C(c) c ## ULL


/* Limits of integral types.  */

/* Minimum of signed integral types.  */
#define INT8_MIN (-128)
#define INT16_MIN (-32767-1)
#define INT32_MIN (-2147483647-1)
#define INT64_MIN (-__INT64_C(9223372036854775807)-1)
/* Maximum of signed integral types.  */
#define INT8_MAX (127)
#define INT16_MAX (32767)
#define INT32_MAX (2147483647)
#define INT64_MAX (__INT64_C(9223372036854775807))

/* Maximum of unsigned integral types.  */
#define UINT8_MAX (255)
#define UINT16_MAX (65535)
#define UINT32_MAX (4294967295U)
#define UINT64_MAX (__UINT64_C(18446744073709551615))


/* Minimum of signed integral types having a minimum size.  */
#define INT_LEAST8_MIN (-128)
#define INT_LEAST16_MIN (-32767-1)
#define INT_LEAST32_MIN (-2147483647-1)
#define INT_LEAST64_MIN (-__INT64_C(9223372036854775807)-1)
/* Maximum of signed integral types having a minimum size.  */
#define INT_LEAST8_MAX (127)
#define INT_LEAST16_MAX (32767)
#define INT_LEAST32_MAX (2147483647)
#define INT_LEAST64_MAX (__INT64_C(9223372036854775807))

/* Maximum of unsigned integral types having a minimum size.  */
#define UINT_LEAST8_MAX (255)
#define UINT_LEAST16_MAX (65535)
#define UINT_LEAST32_MAX (4294967295U)
#define UINT_LEAST64_MAX (__UINT64_C(18446744073709551615))


/* Minimum of fast signed integral types having a minimum size.  */
#define INT_FAST8_MIN (-128)




#define INT_FAST16_MIN (-2147483647-1)
#define INT_FAST32_MIN (-2147483647-1)

#define INT_FAST64_MIN (-__INT64_C(9223372036854775807)-1)
/* Maximum of fast signed integral types having a minimum size.  */
#define INT_FAST8_MAX (127)




#define INT_FAST16_MAX (2147483647)
#define INT_FAST32_MAX (2147483647)

#define INT_FAST64_MAX (__INT64_C(9223372036854775807))

/* Maximum of fast unsigned integral types having a minimum size.  */
#define UINT_FAST8_MAX (255)




#define UINT_FAST16_MAX (4294967295U)
#define UINT_FAST32_MAX (4294967295U)

#define UINT_FAST64_MAX (__UINT64_C(18446744073709551615))


/* Values to test for integral types holding `void *' pointer.  */





#define INTPTR_MIN (-2147483647-1)
#define INTPTR_MAX (2147483647)
#define UINTPTR_MAX (4294967295U)



/* Minimum for largest signed integral type.  */
#define INTMAX_MIN (-__INT64_C(9223372036854775807)-1)
/* Maximum for largest signed integral type.  */
#define INTMAX_MAX (__INT64_C(9223372036854775807))

/* Maximum for largest unsigned integral type.  */
#define UINTMAX_MAX (__UINT64_C(18446744073709551615))


/* Limits of other integer types.  */

/* Limits of `ptrdiff_t' type.  */




#define PTRDIFF_MIN (-2147483647-1)
#define PTRDIFF_MAX (2147483647)


/* Limits of `sig_atomic_t'.  */
#define SIG_ATOMIC_MIN (-2147483647-1)
#define SIG_ATOMIC_MAX (2147483647)

/* Limit of `size_t' type.  */






#define SIZE_MAX (4294967295U)



/* Limits of `wchar_t'.  */

/* These constants might also be defined in <wchar.h>.  */
#define WCHAR_MIN __WCHAR_MIN
#define WCHAR_MAX __WCHAR_MAX


/* Limits of `wint_t'.  */
#define WINT_MIN (0u)
#define WINT_MAX (4294967295u)

/* Signed.  */
#define INT8_C(c) c
#define INT16_C(c) c
#define INT32_C(c) c



#define INT64_C(c) c ## LL


/* Unsigned.  */
#define UINT8_C(c) c
#define UINT16_C(c) c
#define UINT32_C(c) c ## U



#define UINT64_C(c) c ## ULL


/* Maximal type.  */




#define INTMAX_C(c) c ## LL
#define UINTMAX_C(c) c ## ULL
# 10 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stdint.h" 2 3 4



#define _GCC_WRAP_STDINT_H 
# 68 "pifunk.c" 2
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */



#define _STDDEF_H 
#define _STDDEF_H_ 
/* snaroff@next.com says the NeXT needs this.  */
#define _ANSI_STDDEF_H 



/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 137 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#define _PTRDIFF_T 
#define _T_PTRDIFF_ 
#define _T_PTRDIFF 
#define __PTRDIFF_T 
#define _PTRDIFF_T_ 
#define _BSD_PTRDIFF_T_ 
#define ___int_ptrdiff_t_h 
#define _GCC_PTRDIFF_T 
#define _PTRDIFF_T_DECLARED 



typedef int ptrdiff_t;
# 160 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 347 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_wchar_t
# 362 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 69 "pifunk.c" 2
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stdalign.h" 1 3 4
/* Copyright (C) 2011-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* ISO C1X: 7.15 Alignment <stdalign.h>.  */


#define _STDALIGN_H 



#define alignas _Alignas
#define alignof _Alignof

#define __alignas_is_defined 1
#define __alignof_is_defined 1
# 70 "pifunk.c" 2
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stdnoreturn.h" 1 3 4
/* Copyright (C) 2011-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* ISO C1X: 7.23 _Noreturn <stdnoreturn.h>.  */


#define _STDNORETURN_H 



#define noreturn _Noreturn
# 71 "pifunk.c" 2
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stdatomic.h" 1 3 4
/* Copyright (C) 2013-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* ISO C11 Standard:  7.17  Atomics <stdatomic.h>.  */


#define _STDATOMIC_H 

typedef enum
  {
    memory_order_relaxed = 0,
    memory_order_consume = 1,
    memory_order_acquire = 2,
    memory_order_release = 3,
    memory_order_acq_rel = 4,
    memory_order_seq_cst = 5
  } memory_order;


typedef _Atomic _Bool atomic_bool;
typedef _Atomic char atomic_char;
typedef _Atomic signed char atomic_schar;
typedef _Atomic unsigned char atomic_uchar;
typedef _Atomic short atomic_short;
typedef _Atomic unsigned short atomic_ushort;
typedef _Atomic int atomic_int;
typedef _Atomic unsigned int atomic_uint;
typedef _Atomic long atomic_long;
typedef _Atomic unsigned long atomic_ulong;
typedef _Atomic long long atomic_llong;
typedef _Atomic unsigned long long atomic_ullong;
typedef _Atomic short unsigned int atomic_char16_t;
typedef _Atomic unsigned int atomic_char32_t;
typedef _Atomic unsigned int atomic_wchar_t;
typedef _Atomic signed char atomic_int_least8_t;
typedef _Atomic unsigned char atomic_uint_least8_t;
typedef _Atomic short int atomic_int_least16_t;
typedef _Atomic short unsigned int atomic_uint_least16_t;
typedef _Atomic int atomic_int_least32_t;
typedef _Atomic unsigned int atomic_uint_least32_t;
typedef _Atomic long long int atomic_int_least64_t;
typedef _Atomic long long unsigned int atomic_uint_least64_t;
typedef _Atomic signed char atomic_int_fast8_t;
typedef _Atomic unsigned char atomic_uint_fast8_t;
typedef _Atomic int atomic_int_fast16_t;
typedef _Atomic unsigned int atomic_uint_fast16_t;
typedef _Atomic int atomic_int_fast32_t;
typedef _Atomic unsigned int atomic_uint_fast32_t;
typedef _Atomic long long int atomic_int_fast64_t;
typedef _Atomic long long unsigned int atomic_uint_fast64_t;
typedef _Atomic int atomic_intptr_t;
typedef _Atomic unsigned int atomic_uintptr_t;
typedef _Atomic unsigned int atomic_size_t;
typedef _Atomic int atomic_ptrdiff_t;
typedef _Atomic long long int atomic_intmax_t;
typedef _Atomic long long unsigned int atomic_uintmax_t;


#define ATOMIC_VAR_INIT(VALUE) (VALUE)

/* Initialize an atomic object pointed to by PTR with VAL.  */
#define atomic_init(PTR,VAL) atomic_store_explicit (PTR, VAL, __ATOMIC_RELAXED)


#define kill_dependency(Y) __extension__ ({ __auto_type __kill_dependency_tmp = (Y); __kill_dependency_tmp; })






extern void atomic_thread_fence (memory_order);
#define atomic_thread_fence(MO) __atomic_thread_fence (MO)
extern void atomic_signal_fence (memory_order);
#define atomic_signal_fence(MO) __atomic_signal_fence (MO)
#define atomic_is_lock_free(OBJ) __atomic_is_lock_free (sizeof (*(OBJ)), (OBJ))

#define ATOMIC_BOOL_LOCK_FREE __GCC_ATOMIC_BOOL_LOCK_FREE
#define ATOMIC_CHAR_LOCK_FREE __GCC_ATOMIC_CHAR_LOCK_FREE
#define ATOMIC_CHAR16_T_LOCK_FREE __GCC_ATOMIC_CHAR16_T_LOCK_FREE
#define ATOMIC_CHAR32_T_LOCK_FREE __GCC_ATOMIC_CHAR32_T_LOCK_FREE
#define ATOMIC_WCHAR_T_LOCK_FREE __GCC_ATOMIC_WCHAR_T_LOCK_FREE
#define ATOMIC_SHORT_LOCK_FREE __GCC_ATOMIC_SHORT_LOCK_FREE
#define ATOMIC_INT_LOCK_FREE __GCC_ATOMIC_INT_LOCK_FREE
#define ATOMIC_LONG_LOCK_FREE __GCC_ATOMIC_LONG_LOCK_FREE
#define ATOMIC_LLONG_LOCK_FREE __GCC_ATOMIC_LLONG_LOCK_FREE
#define ATOMIC_POINTER_LOCK_FREE __GCC_ATOMIC_POINTER_LOCK_FREE


/* Note that these macros require __typeof__ and __auto_type to remove
   _Atomic qualifiers (and const qualifiers, if those are valid on
   macro operands).
   
   Also note that the header file uses the generic form of __atomic
   builtins, which requires the address to be taken of the value
   parameter, and then we pass that value on.  This allows the macros
   to work for any type, and the compiler is smart enough to convert
   these to lock-free _N variants if possible, and throw away the
   temps.  */

#define atomic_store_explicit(PTR,VAL,MO) __extension__ ({ __auto_type __atomic_store_ptr = (PTR); __typeof__ (*__atomic_store_ptr) __atomic_store_tmp = (VAL); __atomic_store (__atomic_store_ptr, &__atomic_store_tmp, (MO)); })







#define atomic_store(PTR,VAL) atomic_store_explicit (PTR, VAL, __ATOMIC_SEQ_CST)



#define atomic_load_explicit(PTR,MO) __extension__ ({ __auto_type __atomic_load_ptr = (PTR); __typeof__ (*__atomic_load_ptr) __atomic_load_tmp; __atomic_load (__atomic_load_ptr, &__atomic_load_tmp, (MO)); __atomic_load_tmp; })
# 142 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stdatomic.h" 3 4
#define atomic_load(PTR) atomic_load_explicit (PTR, __ATOMIC_SEQ_CST)


#define atomic_exchange_explicit(PTR,VAL,MO) __extension__ ({ __auto_type __atomic_exchange_ptr = (PTR); __typeof__ (*__atomic_exchange_ptr) __atomic_exchange_val = (VAL); __typeof__ (*__atomic_exchange_ptr) __atomic_exchange_tmp; __atomic_exchange (__atomic_exchange_ptr, &__atomic_exchange_val, &__atomic_exchange_tmp, (MO)); __atomic_exchange_tmp; })
# 156 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stdatomic.h" 3 4
#define atomic_exchange(PTR,VAL) atomic_exchange_explicit (PTR, VAL, __ATOMIC_SEQ_CST)



#define atomic_compare_exchange_strong_explicit(PTR,VAL,DES,SUC,FAIL) __extension__ ({ __auto_type __atomic_compare_exchange_ptr = (PTR); __typeof__ (*__atomic_compare_exchange_ptr) __atomic_compare_exchange_tmp = (DES); __atomic_compare_exchange (__atomic_compare_exchange_ptr, (VAL), &__atomic_compare_exchange_tmp, 0, (SUC), (FAIL)); })
# 171 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stdatomic.h" 3 4
#define atomic_compare_exchange_strong(PTR,VAL,DES) atomic_compare_exchange_strong_explicit (PTR, VAL, DES, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)



#define atomic_compare_exchange_weak_explicit(PTR,VAL,DES,SUC,FAIL) __extension__ ({ __auto_type __atomic_compare_exchange_ptr = (PTR); __typeof__ (*__atomic_compare_exchange_ptr) __atomic_compare_exchange_tmp = (DES); __atomic_compare_exchange (__atomic_compare_exchange_ptr, (VAL), &__atomic_compare_exchange_tmp, 1, (SUC), (FAIL)); })
# 186 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stdatomic.h" 3 4
#define atomic_compare_exchange_weak(PTR,VAL,DES) atomic_compare_exchange_weak_explicit (PTR, VAL, DES, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)





#define atomic_fetch_add(PTR,VAL) __atomic_fetch_add ((PTR), (VAL), __ATOMIC_SEQ_CST)

#define atomic_fetch_add_explicit(PTR,VAL,MO) __atomic_fetch_add ((PTR), (VAL), (MO))


#define atomic_fetch_sub(PTR,VAL) __atomic_fetch_sub ((PTR), (VAL), __ATOMIC_SEQ_CST)

#define atomic_fetch_sub_explicit(PTR,VAL,MO) __atomic_fetch_sub ((PTR), (VAL), (MO))


#define atomic_fetch_or(PTR,VAL) __atomic_fetch_or ((PTR), (VAL), __ATOMIC_SEQ_CST)

#define atomic_fetch_or_explicit(PTR,VAL,MO) __atomic_fetch_or ((PTR), (VAL), (MO))


#define atomic_fetch_xor(PTR,VAL) __atomic_fetch_xor ((PTR), (VAL), __ATOMIC_SEQ_CST)

#define atomic_fetch_xor_explicit(PTR,VAL,MO) __atomic_fetch_xor ((PTR), (VAL), (MO))


#define atomic_fetch_and(PTR,VAL) __atomic_fetch_and ((PTR), (VAL), __ATOMIC_SEQ_CST)

#define atomic_fetch_and_explicit(PTR,VAL,MO) __atomic_fetch_and ((PTR), (VAL), (MO))



typedef _Atomic struct
{

  _Bool __val;



} atomic_flag;

#define ATOMIC_FLAG_INIT { 0 }


extern _Bool atomic_flag_test_and_set (volatile atomic_flag *);
#define atomic_flag_test_and_set(PTR) __atomic_test_and_set ((PTR), __ATOMIC_SEQ_CST)

extern _Bool atomic_flag_test_and_set_explicit (volatile atomic_flag *,
      memory_order);
#define atomic_flag_test_and_set_explicit(PTR,MO) __atomic_test_and_set ((PTR), (MO))


extern void atomic_flag_clear (volatile atomic_flag *);
#define atomic_flag_clear(PTR) __atomic_clear ((PTR), __ATOMIC_SEQ_CST)
extern void atomic_flag_clear_explicit (volatile atomic_flag *, memory_order);
#define atomic_flag_clear_explicit(PTR,MO) __atomic_clear ((PTR), (MO))
# 72 "pifunk.c" 2
# 1 "/usr/include/unistd.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.10 Symbolic Constants		<unistd.h>
 */


#define _UNISTD_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/unistd.h" 2 3 4



/* These may be used to determine what facilities are present at compile time.
   Their values can be obtained at run time from `sysconf'.  */


/* POSIX Standard approved as ISO/IEC 9945-1 as of September 2008.  */
#define _POSIX_VERSION 200809L
# 49 "/usr/include/unistd.h" 3 4
/* These are not #ifdef __USE_POSIX2 because they are
   in the theoretically application-owned namespace.  */


#define __POSIX2_THIS_VERSION 200809L
/* The utilities on GNU systems also correspond to this version.  */
# 66 "/usr/include/unistd.h" 3 4
/* The utilities on GNU systems also correspond to this version.  */
#define _POSIX2_VERSION __POSIX2_THIS_VERSION

/* This symbol was required until the 2001 edition of POSIX.  */
#define _POSIX2_C_VERSION __POSIX2_THIS_VERSION

/* If defined, the implementation supports the
   C Language Bindings Option.  */
#define _POSIX2_C_BIND __POSIX2_THIS_VERSION

/* If defined, the implementation supports the
   C Language Development Utilities Option.  */
#define _POSIX2_C_DEV __POSIX2_THIS_VERSION

/* If defined, the implementation supports the
   Software Development Utilities Option.  */
#define _POSIX2_SW_DEV __POSIX2_THIS_VERSION

/* If defined, the implementation supports the
   creation of locales with the localedef utility.  */
#define _POSIX2_LOCALEDEF __POSIX2_THIS_VERSION

/* X/Open version number to which the library conforms.  It is selectable.  */

#define _XOPEN_VERSION 700
# 99 "/usr/include/unistd.h" 3 4
/* Commands and utilities from XPG4 are available.  */
#define _XOPEN_XCU_VERSION 4

/* We are compatible with the old published standards as well.  */
#define _XOPEN_XPG2 1
#define _XOPEN_XPG3 1
#define _XOPEN_XPG4 1

/* The X/Open Unix extensions are available.  */
#define _XOPEN_UNIX 1

/* Encryption is present.  */
#define _XOPEN_CRYPT 1

/* The enhanced internationalization capabilities according to XPG4.2
   are present.  */
#define _XOPEN_ENH_I18N 1

/* The legacy interfaces are also available.  */
#define _XOPEN_LEGACY 1


/* Get values of POSIX options:

   If these symbols are defined, the corresponding features are
   always available.  If not, they may be available sometimes.
   The current values can be obtained with `sysconf'.

   _POSIX_JOB_CONTROL		Job control is supported.
   _POSIX_SAVED_IDS		Processes have a saved set-user-ID
				and a saved set-group-ID.
   _POSIX_REALTIME_SIGNALS	Real-time, queued signals are supported.
   _POSIX_PRIORITY_SCHEDULING	Priority scheduling is supported.
   _POSIX_TIMERS		POSIX.4 clocks and timers are supported.
   _POSIX_ASYNCHRONOUS_IO	Asynchronous I/O is supported.
   _POSIX_PRIORITIZED_IO	Prioritized asynchronous I/O is supported.
   _POSIX_SYNCHRONIZED_IO	Synchronizing file data is supported.
   _POSIX_FSYNC			The fsync function is present.
   _POSIX_MAPPED_FILES		Mapping of files to memory is supported.
   _POSIX_MEMLOCK		Locking of all memory is supported.
   _POSIX_MEMLOCK_RANGE		Locking of ranges of memory is supported.
   _POSIX_MEMORY_PROTECTION	Setting of memory protections is supported.
   _POSIX_MESSAGE_PASSING	POSIX.4 message queues are supported.
   _POSIX_SEMAPHORES		POSIX.4 counting semaphores are supported.
   _POSIX_SHARED_MEMORY_OBJECTS	POSIX.4 shared memory objects are supported.
   _POSIX_THREADS		POSIX.1c pthreads are supported.
   _POSIX_THREAD_ATTR_STACKADDR	Thread stack address attribute option supported.
   _POSIX_THREAD_ATTR_STACKSIZE	Thread stack size attribute option supported.
   _POSIX_THREAD_SAFE_FUNCTIONS	Thread-safe functions are supported.
   _POSIX_THREAD_PRIORITY_SCHEDULING
				POSIX.1c thread execution scheduling supported.
   _POSIX_THREAD_PRIO_INHERIT	Thread priority inheritance option supported.
   _POSIX_THREAD_PRIO_PROTECT	Thread priority protection option supported.
   _POSIX_THREAD_PROCESS_SHARED	Process-shared synchronization supported.
   _POSIX_PII			Protocol-independent interfaces are supported.
   _POSIX_PII_XTI		XTI protocol-indep. interfaces are supported.
   _POSIX_PII_SOCKET		Socket protocol-indep. interfaces are supported.
   _POSIX_PII_INTERNET		Internet family of protocols supported.
   _POSIX_PII_INTERNET_STREAM	Connection-mode Internet protocol supported.
   _POSIX_PII_INTERNET_DGRAM	Connectionless Internet protocol supported.
   _POSIX_PII_OSI		ISO/OSI family of protocols supported.
   _POSIX_PII_OSI_COTS		Connection-mode ISO/OSI service supported.
   _POSIX_PII_OSI_CLTS		Connectionless ISO/OSI service supported.
   _POSIX_POLL			Implementation supports `poll' function.
   _POSIX_SELECT		Implementation supports `select' and `pselect'.

   _XOPEN_REALTIME		X/Open realtime support is available.
   _XOPEN_REALTIME_THREADS	X/Open realtime thread support is available.
   _XOPEN_SHM			Shared memory interface according to XPG4.2.

   _XBS5_ILP32_OFF32		Implementation provides environment with 32-bit
				int, long, pointer, and off_t types.
   _XBS5_ILP32_OFFBIG		Implementation provides environment with 32-bit
				int, long, and pointer and off_t with at least
				64 bits.
   _XBS5_LP64_OFF64		Implementation provides environment with 32-bit
				int, and 64-bit long, pointer, and off_t types.
   _XBS5_LPBIG_OFFBIG		Implementation provides environment with at
				least 32 bits int and long, pointer, and off_t
				with at least 64 bits.

   If any of these symbols is defined as -1, the corresponding option is not
   true for any file.  If any is defined as other than -1, the corresponding
   option is true for all files.  If a symbol is not defined at all, the value
   for a specific file can be obtained from `pathconf' and `fpathconf'.

   _POSIX_CHOWN_RESTRICTED	Only the super user can use `chown' to change
				the owner of a file.  `chown' can only be used
				to change the group ID of a file to a group of
				which the calling process is a member.
   _POSIX_NO_TRUNC		Pathname components longer than
				NAME_MAX generate an error.
   _POSIX_VDISABLE		If defined, if the value of an element of the
				`c_cc' member of `struct termios' is
				_POSIX_VDISABLE, no character will have the
				effect associated with that element.
   _POSIX_SYNC_IO		Synchronous I/O may be performed.
   _POSIX_ASYNC_IO		Asynchronous I/O may be performed.
   _POSIX_PRIO_IO		Prioritized Asynchronous I/O may be performed.

   Support for the Large File Support interface is not generally available.
   If it is available the following constants are defined to one.
   _LFS64_LARGEFILE		Low-level I/O supports large files.
   _LFS64_STDIO			Standard I/O supports large files.
   */

# 1 "/usr/include/arm-linux-gnueabihf/bits/posix_opt.h" 1 3 4
/* Define POSIX options for Linux.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If
   not, see <http://www.gnu.org/licenses/>.  */


#define _BITS_POSIX_OPT_H 1

/* Job control is supported.  */
#define _POSIX_JOB_CONTROL 1

/* Processes have a saved set-user-ID and a saved set-group-ID.  */
#define _POSIX_SAVED_IDS 1

/* Priority scheduling is supported.  */
#define _POSIX_PRIORITY_SCHEDULING 200809L

/* Synchronizing file data is supported.  */
#define _POSIX_SYNCHRONIZED_IO 200809L

/* The fsync function is present.  */
#define _POSIX_FSYNC 200809L

/* Mapping of files to memory is supported.  */
#define _POSIX_MAPPED_FILES 200809L

/* Locking of all memory is supported.  */
#define _POSIX_MEMLOCK 200809L

/* Locking of ranges of memory is supported.  */
#define _POSIX_MEMLOCK_RANGE 200809L

/* Setting of memory protections is supported.  */
#define _POSIX_MEMORY_PROTECTION 200809L

/* Some filesystems allow all users to change file ownership.  */
#define _POSIX_CHOWN_RESTRICTED 0

/* `c_cc' member of 'struct termios' structure can be disabled by
   using the value _POSIX_VDISABLE.  */
#define _POSIX_VDISABLE '\0'

/* Filenames are not silently truncated.  */
#define _POSIX_NO_TRUNC 1

/* X/Open realtime support is available.  */
#define _XOPEN_REALTIME 1

/* X/Open thread realtime support is available.  */
#define _XOPEN_REALTIME_THREADS 1

/* XPG4.2 shared memory is supported.  */
#define _XOPEN_SHM 1

/* Tell we have POSIX threads.  */
#define _POSIX_THREADS 200809L

/* We have the reentrant functions described in POSIX.  */
#define _POSIX_REENTRANT_FUNCTIONS 1
#define _POSIX_THREAD_SAFE_FUNCTIONS 200809L

/* We provide priority scheduling for threads.  */
#define _POSIX_THREAD_PRIORITY_SCHEDULING 200809L

/* We support user-defined stack sizes.  */
#define _POSIX_THREAD_ATTR_STACKSIZE 200809L

/* We support user-defined stacks.  */
#define _POSIX_THREAD_ATTR_STACKADDR 200809L

/* We support priority inheritence.  */
#define _POSIX_THREAD_PRIO_INHERIT 200809L

/* We support priority protection, though only for non-robust
   mutexes.  */
#define _POSIX_THREAD_PRIO_PROTECT 200809L


/* We support priority inheritence for robust mutexes.  */
#define _POSIX_THREAD_ROBUST_PRIO_INHERIT 200809L

/* We do not support priority protection for robust mutexes.  */
#define _POSIX_THREAD_ROBUST_PRIO_PROTECT -1


/* We support POSIX.1b semaphores.  */
#define _POSIX_SEMAPHORES 200809L

/* Real-time signals are supported.  */
#define _POSIX_REALTIME_SIGNALS 200809L

/* We support asynchronous I/O.  */
#define _POSIX_ASYNCHRONOUS_IO 200809L
#define _POSIX_ASYNC_IO 1
/* Alternative name for Unix98.  */
#define _LFS_ASYNCHRONOUS_IO 1
/* Support for prioritization is also available.  */
#define _POSIX_PRIORITIZED_IO 200809L

/* The LFS support in asynchronous I/O is also available.  */
#define _LFS64_ASYNCHRONOUS_IO 1

/* The rest of the LFS is also available.  */
#define _LFS_LARGEFILE 1
#define _LFS64_LARGEFILE 1
#define _LFS64_STDIO 1

/* POSIX shared memory objects are implemented.  */
#define _POSIX_SHARED_MEMORY_OBJECTS 200809L

/* CPU-time clocks support needs to be checked at runtime.  */
#define _POSIX_CPUTIME 0

/* Clock support in threads must be also checked at runtime.  */
#define _POSIX_THREAD_CPUTIME 0

/* GNU libc provides regular expression handling.  */
#define _POSIX_REGEXP 1

/* Reader/Writer locks are available.  */
#define _POSIX_READER_WRITER_LOCKS 200809L

/* We have a POSIX shell.  */
#define _POSIX_SHELL 1

/* We support the Timeouts option.  */
#define _POSIX_TIMEOUTS 200809L

/* We support spinlocks.  */
#define _POSIX_SPIN_LOCKS 200809L

/* The `spawn' function family is supported.  */
#define _POSIX_SPAWN 200809L

/* We have POSIX timers.  */
#define _POSIX_TIMERS 200809L

/* The barrier functions are available.  */
#define _POSIX_BARRIERS 200809L

/* POSIX message queues are available.  */
#define _POSIX_MESSAGE_PASSING 200809L

/* Thread process-shared synchronization is supported.  */
#define _POSIX_THREAD_PROCESS_SHARED 200809L

/* The monotonic clock might be available.  */
#define _POSIX_MONOTONIC_CLOCK 0

/* The clock selection interfaces are available.  */
#define _POSIX_CLOCK_SELECTION 200809L

/* Advisory information interfaces are available.  */
#define _POSIX_ADVISORY_INFO 200809L

/* IPv6 support is available.  */
#define _POSIX_IPV6 200809L

/* Raw socket support is available.  */
#define _POSIX_RAW_SOCKETS 200809L

/* We have at least one terminal.  */
#define _POSIX2_CHAR_TERM 200809L

/* Neither process nor thread sporadic server interfaces is available.  */
#define _POSIX_SPORADIC_SERVER -1
#define _POSIX_THREAD_SPORADIC_SERVER -1

/* trace.h is not available.  */
#define _POSIX_TRACE -1
#define _POSIX_TRACE_EVENT_FILTER -1
#define _POSIX_TRACE_INHERIT -1
#define _POSIX_TRACE_LOG -1

/* Typed memory objects are not available.  */
#define _POSIX_TYPED_MEMORY_OBJECTS -1
# 206 "/usr/include/unistd.h" 2 3 4

/* Get the environment definitions from Unix98.  */

# 1 "/usr/include/arm-linux-gnueabihf/bits/environments.h" 1 3 4
/* Copyright (C) 1999-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





# 1 "/usr/include/arm-linux-gnueabihf/bits/wordsize.h" 1 3 4
/* Copyright (C) 1999-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#define __WORDSIZE 32
# 23 "/usr/include/arm-linux-gnueabihf/bits/environments.h" 2 3 4

/* This header should define the following symbols under the described
   situations.  A value `1' means that the model is always supported,
   `-1' means it is never supported.  Undefined means it cannot be
   statically decided.

   _POSIX_V7_ILP32_OFF32   32bit int, long, pointers, and off_t type
   _POSIX_V7_ILP32_OFFBIG  32bit int, long, and pointers and larger off_t type

   _POSIX_V7_LP64_OFF32	   64bit long and pointers and 32bit off_t type
   _POSIX_V7_LPBIG_OFFBIG  64bit long and pointers and large off_t type

   The macros _POSIX_V6_ILP32_OFF32, _POSIX_V6_ILP32_OFFBIG,
   _POSIX_V6_LP64_OFF32, _POSIX_V6_LPBIG_OFFBIG, _XBS5_ILP32_OFF32,
   _XBS5_ILP32_OFFBIG, _XBS5_LP64_OFF32, and _XBS5_LPBIG_OFFBIG were
   used in previous versions of the Unix standard and are available
   only for compatibility.
*/
# 64 "/usr/include/arm-linux-gnueabihf/bits/environments.h" 3 4
/* By default we have 32-bit wide `int', `long int', pointers and `off_t'
   and all platforms support LFS.  */
#define _POSIX_V7_ILP32_OFF32 1
#define _POSIX_V7_ILP32_OFFBIG 1
#define _POSIX_V6_ILP32_OFF32 1
#define _POSIX_V6_ILP32_OFFBIG 1
#define _XBS5_ILP32_OFF32 1
#define _XBS5_ILP32_OFFBIG 1

/* We optionally provide an environment with the above size but an 64-bit
   side `off_t'.  Therefore we don't define _POSIX_V7_ILP32_OFFBIG.  */

/* We can never provide environments with 64-bit wide pointers.  */
#define _POSIX_V7_LP64_OFF64 -1
#define _POSIX_V7_LPBIG_OFFBIG -1
#define _POSIX_V6_LP64_OFF64 -1
#define _POSIX_V6_LPBIG_OFFBIG -1
#define _XBS5_LP64_OFF64 -1
#define _XBS5_LPBIG_OFFBIG -1

/* CFLAGS.  */
#define __ILP32_OFFBIG_CFLAGS "-D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64"
# 210 "/usr/include/unistd.h" 2 3 4


/* Standard file descriptors.  */
#define STDIN_FILENO 0
#define STDOUT_FILENO 1
#define STDERR_FILENO 2


/* All functions that are not declared anywhere else.  */

# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 221 "/usr/include/unistd.h" 2 3 4






#define __need_size_t 
#define __need_NULL 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 160 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 347 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_wchar_t
# 362 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 230 "/usr/include/unistd.h" 2 3 4


/* The Single Unix specification says that some more types are
   available here.  */
# 277 "/usr/include/unistd.h" 3 4
typedef __socklen_t socklen_t;
#define __socklen_t_defined 



/* Values for the second argument to access.
   These may be OR'd together.  */
#define R_OK 4
#define W_OK 2
#define X_OK 1
#define F_OK 0

/* Test for access to NAME using the real UID and real GID.  */
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Test for access to NAME using the effective UID and GID
   (as normal file operations use).  */
extern int euidaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* An alias for `euidaccess', used by some other systems.  */
extern int eaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



/* Test for access to FILE relative to the directory FD is open on.
   If AT_EACCESS is set in FLAG, then use effective IDs like `eaccess',
   otherwise use real IDs like `access'.  */
extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



/* Values for the WHENCE argument to lseek.  */
# 324 "/usr/include/unistd.h" 3 4
/* Old BSD names for the same constants; just for compatibility.  */
#define L_SET SEEK_SET
#define L_INCR SEEK_CUR
#define L_XTND SEEK_END



/* Move FD's file position to OFFSET bytes from the
   beginning of the file (if WHENCE is SEEK_SET),
   the current position (if WHENCE is SEEK_CUR),
   or the end of the file (if WHENCE is SEEK_END).
   Return the new file position.  */

extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ , __leaf__));
# 348 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     __attribute__ ((__nothrow__ , __leaf__));


/* Close the file descriptor FD.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int close (int __fd);

/* Read NBYTES into BUF from FD.  Return the
   number read, -1 for errors or 0 for EOF.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;

/* Write N bytes of BUF to FD.  Return the number written, or -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t write (int __fd, const void *__buf, size_t __n) ;



/* Read NBYTES into BUF from FD at the given position OFFSET without
   changing the file pointer.  Return the number read, -1 for errors
   or 0 for EOF.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;

/* Write N bytes of BUF to FD at the given position OFFSET without
   changing the file pointer.  Return the number written, or -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 404 "/usr/include/unistd.h" 3 4
/* Read NBYTES into BUF from FD at the given position OFFSET without
   changing the file pointer.  Return the number read, -1 for errors
   or 0 for EOF.  */
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;
/* Write N bytes of BUF to FD at the given position OFFSET without
   changing the file pointer.  Return the number written, or -1.  */
extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;



/* Create a one-way communication channel (pipe).
   If successful, two file descriptors are stored in PIPEDES;
   bytes written on PIPEDES[1] can be read from PIPEDES[0].
   Returns 0 if successful, -1 if not.  */
extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ , __leaf__)) ;


/* Same as pipe but apply flags passed in FLAGS to the new file
   descriptors.  */
extern int pipe2 (int __pipedes[2], int __flags) __attribute__ ((__nothrow__ , __leaf__)) ;


/* Schedule an alarm.  In SECONDS seconds, the process will get a SIGALRM.
   If SECONDS is zero, any currently scheduled alarm will be cancelled.
   The function returns the number of seconds remaining until the last
   alarm scheduled would have signaled, or zero if there wasn't one.
   There is no return value to indicate an error, but you can set `errno'
   to 0 and check its value after calling `alarm', and this might tell you.
   The signal may come late due to processor scheduling.  */
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ , __leaf__));

/* Make the process sleep for SECONDS seconds, or until a signal arrives
   and is not ignored.  The function returns the number of seconds less
   than SECONDS which it actually slept (thus zero if it slept the full time).
   If a signal handler does a `longjmp' or modifies the handling of the
   SIGALRM signal while inside `sleep' call, the handling of the SIGALRM
   signal afterwards is undefined.  There is no return value to indicate
   error, but if `sleep' returns SECONDS, it probably didn't work.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern unsigned int sleep (unsigned int __seconds);



/* Set an alarm to go off (generating a SIGALRM signal) in VALUE
   microseconds.  If INTERVAL is nonzero, when the alarm goes off, the
   timer is reset to go off every INTERVAL microseconds thereafter.
   Returns the number of microseconds remaining before the alarm.  */
extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ , __leaf__));

/* Sleep USECONDS microseconds, or until a signal arrives that is not blocked
   or ignored.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int usleep (__useconds_t __useconds);



/* Suspend the process until a signal arrives.
   This always returns -1 and sets `errno' to EINTR.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pause (void);


/* Change the owner and group of FILE.  */
extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;


/* Change the owner and group of the file that FD is open on.  */
extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__)) ;


/* Change owner and group of FILE, if it is a symbolic
   link the ownership of the symbolic link is changed.  */
extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




/* Change the owner and group of FILE relative to the directory FD is open
   on.  */
extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;


/* Change the process's working directory to PATH.  */
extern int chdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;


/* Change the process's working directory to the one FD is open on.  */
extern int fchdir (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;


/* Get the pathname of the current working directory,
   and put it in SIZE bytes of BUF.  Returns NULL if the
   directory couldn't be determined or SIZE was too small.
   If successful, returns BUF.  In GNU, if BUF is NULL,
   an array is allocated with `malloc'; the array is SIZE
   bytes long, unless SIZE == 0, in which case it is as
   big as necessary.  */
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) ;


/* Return a malloc'd string containing the current directory name.
   If the environment variable `PWD' is set, and its value is correct,
   that value is used.  */
extern char *get_current_dir_name (void) __attribute__ ((__nothrow__ , __leaf__));




/* Put the absolute pathname of the current working directory in BUF.
   If successful, return BUF.  If not, put an error message in
   BUF and return NULL.  BUF should be at least PATH_MAX bytes long.  */
extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;



/* Duplicate FD, returning a new file descriptor on the same file.  */
extern int dup (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;

/* Duplicate FD to FD2, closing FD2 and making it open on the same file.  */
extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ , __leaf__));


/* Duplicate FD to FD2, closing FD2 and making it open on the same
   file while setting flags according to FLAGS.  */
extern int dup3 (int __fd, int __fd2, int __flags) __attribute__ ((__nothrow__ , __leaf__));


/* NULL-terminated array of "NAME=VALUE" environment variables.  */
extern char **__environ;

extern char **environ;



/* Replace the current process, executing PATH with arguments ARGV and
   environment ENVP.  ARGV and ENVP are terminated by NULL pointers.  */
extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


/* Execute the file FD refers to, overlaying the running program image.
   ARGV and ENVP are passed to the new program, as for `execve'.  */
extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



/* Execute PATH with arguments ARGV and environment from `environ'.  */
extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Execute PATH with all arguments after PATH until a NULL pointer,
   and the argument after that for environment.  */
extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Execute PATH with all arguments after PATH until
   a NULL pointer and environment from `environ'.  */
extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Execute FILE, searching in the `PATH' environment variable if it contains
   no slashes, with arguments ARGV and environment from `environ'.  */
extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Execute FILE, searching in the `PATH' environment variable if
   it contains no slashes, with all arguments after FILE until a
   NULL pointer and environment from `environ'.  */
extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


/* Execute FILE, searching in the `PATH' environment variable if it contains
   no slashes, with arguments ARGV and environment from `environ'.  */
extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




/* Add INC to priority of the current process.  */
extern int nice (int __inc) __attribute__ ((__nothrow__ , __leaf__)) ;



/* Terminate program execution with the low-order 8 bits of STATUS.  */
extern void _exit (int __status) __attribute__ ((__noreturn__));


/* Get the `_PC_*' symbols for the NAME argument to `pathconf' and `fpathconf';
   the `_SC_*' symbols for the NAME argument to `sysconf';
   and the `_CS_*' symbols for the NAME argument to `confstr'.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/confname.h" 1 3 4
/* `sysconf', `pathconf', and `confstr' NAME values.  Generic version.
   Copyright (C) 1993-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* Values for the NAME argument to `pathconf' and `fpathconf'.  */
enum
  {
    _PC_LINK_MAX,
#define _PC_LINK_MAX _PC_LINK_MAX
    _PC_MAX_CANON,
#define _PC_MAX_CANON _PC_MAX_CANON
    _PC_MAX_INPUT,
#define _PC_MAX_INPUT _PC_MAX_INPUT
    _PC_NAME_MAX,
#define _PC_NAME_MAX _PC_NAME_MAX
    _PC_PATH_MAX,
#define _PC_PATH_MAX _PC_PATH_MAX
    _PC_PIPE_BUF,
#define _PC_PIPE_BUF _PC_PIPE_BUF
    _PC_CHOWN_RESTRICTED,
#define _PC_CHOWN_RESTRICTED _PC_CHOWN_RESTRICTED
    _PC_NO_TRUNC,
#define _PC_NO_TRUNC _PC_NO_TRUNC
    _PC_VDISABLE,
#define _PC_VDISABLE _PC_VDISABLE
    _PC_SYNC_IO,
#define _PC_SYNC_IO _PC_SYNC_IO
    _PC_ASYNC_IO,
#define _PC_ASYNC_IO _PC_ASYNC_IO
    _PC_PRIO_IO,
#define _PC_PRIO_IO _PC_PRIO_IO
    _PC_SOCK_MAXBUF,
#define _PC_SOCK_MAXBUF _PC_SOCK_MAXBUF
    _PC_FILESIZEBITS,
#define _PC_FILESIZEBITS _PC_FILESIZEBITS
    _PC_REC_INCR_XFER_SIZE,
#define _PC_REC_INCR_XFER_SIZE _PC_REC_INCR_XFER_SIZE
    _PC_REC_MAX_XFER_SIZE,
#define _PC_REC_MAX_XFER_SIZE _PC_REC_MAX_XFER_SIZE
    _PC_REC_MIN_XFER_SIZE,
#define _PC_REC_MIN_XFER_SIZE _PC_REC_MIN_XFER_SIZE
    _PC_REC_XFER_ALIGN,
#define _PC_REC_XFER_ALIGN _PC_REC_XFER_ALIGN
    _PC_ALLOC_SIZE_MIN,
#define _PC_ALLOC_SIZE_MIN _PC_ALLOC_SIZE_MIN
    _PC_SYMLINK_MAX,
#define _PC_SYMLINK_MAX _PC_SYMLINK_MAX
    _PC_2_SYMLINKS
#define _PC_2_SYMLINKS _PC_2_SYMLINKS
  };

/* Values for the argument to `sysconf'.  */
enum
  {
    _SC_ARG_MAX,
#define _SC_ARG_MAX _SC_ARG_MAX
    _SC_CHILD_MAX,
#define _SC_CHILD_MAX _SC_CHILD_MAX
    _SC_CLK_TCK,
#define _SC_CLK_TCK _SC_CLK_TCK
    _SC_NGROUPS_MAX,
#define _SC_NGROUPS_MAX _SC_NGROUPS_MAX
    _SC_OPEN_MAX,
#define _SC_OPEN_MAX _SC_OPEN_MAX
    _SC_STREAM_MAX,
#define _SC_STREAM_MAX _SC_STREAM_MAX
    _SC_TZNAME_MAX,
#define _SC_TZNAME_MAX _SC_TZNAME_MAX
    _SC_JOB_CONTROL,
#define _SC_JOB_CONTROL _SC_JOB_CONTROL
    _SC_SAVED_IDS,
#define _SC_SAVED_IDS _SC_SAVED_IDS
    _SC_REALTIME_SIGNALS,
#define _SC_REALTIME_SIGNALS _SC_REALTIME_SIGNALS
    _SC_PRIORITY_SCHEDULING,
#define _SC_PRIORITY_SCHEDULING _SC_PRIORITY_SCHEDULING
    _SC_TIMERS,
#define _SC_TIMERS _SC_TIMERS
    _SC_ASYNCHRONOUS_IO,
#define _SC_ASYNCHRONOUS_IO _SC_ASYNCHRONOUS_IO
    _SC_PRIORITIZED_IO,
#define _SC_PRIORITIZED_IO _SC_PRIORITIZED_IO
    _SC_SYNCHRONIZED_IO,
#define _SC_SYNCHRONIZED_IO _SC_SYNCHRONIZED_IO
    _SC_FSYNC,
#define _SC_FSYNC _SC_FSYNC
    _SC_MAPPED_FILES,
#define _SC_MAPPED_FILES _SC_MAPPED_FILES
    _SC_MEMLOCK,
#define _SC_MEMLOCK _SC_MEMLOCK
    _SC_MEMLOCK_RANGE,
#define _SC_MEMLOCK_RANGE _SC_MEMLOCK_RANGE
    _SC_MEMORY_PROTECTION,
#define _SC_MEMORY_PROTECTION _SC_MEMORY_PROTECTION
    _SC_MESSAGE_PASSING,
#define _SC_MESSAGE_PASSING _SC_MESSAGE_PASSING
    _SC_SEMAPHORES,
#define _SC_SEMAPHORES _SC_SEMAPHORES
    _SC_SHARED_MEMORY_OBJECTS,
#define _SC_SHARED_MEMORY_OBJECTS _SC_SHARED_MEMORY_OBJECTS
    _SC_AIO_LISTIO_MAX,
#define _SC_AIO_LISTIO_MAX _SC_AIO_LISTIO_MAX
    _SC_AIO_MAX,
#define _SC_AIO_MAX _SC_AIO_MAX
    _SC_AIO_PRIO_DELTA_MAX,
#define _SC_AIO_PRIO_DELTA_MAX _SC_AIO_PRIO_DELTA_MAX
    _SC_DELAYTIMER_MAX,
#define _SC_DELAYTIMER_MAX _SC_DELAYTIMER_MAX
    _SC_MQ_OPEN_MAX,
#define _SC_MQ_OPEN_MAX _SC_MQ_OPEN_MAX
    _SC_MQ_PRIO_MAX,
#define _SC_MQ_PRIO_MAX _SC_MQ_PRIO_MAX
    _SC_VERSION,
#define _SC_VERSION _SC_VERSION
    _SC_PAGESIZE,
#define _SC_PAGESIZE _SC_PAGESIZE
#define _SC_PAGE_SIZE _SC_PAGESIZE
    _SC_RTSIG_MAX,
#define _SC_RTSIG_MAX _SC_RTSIG_MAX
    _SC_SEM_NSEMS_MAX,
#define _SC_SEM_NSEMS_MAX _SC_SEM_NSEMS_MAX
    _SC_SEM_VALUE_MAX,
#define _SC_SEM_VALUE_MAX _SC_SEM_VALUE_MAX
    _SC_SIGQUEUE_MAX,
#define _SC_SIGQUEUE_MAX _SC_SIGQUEUE_MAX
    _SC_TIMER_MAX,
#define _SC_TIMER_MAX _SC_TIMER_MAX

    /* Values for the argument to `sysconf'
       corresponding to _POSIX2_* symbols.  */
    _SC_BC_BASE_MAX,
#define _SC_BC_BASE_MAX _SC_BC_BASE_MAX
    _SC_BC_DIM_MAX,
#define _SC_BC_DIM_MAX _SC_BC_DIM_MAX
    _SC_BC_SCALE_MAX,
#define _SC_BC_SCALE_MAX _SC_BC_SCALE_MAX
    _SC_BC_STRING_MAX,
#define _SC_BC_STRING_MAX _SC_BC_STRING_MAX
    _SC_COLL_WEIGHTS_MAX,
#define _SC_COLL_WEIGHTS_MAX _SC_COLL_WEIGHTS_MAX
    _SC_EQUIV_CLASS_MAX,
#define _SC_EQUIV_CLASS_MAX _SC_EQUIV_CLASS_MAX
    _SC_EXPR_NEST_MAX,
#define _SC_EXPR_NEST_MAX _SC_EXPR_NEST_MAX
    _SC_LINE_MAX,
#define _SC_LINE_MAX _SC_LINE_MAX
    _SC_RE_DUP_MAX,
#define _SC_RE_DUP_MAX _SC_RE_DUP_MAX
    _SC_CHARCLASS_NAME_MAX,
#define _SC_CHARCLASS_NAME_MAX _SC_CHARCLASS_NAME_MAX

    _SC_2_VERSION,
#define _SC_2_VERSION _SC_2_VERSION
    _SC_2_C_BIND,
#define _SC_2_C_BIND _SC_2_C_BIND
    _SC_2_C_DEV,
#define _SC_2_C_DEV _SC_2_C_DEV
    _SC_2_FORT_DEV,
#define _SC_2_FORT_DEV _SC_2_FORT_DEV
    _SC_2_FORT_RUN,
#define _SC_2_FORT_RUN _SC_2_FORT_RUN
    _SC_2_SW_DEV,
#define _SC_2_SW_DEV _SC_2_SW_DEV
    _SC_2_LOCALEDEF,
#define _SC_2_LOCALEDEF _SC_2_LOCALEDEF

    _SC_PII,
#define _SC_PII _SC_PII
    _SC_PII_XTI,
#define _SC_PII_XTI _SC_PII_XTI
    _SC_PII_SOCKET,
#define _SC_PII_SOCKET _SC_PII_SOCKET
    _SC_PII_INTERNET,
#define _SC_PII_INTERNET _SC_PII_INTERNET
    _SC_PII_OSI,
#define _SC_PII_OSI _SC_PII_OSI
    _SC_POLL,
#define _SC_POLL _SC_POLL
    _SC_SELECT,
#define _SC_SELECT _SC_SELECT
    _SC_UIO_MAXIOV,
#define _SC_UIO_MAXIOV _SC_UIO_MAXIOV
    _SC_IOV_MAX = _SC_UIO_MAXIOV,
#define _SC_IOV_MAX _SC_IOV_MAX
    _SC_PII_INTERNET_STREAM,
#define _SC_PII_INTERNET_STREAM _SC_PII_INTERNET_STREAM
    _SC_PII_INTERNET_DGRAM,
#define _SC_PII_INTERNET_DGRAM _SC_PII_INTERNET_DGRAM
    _SC_PII_OSI_COTS,
#define _SC_PII_OSI_COTS _SC_PII_OSI_COTS
    _SC_PII_OSI_CLTS,
#define _SC_PII_OSI_CLTS _SC_PII_OSI_CLTS
    _SC_PII_OSI_M,
#define _SC_PII_OSI_M _SC_PII_OSI_M
    _SC_T_IOV_MAX,
#define _SC_T_IOV_MAX _SC_T_IOV_MAX

    /* Values according to POSIX 1003.1c (POSIX threads).  */
    _SC_THREADS,
#define _SC_THREADS _SC_THREADS
    _SC_THREAD_SAFE_FUNCTIONS,
#define _SC_THREAD_SAFE_FUNCTIONS _SC_THREAD_SAFE_FUNCTIONS
    _SC_GETGR_R_SIZE_MAX,
#define _SC_GETGR_R_SIZE_MAX _SC_GETGR_R_SIZE_MAX
    _SC_GETPW_R_SIZE_MAX,
#define _SC_GETPW_R_SIZE_MAX _SC_GETPW_R_SIZE_MAX
    _SC_LOGIN_NAME_MAX,
#define _SC_LOGIN_NAME_MAX _SC_LOGIN_NAME_MAX
    _SC_TTY_NAME_MAX,
#define _SC_TTY_NAME_MAX _SC_TTY_NAME_MAX
    _SC_THREAD_DESTRUCTOR_ITERATIONS,
#define _SC_THREAD_DESTRUCTOR_ITERATIONS _SC_THREAD_DESTRUCTOR_ITERATIONS
    _SC_THREAD_KEYS_MAX,
#define _SC_THREAD_KEYS_MAX _SC_THREAD_KEYS_MAX
    _SC_THREAD_STACK_MIN,
#define _SC_THREAD_STACK_MIN _SC_THREAD_STACK_MIN
    _SC_THREAD_THREADS_MAX,
#define _SC_THREAD_THREADS_MAX _SC_THREAD_THREADS_MAX
    _SC_THREAD_ATTR_STACKADDR,
#define _SC_THREAD_ATTR_STACKADDR _SC_THREAD_ATTR_STACKADDR
    _SC_THREAD_ATTR_STACKSIZE,
#define _SC_THREAD_ATTR_STACKSIZE _SC_THREAD_ATTR_STACKSIZE
    _SC_THREAD_PRIORITY_SCHEDULING,
#define _SC_THREAD_PRIORITY_SCHEDULING _SC_THREAD_PRIORITY_SCHEDULING
    _SC_THREAD_PRIO_INHERIT,
#define _SC_THREAD_PRIO_INHERIT _SC_THREAD_PRIO_INHERIT
    _SC_THREAD_PRIO_PROTECT,
#define _SC_THREAD_PRIO_PROTECT _SC_THREAD_PRIO_PROTECT
    _SC_THREAD_PROCESS_SHARED,
#define _SC_THREAD_PROCESS_SHARED _SC_THREAD_PROCESS_SHARED

    _SC_NPROCESSORS_CONF,
#define _SC_NPROCESSORS_CONF _SC_NPROCESSORS_CONF
    _SC_NPROCESSORS_ONLN,
#define _SC_NPROCESSORS_ONLN _SC_NPROCESSORS_ONLN
    _SC_PHYS_PAGES,
#define _SC_PHYS_PAGES _SC_PHYS_PAGES
    _SC_AVPHYS_PAGES,
#define _SC_AVPHYS_PAGES _SC_AVPHYS_PAGES
    _SC_ATEXIT_MAX,
#define _SC_ATEXIT_MAX _SC_ATEXIT_MAX
    _SC_PASS_MAX,
#define _SC_PASS_MAX _SC_PASS_MAX

    _SC_XOPEN_VERSION,
#define _SC_XOPEN_VERSION _SC_XOPEN_VERSION
    _SC_XOPEN_XCU_VERSION,
#define _SC_XOPEN_XCU_VERSION _SC_XOPEN_XCU_VERSION
    _SC_XOPEN_UNIX,
#define _SC_XOPEN_UNIX _SC_XOPEN_UNIX
    _SC_XOPEN_CRYPT,
#define _SC_XOPEN_CRYPT _SC_XOPEN_CRYPT
    _SC_XOPEN_ENH_I18N,
#define _SC_XOPEN_ENH_I18N _SC_XOPEN_ENH_I18N
    _SC_XOPEN_SHM,
#define _SC_XOPEN_SHM _SC_XOPEN_SHM

    _SC_2_CHAR_TERM,
#define _SC_2_CHAR_TERM _SC_2_CHAR_TERM
    _SC_2_C_VERSION,
#define _SC_2_C_VERSION _SC_2_C_VERSION
    _SC_2_UPE,
#define _SC_2_UPE _SC_2_UPE

    _SC_XOPEN_XPG2,
#define _SC_XOPEN_XPG2 _SC_XOPEN_XPG2
    _SC_XOPEN_XPG3,
#define _SC_XOPEN_XPG3 _SC_XOPEN_XPG3
    _SC_XOPEN_XPG4,
#define _SC_XOPEN_XPG4 _SC_XOPEN_XPG4

    _SC_CHAR_BIT,
#define _SC_CHAR_BIT _SC_CHAR_BIT
    _SC_CHAR_MAX,
#define _SC_CHAR_MAX _SC_CHAR_MAX
    _SC_CHAR_MIN,
#define _SC_CHAR_MIN _SC_CHAR_MIN
    _SC_INT_MAX,
#define _SC_INT_MAX _SC_INT_MAX
    _SC_INT_MIN,
#define _SC_INT_MIN _SC_INT_MIN
    _SC_LONG_BIT,
#define _SC_LONG_BIT _SC_LONG_BIT
    _SC_WORD_BIT,
#define _SC_WORD_BIT _SC_WORD_BIT
    _SC_MB_LEN_MAX,
#define _SC_MB_LEN_MAX _SC_MB_LEN_MAX
    _SC_NZERO,
#define _SC_NZERO _SC_NZERO
    _SC_SSIZE_MAX,
#define _SC_SSIZE_MAX _SC_SSIZE_MAX
    _SC_SCHAR_MAX,
#define _SC_SCHAR_MAX _SC_SCHAR_MAX
    _SC_SCHAR_MIN,
#define _SC_SCHAR_MIN _SC_SCHAR_MIN
    _SC_SHRT_MAX,
#define _SC_SHRT_MAX _SC_SHRT_MAX
    _SC_SHRT_MIN,
#define _SC_SHRT_MIN _SC_SHRT_MIN
    _SC_UCHAR_MAX,
#define _SC_UCHAR_MAX _SC_UCHAR_MAX
    _SC_UINT_MAX,
#define _SC_UINT_MAX _SC_UINT_MAX
    _SC_ULONG_MAX,
#define _SC_ULONG_MAX _SC_ULONG_MAX
    _SC_USHRT_MAX,
#define _SC_USHRT_MAX _SC_USHRT_MAX

    _SC_NL_ARGMAX,
#define _SC_NL_ARGMAX _SC_NL_ARGMAX
    _SC_NL_LANGMAX,
#define _SC_NL_LANGMAX _SC_NL_LANGMAX
    _SC_NL_MSGMAX,
#define _SC_NL_MSGMAX _SC_NL_MSGMAX
    _SC_NL_NMAX,
#define _SC_NL_NMAX _SC_NL_NMAX
    _SC_NL_SETMAX,
#define _SC_NL_SETMAX _SC_NL_SETMAX
    _SC_NL_TEXTMAX,
#define _SC_NL_TEXTMAX _SC_NL_TEXTMAX

    _SC_XBS5_ILP32_OFF32,
#define _SC_XBS5_ILP32_OFF32 _SC_XBS5_ILP32_OFF32
    _SC_XBS5_ILP32_OFFBIG,
#define _SC_XBS5_ILP32_OFFBIG _SC_XBS5_ILP32_OFFBIG
    _SC_XBS5_LP64_OFF64,
#define _SC_XBS5_LP64_OFF64 _SC_XBS5_LP64_OFF64
    _SC_XBS5_LPBIG_OFFBIG,
#define _SC_XBS5_LPBIG_OFFBIG _SC_XBS5_LPBIG_OFFBIG

    _SC_XOPEN_LEGACY,
#define _SC_XOPEN_LEGACY _SC_XOPEN_LEGACY
    _SC_XOPEN_REALTIME,
#define _SC_XOPEN_REALTIME _SC_XOPEN_REALTIME
    _SC_XOPEN_REALTIME_THREADS,
#define _SC_XOPEN_REALTIME_THREADS _SC_XOPEN_REALTIME_THREADS

    _SC_ADVISORY_INFO,
#define _SC_ADVISORY_INFO _SC_ADVISORY_INFO
    _SC_BARRIERS,
#define _SC_BARRIERS _SC_BARRIERS
    _SC_BASE,
#define _SC_BASE _SC_BASE
    _SC_C_LANG_SUPPORT,
#define _SC_C_LANG_SUPPORT _SC_C_LANG_SUPPORT
    _SC_C_LANG_SUPPORT_R,
#define _SC_C_LANG_SUPPORT_R _SC_C_LANG_SUPPORT_R
    _SC_CLOCK_SELECTION,
#define _SC_CLOCK_SELECTION _SC_CLOCK_SELECTION
    _SC_CPUTIME,
#define _SC_CPUTIME _SC_CPUTIME
    _SC_THREAD_CPUTIME,
#define _SC_THREAD_CPUTIME _SC_THREAD_CPUTIME
    _SC_DEVICE_IO,
#define _SC_DEVICE_IO _SC_DEVICE_IO
    _SC_DEVICE_SPECIFIC,
#define _SC_DEVICE_SPECIFIC _SC_DEVICE_SPECIFIC
    _SC_DEVICE_SPECIFIC_R,
#define _SC_DEVICE_SPECIFIC_R _SC_DEVICE_SPECIFIC_R
    _SC_FD_MGMT,
#define _SC_FD_MGMT _SC_FD_MGMT
    _SC_FIFO,
#define _SC_FIFO _SC_FIFO
    _SC_PIPE,
#define _SC_PIPE _SC_PIPE
    _SC_FILE_ATTRIBUTES,
#define _SC_FILE_ATTRIBUTES _SC_FILE_ATTRIBUTES
    _SC_FILE_LOCKING,
#define _SC_FILE_LOCKING _SC_FILE_LOCKING
    _SC_FILE_SYSTEM,
#define _SC_FILE_SYSTEM _SC_FILE_SYSTEM
    _SC_MONOTONIC_CLOCK,
#define _SC_MONOTONIC_CLOCK _SC_MONOTONIC_CLOCK
    _SC_MULTI_PROCESS,
#define _SC_MULTI_PROCESS _SC_MULTI_PROCESS
    _SC_SINGLE_PROCESS,
#define _SC_SINGLE_PROCESS _SC_SINGLE_PROCESS
    _SC_NETWORKING,
#define _SC_NETWORKING _SC_NETWORKING
    _SC_READER_WRITER_LOCKS,
#define _SC_READER_WRITER_LOCKS _SC_READER_WRITER_LOCKS
    _SC_SPIN_LOCKS,
#define _SC_SPIN_LOCKS _SC_SPIN_LOCKS
    _SC_REGEXP,
#define _SC_REGEXP _SC_REGEXP
    _SC_REGEX_VERSION,
#define _SC_REGEX_VERSION _SC_REGEX_VERSION
    _SC_SHELL,
#define _SC_SHELL _SC_SHELL
    _SC_SIGNALS,
#define _SC_SIGNALS _SC_SIGNALS
    _SC_SPAWN,
#define _SC_SPAWN _SC_SPAWN
    _SC_SPORADIC_SERVER,
#define _SC_SPORADIC_SERVER _SC_SPORADIC_SERVER
    _SC_THREAD_SPORADIC_SERVER,
#define _SC_THREAD_SPORADIC_SERVER _SC_THREAD_SPORADIC_SERVER
    _SC_SYSTEM_DATABASE,
#define _SC_SYSTEM_DATABASE _SC_SYSTEM_DATABASE
    _SC_SYSTEM_DATABASE_R,
#define _SC_SYSTEM_DATABASE_R _SC_SYSTEM_DATABASE_R
    _SC_TIMEOUTS,
#define _SC_TIMEOUTS _SC_TIMEOUTS
    _SC_TYPED_MEMORY_OBJECTS,
#define _SC_TYPED_MEMORY_OBJECTS _SC_TYPED_MEMORY_OBJECTS
    _SC_USER_GROUPS,
#define _SC_USER_GROUPS _SC_USER_GROUPS
    _SC_USER_GROUPS_R,
#define _SC_USER_GROUPS_R _SC_USER_GROUPS_R
    _SC_2_PBS,
#define _SC_2_PBS _SC_2_PBS
    _SC_2_PBS_ACCOUNTING,
#define _SC_2_PBS_ACCOUNTING _SC_2_PBS_ACCOUNTING
    _SC_2_PBS_LOCATE,
#define _SC_2_PBS_LOCATE _SC_2_PBS_LOCATE
    _SC_2_PBS_MESSAGE,
#define _SC_2_PBS_MESSAGE _SC_2_PBS_MESSAGE
    _SC_2_PBS_TRACK,
#define _SC_2_PBS_TRACK _SC_2_PBS_TRACK
    _SC_SYMLOOP_MAX,
#define _SC_SYMLOOP_MAX _SC_SYMLOOP_MAX
    _SC_STREAMS,
#define _SC_STREAMS _SC_STREAMS
    _SC_2_PBS_CHECKPOINT,
#define _SC_2_PBS_CHECKPOINT _SC_2_PBS_CHECKPOINT

    _SC_V6_ILP32_OFF32,
#define _SC_V6_ILP32_OFF32 _SC_V6_ILP32_OFF32
    _SC_V6_ILP32_OFFBIG,
#define _SC_V6_ILP32_OFFBIG _SC_V6_ILP32_OFFBIG
    _SC_V6_LP64_OFF64,
#define _SC_V6_LP64_OFF64 _SC_V6_LP64_OFF64
    _SC_V6_LPBIG_OFFBIG,
#define _SC_V6_LPBIG_OFFBIG _SC_V6_LPBIG_OFFBIG

    _SC_HOST_NAME_MAX,
#define _SC_HOST_NAME_MAX _SC_HOST_NAME_MAX
    _SC_TRACE,
#define _SC_TRACE _SC_TRACE
    _SC_TRACE_EVENT_FILTER,
#define _SC_TRACE_EVENT_FILTER _SC_TRACE_EVENT_FILTER
    _SC_TRACE_INHERIT,
#define _SC_TRACE_INHERIT _SC_TRACE_INHERIT
    _SC_TRACE_LOG,
#define _SC_TRACE_LOG _SC_TRACE_LOG

    _SC_LEVEL1_ICACHE_SIZE,
#define _SC_LEVEL1_ICACHE_SIZE _SC_LEVEL1_ICACHE_SIZE
    _SC_LEVEL1_ICACHE_ASSOC,
#define _SC_LEVEL1_ICACHE_ASSOC _SC_LEVEL1_ICACHE_ASSOC
    _SC_LEVEL1_ICACHE_LINESIZE,
#define _SC_LEVEL1_ICACHE_LINESIZE _SC_LEVEL1_ICACHE_LINESIZE
    _SC_LEVEL1_DCACHE_SIZE,
#define _SC_LEVEL1_DCACHE_SIZE _SC_LEVEL1_DCACHE_SIZE
    _SC_LEVEL1_DCACHE_ASSOC,
#define _SC_LEVEL1_DCACHE_ASSOC _SC_LEVEL1_DCACHE_ASSOC
    _SC_LEVEL1_DCACHE_LINESIZE,
#define _SC_LEVEL1_DCACHE_LINESIZE _SC_LEVEL1_DCACHE_LINESIZE
    _SC_LEVEL2_CACHE_SIZE,
#define _SC_LEVEL2_CACHE_SIZE _SC_LEVEL2_CACHE_SIZE
    _SC_LEVEL2_CACHE_ASSOC,
#define _SC_LEVEL2_CACHE_ASSOC _SC_LEVEL2_CACHE_ASSOC
    _SC_LEVEL2_CACHE_LINESIZE,
#define _SC_LEVEL2_CACHE_LINESIZE _SC_LEVEL2_CACHE_LINESIZE
    _SC_LEVEL3_CACHE_SIZE,
#define _SC_LEVEL3_CACHE_SIZE _SC_LEVEL3_CACHE_SIZE
    _SC_LEVEL3_CACHE_ASSOC,
#define _SC_LEVEL3_CACHE_ASSOC _SC_LEVEL3_CACHE_ASSOC
    _SC_LEVEL3_CACHE_LINESIZE,
#define _SC_LEVEL3_CACHE_LINESIZE _SC_LEVEL3_CACHE_LINESIZE
    _SC_LEVEL4_CACHE_SIZE,
#define _SC_LEVEL4_CACHE_SIZE _SC_LEVEL4_CACHE_SIZE
    _SC_LEVEL4_CACHE_ASSOC,
#define _SC_LEVEL4_CACHE_ASSOC _SC_LEVEL4_CACHE_ASSOC
    _SC_LEVEL4_CACHE_LINESIZE,
#define _SC_LEVEL4_CACHE_LINESIZE _SC_LEVEL4_CACHE_LINESIZE
    /* Leave room here, maybe we need a few more cache levels some day.  */

    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,
#define _SC_IPV6 _SC_IPV6
    _SC_RAW_SOCKETS,
#define _SC_RAW_SOCKETS _SC_RAW_SOCKETS

    _SC_V7_ILP32_OFF32,
#define _SC_V7_ILP32_OFF32 _SC_V7_ILP32_OFF32
    _SC_V7_ILP32_OFFBIG,
#define _SC_V7_ILP32_OFFBIG _SC_V7_ILP32_OFFBIG
    _SC_V7_LP64_OFF64,
#define _SC_V7_LP64_OFF64 _SC_V7_LP64_OFF64
    _SC_V7_LPBIG_OFFBIG,
#define _SC_V7_LPBIG_OFFBIG _SC_V7_LPBIG_OFFBIG

    _SC_SS_REPL_MAX,
#define _SC_SS_REPL_MAX _SC_SS_REPL_MAX

    _SC_TRACE_EVENT_NAME_MAX,
#define _SC_TRACE_EVENT_NAME_MAX _SC_TRACE_EVENT_NAME_MAX
    _SC_TRACE_NAME_MAX,
#define _SC_TRACE_NAME_MAX _SC_TRACE_NAME_MAX
    _SC_TRACE_SYS_MAX,
#define _SC_TRACE_SYS_MAX _SC_TRACE_SYS_MAX
    _SC_TRACE_USER_EVENT_MAX,
#define _SC_TRACE_USER_EVENT_MAX _SC_TRACE_USER_EVENT_MAX

    _SC_XOPEN_STREAMS,
#define _SC_XOPEN_STREAMS _SC_XOPEN_STREAMS

    _SC_THREAD_ROBUST_PRIO_INHERIT,
#define _SC_THREAD_ROBUST_PRIO_INHERIT _SC_THREAD_ROBUST_PRIO_INHERIT
    _SC_THREAD_ROBUST_PRIO_PROTECT
#define _SC_THREAD_ROBUST_PRIO_PROTECT _SC_THREAD_ROBUST_PRIO_PROTECT
  };

/* Values for the NAME argument to `confstr'.  */
enum
  {
    _CS_PATH, /* The default search path.  */
#define _CS_PATH _CS_PATH

    _CS_V6_WIDTH_RESTRICTED_ENVS,
#define _CS_V6_WIDTH_RESTRICTED_ENVS _CS_V6_WIDTH_RESTRICTED_ENVS
#define _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS _CS_V6_WIDTH_RESTRICTED_ENVS

    _CS_GNU_LIBC_VERSION,
#define _CS_GNU_LIBC_VERSION _CS_GNU_LIBC_VERSION
    _CS_GNU_LIBPTHREAD_VERSION,
#define _CS_GNU_LIBPTHREAD_VERSION _CS_GNU_LIBPTHREAD_VERSION

    _CS_V5_WIDTH_RESTRICTED_ENVS,
#define _CS_V5_WIDTH_RESTRICTED_ENVS _CS_V5_WIDTH_RESTRICTED_ENVS
#define _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS _CS_V5_WIDTH_RESTRICTED_ENVS

    _CS_V7_WIDTH_RESTRICTED_ENVS,
#define _CS_V7_WIDTH_RESTRICTED_ENVS _CS_V7_WIDTH_RESTRICTED_ENVS
#define _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS _CS_V7_WIDTH_RESTRICTED_ENVS

    _CS_LFS_CFLAGS = 1000,
#define _CS_LFS_CFLAGS _CS_LFS_CFLAGS
    _CS_LFS_LDFLAGS,
#define _CS_LFS_LDFLAGS _CS_LFS_LDFLAGS
    _CS_LFS_LIBS,
#define _CS_LFS_LIBS _CS_LFS_LIBS
    _CS_LFS_LINTFLAGS,
#define _CS_LFS_LINTFLAGS _CS_LFS_LINTFLAGS
    _CS_LFS64_CFLAGS,
#define _CS_LFS64_CFLAGS _CS_LFS64_CFLAGS
    _CS_LFS64_LDFLAGS,
#define _CS_LFS64_LDFLAGS _CS_LFS64_LDFLAGS
    _CS_LFS64_LIBS,
#define _CS_LFS64_LIBS _CS_LFS64_LIBS
    _CS_LFS64_LINTFLAGS,
#define _CS_LFS64_LINTFLAGS _CS_LFS64_LINTFLAGS

    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
#define _CS_XBS5_ILP32_OFF32_CFLAGS _CS_XBS5_ILP32_OFF32_CFLAGS
    _CS_XBS5_ILP32_OFF32_LDFLAGS,
#define _CS_XBS5_ILP32_OFF32_LDFLAGS _CS_XBS5_ILP32_OFF32_LDFLAGS
    _CS_XBS5_ILP32_OFF32_LIBS,
#define _CS_XBS5_ILP32_OFF32_LIBS _CS_XBS5_ILP32_OFF32_LIBS
    _CS_XBS5_ILP32_OFF32_LINTFLAGS,
#define _CS_XBS5_ILP32_OFF32_LINTFLAGS _CS_XBS5_ILP32_OFF32_LINTFLAGS
    _CS_XBS5_ILP32_OFFBIG_CFLAGS,
#define _CS_XBS5_ILP32_OFFBIG_CFLAGS _CS_XBS5_ILP32_OFFBIG_CFLAGS
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,
#define _CS_XBS5_ILP32_OFFBIG_LDFLAGS _CS_XBS5_ILP32_OFFBIG_LDFLAGS
    _CS_XBS5_ILP32_OFFBIG_LIBS,
#define _CS_XBS5_ILP32_OFFBIG_LIBS _CS_XBS5_ILP32_OFFBIG_LIBS
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,
#define _CS_XBS5_ILP32_OFFBIG_LINTFLAGS _CS_XBS5_ILP32_OFFBIG_LINTFLAGS
    _CS_XBS5_LP64_OFF64_CFLAGS,
#define _CS_XBS5_LP64_OFF64_CFLAGS _CS_XBS5_LP64_OFF64_CFLAGS
    _CS_XBS5_LP64_OFF64_LDFLAGS,
#define _CS_XBS5_LP64_OFF64_LDFLAGS _CS_XBS5_LP64_OFF64_LDFLAGS
    _CS_XBS5_LP64_OFF64_LIBS,
#define _CS_XBS5_LP64_OFF64_LIBS _CS_XBS5_LP64_OFF64_LIBS
    _CS_XBS5_LP64_OFF64_LINTFLAGS,
#define _CS_XBS5_LP64_OFF64_LINTFLAGS _CS_XBS5_LP64_OFF64_LINTFLAGS
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,
#define _CS_XBS5_LPBIG_OFFBIG_CFLAGS _CS_XBS5_LPBIG_OFFBIG_CFLAGS
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,
#define _CS_XBS5_LPBIG_OFFBIG_LDFLAGS _CS_XBS5_LPBIG_OFFBIG_LDFLAGS
    _CS_XBS5_LPBIG_OFFBIG_LIBS,
#define _CS_XBS5_LPBIG_OFFBIG_LIBS _CS_XBS5_LPBIG_OFFBIG_LIBS
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,
#define _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS

    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,
#define _CS_POSIX_V6_ILP32_OFF32_CFLAGS _CS_POSIX_V6_ILP32_OFF32_CFLAGS
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,
#define _CS_POSIX_V6_ILP32_OFF32_LDFLAGS _CS_POSIX_V6_ILP32_OFF32_LDFLAGS
    _CS_POSIX_V6_ILP32_OFF32_LIBS,
#define _CS_POSIX_V6_ILP32_OFF32_LIBS _CS_POSIX_V6_ILP32_OFF32_LIBS
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,
#define _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,
#define _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,
#define _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,
#define _CS_POSIX_V6_ILP32_OFFBIG_LIBS _CS_POSIX_V6_ILP32_OFFBIG_LIBS
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,
#define _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS
    _CS_POSIX_V6_LP64_OFF64_CFLAGS,
#define _CS_POSIX_V6_LP64_OFF64_CFLAGS _CS_POSIX_V6_LP64_OFF64_CFLAGS
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,
#define _CS_POSIX_V6_LP64_OFF64_LDFLAGS _CS_POSIX_V6_LP64_OFF64_LDFLAGS
    _CS_POSIX_V6_LP64_OFF64_LIBS,
#define _CS_POSIX_V6_LP64_OFF64_LIBS _CS_POSIX_V6_LP64_OFF64_LIBS
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,
#define _CS_POSIX_V6_LP64_OFF64_LINTFLAGS _CS_POSIX_V6_LP64_OFF64_LINTFLAGS
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,
#define _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,
#define _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,
#define _CS_POSIX_V6_LPBIG_OFFBIG_LIBS _CS_POSIX_V6_LPBIG_OFFBIG_LIBS
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,
#define _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS

    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,
#define _CS_POSIX_V7_ILP32_OFF32_CFLAGS _CS_POSIX_V7_ILP32_OFF32_CFLAGS
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,
#define _CS_POSIX_V7_ILP32_OFF32_LDFLAGS _CS_POSIX_V7_ILP32_OFF32_LDFLAGS
    _CS_POSIX_V7_ILP32_OFF32_LIBS,
#define _CS_POSIX_V7_ILP32_OFF32_LIBS _CS_POSIX_V7_ILP32_OFF32_LIBS
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,
#define _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,
#define _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,
#define _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,
#define _CS_POSIX_V7_ILP32_OFFBIG_LIBS _CS_POSIX_V7_ILP32_OFFBIG_LIBS
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,
#define _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS
    _CS_POSIX_V7_LP64_OFF64_CFLAGS,
#define _CS_POSIX_V7_LP64_OFF64_CFLAGS _CS_POSIX_V7_LP64_OFF64_CFLAGS
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,
#define _CS_POSIX_V7_LP64_OFF64_LDFLAGS _CS_POSIX_V7_LP64_OFF64_LDFLAGS
    _CS_POSIX_V7_LP64_OFF64_LIBS,
#define _CS_POSIX_V7_LP64_OFF64_LIBS _CS_POSIX_V7_LP64_OFF64_LIBS
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,
#define _CS_POSIX_V7_LP64_OFF64_LINTFLAGS _CS_POSIX_V7_LP64_OFF64_LINTFLAGS
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,
#define _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,
#define _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,
#define _CS_POSIX_V7_LPBIG_OFFBIG_LIBS _CS_POSIX_V7_LPBIG_OFFBIG_LIBS
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,
#define _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS

    _CS_V6_ENV,
#define _CS_V6_ENV _CS_V6_ENV
    _CS_V7_ENV
#define _CS_V7_ENV _CS_V7_ENV
  };
# 613 "/usr/include/unistd.h" 2 3 4

/* Get file-specific configuration information about PATH.  */
extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Get file-specific configuration about descriptor FD.  */
extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ , __leaf__));

/* Get the value of the system variable NAME.  */
extern long int sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));


/* Get the value of the string-valued system variable NAME.  */
extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));



/* Get the process ID of the calling process.  */
extern __pid_t getpid (void) __attribute__ ((__nothrow__ , __leaf__));

/* Get the process ID of the calling process's parent.  */
extern __pid_t getppid (void) __attribute__ ((__nothrow__ , __leaf__));

/* Get the process group ID of the calling process.  */
extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ , __leaf__));

/* Get the process group ID of process PID.  */
extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));



/* Set the process group ID of the process matching PID to PGID.
   If PID is zero, the current process's process group ID is set.
   If PGID is zero, the process ID of the process is used.  */
extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ , __leaf__));


/* Both System V and BSD have `setpgrp' functions, but with different
   calling conventions.  The BSD function is the same as POSIX.1 `setpgid'
   (above).  The System V function takes no arguments and puts the calling
   process in its on group like `setpgid (0, 0)'.

   New programs should always use `setpgid' instead.

   GNU provides the POSIX.1 function.  */

/* Set the process group ID of the calling process to its own PID.
   This is exactly the same as `setpgid (0, 0)'.  */
extern int setpgrp (void) __attribute__ ((__nothrow__ , __leaf__));



/* Create a new session with the calling process as its leader.
   The process group IDs of the session and the calling process
   are set to the process ID of the calling process, which is returned.  */
extern __pid_t setsid (void) __attribute__ ((__nothrow__ , __leaf__));


/* Return the session ID of the given process.  */
extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));


/* Get the real user ID of the calling process.  */
extern __uid_t getuid (void) __attribute__ ((__nothrow__ , __leaf__));

/* Get the effective user ID of the calling process.  */
extern __uid_t geteuid (void) __attribute__ ((__nothrow__ , __leaf__));

/* Get the real group ID of the calling process.  */
extern __gid_t getgid (void) __attribute__ ((__nothrow__ , __leaf__));

/* Get the effective group ID of the calling process.  */
extern __gid_t getegid (void) __attribute__ ((__nothrow__ , __leaf__));

/* If SIZE is zero, return the number of supplementary groups
   the calling process is in.  Otherwise, fill in the group IDs
   of its supplementary groups in LIST and return the number written.  */
extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ , __leaf__)) ;


/* Return nonzero iff the calling process is in group GID.  */
extern int group_member (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__));


/* Set the user ID of the calling process to UID.
   If the calling process is the super-user, set the real
   and effective user IDs, and the saved set-user-ID to UID;
   if not, the effective user ID is set to UID.  */
extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;


/* Set the real user ID of the calling process to RUID,
   and the effective user ID of the calling process to EUID.  */
extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ , __leaf__)) ;



/* Set the effective user ID of the calling process to UID.  */
extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;


/* Set the group ID of the calling process to GID.
   If the calling process is the super-user, set the real
   and effective group IDs, and the saved set-group-ID to GID;
   if not, the effective group ID is set to GID.  */
extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;


/* Set the real group ID of the calling process to RGID,
   and the effective group ID of the calling process to EGID.  */
extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ , __leaf__)) ;



/* Set the effective group ID of the calling process to GID.  */
extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;



/* Fetch the real user ID, effective user ID, and saved-set user ID,
   of the calling process.  */
extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     __attribute__ ((__nothrow__ , __leaf__));

/* Fetch the real group ID, effective group ID, and saved-set group ID,
   of the calling process.  */
extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     __attribute__ ((__nothrow__ , __leaf__));

/* Set the real user ID, effective user ID, and saved-set user ID,
   of the calling process to RUID, EUID, and SUID, respectively.  */
extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     __attribute__ ((__nothrow__ , __leaf__)) ;

/* Set the real group ID, effective group ID, and saved-set group ID,
   of the calling process to RGID, EGID, and SGID, respectively.  */
extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     __attribute__ ((__nothrow__ , __leaf__)) ;



/* Clone the calling process, creating an exact copy.
   Return -1 for errors, 0 to the new process,
   and the process ID of the new process to the old process.  */
extern __pid_t fork (void) __attribute__ ((__nothrow__));



/* Clone the calling process, but without copying the whole address space.
   The calling process is suspended until the new process exits or is
   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
   and the process ID of the new process to the old process.  */
extern __pid_t vfork (void) __attribute__ ((__nothrow__ , __leaf__));



/* Return the pathname of the terminal FD is open on, or NULL on errors.
   The returned storage is good only until the next call to this function.  */
extern char *ttyname (int __fd) __attribute__ ((__nothrow__ , __leaf__));

/* Store at most BUFLEN characters of the pathname of the terminal FD is
   open on in BUF.  Return 0 on success, otherwise an error number.  */
extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;

/* Return 1 if FD is a valid descriptor associated
   with a terminal, zero if not.  */
extern int isatty (int __fd) __attribute__ ((__nothrow__ , __leaf__));


/* Return the index into the active-logins file (utmp) for
   the controlling terminal.  */
extern int ttyslot (void) __attribute__ ((__nothrow__ , __leaf__));



/* Make a link to FROM named TO.  */
extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;


/* Like link but relative paths in TO and FROM are interpreted relative
   to FROMFD and TOFD respectively.  */
extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4))) ;



/* Make a symbolic link to FROM named TO.  */
extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;

/* Read the contents of the symbolic link PATH into no more than
   LEN bytes of BUF.  The contents are not null-terminated.
   Returns the number of characters read, or -1 for errors.  */
extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;



/* Like symlink but a relative path in TO is interpreted relative to TOFD.  */
extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3))) ;

/* Like readlink but a relative PATH is interpreted relative to FD.  */
extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3))) ;


/* Remove the link NAME.  */
extern int unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Remove the link NAME relative to FD.  */
extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


/* Remove the directory PATH.  */
extern int rmdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Return the foreground process group ID of FD.  */
extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ , __leaf__));

/* Set the foreground process group ID of FD set PGRP_ID.  */
extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ , __leaf__));


/* Return the login name of the user.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern char *getlogin (void);

/* Return at most NAME_LEN characters of the login name of the user in NAME.
   If it cannot be determined or some other error occurred, return the error
   code.  Otherwise return 0.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));



/* Set the login name returned by `getlogin'.  */
extern int setlogin (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




/* Get definitions and prototypes for functions to process the
   arguments in ARGV (ARGC of them, minus the program name) for
   options given in OPTS.  */
#define __need_getopt 
# 1 "/usr/include/getopt.h" 1 3 4
/* Declarations for getopt.
   Copyright (C) 1989-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */







/* If __GNU_LIBRARY__ is not already defined, either we are being used
   standalone, or this is the first header included in the source file.
   If we are being used with glibc, we need to include <features.h>, but
   that does not exist if we are standalone.  So: if __GNU_LIBRARY__ is
   not defined, include <ctype.h>, which will pull in <features.h> for us
   if it's from glibc.  (Why ctype.h?  It's guaranteed to exist and it
   doesn't flood the namespace with stuff the way some other headers do.)  */
# 51 "/usr/include/getopt.h" 3 4
/* For communication from `getopt' to the caller.
   When `getopt' finds an option that takes an argument,
   the argument value is returned here.
   Also, when `ordering' is RETURN_IN_ORDER,
   each non-option ARGV-element is returned here.  */

extern char *optarg;

/* Index in ARGV of the next element to be scanned.
   This is used for communication to and from the caller
   and for communication between successive calls to `getopt'.

   On entry to `getopt', zero means this is the first call; initialize.

   When `getopt' returns -1, this is the index of the first of the
   non-option elements that the caller should itself scan.

   Otherwise, `optind' communicates from one call to the next
   how much of ARGV has been scanned so far.  */

extern int optind;

/* Callers store zero here to inhibit the error message `getopt' prints
   for unrecognized options.  */

extern int opterr;

/* Set to an option character which was unrecognized.  */

extern int optopt;
# 122 "/usr/include/getopt.h" 3 4
/* Get definitions and prototypes for functions to process the
   arguments in ARGV (ARGC of them, minus the program name) for
   options given in OPTS.

   Return the option character from OPTS just read.  Return -1 when
   there are no more options.  For unrecognized options, or options
   missing arguments, `optopt' is set to the option letter, and '?' is
   returned.

   The OPTS string is a list of characters which are recognized option
   letters, optionally followed by colons, specifying that that letter
   takes an argument, to be placed in `optarg'.

   If a letter in OPTS is followed by two colons, its argument is
   optional.  This behavior is specific to the GNU `getopt'.

   The argument `--' causes premature termination of argument
   scanning, explicitly telling `getopt' that there are no more
   options.

   If OPTS begins with `--', then non-option arguments are treated as
   arguments to the option '\0'.  This behavior is specific to the GNU
   `getopt'.  */


/* Many other libraries have conflicting prototypes for getopt, with
   differences in the consts, in stdlib.h.  To avoid compilation
   errors, only prototype getopt for the GNU C library.  */
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ , __leaf__));
# 188 "/usr/include/getopt.h" 3 4
/* Make sure we later can get all the definitions and declarations.  */
#undef __need_getopt
# 874 "/usr/include/unistd.h" 2 3 4




/* Put the name of the current host in no more than LEN bytes of NAME.
   The result is null-terminated if LEN is large enough for the full
   name and the terminator.  */
extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




/* Set the name of the current host to NAME, which is LEN bytes long.
   This call is restricted to the super-user.  */
extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;

/* Set the current machine's Internet number to ID.
   This call is restricted to the super-user.  */
extern int sethostid (long int __id) __attribute__ ((__nothrow__ , __leaf__)) ;


/* Get and set the NIS (aka YP) domain name, if any.
   Called just like `gethostname' and `sethostname'.
   The NIS domain name is usually the empty string when not using NIS.  */
extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;


/* Revoke access permissions to all processes currently communicating
   with the control terminal, and then send a SIGHUP signal to the process
   group of the control terminal.  */
extern int vhangup (void) __attribute__ ((__nothrow__ , __leaf__));

/* Revoke the access of all descriptors currently open on FILE.  */
extern int revoke (const char *__file) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;


/* Enable statistical profiling, writing samples of the PC into at most
   SIZE bytes of SAMPLE_BUFFER; every processor clock tick while profiling
   is enabled, the system examines the user PC and increments
   SAMPLE_BUFFER[((PC - OFFSET) / 2) * SCALE / 65536].  If SCALE is zero,
   disable profiling.  Returns zero on success, -1 on error.  */
extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Turn accounting on if NAME is an existing file.  The system will then write
   a record for each process as it terminates, to this file.  If NAME is NULL,
   turn accounting off.  This call is restricted to the super-user.  */
extern int acct (const char *__name) __attribute__ ((__nothrow__ , __leaf__));


/* Successive calls return the shells listed in `/etc/shells'.  */
extern char *getusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void endusershell (void) __attribute__ ((__nothrow__ , __leaf__)); /* Discard cached info.  */
extern void setusershell (void) __attribute__ ((__nothrow__ , __leaf__)); /* Rewind and re-read the file.  */


/* Put the program in the background, and dissociate from the controlling
   terminal.  If NOCHDIR is zero, do `chdir ("/")'.  If NOCLOSE is zero,
   redirects stdin, stdout, and stderr to /dev/null.  */
extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ , __leaf__)) ;




/* Make PATH be the root directory (the starting point for absolute paths).
   This call is restricted to the super-user.  */
extern int chroot (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;

/* Prompt with PROMPT and read a string from the terminal without echoing.
   Uses /dev/tty if possible; otherwise stderr and stdin.  */
extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));



/* Make all changes done to FD actually appear on disk.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int fsync (int __fd);



/* Make all changes done to all files on the file system associated
   with FD actually appear on disk.  */
extern int syncfs (int __fd) __attribute__ ((__nothrow__ , __leaf__));





/* Return identifier for the current host.  */
extern long int gethostid (void);

/* Make all changes done to all files actually appear on disk.  */
extern void sync (void) __attribute__ ((__nothrow__ , __leaf__));



/* Return the number of bytes in a page.  This is the system's page size,
   which is not necessarily the same as the hardware page size.  */
extern int getpagesize (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


/* Return the maximum number of file descriptors
   the current process could possibly have.  */
extern int getdtablesize (void) __attribute__ ((__nothrow__ , __leaf__));







/* Truncate FILE to LENGTH bytes.  */

extern int truncate (const char *__file, __off_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1007 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;







/* Truncate the file FD is open on to LENGTH bytes.  */

extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1028 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1037 "/usr/include/unistd.h" 3 4
/* Set the end of accessible data space (aka "the break") to ADDR.
   Returns zero on success and -1 for errors (with errno set).  */
extern int brk (void *__addr) __attribute__ ((__nothrow__ , __leaf__)) ;

/* Increase or decrease the end of accessible data space by DELTA bytes.
   If successful, returns the address the previous end of data space
   (i.e. the beginning of the new space, if DELTA > 0);
   returns (void *) -1 for errors (with errno set).  */
extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ , __leaf__));




/* Invoke `system call' number SYSNO, passing it the remaining arguments.
   This is completely system-dependent, and not often useful.

   In Unix, `syscall' sets `errno' for all errors and most calls return -1
   for errors; in many systems you cannot pass arguments or get return
   values for all system calls (`pipe', `fork', and `getppid' typically
   among them).

   In Mach, all system calls take normal arguments and always return an
   error code (zero for success).  */
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ , __leaf__));





/* NOTE: These declarations also appear in <fcntl.h>; be sure to keep both
   files consistent.  Some systems have them there and some here, and some
   software depends on the macros being defined without including both.  */

/* `lockf' is a simpler interface to the locking facilities of `fcntl'.
   LEN is always relative to the current file position.
   The CMD argument is one of the following.

   This function is a cancellation point and therefore not marked with
   __THROW.  */

#define F_ULOCK 0
#define F_LOCK 1
#define F_TLOCK 2
#define F_TEST 3


extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1093 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;






/* Evaluate EXPRESSION, and repeat as long as it returns -1 with `errno'
   set to EINTR.  */

#define TEMP_FAILURE_RETRY(expression) (__extension__ ({ long int __result; do __result = (long int) (expression); while (__result == -1L && errno == EINTR); __result; }))
# 1112 "/usr/include/unistd.h" 3 4
/* Synchronize at least the data part of a file with the underlying
   media.  */
extern int fdatasync (int __fildes);



/* XPG4.2 specifies that prototypes for the encryption functions must
   be defined here.  */

/* Encrypt at most 8 characters from KEY using salt to perturb DES.  */
extern char *crypt (const char *__key, const char *__salt)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Encrypt data in BLOCK in place if EDFLAG is zero; otherwise decrypt
   block in place.  */
extern void encrypt (char *__glibc_block, int __edflag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Swab pairs bytes in the first N bytes of the area pointed to by
   FROM and copy the result to TO.  The value of TO must not be in the
   range [FROM - N + 1, FROM - 1].  If N is odd the first byte in FROM
   is without partner.  */
extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



/* Prior to Issue 6, the Single Unix Specification required these
   prototypes to appear in this header.  They are also found in
   <stdio.h>.  */
# 1152 "/usr/include/unistd.h" 3 4
/* Unix98 requires this function to be declared here.  In other
   standards it is in <pthread.h>.  */







/* Define some macros helping to catch buffer overflows.  */





# 73 "pifunk.c" 2

# 73 "pifunk.c"
// functionality includes
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/iso646.h" 1 3 4

# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/iso646.h" 3 4
/* Copyright (C) 1997-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.9  Alternative spellings  <iso646.h>
 */


#define _ISO646_H 


#define and &&
#define and_eq &=
#define bitand &
#define bitor |
#define compl ~
#define not !
#define not_eq !=
#define or ||
#define or_eq |=
#define xor ^
#define xor_eq ^=
# 75 "pifunk.c" 2
# 1 "/usr/include/argp.h" 1 3 4
/* Hierarchial argument parsing, layered over getopt.
   Copyright (C) 1995-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Written by Miles Bader <miles@gnu.ai.mit.edu>.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _ARGP_H 

# 1 "/usr/include/stdio.h" 1 3 4
/* Define ISO C stdio on top of C++ iostreams.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.19 Input/output	<stdio.h>
 */
# 24 "/usr/include/argp.h" 2 3 4
# 1 "/usr/include/ctype.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard 7.4: Character handling	<ctype.h>
 */


#define _CTYPE_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/ctype.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 27 "/usr/include/ctype.h" 2 3 4




/* These are all the characteristics of characters.
   If there get to be more than 16 distinct characteristics,
   many things must be changed that use `unsigned short int's.

   The characteristics are stored always in network byte order (big
   endian).  We define the bit value interpretations here dependent on the
   machine's byte order.  */

# 1 "/usr/include/endian.h" 1 3 4
/* Copyright (C) 1992-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 40 "/usr/include/ctype.h" 2 3 4



#define _ISbit(bit) ((bit) < 8 ? ((1 << (bit)) << 8) : ((1 << (bit)) >> 8))


enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)), /* UPPERCASE.  */
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)), /* lowercase.  */
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)), /* Alphabetic.  */
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)), /* Numeric.  */
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)), /* Hexadecimal numeric.  */
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)), /* Whitespace.  */
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)), /* Printing.  */
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)), /* Graphical.  */
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)), /* Blank (usually SPC and TAB).  */
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)), /* Control character.  */
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)), /* Punctuation.  */
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8)) /* Alphanumeric.  */
};


/* These are defined in ctype-info.c.
   The declarations here must match those in localeinfo.h.

   In the thread-specific locale model (see `uselocale' in <locale.h>)
   we cannot use global variables for these as was done in the past.
   Instead, the following accessor functions return the address of
   each variable, which is local to the current thread if multithreaded.

   These point into arrays of 384, so they can be indexed by any `unsigned
   char' value [0,255]; by EOF (-1); or by any `signed char' value
   [-128,-1).  ISO C requires that the ctype functions work for `unsigned
   char' values and for EOF; we also support negative `signed char' values
   for broken old programs.  The case conversion arrays are of `int's
   rather than `unsigned char's because tolower (EOF) must be EOF, which
   doesn't fit into an `unsigned char'.  But today more important is that
   the arrays are also used for multi-byte character sets.  */
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



#define __isctype(c,type) ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)
# 99 "/usr/include/ctype.h" 3 4
#define __isascii(c) (((c) & ~0x7f) == 0)
#define __toascii(c) ((c) & 0x7f)

#define __exctype(name) extern int name (int) __THROW



/* The following names are all functions:
     int isCHARACTERISTIC(int c);
   which return nonzero iff C has CHARACTERISTIC.
   For the meaning of the characteristic names, see the `enum' above.  */
extern int isalnum (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha (int) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit (int) __attribute__ ((__nothrow__ , __leaf__));
extern int islower (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint (int) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit (int) __attribute__ ((__nothrow__ , __leaf__));


/* Return the lowercase version of C.  */
extern int tolower (int __c) __attribute__ ((__nothrow__ , __leaf__));

/* Return the uppercase version of C.  */
extern int toupper (int __c) __attribute__ ((__nothrow__ , __leaf__));




/* ISO C99 introduced one new function.  */



extern int isblank (int) __attribute__ ((__nothrow__ , __leaf__));





/* Test C for a set of character classes according to MASK.  */
extern int isctype (int __c, int __mask) __attribute__ ((__nothrow__ , __leaf__));




/* Return nonzero iff C is in the ASCII set
   (i.e., is no more than 7 bits wide).  */
extern int isascii (int __c) __attribute__ ((__nothrow__ , __leaf__));

/* Return the part of C that is in the ASCII set
   (i.e., the low-order 7 bits of C).  */
extern int toascii (int __c) __attribute__ ((__nothrow__ , __leaf__));

/* These are the same as `toupper' and `tolower' except that they do not
   check the argument for being in the range of a `char'.  */
extern int _toupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int _tolower (int) __attribute__ ((__nothrow__ , __leaf__));


/* This code is needed for the optimized mapping functions.  */
#define __tobody(c,f,a,args) (__extension__ ({ int __res; if (sizeof (c) > 1) { if (__builtin_constant_p (c)) { int __c = (c); __res = __c < -128 || __c > 255 ? __c : (a)[__c]; } else __res = f args; } else __res = (a)[(int) (c)]; __res; }))
# 197 "/usr/include/ctype.h" 3 4
#define isalnum(c) __isctype((c), _ISalnum)
#define isalpha(c) __isctype((c), _ISalpha)
#define iscntrl(c) __isctype((c), _IScntrl)
#define isdigit(c) __isctype((c), _ISdigit)
#define islower(c) __isctype((c), _ISlower)
#define isgraph(c) __isctype((c), _ISgraph)
#define isprint(c) __isctype((c), _ISprint)
#define ispunct(c) __isctype((c), _ISpunct)
#define isspace(c) __isctype((c), _ISspace)
#define isupper(c) __isctype((c), _ISupper)
#define isxdigit(c) __isctype((c), _ISxdigit)

#define isblank(c) __isctype((c), _ISblank)




extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) tolower (int __c)
{
  return __c >= -128 && __c < 256 ? (*__ctype_tolower_loc ())[__c] : __c;
}

extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) toupper (int __c)
{
  return __c >= -128 && __c < 256 ? (*__ctype_toupper_loc ())[__c] : __c;
}



#define tolower(c) __tobody (c, tolower, *__ctype_tolower_loc (), (c))
#define toupper(c) __tobody (c, toupper, *__ctype_toupper_loc (), (c))



#define isascii(c) __isascii (c)
#define toascii(c) __toascii (c)

#define _tolower(c) ((int) (*__ctype_tolower_loc ())[(int) (c)])
#define _toupper(c) ((int) (*__ctype_toupper_loc ())[(int) (c)])






/* The concept of one static locale per category is not very well
   thought out.  Many applications will need to process its data using
   information from several different locales.  Another application is
   the implementation of the internationalization handling in the
   upcoming ISO C++ standard library.  To support this another set of
   the functions using locale data exist which have an additional
   argument.

   Attention: all these functions are *not* standardized in any form.
   This is a proof-of-concept implementation.  */

/* Structure for reentrant locale using functions.  This is an
   (almost) opaque type for the user level programs.  */
# 1 "/usr/include/xlocale.h" 1 3 4
/* Definition of locale datatype.
   Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 258 "/usr/include/ctype.h" 2 3 4

/* These definitions are similar to the ones above but all functions
   take as an argument a handle for the locale which shall be used.  */
#define __isctype_l(c,type,locale) ((locale)->__ctype_b[(int) (c)] & (unsigned short int) type)


#define __exctype_l(name) extern int name (int, __locale_t) __THROW


/* The following names are all functions:
     int isCHARACTERISTIC(int c, locale_t *locale);
   which return nonzero iff C has CHARACTERISTIC.
   For the meaning of the characteristic names, see the `enum' above.  */
extern int isalnum_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int islower_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));

extern int isblank_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));


/* Return the lowercase version of C in locale L.  */
extern int __tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));

/* Return the uppercase version of C.  */
extern int __toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));


#define __tolower_l(c,locale) __tobody (c, __tolower_l, (locale)->__ctype_tolower, (c, locale))

#define __toupper_l(c,locale) __tobody (c, __toupper_l, (locale)->__ctype_toupper, (c, locale))

#define tolower_l(c,locale) __tolower_l ((c), (locale))
#define toupper_l(c,locale) __toupper_l ((c), (locale))




#define __isalnum_l(c,l) __isctype_l((c), _ISalnum, (l))
#define __isalpha_l(c,l) __isctype_l((c), _ISalpha, (l))
#define __iscntrl_l(c,l) __isctype_l((c), _IScntrl, (l))
#define __isdigit_l(c,l) __isctype_l((c), _ISdigit, (l))
#define __islower_l(c,l) __isctype_l((c), _ISlower, (l))
#define __isgraph_l(c,l) __isctype_l((c), _ISgraph, (l))
#define __isprint_l(c,l) __isctype_l((c), _ISprint, (l))
#define __ispunct_l(c,l) __isctype_l((c), _ISpunct, (l))
#define __isspace_l(c,l) __isctype_l((c), _ISspace, (l))
#define __isupper_l(c,l) __isctype_l((c), _ISupper, (l))
#define __isxdigit_l(c,l) __isctype_l((c), _ISxdigit, (l))

#define __isblank_l(c,l) __isctype_l((c), _ISblank, (l))


#define __isascii_l(c,l) ((l), __isascii (c))
#define __toascii_l(c,l) ((l), __toascii (c))


#define isalnum_l(c,l) __isalnum_l ((c), (l))
#define isalpha_l(c,l) __isalpha_l ((c), (l))
#define iscntrl_l(c,l) __iscntrl_l ((c), (l))
#define isdigit_l(c,l) __isdigit_l ((c), (l))
#define islower_l(c,l) __islower_l ((c), (l))
#define isgraph_l(c,l) __isgraph_l ((c), (l))
#define isprint_l(c,l) __isprint_l ((c), (l))
#define ispunct_l(c,l) __ispunct_l ((c), (l))
#define isspace_l(c,l) __isspace_l ((c), (l))
#define isupper_l(c,l) __isupper_l ((c), (l))
#define isxdigit_l(c,l) __isxdigit_l ((c), (l))

#define isblank_l(c,l) __isblank_l ((c), (l))


#define isascii_l(c,l) __isascii_l ((c), (l))
#define toascii_l(c,l) __toascii_l ((c), (l))







# 25 "/usr/include/argp.h" 2 3 4
# 1 "/usr/include/getopt.h" 1 3 4
/* Declarations for getopt.
   Copyright (C) 1989-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */




#define _GETOPT_H 1


/* If __GNU_LIBRARY__ is not already defined, either we are being used
   standalone, or this is the first header included in the source file.
   If we are being used with glibc, we need to include <features.h>, but
   that does not exist if we are standalone.  So: if __GNU_LIBRARY__ is
   not defined, include <ctype.h>, which will pull in <features.h> for us
   if it's from glibc.  (Why ctype.h?  It's guaranteed to exist and it
   doesn't flood the namespace with stuff the way some other headers do.)  */
# 51 "/usr/include/getopt.h" 3 4
/* For communication from `getopt' to the caller.
   When `getopt' finds an option that takes an argument,
   the argument value is returned here.
   Also, when `ordering' is RETURN_IN_ORDER,
   each non-option ARGV-element is returned here.  */

extern char *optarg;

/* Index in ARGV of the next element to be scanned.
   This is used for communication to and from the caller
   and for communication between successive calls to `getopt'.

   On entry to `getopt', zero means this is the first call; initialize.

   When `getopt' returns -1, this is the index of the first of the
   non-option elements that the caller should itself scan.

   Otherwise, `optind' communicates from one call to the next
   how much of ARGV has been scanned so far.  */

extern int optind;

/* Callers store zero here to inhibit the error message `getopt' prints
   for unrecognized options.  */

extern int opterr;

/* Set to an option character which was unrecognized.  */

extern int optopt;


/* Describe the long-named options requested by the application.
   The LONG_OPTIONS argument to getopt_long or getopt_long_only is a vector
   of `struct option' terminated by an element containing a name which is
   zero.

   The field `has_arg' is:
   no_argument		(or 0) if the option does not take an argument,
   required_argument	(or 1) if the option requires an argument,
   optional_argument 	(or 2) if the option takes an optional argument.

   If the field `flag' is not NULL, it points to a variable that is set
   to the value given in the field `val' when the option is found, but
   left unchanged if the option is not found.

   To have a long-named option do something other than set an `int' to
   a compiled-in constant, such as set a value from `optarg', set the
   option's `flag' field to zero and its `val' field to a nonzero
   value (the equivalent single-letter option character, if there is
   one).  For long options that have a zero `flag' field, `getopt'
   returns the contents of the `val' field.  */

struct option
{
  const char *name;
  /* has_arg can't be an enum because some compilers complain about
     type mismatches in all the code that assumes it is an int.  */
  int has_arg;
  int *flag;
  int val;
};

/* Names for the values of the `has_arg' field of `struct option'.  */

#define no_argument 0
#define required_argument 1
#define optional_argument 2



/* Get definitions and prototypes for functions to process the
   arguments in ARGV (ARGC of them, minus the program name) for
   options given in OPTS.

   Return the option character from OPTS just read.  Return -1 when
   there are no more options.  For unrecognized options, or options
   missing arguments, `optopt' is set to the option letter, and '?' is
   returned.

   The OPTS string is a list of characters which are recognized option
   letters, optionally followed by colons, specifying that that letter
   takes an argument, to be placed in `optarg'.

   If a letter in OPTS is followed by two colons, its argument is
   optional.  This behavior is specific to the GNU `getopt'.

   The argument `--' causes premature termination of argument
   scanning, explicitly telling `getopt' that there are no more
   options.

   If OPTS begins with `--', then non-option arguments are treated as
   arguments to the option '\0'.  This behavior is specific to the GNU
   `getopt'.  */


/* Many other libraries have conflicting prototypes for getopt, with
   differences in the consts, in stdlib.h.  To avoid compilation
   errors, only prototype getopt for the GNU C library.  */
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ , __leaf__));
# 173 "/usr/include/getopt.h" 3 4
extern int getopt_long (int ___argc, char *const *___argv,
   const char *__shortopts,
          const struct option *__longopts, int *__longind)
       __attribute__ ((__nothrow__ , __leaf__));
extern int getopt_long_only (int ___argc, char *const *___argv,
        const char *__shortopts,
               const struct option *__longopts, int *__longind)
       __attribute__ ((__nothrow__ , __leaf__));







/* Make sure we later can get all the definitions and declarations.  */
#undef __need_getopt
# 26 "/usr/include/argp.h" 2 3 4
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include-fixed/limits.h" 1 3 4
/* Copyright (C) 1992-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */

#define _GCC_LIMITS_H_ 


/* Use "..." so that we find syslimits.h only in this same directory.  */
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include-fixed/syslimits.h" 1 3 4
/* syslimits.h stands for the system's own limits.h file.
   If we can use it ok unmodified, then we install this text.
   If fixincludes fixes it, then the fixed version is installed
   instead of this text.  */

#define _GCC_NEXT_LIMITS_H 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include-fixed/limits.h" 1 3 4
/* Copyright (C) 1992-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */
# 168 "/usr/lib/gcc/arm-linux-gnueabihf/6/include-fixed/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.10/5.2.4.2.1 Sizes of integer types	<limits.h>
 */


#define _LIBC_LIMITS_H_ 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/limits.h" 2 3 4


/* Maximum length of any multibyte character in any locale.
   We define this value here since the gcc header does not define
   the correct value.  */
#define MB_LEN_MAX 16


/* If we are not using GNU CC we have to define all the symbols ourself.
   Otherwise use gcc's definitions (see below).  */
# 116 "/usr/include/limits.h" 3 4
 /* Get the compiler's limits.h, which defines almost all the ISO constants.

    We put this #include_next outside the double inclusion check because
    it should be possible to include this file more than once and still get
    the definitions from gcc's header.  */





/* The <limits.h> files in some gcc versions don't define LLONG_MIN,
   LLONG_MAX, and ULLONG_MAX.  Instead only the values gcc defined for
   ages are available.  */


#define LLONG_MIN (-LLONG_MAX-1)


#define LLONG_MAX __LONG_LONG_MAX__


#define ULLONG_MAX (LLONG_MAX * 2ULL + 1)




/* POSIX adds things to <limits.h>.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/posix1_lim.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.9.2 Minimum Values	Added to <limits.h>
 *
 *	Never include this file directly; use <limits.h> instead.
 */


#define _BITS_POSIX1_LIM_H 1


/* These are the standard-mandated minimum values.  */

/* Minimum number of operations in one list I/O call.  */
#define _POSIX_AIO_LISTIO_MAX 2

/* Minimal number of outstanding asynchronous I/O operations.  */
#define _POSIX_AIO_MAX 1

/* Maximum length of arguments to `execve', including environment.  */
#define _POSIX_ARG_MAX 4096

/* Maximum simultaneous processes per real user ID.  */

#define _POSIX_CHILD_MAX 25




/* Minimal number of timer expiration overruns.  */
#define _POSIX_DELAYTIMER_MAX 32

/* Maximum length of a host name (not including the terminating null)
   as returned from the GETHOSTNAME function.  */
#define _POSIX_HOST_NAME_MAX 255

/* Maximum link count of a file.  */
#define _POSIX_LINK_MAX 8

/* Maximum length of login name.  */
#define _POSIX_LOGIN_NAME_MAX 9

/* Number of bytes in a terminal canonical input queue.  */
#define _POSIX_MAX_CANON 255

/* Number of bytes for which space will be
   available in a terminal input queue.  */
#define _POSIX_MAX_INPUT 255

/* Maximum number of message queues open for a process.  */
#define _POSIX_MQ_OPEN_MAX 8

/* Maximum number of supported message priorities.  */
#define _POSIX_MQ_PRIO_MAX 32

/* Number of bytes in a filename.  */
#define _POSIX_NAME_MAX 14

/* Number of simultaneous supplementary group IDs per process.  */

#define _POSIX_NGROUPS_MAX 8




/* Number of files one process can have open at once.  */

#define _POSIX_OPEN_MAX 20





/* Number of descriptors that a process may examine with `pselect' or
   `select'.  */
#define _POSIX_FD_SETSIZE _POSIX_OPEN_MAX


/* Number of bytes in a pathname.  */
#define _POSIX_PATH_MAX 256

/* Number of bytes than can be written atomically to a pipe.  */
#define _POSIX_PIPE_BUF 512

/* The number of repeated occurrences of a BRE permitted by the
   REGEXEC and REGCOMP functions when using the interval notation.  */
#define _POSIX_RE_DUP_MAX 255

/* Minimal number of realtime signals reserved for the application.  */
#define _POSIX_RTSIG_MAX 8

/* Number of semaphores a process can have.  */
#define _POSIX_SEM_NSEMS_MAX 256

/* Maximal value of a semaphore.  */
#define _POSIX_SEM_VALUE_MAX 32767

/* Number of pending realtime signals.  */
#define _POSIX_SIGQUEUE_MAX 32

/* Largest value of a `ssize_t'.  */
#define _POSIX_SSIZE_MAX 32767

/* Number of streams a process can have open at once.  */
#define _POSIX_STREAM_MAX 8

/* The number of bytes in a symbolic link.  */
#define _POSIX_SYMLINK_MAX 255

/* The number of symbolic links that can be traversed in the
   resolution of a pathname in the absence of a loop.  */
#define _POSIX_SYMLOOP_MAX 8

/* Number of timer for a process.  */
#define _POSIX_TIMER_MAX 32

/* Maximum number of characters in a tty name.  */
#define _POSIX_TTY_NAME_MAX 9

/* Maximum length of a timezone name (element of `tzname').  */

#define _POSIX_TZNAME_MAX 6





/* Maximum number of connections that can be queued on a socket.  */
#define _POSIX_QLIMIT 1

/* Maximum number of bytes that can be buffered on a socket for send
   or receive.  */
#define _POSIX_HIWAT _POSIX_PIPE_BUF

/* Maximum number of elements in an `iovec' array.  */
#define _POSIX_UIO_MAXIOV 16


/* Maximum clock resolution in nanoseconds.  */
#define _POSIX_CLOCKRES_MIN 20000000


/* Get the implementation-specific values for the above.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/local_lim.h" 1 3 4
/* Minimum guaranteed maximum values for system limits.  Linux version.
   Copyright (C) 1993-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If
   not, see <http://www.gnu.org/licenses/>.  */

/* The kernel header pollutes the namespace with the NR_OPEN symbol
   and defines LINK_MAX although filesystems have different maxima.  A
   similar thing is true for OPEN_MAX: the limit can be changed at
   runtime and therefore the macro must not be defined.  Remove this
   after including the header if necessary.  */

#define __undef_NR_OPEN 


#define __undef_LINK_MAX 


#define __undef_OPEN_MAX 


#define __undef_ARG_MAX 


/* The kernel sources contain a file with all the needed information.  */
# 1 "/usr/include/linux/limits.h" 1 3 4

#define _LINUX_LIMITS_H 

#define NR_OPEN 1024

#define NGROUPS_MAX 65536
#define ARG_MAX 131072
#define LINK_MAX 127
#define MAX_CANON 255
#define MAX_INPUT 255
#define NAME_MAX 255
#define PATH_MAX 4096
#define PIPE_BUF 4096
#define XATTR_NAME_MAX 255
#define XATTR_SIZE_MAX 65536
#define XATTR_LIST_MAX 65536

#define RTSIG_MAX 32
# 39 "/usr/include/arm-linux-gnueabihf/bits/local_lim.h" 2 3 4

/* Have to remove NR_OPEN?  */

#undef NR_OPEN
#undef __undef_NR_OPEN

/* Have to remove LINK_MAX?  */

#undef LINK_MAX
#undef __undef_LINK_MAX

/* Have to remove OPEN_MAX?  */

#undef OPEN_MAX
#undef __undef_OPEN_MAX

/* Have to remove ARG_MAX?  */

#undef ARG_MAX
#undef __undef_ARG_MAX


/* The number of data keys per process.  */
#define _POSIX_THREAD_KEYS_MAX 128
/* This is the value this implementation supports.  */
#define PTHREAD_KEYS_MAX 1024

/* Controlling the iterations of destructors for thread-specific data.  */
#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS 4
/* Number of iterations this implementation does.  */
#define PTHREAD_DESTRUCTOR_ITERATIONS _POSIX_THREAD_DESTRUCTOR_ITERATIONS

/* The number of threads per process.  */
#define _POSIX_THREAD_THREADS_MAX 64
/* We have no predefined limit on the number of threads.  */
#undef PTHREAD_THREADS_MAX

/* Maximum amount by which a process can descrease its asynchronous I/O
   priority level.  */
#define AIO_PRIO_DELTA_MAX 20

/* Minimum size for a thread.  We are free to choose a reasonable value.  */
#define PTHREAD_STACK_MIN 16384

/* Maximum number of timer expiration overruns.  */
#define DELAYTIMER_MAX 2147483647

/* Maximum tty name length.  */
#define TTY_NAME_MAX 32

/* Maximum login name length.  This is arbitrary.  */
#define LOGIN_NAME_MAX 256

/* Maximum host name length.  */
#define HOST_NAME_MAX 64

/* Maximum message queue priority level.  */
#define MQ_PRIO_MAX 32768

/* Maximum value the semaphore can have.  */
#define SEM_VALUE_MAX (2147483647)
# 161 "/usr/include/arm-linux-gnueabihf/bits/posix1_lim.h" 2 3 4



#define SSIZE_MAX LONG_MAX



/* This value is a guaranteed minimum maximum.
   The current maximum can be got from `sysconf'.  */
# 144 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/arm-linux-gnueabihf/bits/posix2_lim.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; include <limits.h> instead.
 */


#define _BITS_POSIX2_LIM_H 1


/* The maximum `ibase' and `obase' values allowed by the `bc' utility.  */
#define _POSIX2_BC_BASE_MAX 99

/* The maximum number of elements allowed in an array by the `bc' utility.  */
#define _POSIX2_BC_DIM_MAX 2048

/* The maximum `scale' value allowed by the `bc' utility.  */
#define _POSIX2_BC_SCALE_MAX 99

/* The maximum length of a string constant accepted by the `bc' utility.  */
#define _POSIX2_BC_STRING_MAX 1000

/* The maximum number of weights that can be assigned to an entry of
   the LC_COLLATE `order' keyword in the locale definition file.  */
#define _POSIX2_COLL_WEIGHTS_MAX 2

/* The maximum number of expressions that can be nested
   within parentheses by the `expr' utility.  */
#define _POSIX2_EXPR_NEST_MAX 32

/* The maximum length, in bytes, of an input line.  */
#define _POSIX2_LINE_MAX 2048

/* The maximum number of repeated occurrences of a regular expression
   permitted when using the interval notation `\{M,N\}'.  */
#define _POSIX2_RE_DUP_MAX 255

/* The maximum number of bytes in a character class name.  We have no
   fixed limit, 2048 is a high number.  */
#define _POSIX2_CHARCLASS_NAME_MAX 14


/* These values are implementation-specific,
   and may vary within the implementation.
   Their precise values can be obtained from sysconf.  */


#define BC_BASE_MAX _POSIX2_BC_BASE_MAX


#define BC_DIM_MAX _POSIX2_BC_DIM_MAX


#define BC_SCALE_MAX _POSIX2_BC_SCALE_MAX


#define BC_STRING_MAX _POSIX2_BC_STRING_MAX


#define COLL_WEIGHTS_MAX 255


#define EXPR_NEST_MAX _POSIX2_EXPR_NEST_MAX


#define LINE_MAX _POSIX2_LINE_MAX


#define CHARCLASS_NAME_MAX 2048


/* This value is defined like this in regex.h.  */
#define RE_DUP_MAX (0x7fff)
# 148 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/arm-linux-gnueabihf/bits/xopen_lim.h" 1 3 4
/* Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <limits.h> instead.
 */

/* Additional definitions from X/Open Portability Guide, Issue 4, Version 2
   System Interfaces and Headers, 4.16 <limits.h>

   Please note only the values which are not greater than the minimum
   stated in the standard document are listed.  The `sysconf' functions
   should be used to obtain the actual value.  */


#define _XOPEN_LIM_H 1

#define __need_IOV_MAX 
# 1 "/usr/include/arm-linux-gnueabihf/bits/stdio_lim.h" 1 3 4
/* Copyright (C) 1994-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






#define L_tmpnam 20
#define TMP_MAX 238328
#define FILENAME_MAX 4096


#define L_ctermid 9

#define L_cuserid 9





#undef FOPEN_MAX
#define FOPEN_MAX 16



#define IOV_MAX 1024
# 34 "/usr/include/arm-linux-gnueabihf/bits/xopen_lim.h" 2 3 4

/* We do not provide fixed values for

   ARG_MAX	Maximum length of argument to the `exec' function
		including environment data.

   ATEXIT_MAX	Maximum number of functions that may be registered
		with `atexit'.

   CHILD_MAX	Maximum number of simultaneous processes per real
		user ID.

   OPEN_MAX	Maximum number of files that one process can have open
		at anyone time.

   PAGESIZE
   PAGE_SIZE	Size of bytes of a page.

   PASS_MAX	Maximum number of significant bytes in a password.

   We only provide a fixed limit for

   IOV_MAX	Maximum number of `iovec' structures that one process has
		available for use with `readv' or writev'.

   if this is indeed fixed by the underlying system.
*/


/* Maximum number of `iovec' structures that one process has available
   for use with `readv' or writev'.  */
#define _XOPEN_IOV_MAX _POSIX_UIO_MAXIOV


/* Maximum value of `digit' in calls to the `printf' and `scanf'
   functions.  We have no limit, so return a reasonable value.  */
#define NL_ARGMAX _POSIX_ARG_MAX

/* Maximum number of bytes in a `LANG' name.  We have no limit.  */
#define NL_LANGMAX _POSIX2_LINE_MAX

/* Maximum message number.  We have no limit.  */
#define NL_MSGMAX INT_MAX

/* Maximum number of bytes in N-to-1 collation mapping.  We have no
   limit.  */

#define NL_NMAX INT_MAX


/* Maximum set number.  We have no limit.  */
#define NL_SETMAX INT_MAX

/* Maximum number of bytes in a message.  We have no limit.  */
#define NL_TEXTMAX INT_MAX

/* Default process priority.  */
#define NZERO 20


/* Number of bits in a word of type `int'.  */
# 111 "/usr/include/arm-linux-gnueabihf/bits/xopen_lim.h" 3 4
#define WORD_BIT 32
# 121 "/usr/include/arm-linux-gnueabihf/bits/xopen_lim.h" 3 4
/* Number of bits in a word of type `long int'.  */
# 131 "/usr/include/arm-linux-gnueabihf/bits/xopen_lim.h" 3 4
#define LONG_BIT 32
# 152 "/usr/include/limits.h" 2 3 4
# 169 "/usr/lib/gcc/arm-linux-gnueabihf/6/include-fixed/limits.h" 2 3 4
# 8 "/usr/lib/gcc/arm-linux-gnueabihf/6/include-fixed/syslimits.h" 2 3 4
#undef _GCC_NEXT_LIMITS_H
# 35 "/usr/lib/gcc/arm-linux-gnueabihf/6/include-fixed/limits.h" 2 3 4

/* Copyright (C) 1991-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */


#define _LIMITS_H___ 

/* Number of bits in a `char'.  */
#undef CHAR_BIT
#define CHAR_BIT __CHAR_BIT__

/* Maximum length of a multibyte character.  */




/* Minimum and maximum values a `signed char' can hold.  */
#undef SCHAR_MIN
#define SCHAR_MIN (-SCHAR_MAX - 1)
#undef SCHAR_MAX
#define SCHAR_MAX __SCHAR_MAX__

/* Maximum value an `unsigned char' can hold.  (Minimum is 0).  */
#undef UCHAR_MAX



#define UCHAR_MAX (SCHAR_MAX * 2 + 1)


/* Minimum and maximum values a `char' can hold.  */

#undef CHAR_MIN



#define CHAR_MIN 0

#undef CHAR_MAX
#define CHAR_MAX UCHAR_MAX







/* Minimum and maximum values a `signed short int' can hold.  */
#undef SHRT_MIN
#define SHRT_MIN (-SHRT_MAX - 1)
#undef SHRT_MAX
#define SHRT_MAX __SHRT_MAX__

/* Maximum value an `unsigned short int' can hold.  (Minimum is 0).  */
#undef USHRT_MAX



#define USHRT_MAX (SHRT_MAX * 2 + 1)


/* Minimum and maximum values a `signed int' can hold.  */
#undef INT_MIN
#define INT_MIN (-INT_MAX - 1)
#undef INT_MAX
#define INT_MAX __INT_MAX__

/* Maximum value an `unsigned int' can hold.  (Minimum is 0).  */
#undef UINT_MAX
#define UINT_MAX (INT_MAX * 2U + 1U)

/* Minimum and maximum values a `signed long int' can hold.
   (Same as `int').  */
#undef LONG_MIN
#define LONG_MIN (-LONG_MAX - 1L)
#undef LONG_MAX
#define LONG_MAX __LONG_MAX__

/* Maximum value an `unsigned long int' can hold.  (Minimum is 0).  */
#undef ULONG_MAX
#define ULONG_MAX (LONG_MAX * 2UL + 1UL)


/* Minimum and maximum values a `signed long long int' can hold.  */
#undef LLONG_MIN
#define LLONG_MIN (-LLONG_MAX - 1LL)
#undef LLONG_MAX
#define LLONG_MAX __LONG_LONG_MAX__

/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0).  */
#undef ULLONG_MAX
#define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)



/* Minimum and maximum values a `signed long long int' can hold.  */
#undef LONG_LONG_MIN
#define LONG_LONG_MIN (-LONG_LONG_MAX - 1LL)
#undef LONG_LONG_MAX
#define LONG_LONG_MAX __LONG_LONG_MAX__

/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0).  */
#undef ULONG_LONG_MAX
#define ULONG_LONG_MAX (LONG_LONG_MAX * 2ULL + 1ULL)



/* This administrivia gets added to the end of limits.h
   if the system has its own version of limits.h.  */
# 27 "/usr/include/argp.h" 2 3 4

#define __need_error_t 
# 1 "/usr/include/errno.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.5 Errors	<errno.h>
 */



/* The includer defined __need_Emath if he wants only the definitions
   of EDOM and ERANGE, and not everything else.  */

#define _ERRNO_H 1
# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 29 "/usr/include/errno.h" 2 3 4




/* Get the error number constants from the system-specific file.
   This file will test __need_Emath and _ERRNO_H.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/errno.h" 1 3 4
/* Error constants.  Linux specific version.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */



#undef EDOM
#undef EILSEQ
#undef ERANGE
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/arm-linux-gnueabihf/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4

#define _ASM_GENERIC_ERRNO_H 

# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4

#define _ASM_GENERIC_ERRNO_BASE_H 

#define EPERM 1
#define ENOENT 2
#define ESRCH 3
#define EINTR 4
#define EIO 5
#define ENXIO 6
#define E2BIG 7
#define ENOEXEC 8
#define EBADF 9
#define ECHILD 10
#define EAGAIN 11
#define ENOMEM 12
#define EACCES 13
#define EFAULT 14
#define ENOTBLK 15
#define EBUSY 16
#define EEXIST 17
#define EXDEV 18
#define ENODEV 19
#define ENOTDIR 20
#define EISDIR 21
#define EINVAL 22
#define ENFILE 23
#define EMFILE 24
#define ENOTTY 25
#define ETXTBSY 26
#define EFBIG 27
#define ENOSPC 28
#define ESPIPE 29
#define EROFS 30
#define EMLINK 31
#define EPIPE 32
#define EDOM 33
#define ERANGE 34
# 5 "/usr/include/asm-generic/errno.h" 2 3 4

#define EDEADLK 35
#define ENAMETOOLONG 36
#define ENOLCK 37

/*
 * This error code is special: arch syscall entry code will return
 * -ENOSYS if users try to call a syscall that doesn't exist.  To keep
 * failures of syscalls that really do exist distinguishable from
 * failures due to attempts to use a nonexistent syscall, syscall
 * implementations should refrain from returning -ENOSYS.
 */
#define ENOSYS 38

#define ENOTEMPTY 39
#define ELOOP 40
#define EWOULDBLOCK EAGAIN
#define ENOMSG 42
#define EIDRM 43
#define ECHRNG 44
#define EL2NSYNC 45
#define EL3HLT 46
#define EL3RST 47
#define ELNRNG 48
#define EUNATCH 49
#define ENOCSI 50
#define EL2HLT 51
#define EBADE 52
#define EBADR 53
#define EXFULL 54
#define ENOANO 55
#define EBADRQC 56
#define EBADSLT 57

#define EDEADLOCK EDEADLK

#define EBFONT 59
#define ENOSTR 60
#define ENODATA 61
#define ETIME 62
#define ENOSR 63
#define ENONET 64
#define ENOPKG 65
#define EREMOTE 66
#define ENOLINK 67
#define EADV 68
#define ESRMNT 69
#define ECOMM 70
#define EPROTO 71
#define EMULTIHOP 72
#define EDOTDOT 73
#define EBADMSG 74
#define EOVERFLOW 75
#define ENOTUNIQ 76
#define EBADFD 77
#define EREMCHG 78
#define ELIBACC 79
#define ELIBBAD 80
#define ELIBSCN 81
#define ELIBMAX 82
#define ELIBEXEC 83
#define EILSEQ 84
#define ERESTART 85
#define ESTRPIPE 86
#define EUSERS 87
#define ENOTSOCK 88
#define EDESTADDRREQ 89
#define EMSGSIZE 90
#define EPROTOTYPE 91
#define ENOPROTOOPT 92
#define EPROTONOSUPPORT 93
#define ESOCKTNOSUPPORT 94
#define EOPNOTSUPP 95
#define EPFNOSUPPORT 96
#define EAFNOSUPPORT 97
#define EADDRINUSE 98
#define EADDRNOTAVAIL 99
#define ENETDOWN 100
#define ENETUNREACH 101
#define ENETRESET 102
#define ECONNABORTED 103
#define ECONNRESET 104
#define ENOBUFS 105
#define EISCONN 106
#define ENOTCONN 107
#define ESHUTDOWN 108
#define ETOOMANYREFS 109
#define ETIMEDOUT 110
#define ECONNREFUSED 111
#define EHOSTDOWN 112
#define EHOSTUNREACH 113
#define EALREADY 114
#define EINPROGRESS 115
#define ESTALE 116
#define EUCLEAN 117
#define ENOTNAM 118
#define ENAVAIL 119
#define EISNAM 120
#define EREMOTEIO 121
#define EDQUOT 122

#define ENOMEDIUM 123
#define EMEDIUMTYPE 124
#define ECANCELED 125
#define ENOKEY 126
#define EKEYEXPIRED 127
#define EKEYREVOKED 128
#define EKEYREJECTED 129

/* for robust mutexes */
#define EOWNERDEAD 130
#define ENOTRECOVERABLE 131

#define ERFKILL 132

#define EHWPOISON 133
# 1 "/usr/include/arm-linux-gnueabihf/asm/errno.h" 2 3 4
# 1 "/usr/include/linux/errno.h" 2 3 4
# 25 "/usr/include/arm-linux-gnueabihf/bits/errno.h" 2 3 4

/* Linux has no ENOTSUP error code.  */
#define ENOTSUP EOPNOTSUPP

/* Older Linux versions also had no ECANCELED error code.  */




/* Support for error codes to support robust mutexes was added later, too.  */
# 49 "/usr/include/arm-linux-gnueabihf/bits/errno.h" 3 4
/* Function to get address of global `errno' variable.  */
extern int *__errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


/* When using threads, errno is a per-thread value.  */
#define errno (*__errno_location ())
# 36 "/usr/include/errno.h" 2 3 4
#undef __need_Emath



/* Declare the `errno' variable, unless it's defined as a macro by
   bits/errno.h.  This is the case in GNU, where it is a per-thread
   variable.  This redeclaration using the macro still works, but it
   will be a function declaration without a prototype and may trigger
   a -Wstrict-prototypes warning.  */






/* The full and simple forms of the name with which the program was
   invoked.  These variables are set up automatically at startup based on
   the value of ARGV[0] (this works only if you use GNU ld).  */
extern char *program_invocation_name, *program_invocation_short_name;







/* The Hurd <bits/errno.h> defines `error_t' as an enumerated type so
   that printing `error_t' values in the debugger shows the names.  We
   might need this definition sometimes even if this file was included
   before.  */


typedef int error_t;
#define __error_t_defined 1

#undef __need_error_t
# 30 "/usr/include/argp.h" 2 3 4








/* A description of a particular option.  A pointer to an array of
   these is passed in the OPTIONS field of an argp structure.  Each option
   entry can correspond to one long option and/or one short option; more
   names for the same option can be added by following an entry in an option
   array with options having the OPTION_ALIAS flag set.  */
struct argp_option
{
  /* The long option name.  For more than one name for the same option, you
     can use following options with the OPTION_ALIAS flag set.  */
  const char *name;

  /* What key is returned for this option.  If > 0 and printable, then it's
     also accepted as a short option.  */
  int key;

  /* If non-NULL, this is the name of the argument associated with this
     option, which is required unless the OPTION_ARG_OPTIONAL flag is set. */
  const char *arg;

  /* OPTION_ flags.  */
  int flags;

  /* The doc string for this option.  If both NAME and KEY are 0, This string
     will be printed outdented from the normal option column, making it
     useful as a group header (it will be the first thing printed in its
     group); in this usage, it's conventional to end the string with a `:'.  */
  const char *doc;

  /* The group this option is in.  In a long help message, options are sorted
     alphabetically within each group, and the groups presented in the order
     0, 1, 2, ..., n, -m, ..., -2, -1.  Every entry in an options array with
     if this field 0 will inherit the group number of the previous entry, or
     zero if it's the first one, unless its a group header (NAME and KEY both
     0), in which case, the previous entry + 1 is the default.  Automagic
     options such as --help are put into group -1.  */
  int group;
};

/* The argument associated with this option is optional.  */
#define OPTION_ARG_OPTIONAL 0x1

/* This option isn't displayed in any help messages.  */
#define OPTION_HIDDEN 0x2

/* This option is an alias for the closest previous non-alias option.  This
   means that it will be displayed in the same help entry, and will inherit
   fields other than NAME and KEY from the aliased option.  */
#define OPTION_ALIAS 0x4

/* This option isn't actually an option (and so should be ignored by the
   actual option parser), but rather an arbitrary piece of documentation that
   should be displayed in much the same manner as the options.  If this flag
   is set, then the option NAME field is displayed unmodified (e.g., no `--'
   prefix is added) at the left-margin (where a *short* option would normally
   be displayed), and the documentation string in the normal place.  For
   purposes of sorting, any leading whitespace and punctuation is ignored,
   except that if the first non-whitespace character is not `-', this entry
   is displayed after all options (and OPTION_DOC entries with a leading `-')
   in the same group.  */
#define OPTION_DOC 0x8

/* This option shouldn't be included in `long' usage messages (but is still
   included in help messages).  This is mainly intended for options that are
   completely documented in an argp's ARGS_DOC field, in which case including
   the option in the generic usage list would be redundant.  For instance,
   if ARGS_DOC is "FOO BAR\n-x BLAH", and the `-x' option's purpose is to
   distinguish these two cases, -x should probably be marked
   OPTION_NO_USAGE.  */
#define OPTION_NO_USAGE 0x10

struct argp; /* fwd declare this type */
struct argp_state; /* " */
struct argp_child; /* " */

/* The type of a pointer to an argp parsing function.  */
typedef error_t (*argp_parser_t) (int __key, char *__arg,
      struct argp_state *__state);

/* What to return for unrecognized keys.  For special ARGP_KEY_ keys, such
   returns will simply be ignored.  For user keys, this error will be turned
   into EINVAL (if the call to argp_parse is such that errors are propagated
   back to the user instead of exiting); returning EINVAL itself would result
   in an immediate stop to parsing in *all* cases.  */
#define ARGP_ERR_UNKNOWN E2BIG

/* Special values for the KEY argument to an argument parsing function.
   ARGP_ERR_UNKNOWN should be returned if they aren't understood.

   The sequence of keys to a parsing function is either (where each
   uppercased word should be prefixed by `ARGP_KEY_' and opt is a user key):

       INIT opt... NO_ARGS END SUCCESS  -- No non-option arguments at all
   or  INIT (opt | ARG)... END SUCCESS  -- All non-option args parsed
   or  INIT (opt | ARG)... SUCCESS      -- Some non-option arg unrecognized

   The third case is where every parser returned ARGP_KEY_UNKNOWN for an
   argument, in which case parsing stops at that argument (returning the
   unparsed arguments to the caller of argp_parse if requested, or stopping
   with an error message if not).

   If an error occurs (either detected by argp, or because the parsing
   function returned an error value), then the parser is called with
   ARGP_KEY_ERROR, and no further calls are made.  */

/* This is not an option at all, but rather a command line argument.  If a
   parser receiving this key returns success, the fact is recorded, and the
   ARGP_KEY_NO_ARGS case won't be used.  HOWEVER, if while processing the
   argument, a parser function decrements the NEXT field of the state it's
   passed, the option won't be considered processed; this is to allow you to
   actually modify the argument (perhaps into an option), and have it
   processed again.  */
#define ARGP_KEY_ARG 0
/* There are remaining arguments not parsed by any parser, which may be found
   starting at (STATE->argv + STATE->next).  If success is returned, but
   STATE->next left untouched, it's assumed that all arguments were consume,
   otherwise, the parser should adjust STATE->next to reflect any arguments
   consumed.  */
#define ARGP_KEY_ARGS 0x1000006
/* There are no more command line arguments at all.  */
#define ARGP_KEY_END 0x1000001
/* Because it's common to want to do some special processing if there aren't
   any non-option args, user parsers are called with this key if they didn't
   successfully process any non-option arguments.  Called just before
   ARGP_KEY_END (where more general validity checks on previously parsed
   arguments can take place).  */
#define ARGP_KEY_NO_ARGS 0x1000002
/* Passed in before any parsing is done.  Afterwards, the values of each
   element of the CHILD_INPUT field, if any, in the state structure is
   copied to each child's state to be the initial value of the INPUT field.  */
#define ARGP_KEY_INIT 0x1000003
/* Use after all other keys, including SUCCESS & END.  */
#define ARGP_KEY_FINI 0x1000007
/* Passed in when parsing has successfully been completed (even if there are
   still arguments remaining).  */
#define ARGP_KEY_SUCCESS 0x1000004
/* Passed in if an error occurs.  */
#define ARGP_KEY_ERROR 0x1000005

/* An argp structure contains a set of options declarations, a function to
   deal with parsing one, documentation string, a possible vector of child
   argp's, and perhaps a function to filter help output.  When actually
   parsing options, getopt is called with the union of all the argp
   structures chained together through their CHILD pointers, with conflicts
   being resolved in favor of the first occurrence in the chain.  */
struct argp
{
  /* An array of argp_option structures, terminated by an entry with both
     NAME and KEY having a value of 0.  */
  const struct argp_option *options;

  /* What to do with an option from this structure.  KEY is the key
     associated with the option, and ARG is any associated argument (NULL if
     none was supplied).  If KEY isn't understood, ARGP_ERR_UNKNOWN should be
     returned.  If a non-zero, non-ARGP_ERR_UNKNOWN value is returned, then
     parsing is stopped immediately, and that value is returned from
     argp_parse().  For special (non-user-supplied) values of KEY, see the
     ARGP_KEY_ definitions below.  */
  argp_parser_t parser;

  /* A string describing what other arguments are wanted by this program.  It
     is only used by argp_usage to print the `Usage:' message.  If it
     contains newlines, the strings separated by them are considered
     alternative usage patterns, and printed on separate lines (lines after
     the first are prefix by `  or: ' instead of `Usage:').  */
  const char *args_doc;

  /* If non-NULL, a string containing extra text to be printed before and
     after the options in a long help message (separated by a vertical tab
     `\v' character).  */
  const char *doc;

  /* A vector of argp_children structures, terminated by a member with a 0
     argp field, pointing to child argps should be parsed with this one.  Any
     conflicts are resolved in favor of this argp, or early argps in the
     CHILDREN list.  This field is useful if you use libraries that supply
     their own argp structure, which you want to use in conjunction with your
     own.  */
  const struct argp_child *children;

  /* If non-zero, this should be a function to filter the output of help
     messages.  KEY is either a key from an option, in which case TEXT is
     that option's help text, or a special key from the ARGP_KEY_HELP_
     defines, below, describing which other help text TEXT is.  The function
     should return either TEXT, if it should be used as-is, a replacement
     string, which should be malloced, and will be freed by argp, or NULL,
     meaning `print nothing'.  The value for TEXT is *after* any translation
     has been done, so if any of the replacement text also needs translation,
     that should be done by the filter function.  INPUT is either the input
     supplied to argp_parse, or NULL, if argp_help was called directly.  */
  char *(*help_filter) (int __key, const char *__text, void *__input);

  /* If non-zero the strings used in the argp library are translated using
     the domain described by this string.  Otherwise the currently installed
     default domain is used.  */
  const char *argp_domain;
};

/* Possible KEY arguments to a help filter function.  */
#define ARGP_KEY_HELP_PRE_DOC 0x2000001
#define ARGP_KEY_HELP_POST_DOC 0x2000002
#define ARGP_KEY_HELP_HEADER 0x2000003
#define ARGP_KEY_HELP_EXTRA 0x2000004

/* Explanatory note emitted when duplicate option arguments have been
   suppressed.  */
#define ARGP_KEY_HELP_DUP_ARGS_NOTE 0x2000005
#define ARGP_KEY_HELP_ARGS_DOC 0x2000006

/* When an argp has a non-zero CHILDREN field, it should point to a vector of
   argp_child structures, each of which describes a subsidiary argp.  */
struct argp_child
{
  /* The child parser.  */
  const struct argp *argp;

  /* Flags for this child.  */
  int flags;

  /* If non-zero, an optional header to be printed in help output before the
     child options.  As a side-effect, a non-zero value forces the child
     options to be grouped together; to achieve this effect without actually
     printing a header string, use a value of "".  */
  const char *header;

  /* Where to group the child options relative to the other (`consolidated')
     options in the parent argp; the values are the same as the GROUP field
     in argp_option structs, but all child-groupings follow parent options at
     a particular group level.  If both this field and HEADER are zero, then
     they aren't grouped at all, but rather merged with the parent options
     (merging the child's grouping levels with the parents).  */
  int group;
};

/* Parsing state.  This is provided to parsing functions called by argp,
   which may examine and, as noted, modify fields.  */
struct argp_state
{
  /* The top level ARGP being parsed.  */
  const struct argp *root_argp;

  /* The argument vector being parsed.  May be modified.  */
  int argc;
  char **argv;

  /* The index in ARGV of the next arg that to be parsed.  May be modified. */
  int next;

  /* The flags supplied to argp_parse.  May be modified.  */
  unsigned flags;

  /* While calling a parsing function with a key of ARGP_KEY_ARG, this is the
     number of the current arg, starting at zero, and incremented after each
     such call returns.  At all other times, this is the number of such
     arguments that have been processed.  */
  unsigned arg_num;

  /* If non-zero, the index in ARGV of the first argument following a special
     `--' argument (which prevents anything following being interpreted as an
     option).  Only set once argument parsing has proceeded past this point. */
  int quoted;

  /* An arbitrary pointer passed in from the user.  */
  void *input;
  /* Values to pass to child parsers.  This vector will be the same length as
     the number of children for the current parser.  */
  void **child_inputs;

  /* For the parser's use.  Initialized to 0.  */
  void *hook;

  /* The name used when printing messages.  This is initialized to ARGV[0],
     or PROGRAM_INVOCATION_NAME if that is unavailable.  */
  char *name;

  /* Streams used when argp prints something.  */
  FILE *err_stream; /* For errors; initialized to stderr. */
  FILE *out_stream; /* For information; initialized to stdout. */

  void *pstate; /* Private, for use by argp.  */
};

/* Flags for argp_parse (note that the defaults are those that are
   convenient for program command line parsing): */

/* Don't ignore the first element of ARGV.  Normally (and always unless
   ARGP_NO_ERRS is set) the first element of the argument vector is
   skipped for option parsing purposes, as it corresponds to the program name
   in a command line.  */
#define ARGP_PARSE_ARGV0 0x01

/* Don't print error messages for unknown options to stderr; unless this flag
   is set, ARGP_PARSE_ARGV0 is ignored, as ARGV[0] is used as the program
   name in the error messages.  This flag implies ARGP_NO_EXIT (on the
   assumption that silent exiting upon errors is bad behaviour).  */
#define ARGP_NO_ERRS 0x02

/* Don't parse any non-option args.  Normally non-option args are parsed by
   calling the parse functions with a key of ARGP_KEY_ARG, and the actual arg
   as the value.  Since it's impossible to know which parse function wants to
   handle it, each one is called in turn, until one returns 0 or an error
   other than ARGP_ERR_UNKNOWN; if an argument is handled by no one, the
   argp_parse returns prematurely (but with a return value of 0).  If all
   args have been parsed without error, all parsing functions are called one
   last time with a key of ARGP_KEY_END.  This flag needn't normally be set,
   as the normal behavior is to stop parsing as soon as some argument can't
   be handled.  */
#define ARGP_NO_ARGS 0x04

/* Parse options and arguments in the same order they occur on the command
   line -- normally they're rearranged so that all options come first. */
#define ARGP_IN_ORDER 0x08

/* Don't provide the standard long option --help, which causes usage and
      option help information to be output to stdout, and exit (0) called. */
#define ARGP_NO_HELP 0x10

/* Don't exit on errors (they may still result in error messages).  */
#define ARGP_NO_EXIT 0x20

/* Use the gnu getopt `long-only' rules for parsing arguments.  */
#define ARGP_LONG_ONLY 0x40

/* Turns off any message-printing/exiting options.  */
#define ARGP_SILENT (ARGP_NO_EXIT | ARGP_NO_ERRS | ARGP_NO_HELP)

/* Parse the options strings in ARGC & ARGV according to the options in ARGP.
   FLAGS is one of the ARGP_ flags above.  If ARG_INDEX is non-NULL, the
   index in ARGV of the first unparsed option is returned in it.  If an
   unknown option is present, ARGP_ERR_UNKNOWN is returned; if some parser
   routine returned a non-zero value, it is returned; otherwise 0 is
   returned.  This function may also call exit unless the ARGP_NO_HELP flag
   is set.  INPUT is a pointer to a value to be passed in to the parser.  */
extern error_t argp_parse (const struct argp *__restrict __argp,
      int __argc, char **__restrict __argv,
      unsigned __flags, int *__restrict __arg_index,
      void *__restrict __input);
extern error_t __argp_parse (const struct argp *__restrict __argp,
        int __argc, char **__restrict __argv,
        unsigned __flags, int *__restrict __arg_index,
        void *__restrict __input);

/* Global variables.  */

/* If defined or set by the user program to a non-zero value, then a default
   option --version is added (unless the ARGP_NO_HELP flag is used), which
   will print this string followed by a newline and exit (unless the
   ARGP_NO_EXIT flag is used).  Overridden by ARGP_PROGRAM_VERSION_HOOK.  */
extern const char *argp_program_version;

/* If defined or set by the user program to a non-zero value, then a default
   option --version is added (unless the ARGP_NO_HELP flag is used), which
   calls this function with a stream to print the version to and a pointer to
   the current parsing state, and then exits (unless the ARGP_NO_EXIT flag is
   used).  This variable takes precedent over ARGP_PROGRAM_VERSION.  */
extern void (*argp_program_version_hook) (FILE *__restrict __stream,
       struct argp_state *__restrict
       __state);

/* If defined or set by the user program, it should point to string that is
   the bug-reporting address for the program.  It will be printed by
   argp_help if the ARGP_HELP_BUG_ADDR flag is set (as it is by various
   standard help messages), embedded in a sentence that says something like
   `Report bugs to ADDR.'.  */
extern const char *argp_program_bug_address;

/* The exit status that argp will use when exiting due to a parsing error.
   If not defined or set by the user program, this defaults to EX_USAGE from
   <sysexits.h>.  */
extern error_t argp_err_exit_status;

/* Flags for argp_help.  */
#define ARGP_HELP_USAGE 0x01
#define ARGP_HELP_SHORT_USAGE 0x02
#define ARGP_HELP_SEE 0x04
#define ARGP_HELP_LONG 0x08
#define ARGP_HELP_PRE_DOC 0x10
#define ARGP_HELP_POST_DOC 0x20
#define ARGP_HELP_DOC (ARGP_HELP_PRE_DOC | ARGP_HELP_POST_DOC)
#define ARGP_HELP_BUG_ADDR 0x40
#define ARGP_HELP_LONG_ONLY 0x80


/* These ARGP_HELP flags are only understood by argp_state_help.  */
#define ARGP_HELP_EXIT_ERR 0x100
#define ARGP_HELP_EXIT_OK 0x200

/* The standard thing to do after a program command line parsing error, if an
   error message has already been printed.  */
#define ARGP_HELP_STD_ERR (ARGP_HELP_SEE | ARGP_HELP_EXIT_ERR)

/* The standard thing to do after a program command line parsing error, if no
   more specific error message has been printed.  */
#define ARGP_HELP_STD_USAGE (ARGP_HELP_SHORT_USAGE | ARGP_HELP_SEE | ARGP_HELP_EXIT_ERR)

/* The standard thing to do in response to a --help option.  */
#define ARGP_HELP_STD_HELP (ARGP_HELP_SHORT_USAGE | ARGP_HELP_LONG | ARGP_HELP_EXIT_OK | ARGP_HELP_DOC | ARGP_HELP_BUG_ADDR)



/* Output a usage message for ARGP to STREAM.  FLAGS are from the set
   ARGP_HELP_*.  */
extern void argp_help (const struct argp *__restrict __argp,
         FILE *__restrict __stream,
         unsigned __flags, char *__restrict __name);
extern void __argp_help (const struct argp *__restrict __argp,
    FILE *__restrict __stream, unsigned __flags,
    char *__name);

/* The following routines are intended to be called from within an argp
   parsing routine (thus taking an argp_state structure as the first
   argument).  They may or may not print an error message and exit, depending
   on the flags in STATE -- in any case, the caller should be prepared for
   them *not* to exit, and should return an appropiate error after calling
   them.  [argp_usage & argp_error should probably be called argp_state_...,
   but they're used often enough that they should be short]  */

/* Output, if appropriate, a usage message for STATE to STREAM.  FLAGS are
   from the set ARGP_HELP_*.  */
extern void argp_state_help (const struct argp_state *__restrict __state,
        FILE *__restrict __stream,
        unsigned int __flags);
extern void __argp_state_help (const struct argp_state *__restrict __state,
          FILE *__restrict __stream,
          unsigned int __flags);

/* Possibly output the standard usage message for ARGP to stderr and exit.  */
extern void argp_usage (const struct argp_state *__state);
extern void __argp_usage (const struct argp_state *__state);

/* If appropriate, print the printf string FMT and following args, preceded
   by the program name and `:', to stderr, and followed by a `Try ... --help'
   message, then exit (1).  */
extern void argp_error (const struct argp_state *__restrict __state,
   const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));
extern void __argp_error (const struct argp_state *__restrict __state,
     const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));

/* Similar to the standard gnu error-reporting function error(), but will
   respect the ARGP_NO_EXIT and ARGP_NO_ERRS flags in STATE, and will print
   to STATE->err_stream.  This is useful for argument parsing code that is
   shared between program startup (when exiting is desired) and runtime
   option parsing (when typically an error code is returned instead).  The
   difference between this function and argp_error is that the latter is for
   *parsing errors*, and the former is for other problems that occur during
   parsing but don't reflect a (syntactic) problem with the input.  */
extern void argp_failure (const struct argp_state *__restrict __state,
     int __status, int __errnum,
     const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 4, 5)));
extern void __argp_failure (const struct argp_state *__restrict __state,
       int __status, int __errnum,
       const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 4, 5)));

/* Returns true if the option OPT is a valid short option.  */
extern int _option_is_short (const struct argp_option *__opt) __attribute__ ((__nothrow__ , __leaf__));
extern int __option_is_short (const struct argp_option *__opt) __attribute__ ((__nothrow__ , __leaf__));

/* Returns true if the option OPT is in fact the last (unused) entry in an
   options array.  */
extern int _option_is_end (const struct argp_option *__opt) __attribute__ ((__nothrow__ , __leaf__));
extern int __option_is_end (const struct argp_option *__opt) __attribute__ ((__nothrow__ , __leaf__));

/* Return the input field for ARGP in the parser corresponding to STATE; used
   by the help routines.  */
extern void *_argp_input (const struct argp *__restrict __argp,
     const struct argp_state *__restrict __state)
     __attribute__ ((__nothrow__ , __leaf__));
extern void *__argp_input (const struct argp *__restrict __argp,
      const struct argp_state *__restrict __state)
     __attribute__ ((__nothrow__ , __leaf__));




#define __argp_usage argp_usage
#define __argp_state_help argp_state_help
#define __option_is_short _option_is_short
#define __option_is_end _option_is_end



#define ARGP_EI __extern_inline


extern __inline __attribute__ ((__gnu_inline__)) void
argp_usage (const struct argp_state *__state)
{
  argp_state_help (__state, stderr, (0x02 | 0x04 | 0x100));
}

extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) _option_is_short (const struct argp_option *__opt)
{
  if (__opt->flags & 0x8)
    return 0;
  else
    {
      int __key = __opt->key;
      return __key > 0 && __key <= (0x7f * 2 + 1) && ((*__ctype_b_loc ())[(int) ((__key))] & (unsigned short int) _ISprint);
    }
}

extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) _option_is_end (const struct argp_option *__opt)
{
  return !__opt->key && !__opt->name && !__opt->doc && !__opt->group;
}


#undef __argp_usage
#undef __argp_state_help
#undef __option_is_short
#undef __option_is_end




# 76 "pifunk.c" 2
# 1 "/usr/include/string.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.21 String handling	<string.h>
 */


#define _STRING_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/string.h" 2 3 4



/* Get size_t and NULL from <stddef.h>.  */
#define __need_size_t 
#define __need_NULL 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 160 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 347 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_wchar_t
# 362 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 33 "/usr/include/string.h" 2 3 4

/* Tell the caller that we provide correct C++ prototypes.  */






/* Copy N bytes of SRC to DEST.  */
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
/* Copy N bytes of SRC to DEST, guaranteeing
   correct behavior for overlapping strings.  */
extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


/* Copy no more than N bytes of SRC to DEST, stopping when C is found.
   Return the position in DEST one byte past where C was copied,
   or NULL if C was not found in the first N bytes of SRC.  */

extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




/* Set N bytes of S to C.  */
extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Compare N bytes of S1 and S2.  */
extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

/* Search N bytes of S for C.  */
# 92 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




/* Search in S for C.  This is similar to `memchr' but there is no
   length limit.  */






extern void *rawmemchr (const void *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


/* Search N bytes of S for the final occurrence of C.  */






extern void *memrchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





/* Copy SRC to DEST.  */
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
/* Copy no more than N characters of SRC to DEST.  */
extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Append SRC onto DEST.  */
extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
/* Append no more than N characters from SRC onto DEST.  */
extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Compare S1 and S2.  */
extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
/* Compare N characters of S1 and S2.  */
extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

/* Compare the collated forms of S1 and S2.  */
extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
/* Put a transformation of SRC into no more than N bytes of DEST.  */
extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



/* The following functions are equivalent to the both above but they
   take the locale they use for the collation as an extra argument.
   This is not standardsized but something like will come.  */
# 1 "/usr/include/xlocale.h" 1 3 4
/* Definition of locale datatype.
   Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 160 "/usr/include/string.h" 2 3 4

/* Compare the collated forms of S1 and S2 using rules from L.  */
extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));
/* Put a transformation of SRC into no more than N bytes of DEST.  */
extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));



/* Duplicate S, returning an identical malloc'd string.  */
extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));


/* Return a malloc'd copy of at most N bytes of STRING.  The
   resultant string is terminated even if no null terminator
   appears before STRING[N].  */

extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));



/* Duplicate S, returning an identical alloca'd string.  */
#define strdupa(s) (__extension__ ({ const char *__old = (s); size_t __len = strlen (__old) + 1; char *__new = (char *) __builtin_alloca (__len); (char *) memcpy (__new, __old, __len); }))
# 194 "/usr/include/string.h" 3 4
/* Return an alloca'd copy of at most N bytes of string.  */
#define strndupa(s,n) (__extension__ ({ const char *__old = (s); size_t __len = strnlen (__old, (n)); char *__new = (char *) __builtin_alloca (__len + 1); __new[__len] = '\0'; (char *) memcpy (__new, __old, __len); }))
# 206 "/usr/include/string.h" 3 4

/* Find the first occurrence of C in S.  */
# 231 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));

/* Find the last occurrence of C in S.  */
# 258 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




/* This function is similar to `strchr'.  But it returns a pointer to
   the closing NUL byte in case C is not found in S.  */






extern char *strchrnul (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




/* Return the length of the initial segment of S which
   consists entirely of characters not in REJECT.  */
extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
/* Return the length of the initial segment of S which
   consists entirely of characters in ACCEPT.  */
extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
/* Find the first occurrence in S of any character in ACCEPT.  */
# 310 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

/* Find the first occurrence of NEEDLE in HAYSTACK.  */
# 337 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



/* Divide S into tokens separated by characters in DELIM.  */
extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


/* Divide S into tokens separated by characters in DELIM.  Information
   passed between calls are stored in SAVE_PTR.  */
extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));



/* Similar to `strstr' but this function ignores the case of both strings.  */







extern char *strcasestr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




/* Find the first occurrence of NEEDLE in HAYSTACK.
   NEEDLE is NEEDLELEN bytes long;
   HAYSTACK is HAYSTACKLEN bytes long.  */
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));

/* Copy N bytes of SRC to DEST, return pointer to bytes after the
   last written byte.  */
extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




/* Return the length of S.  */
extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));



/* Find the length of STRING, but scan at most MAXLEN characters.
   If no '\0' terminator is found in that many characters, return MAXLEN.  */
extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




/* Return a string describing the meaning of the `errno' code in ERRNUM.  */
extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));


/* Reentrant version of `strerror'.
   There are 2 flavors of `strerror_r', GNU which returns the string
   and may or may not use the supplied temporary buffer and POSIX one
   which fills the string into the buffer.
   To use the POSIX version, -D_XOPEN_SOURCE=600 or -D_POSIX_C_SOURCE=200112L
   without -D_GNU_SOURCE is needed, otherwise the GNU version is
   preferred.  */
# 431 "/usr/include/string.h" 3 4
/* If a temporary buffer is required, at most BUFLEN bytes of BUF will be
   used.  */
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;




/* Translate error number to string according to the locale L.  */
extern char *strerror_l (int __errnum, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));



/* We define this function always since `bzero' is sometimes needed when
   the namespace rules does not allow this.  */
extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Copy N bytes of SRC to DEST (like memmove, but args reversed).  */
extern void bcopy (const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set N bytes of S to 0.  */
extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Compare N bytes of S1 and S2 (same as memcmp).  */
extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

/* Find the first occurrence of C in S (same as strchr).  */
# 484 "/usr/include/string.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


/* Find the last occurrence of C in S (same as strrchr).  */
# 512 "/usr/include/string.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


/* Return the position of the first bit set in I, or 0 if none are set.
   The least-significant bit is position 1, the most-significant 32.  */
extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* The following two functions are non-standard but necessary for non-32 bit
   platforms.  */

extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


/* Compare S1 and S2, ignoring case.  */
extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

/* Compare no more than N chars of S1 and S2, ignoring case.  */
extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



/* Again versions of a few functions which use the given locale instead
   of the global one.  */
extern int strcasecmp_l (const char *__s1, const char *__s2,
    __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));



/* Return the next DELIM-delimited token from *STRINGP,
   terminating it with a '\0', and update *STRINGP to point past it.  */
extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



/* Return a string describing the meaning of the signal number in SIG.  */
extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));

/* Copy SRC to DEST, returning the address of the terminating '\0' in DEST.  */
extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Copy no more than N characters of SRC to DEST, returning the address of
   the last character written into DEST.  */
extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



/* Compare S1 and S2 as strings holding name & indices/version numbers.  */
extern int strverscmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

/* Sautee STRING briskly.  */
extern char *strfry (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Frobnicate N bytes of S.  */
extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Return the file name within directory of FILENAME.  We don't
   declare the function if the `basename' macro is available (defined
   in <libgen.h>) which makes the XPG version of this function
   available.  */






extern char *basename (const char *__filename) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 608 "/usr/include/string.h" 3 4
/* When using GNU CC we provide some optimized versions of selected
   functions from this header.  There are two kinds of optimizations:

   - machine-dependent optimizations, most probably using inline
     assembler code; these might be quite expensive since the code
     size can increase significantly.
     These optimizations are not used unless the symbol
	__USE_STRING_INLINES
     is defined before including this header.

   - machine-independent optimizations which do not increase the
     code size significantly and which optimize mainly situations
     where one or more arguments are compile-time constants.
     These optimizations are used always when the compiler is
     taught to optimize.

   One can inhibit all optimizations by defining __NO_STRING_INLINES.  */

/* Get the machine-dependent optimizations (if any).  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/string.h" 1 3 4
/* This file should provide inline versions of string functions.

   Surround GCC-specific parts with #ifdef __GNUC__, and use `__extern_inline'.

   This file should define __STRING_INLINES if functions are actually defined
   as inlines.  */


#define _BITS_STRING_H 1

/* Define whether to use the unaligned string inline ABI.
   The string inline functions are an external ABI, thus cannot be changed
   after the first release of a new target (unlike _STRING_ARCH_unaligned
   which may be changed from release to release).  Targets must support
   unaligned accesses in hardware if either define is set to true.  */
#define _STRING_INLINE_unaligned 0
# 628 "/usr/include/string.h" 2 3 4

/* These are generic optimizations which do not add too much inline code.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/string2.h" 1 3 4
/* Machine-independant string function optimizations.
   Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */







/* Unlike the definitions in the header <bits/string.h> the
   definitions contained here are not optimized down to assembler
   level.  Those optimizations are not always a good idea since this
   means the code size increases a lot.  Instead the definitions here
   optimize some functions in a way which do not dramatically
   increase the code size and which do not use assembler.  The main
   trick is to use GCC's `__builtin_constant_p' function.

   Every function XXX which has a defined version in
   <bits/string.h> must be accompanied by a symbol _HAVE_STRING_ARCH_XXX
   to make sure we don't get redefinitions.

   We must use here macros instead of inline functions since the
   trick won't work with the latter.  */





#define __STRING_INLINE __extern_inline



/* Dereferencing a pointer arg to run sizeof on it fails for the void
   pointer case, so we use this instead.
   Note that __x is evaluated twice. */
#define __string2_1bptr_p(__x) ((size_t)(const void *)((__x) + 1) - (size_t)(const void *)(__x) == 1)


/* Set N bytes of S to C.  */

#define __bzero(s,n) __builtin_memset (s, '\0', n)




extern void *__rawmemchr (const void *__s, int __c);
#define strchr(s,c) (__extension__ (__builtin_constant_p (c) && !__builtin_constant_p (s) && (c) == '\0' ? (char *) __rawmemchr (s, c) : __builtin_strchr (s, c)))







/* Copy SRC to DEST, returning pointer to final NUL byte.  */


#define __stpcpy(dest,src) __builtin_stpcpy (dest, src)
/* In glibc we use this function frequently but for namespace reasons
   we have to use the name `__stpcpy'.  */
#define stpcpy(dest,src) __stpcpy (dest, src)




/* Copy no more than N characters of SRC to DEST.  */

#define strncpy(dest,src,n) __builtin_strncpy (dest, src, n)



/* Append no more than N characters from SRC onto DEST.  */
# 100 "/usr/include/arm-linux-gnueabihf/bits/string2.h" 3 4
#define strncat(dest,src,n) __builtin_strncat (dest, src, n)




/* Compare characters of S1 and S2.  */

#define strcmp(s1,s2) __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (s1) && __builtin_constant_p (s2) && (__s1_len = __builtin_strlen (s1), __s2_len = __builtin_strlen (s2), (!__string2_1bptr_p (s1) || __s1_len >= 4) && (!__string2_1bptr_p (s2) || __s2_len >= 4)) ? __builtin_strcmp (s1, s2) : (__builtin_constant_p (s1) && __string2_1bptr_p (s1) && (__s1_len = __builtin_strlen (s1), __s1_len < 4) ? (__builtin_constant_p (s2) && __string2_1bptr_p (s2) ? __builtin_strcmp (s1, s2) : __strcmp_cg (s1, s2, __s1_len)) : (__builtin_constant_p (s2) && __string2_1bptr_p (s2) && (__s2_len = __builtin_strlen (s2), __s2_len < 4) ? (__builtin_constant_p (s1) && __string2_1bptr_p (s1) ? __builtin_strcmp (s1, s2) : -__strcmp_cg (s2, s1, __s2_len)) : __builtin_strcmp (s1, s2)))); })
# 127 "/usr/include/arm-linux-gnueabihf/bits/string2.h" 3 4
#define __strcmp_cg(s1,s2,l1) (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (s2); int __result = (((const unsigned char *) (const char *) (s1))[0] - __s2[0]); if (l1 > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (s1))[1] - __s2[1]); if (l1 > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (s1))[2] - __s2[2]); if (l1 > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (s1))[3] - __s2[3]); } } __result; }))
# 151 "/usr/include/arm-linux-gnueabihf/bits/string2.h" 3 4
/* Compare N characters of S1 and S2.  */

#define strncmp(s1,s2,n) (__extension__ (__builtin_constant_p (n) && ((__builtin_constant_p (s1) && strlen (s1) < ((size_t) (n))) || (__builtin_constant_p (s2) && strlen (s2) < ((size_t) (n)))) ? strcmp (s1, s2) : strncmp (s1, s2, n)))
# 163 "/usr/include/arm-linux-gnueabihf/bits/string2.h" 3 4
/* Return the length of the initial segment of S which
   consists entirely of characters not in REJECT.  */

#define strcspn(s,reject) __builtin_strcspn (s, reject)



/* Return the length of the initial segment of S which
   consists entirely of characters in ACCEPT.  */

#define strspn(s,accept) __builtin_strspn (s, accept)



/* Find the first occurrence in S of any character in ACCEPT.  */

#define strpbrk(s,accept) __builtin_strpbrk (s, accept)





#define __strtok_r(s,sep,nextp) (__extension__ (__builtin_constant_p (sep) && __string2_1bptr_p (sep) && ((const char *) (sep))[0] != '\0' && ((const char *) (sep))[1] == '\0' ? __strtok_r_1c (s, ((const char *) (sep))[0], nextp) : __strtok_r (s, sep, nextp)))







extern __inline __attribute__ ((__gnu_inline__)) char *__strtok_r_1c (char *__s, char __sep, char **__nextp);
extern __inline __attribute__ ((__gnu_inline__)) char *
__strtok_r_1c (char *__s, char __sep, char **__nextp)
{
  char *__result;
  if (__s == ((void *)0))
    __s = *__nextp;
  while (*__s == __sep)
    ++__s;
  __result = ((void *)0);
  if (*__s != '\0')
    {
      __result = __s++;
      while (*__s != '\0')
 if (*__s++ == __sep)
   {
     __s[-1] = '\0';
     break;
   }
    }
  *__nextp = __s;
  return __result;
}

#define strtok_r(s,sep,nextp) __strtok_r (s, sep, nextp)







extern char *__strsep_g (char **__stringp, const char *__delim);
#define __strsep(s,reject) __extension__ ({ char __r0, __r1, __r2; (__builtin_constant_p (reject) && __string2_1bptr_p (reject) && (__r0 = ((const char *) (reject))[0], ((const char *) (reject))[0] != '\0') ? ((__r1 = ((const char *) (reject))[1], ((const char *) (reject))[1] == '\0') ? __strsep_1c (s, __r0) : ((__r2 = ((const char *) (reject))[2], __r2 == '\0') ? __strsep_2c (s, __r0, __r1) : (((const char *) (reject))[3] == '\0' ? __strsep_3c (s, __r0, __r1, __r2) : __strsep_g (s, reject)))) : __strsep_g (s, reject)); })
# 243 "/usr/include/arm-linux-gnueabihf/bits/string2.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) char *__strsep_1c (char **__s, char __reject);
extern __inline __attribute__ ((__gnu_inline__)) char *
__strsep_1c (char **__s, char __reject)
{
  char *__retval = *__s;
  if (__retval != ((void *)0) && (*__s = (__extension__ (__builtin_constant_p (__reject) && !__builtin_constant_p (__retval) && (__reject) == '\0' ? (char *) __rawmemchr (__retval, __reject) : __builtin_strchr (__retval, __reject)))) != ((void *)0))
    *(*__s)++ = '\0';
  return __retval;
}

extern __inline __attribute__ ((__gnu_inline__)) char *__strsep_2c (char **__s, char __reject1, char __reject2);
extern __inline __attribute__ ((__gnu_inline__)) char *
__strsep_2c (char **__s, char __reject1, char __reject2)
{
  char *__retval = *__s;
  if (__retval != ((void *)0))
    {
      char *__cp = __retval;
      while (1)
 {
   if (*__cp == '\0')
     {
       __cp = ((void *)0);
   break;
     }
   if (*__cp == __reject1 || *__cp == __reject2)
     {
       *__cp++ = '\0';
       break;
     }
   ++__cp;
 }
      *__s = __cp;
    }
  return __retval;
}

extern __inline __attribute__ ((__gnu_inline__)) char *__strsep_3c (char **__s, char __reject1, char __reject2,
       char __reject3);
extern __inline __attribute__ ((__gnu_inline__)) char *
__strsep_3c (char **__s, char __reject1, char __reject2, char __reject3)
{
  char *__retval = *__s;
  if (__retval != ((void *)0))
    {
      char *__cp = __retval;
      while (1)
 {
   if (*__cp == '\0')
     {
       __cp = ((void *)0);
   break;
     }
   if (*__cp == __reject1 || *__cp == __reject2 || *__cp == __reject3)
     {
       *__cp++ = '\0';
       break;
     }
   ++__cp;
 }
      *__s = __cp;
    }
  return __retval;
}

#define strsep(s,reject) __strsep (s, reject)



/* We need the memory allocation functions for inline strdup().
   Referring to stdlib.h (even minimally) is not allowed
   in any of the tight standards compliant modes.  */



#define __need_malloc_and_calloc 
# 1 "/usr/include/stdlib.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.20 General utilities	<stdlib.h>
 */
# 320 "/usr/include/arm-linux-gnueabihf/bits/string2.h" 2 3 4




extern char *__strdup (const char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__));
#define __strdup(s) (__extension__ (__builtin_constant_p (s) && __string2_1bptr_p (s) ? (((const char *) (s))[0] == '\0' ? (char *) calloc ((size_t) 1, (size_t) 1) : ({ size_t __len = strlen (s) + 1; char *__retval = (char *) malloc (__len); if (__retval != NULL) __retval = (char *) memcpy (__retval, s, __len); __retval; })) : __strdup (s)))
# 337 "/usr/include/arm-linux-gnueabihf/bits/string2.h" 3 4
#define strdup(s) __strdup (s)





extern char *__strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__));
#define __strndup(s,n) (__extension__ (__builtin_constant_p (s) && __string2_1bptr_p (s) ? (((const char *) (s))[0] == '\0' ? (char *) calloc ((size_t) 1, (size_t) 1) : ({ size_t __len = strlen (s) + 1; size_t __n = (n); char *__retval; if (__n < __len) __len = __n + 1; __retval = (char *) malloc (__len); if (__retval != NULL) { __retval[__len - 1] = '\0'; __retval = (char *) memcpy (__retval, s, __len - 1); } __retval; })) : __strndup (s, n)))
# 365 "/usr/include/arm-linux-gnueabihf/bits/string2.h" 3 4
#define strndup(s,n) __strndup (s, n)






#undef __STRING_INLINE
# 631 "/usr/include/string.h" 2 3 4
# 643 "/usr/include/string.h" 3 4
#define mempcpy(dest,src,n) __mempcpy_inline (dest, src, n)
#define __mempcpy(dest,src,n) __mempcpy_inline (dest, src, n)

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) void *
__mempcpy_inline (void *__restrict __dest,
    const void *__restrict __src, size_t __n)
{
  return (char *) memcpy (__dest, __src, __n) + __n;
}





# 77 "pifunk.c" 2
# 1 "/usr/include/getopt.h" 1 3 4
/* Declarations for getopt.
   Copyright (C) 1989-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 78 "pifunk.c" 2
# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */





#define _TIME_H 1
# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 28 "/usr/include/time.h" 2 3 4






/* Get size_t and NULL from <stddef.h>.  */
#define __need_size_t 
#define __need_NULL 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 160 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 347 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_wchar_t
# 362 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 38 "/usr/include/time.h" 2 3 4

/* This defines CLOCKS_PER_SEC, which is the number of processor clock
   ticks per second.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/time.h" 1 3 4
/* System-dependent timing definitions.  Linux version.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <time.h> instead.
 */
# 40 "/usr/include/arm-linux-gnueabihf/bits/time.h" 3 4
#define _BITS_TIME_H 1

/* ISO/IEC 9899:1999 7.23.1: Components of time
   The macro `CLOCKS_PER_SEC' is an expression with type `clock_t' that is
   the number per second of the value returned by the `clock' function.  */
/* CAE XSH, Issue 4, Version 2: <time.h>
   The value of CLOCKS_PER_SEC is required to be 1 million on all
   XSI-conformant systems. */
#define CLOCKS_PER_SEC ((clock_t) 1000000)
# 60 "/usr/include/arm-linux-gnueabihf/bits/time.h" 3 4
/* Identifier for system-wide realtime clock.  */
#define CLOCK_REALTIME 0
/* Monotonic system-wide clock.  */
#define CLOCK_MONOTONIC 1
/* High-resolution timer from the CPU.  */
#define CLOCK_PROCESS_CPUTIME_ID 2
/* Thread-specific CPU-time clock.  */
#define CLOCK_THREAD_CPUTIME_ID 3
/* Monotonic system-wide clock, not adjusted for frequency scaling.  */
#define CLOCK_MONOTONIC_RAW 4
/* Identifier for system-wide realtime clock, updated only on ticks.  */
#define CLOCK_REALTIME_COARSE 5
/* Monotonic system-wide clock, updated only on ticks.  */
#define CLOCK_MONOTONIC_COARSE 6
/* Monotonic system-wide clock that includes time spent in suspension.  */
#define CLOCK_BOOTTIME 7
/* Like CLOCK_REALTIME but also wakes suspended system.  */
#define CLOCK_REALTIME_ALARM 8
/* Like CLOCK_BOOTTIME but also wakes suspended system.  */
#define CLOCK_BOOTTIME_ALARM 9
/* Like CLOCK_REALTIME but in International Atomic Time.  */
#define CLOCK_TAI 11

/* Flag to indicate time is absolute.  */
#define TIMER_ABSTIME 1



# 1 "/usr/include/arm-linux-gnueabihf/bits/timex.h" 1 3 4
/* Copyright (C) 1995-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _BITS_TIMEX_H 1

# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 22 "/usr/include/arm-linux-gnueabihf/bits/timex.h" 2 3 4

/* These definitions from linux/timex.h as of 3.18.  */

struct timex
{
  unsigned int modes; /* mode selector */
  __syscall_slong_t offset; /* time offset (usec) */
  __syscall_slong_t freq; /* frequency offset (scaled ppm) */
  __syscall_slong_t maxerror; /* maximum error (usec) */
  __syscall_slong_t esterror; /* estimated error (usec) */
  int status; /* clock command/status */
  __syscall_slong_t constant; /* pll time constant */
  __syscall_slong_t precision; /* clock precision (usec) (ro) */
  __syscall_slong_t tolerance; /* clock frequency tolerance (ppm) (ro) */
  struct timeval time; /* (read only, except for ADJ_SETOFFSET) */
  __syscall_slong_t tick; /* (modified) usecs between clock ticks */
  __syscall_slong_t ppsfreq; /* pps frequency (scaled ppm) (ro) */
  __syscall_slong_t jitter; /* pps jitter (us) (ro) */
  int shift; /* interval duration (s) (shift) (ro) */
  __syscall_slong_t stabil; /* pps stability (scaled ppm) (ro) */
  __syscall_slong_t jitcnt; /* jitter limit exceeded (ro) */
  __syscall_slong_t calcnt; /* calibration intervals (ro) */
  __syscall_slong_t errcnt; /* calibration errors (ro) */
  __syscall_slong_t stbcnt; /* stability limit exceeded (ro) */

  int tai; /* TAI offset (ro) */

  /* ??? */
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};

/* Mode codes (timex.mode) */
#define ADJ_OFFSET 0x0001
#define ADJ_FREQUENCY 0x0002
#define ADJ_MAXERROR 0x0004
#define ADJ_ESTERROR 0x0008
#define ADJ_STATUS 0x0010
#define ADJ_TIMECONST 0x0020
#define ADJ_TAI 0x0080
#define ADJ_SETOFFSET 0x0100
#define ADJ_MICRO 0x1000
#define ADJ_NANO 0x2000
#define ADJ_TICK 0x4000
#define ADJ_OFFSET_SINGLESHOT 0x8001
#define ADJ_OFFSET_SS_READ 0xa001

/* xntp 3.4 compatibility names */
#define MOD_OFFSET ADJ_OFFSET
#define MOD_FREQUENCY ADJ_FREQUENCY
#define MOD_MAXERROR ADJ_MAXERROR
#define MOD_ESTERROR ADJ_ESTERROR
#define MOD_STATUS ADJ_STATUS
#define MOD_TIMECONST ADJ_TIMECONST
#define MOD_CLKB ADJ_TICK
#define MOD_CLKA ADJ_OFFSET_SINGLESHOT
#define MOD_TAI ADJ_TAI
#define MOD_MICRO ADJ_MICRO
#define MOD_NANO ADJ_NANO


/* Status codes (timex.status) */
#define STA_PLL 0x0001
#define STA_PPSFREQ 0x0002
#define STA_PPSTIME 0x0004
#define STA_FLL 0x0008

#define STA_INS 0x0010
#define STA_DEL 0x0020
#define STA_UNSYNC 0x0040
#define STA_FREQHOLD 0x0080

#define STA_PPSSIGNAL 0x0100
#define STA_PPSJITTER 0x0200
#define STA_PPSWANDER 0x0400
#define STA_PPSERROR 0x0800

#define STA_CLOCKERR 0x1000
#define STA_NANO 0x2000
#define STA_MODE 0x4000
#define STA_CLK 0x8000

/* Read-only bits */
#define STA_RONLY (STA_PPSSIGNAL | STA_PPSJITTER | STA_PPSWANDER | STA_PPSERROR | STA_CLOCKERR | STA_NANO | STA_MODE | STA_CLK)
# 89 "/usr/include/arm-linux-gnueabihf/bits/time.h" 2 3 4



/* Tune a POSIX clock.  */
extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) __attribute__ ((__nothrow__ , __leaf__));







#undef __need_timeval
# 42 "/usr/include/time.h" 2 3 4

/* This is the obsolete POSIX.1-1988 name for the same constant.  */
# 66 "/usr/include/time.h" 3 4
#undef __need_clock_t
# 82 "/usr/include/time.h" 3 4
#undef __need_time_t
# 94 "/usr/include/time.h" 3 4
#undef __clockid_time_t
# 106 "/usr/include/time.h" 3 4
#undef __need_timer_t
# 127 "/usr/include/time.h" 3 4
#undef __need_timespec




/* Used by other time functions.  */
struct tm
{
  int tm_sec; /* Seconds.	[0-60] (1 leap second) */
  int tm_min; /* Minutes.	[0-59] */
  int tm_hour; /* Hours.	[0-23] */
  int tm_mday; /* Day.		[1-31] */
  int tm_mon; /* Month.	[0-11] */
  int tm_year; /* Year	- 1900.  */
  int tm_wday; /* Day of week.	[0-6] */
  int tm_yday; /* Days in year.[0-365]	*/
  int tm_isdst; /* DST.		[-1/0/1]*/


  long int tm_gmtoff; /* Seconds east of UTC.  */
  const char *tm_zone; /* Timezone abbreviation.  */




};







/* POSIX.1b structure for timer start values and intervals.  */
struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };

/* We can use a simple forward declaration.  */
struct sigevent;
# 181 "/usr/include/time.h" 3 4
/* Time base values for timespec_get.  */
#define TIME_UTC 1




/* Time used by the program so far (user time + system time).
   The result / CLOCKS_PER_SECOND is program time in seconds.  */
extern clock_t clock (void) __attribute__ ((__nothrow__ , __leaf__));

/* Return the current time and put it in *TIMER if TIMER is not NULL.  */
extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));

/* Return the difference between TIME1 and TIME0.  */
extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return the `time_t' representation of TP and normalize TP.  */
extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


/* Format TP into S according to FORMAT.
   Write no more than MAXSIZE characters and return the number
   of characters written, or 0 if it would exceed MAXSIZE.  */
extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));



/* Parse S according to FORMAT and store binary time information in TP.
   The return value is a pointer to the first unparsed character in S.  */
extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     __attribute__ ((__nothrow__ , __leaf__));



/* Similar to the two functions above but take the information from
   the provided locale and not the global locale.  */
# 1 "/usr/include/xlocale.h" 1 3 4
/* Definition of locale datatype.
   Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 222 "/usr/include/time.h" 2 3 4

extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));




/* Return the `struct tm' representation of *TIMER
   in Universal Coordinated Time (aka Greenwich Mean Time).  */
extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));

/* Return the `struct tm' representation
   of *TIMER in the local timezone.  */
extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));



/* Return the `struct tm' representation of *TIMER in UTC,
   using *TP to store the result.  */
extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));

/* Return the `struct tm' representation of *TIMER in local time,
   using *TP to store the result.  */
extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));



/* Return a string of the form "Day Mon dd hh:mm:ss yyyy\n"
   that is the representation of TP in this format.  */
extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));

/* Equivalent to `asctime (localtime (timer))'.  */
extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));



/* Reentrant versions of the above functions.  */

/* Return in BUF a string of the form "Day Mon dd hh:mm:ss yyyy\n"
   that is the representation of TP in this format.  */
extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));

/* Equivalent to `asctime_r (localtime_r (timer, *TMP*), buf)'.  */
extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



/* Defined in localtime.c.  */
extern char *__tzname[2]; /* Current timezone names.  */
extern int __daylight; /* If daylight-saving time is ever in use.  */
extern long int __timezone; /* Seconds west of UTC.  */



/* Same as above.  */
extern char *tzname[2];

/* Set time conversion information from the TZ environment variable.
   If TZ is not defined, a locale-dependent default is used.  */
extern void tzset (void) __attribute__ ((__nothrow__ , __leaf__));



extern int daylight;
extern long int timezone;



/* Set the system time to *WHEN.
   This call is restricted to the superuser.  */
extern int stime (const time_t *__when) __attribute__ ((__nothrow__ , __leaf__));



/* Nonzero if YEAR is a leap year (every 4 years,
   except every 100th isn't, and every 400th is).  */
#define __isleap(year) ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))




/* Miscellaneous functions many Unices inherited from the public domain
   localtime package.  These are included only for compatibility.  */

/* Like `mktime', but for TP represents Universal Time, not local time.  */
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));

/* Another name for `mktime'.  */
extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));

/* Return the number of days in YEAR.  */
extern int dysize (int __year) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




/* Pause execution for a number of nanoseconds.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);


/* Get resolution of clock CLOCK_ID.  */
extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__ , __leaf__));

/* Get current value of clock CLOCK_ID and store it in TP.  */
extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__ , __leaf__));

/* Set clock CLOCK_ID to value TP.  */
extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     __attribute__ ((__nothrow__ , __leaf__));


/* High-resolution sleep with the specified clock.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);

/* Return clock ID for CPU-time clock.  */
extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__ , __leaf__));



/* Create new per-process timer using CLOCK_ID.  */
extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__ , __leaf__));

/* Delete timer TIMERID.  */
extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));

/* Set timer TIMERID to VALUE, returning old value in OVALUE.  */
extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__ , __leaf__));

/* Get current value of timer TIMERID and store it in VALUE.  */
extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__ , __leaf__));

/* Get expiration overrun for timer TIMERID.  */
extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));




/* Set TS to calendar time based in time base BASE.  */
extern int timespec_get (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




/* Set to one of the following values to indicate an error.
     1  the DATEMSK environment variable is null or undefined,
     2  the template file cannot be opened for reading,
     3  failed to get file status information,
     4  the template file is not a regular file,
     5  an error is encountered while reading the template file,
     6  memory allication failed (not enough memory available),
     7  there is no line in the template that matches the input,
     8  invalid input specification Example: February 31 or a time is
	specified that can not be represented in a time_t (representing
	the time in seconds since 00:00:00 UTC, January 1, 1970) */
extern int getdate_err;

/* Parse the given string as a date specification and return a value
   representing the value.  The templates from the file identified by
   the environment variable DATEMSK are used.  In case of an error
   `getdate_err' is set.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct tm *getdate (const char *__string);



/* Since `getdate' is not reentrant because of the use of `getdate_err'
   and the static buffer to return the result in, we provide a thread-safe
   variant.  The functionality is the same.  The result is returned in
   the buffer pointed to by RESBUFP and in case of an error the return
   value is != 0 with the same values as given above for `getdate_err'.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);



# 79 "pifunk.c" 2
# 1 "/usr/include/sched.h" 1 3 4
/* Definitions for POSIX 1003.1b-1993 (aka POSIX.4) scheduling interface.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _SCHED_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 23 "/usr/include/sched.h" 2 3 4

/* Get type definitions.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 26 "/usr/include/sched.h" 2 3 4

#define __need_size_t 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 160 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 347 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_wchar_t
# 362 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 29 "/usr/include/sched.h" 2 3 4


#define __need_time_t 
#define __need_timespec 

# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 35 "/usr/include/sched.h" 2 3 4







/* Get system specific constant and data structure definitions.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/sched.h" 1 3 4
/* Definitions of constants and data structure for POSIX 1003.1b-1993
   scheduling interface.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 27 "/usr/include/arm-linux-gnueabihf/bits/sched.h" 3 4
/* Scheduling algorithms.  */
#define SCHED_OTHER 0
#define SCHED_FIFO 1
#define SCHED_RR 2

#define SCHED_BATCH 3
#define SCHED_IDLE 5

#define SCHED_RESET_ON_FORK 0x40000000



/* Cloning flags.  */
#define CSIGNAL 0x000000ff
#define CLONE_VM 0x00000100
#define CLONE_FS 0x00000200
#define CLONE_FILES 0x00000400
#define CLONE_SIGHAND 0x00000800
#define CLONE_PTRACE 0x00002000
#define CLONE_VFORK 0x00004000

#define CLONE_PARENT 0x00008000

#define CLONE_THREAD 0x00010000
#define CLONE_NEWNS 0x00020000
#define CLONE_SYSVSEM 0x00040000
#define CLONE_SETTLS 0x00080000
#define CLONE_PARENT_SETTID 0x00100000

#define CLONE_CHILD_CLEARTID 0x00200000

#define CLONE_DETACHED 0x00400000
#define CLONE_UNTRACED 0x00800000

#define CLONE_CHILD_SETTID 0x01000000

#define CLONE_NEWCGROUP 0x02000000
#define CLONE_NEWUTS 0x04000000
#define CLONE_NEWIPC 0x08000000
#define CLONE_NEWUSER 0x10000000
#define CLONE_NEWPID 0x20000000
#define CLONE_NEWNET 0x40000000
#define CLONE_IO 0x80000000


/* The official definition.  */
struct sched_param
  {
    int __sched_priority;
  };




/* Clone current process.  */
extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) __attribute__ ((__nothrow__ , __leaf__));

/* Unshare the specified resources.  */
extern int unshare (int __flags) __attribute__ ((__nothrow__ , __leaf__));

/* Get index of currently used CPU.  */
extern int sched_getcpu (void) __attribute__ ((__nothrow__ , __leaf__));

/* Switch process to namespace of type NSTYPE indicated by FD.  */
extern int setns (int __fd, int __nstype) __attribute__ ((__nothrow__ , __leaf__));









#define __defined_schedparam 1
/* Data structure to describe a process' schedulability.  */
struct __sched_param
  {
    int __sched_priority;
  };
#undef __need_schedparam




#define __cpu_set_t_defined 
/* Size definition for CPU sets.  */
#define __CPU_SETSIZE 1024
#define __NCPUBITS (8 * sizeof (__cpu_mask))

/* Type for array elements in 'cpu_set_t'.  */
typedef unsigned long int __cpu_mask;

/* Basic access functions.  */
#define __CPUELT(cpu) ((cpu) / __NCPUBITS)
#define __CPUMASK(cpu) ((__cpu_mask) 1 << ((cpu) % __NCPUBITS))

/* Data structure to describe CPU mask.  */
typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;

/* Access functions for CPU masks.  */

#define __CPU_ZERO_S(setsize,cpusetp) do __builtin_memset (cpusetp, '\0', setsize); while (0)
# 145 "/usr/include/arm-linux-gnueabihf/bits/sched.h" 3 4
#define __CPU_SET_S(cpu,setsize,cpusetp) (__extension__ ({ size_t __cpu = (cpu); __cpu / 8 < (setsize) ? (((__cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)] |= __CPUMASK (__cpu)) : 0; }))






#define __CPU_CLR_S(cpu,setsize,cpusetp) (__extension__ ({ size_t __cpu = (cpu); __cpu / 8 < (setsize) ? (((__cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)] &= ~__CPUMASK (__cpu)) : 0; }))






#define __CPU_ISSET_S(cpu,setsize,cpusetp) (__extension__ ({ size_t __cpu = (cpu); __cpu / 8 < (setsize) ? ((((const __cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)] & __CPUMASK (__cpu))) != 0 : 0; }))







#define __CPU_COUNT_S(setsize,cpusetp) __sched_cpucount (setsize, cpusetp)



#define __CPU_EQUAL_S(setsize,cpusetp1,cpusetp2) (__builtin_memcmp (cpusetp1, cpusetp2, setsize) == 0)
# 186 "/usr/include/arm-linux-gnueabihf/bits/sched.h" 3 4
#define __CPU_OP_S(setsize,destset,srcset1,srcset2,op) (__extension__ ({ cpu_set_t *__dest = (destset); const __cpu_mask *__arr1 = (srcset1)->__bits; const __cpu_mask *__arr2 = (srcset2)->__bits; size_t __imax = (setsize) / sizeof (__cpu_mask); size_t __i; for (__i = 0; __i < __imax; ++__i) ((__cpu_mask *) __dest->__bits)[__i] = __arr1[__i] op __arr2[__i]; __dest; }))
# 197 "/usr/include/arm-linux-gnueabihf/bits/sched.h" 3 4
#define __CPU_ALLOC_SIZE(count) ((((count) + __NCPUBITS - 1) / __NCPUBITS) * sizeof (__cpu_mask))

#define __CPU_ALLOC(count) __sched_cpualloc (count)
#define __CPU_FREE(cpuset) __sched_cpufree (cpuset)



extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  __attribute__ ((__nothrow__ , __leaf__));
extern cpu_set_t *__sched_cpualloc (size_t __count) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void __sched_cpufree (cpu_set_t *__set) __attribute__ ((__nothrow__ , __leaf__));


# 44 "/usr/include/sched.h" 2 3 4
/* Define the real names for the elements of `struct sched_param'.  */
#define sched_priority __sched_priority




/* Set scheduling parameters for a process.  */
extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     __attribute__ ((__nothrow__ , __leaf__));

/* Retrieve scheduling parameters for a particular process.  */
extern int sched_getparam (__pid_t __pid, struct sched_param *__param) __attribute__ ((__nothrow__ , __leaf__));

/* Set scheduling algorithm and/or parameters for a process.  */
extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) __attribute__ ((__nothrow__ , __leaf__));

/* Retrieve scheduling algorithm for a particular purpose.  */
extern int sched_getscheduler (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));

/* Yield the processor.  */
extern int sched_yield (void) __attribute__ ((__nothrow__ , __leaf__));

/* Get maximum priority value for a scheduler.  */
extern int sched_get_priority_max (int __algorithm) __attribute__ ((__nothrow__ , __leaf__));

/* Get minimum priority value for a scheduler.  */
extern int sched_get_priority_min (int __algorithm) __attribute__ ((__nothrow__ , __leaf__));

/* Get the SCHED_RR interval for the named process.  */
extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) __attribute__ ((__nothrow__ , __leaf__));



/* Access macros for `cpu_set'.  */
#define CPU_SETSIZE __CPU_SETSIZE
#define CPU_SET(cpu,cpusetp) __CPU_SET_S (cpu, sizeof (cpu_set_t), cpusetp)
#define CPU_CLR(cpu,cpusetp) __CPU_CLR_S (cpu, sizeof (cpu_set_t), cpusetp)
#define CPU_ISSET(cpu,cpusetp) __CPU_ISSET_S (cpu, sizeof (cpu_set_t), cpusetp)

#define CPU_ZERO(cpusetp) __CPU_ZERO_S (sizeof (cpu_set_t), cpusetp)
#define CPU_COUNT(cpusetp) __CPU_COUNT_S (sizeof (cpu_set_t), cpusetp)

#define CPU_SET_S(cpu,setsize,cpusetp) __CPU_SET_S (cpu, setsize, cpusetp)
#define CPU_CLR_S(cpu,setsize,cpusetp) __CPU_CLR_S (cpu, setsize, cpusetp)
#define CPU_ISSET_S(cpu,setsize,cpusetp) __CPU_ISSET_S (cpu, setsize, cpusetp)

#define CPU_ZERO_S(setsize,cpusetp) __CPU_ZERO_S (setsize, cpusetp)
#define CPU_COUNT_S(setsize,cpusetp) __CPU_COUNT_S (setsize, cpusetp)

#define CPU_EQUAL(cpusetp1,cpusetp2) __CPU_EQUAL_S (sizeof (cpu_set_t), cpusetp1, cpusetp2)

#define CPU_EQUAL_S(setsize,cpusetp1,cpusetp2) __CPU_EQUAL_S (setsize, cpusetp1, cpusetp2)


#define CPU_AND(destset,srcset1,srcset2) __CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, &)

#define CPU_OR(destset,srcset1,srcset2) __CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, |)

#define CPU_XOR(destset,srcset1,srcset2) __CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, ^)

#define CPU_AND_S(setsize,destset,srcset1,srcset2) __CPU_OP_S (setsize, destset, srcset1, srcset2, &)

#define CPU_OR_S(setsize,destset,srcset1,srcset2) __CPU_OP_S (setsize, destset, srcset1, srcset2, |)

#define CPU_XOR_S(setsize,destset,srcset1,srcset2) __CPU_OP_S (setsize, destset, srcset1, srcset2, ^)


#define CPU_ALLOC_SIZE(count) __CPU_ALLOC_SIZE (count)
#define CPU_ALLOC(count) __CPU_ALLOC (count)
#define CPU_FREE(cpuset) __CPU_FREE (cpuset)


/* Set the CPU affinity for a task */
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) __attribute__ ((__nothrow__ , __leaf__));

/* Get the CPU affinity for a task */
extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) __attribute__ ((__nothrow__ , __leaf__));



# 80 "pifunk.c" 2
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/float.h" 1 3 4
/* Copyright (C) 2002-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  5.2.4.2.2  Characteristics of floating types <float.h>
 */


#define _FLOAT_H___ 

/* Radix of exponent representation, b. */
#undef FLT_RADIX
#define FLT_RADIX __FLT_RADIX__

/* Number of base-FLT_RADIX digits in the significand, p.  */
#undef FLT_MANT_DIG
#undef DBL_MANT_DIG
#undef LDBL_MANT_DIG
#define FLT_MANT_DIG __FLT_MANT_DIG__
#define DBL_MANT_DIG __DBL_MANT_DIG__
#define LDBL_MANT_DIG __LDBL_MANT_DIG__

/* Number of decimal digits, q, such that any floating-point number with q
   decimal digits can be rounded into a floating-point number with p radix b
   digits and back again without change to the q decimal digits,

	p * log10(b)			if b is a power of 10
	floor((p - 1) * log10(b))	otherwise
*/
#undef FLT_DIG
#undef DBL_DIG
#undef LDBL_DIG
#define FLT_DIG __FLT_DIG__
#define DBL_DIG __DBL_DIG__
#define LDBL_DIG __LDBL_DIG__

/* Minimum int x such that FLT_RADIX**(x-1) is a normalized float, emin */
#undef FLT_MIN_EXP
#undef DBL_MIN_EXP
#undef LDBL_MIN_EXP
#define FLT_MIN_EXP __FLT_MIN_EXP__
#define DBL_MIN_EXP __DBL_MIN_EXP__
#define LDBL_MIN_EXP __LDBL_MIN_EXP__

/* Minimum negative integer such that 10 raised to that power is in the
   range of normalized floating-point numbers,

	ceil(log10(b) * (emin - 1))
*/
#undef FLT_MIN_10_EXP
#undef DBL_MIN_10_EXP
#undef LDBL_MIN_10_EXP
#define FLT_MIN_10_EXP __FLT_MIN_10_EXP__
#define DBL_MIN_10_EXP __DBL_MIN_10_EXP__
#define LDBL_MIN_10_EXP __LDBL_MIN_10_EXP__

/* Maximum int x such that FLT_RADIX**(x-1) is a representable float, emax.  */
#undef FLT_MAX_EXP
#undef DBL_MAX_EXP
#undef LDBL_MAX_EXP
#define FLT_MAX_EXP __FLT_MAX_EXP__
#define DBL_MAX_EXP __DBL_MAX_EXP__
#define LDBL_MAX_EXP __LDBL_MAX_EXP__

/* Maximum integer such that 10 raised to that power is in the range of
   representable finite floating-point numbers,

	floor(log10((1 - b**-p) * b**emax))
*/
#undef FLT_MAX_10_EXP
#undef DBL_MAX_10_EXP
#undef LDBL_MAX_10_EXP
#define FLT_MAX_10_EXP __FLT_MAX_10_EXP__
#define DBL_MAX_10_EXP __DBL_MAX_10_EXP__
#define LDBL_MAX_10_EXP __LDBL_MAX_10_EXP__

/* Maximum representable finite floating-point number,

	(1 - b**-p) * b**emax
*/
#undef FLT_MAX
#undef DBL_MAX
#undef LDBL_MAX
#define FLT_MAX __FLT_MAX__
#define DBL_MAX __DBL_MAX__
#define LDBL_MAX __LDBL_MAX__

/* The difference between 1 and the least value greater than 1 that is
   representable in the given floating point type, b**1-p.  */
#undef FLT_EPSILON
#undef DBL_EPSILON
#undef LDBL_EPSILON
#define FLT_EPSILON __FLT_EPSILON__
#define DBL_EPSILON __DBL_EPSILON__
#define LDBL_EPSILON __LDBL_EPSILON__

/* Minimum normalized positive floating-point number, b**(emin - 1).  */
#undef FLT_MIN
#undef DBL_MIN
#undef LDBL_MIN
#define FLT_MIN __FLT_MIN__
#define DBL_MIN __DBL_MIN__
#define LDBL_MIN __LDBL_MIN__

/* Addition rounds to 0: zero, 1: nearest, 2: +inf, 3: -inf, -1: unknown.  */
/* ??? This is supposed to change with calls to fesetround in <fenv.h>.  */
#undef FLT_ROUNDS
#define FLT_ROUNDS 1



/* The floating-point expression evaluation method.
        -1  indeterminate
         0  evaluate all operations and constants just to the range and
            precision of the type
         1  evaluate operations and constants of type float and double
            to the range and precision of the double type, evaluate
            long double operations and constants to the range and
            precision of the long double type
         2  evaluate all operations and constants to the range and
            precision of the long double type

   ??? This ought to change with the setting of the fp control word;
   the value provided by the compiler assumes the widest setting.  */
#undef FLT_EVAL_METHOD
#define FLT_EVAL_METHOD __FLT_EVAL_METHOD__

/* Number of decimal digits, n, such that any floating-point number in the
   widest supported floating type with pmax radix b digits can be rounded
   to a floating-point number with n decimal digits and back again without
   change to the value,

	pmax * log10(b)			if b is a power of 10
	ceil(1 + pmax * log10(b))	otherwise
*/
#undef DECIMAL_DIG
#define DECIMAL_DIG __DECIMAL_DIG__
# 81 "pifunk.c" 2
# 1 "/usr/include/locale.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.11 Localization	<locale.h>
 */


#define _LOCALE_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/locale.h" 2 3 4

#define __need_NULL 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 160 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 347 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_wchar_t
# 362 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/locale.h" 1 3 4
/* Definition of locale category symbol values.
   Copyright (C) 2001-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






#define _BITS_LOCALE_H 1

#define __LC_CTYPE 0
#define __LC_NUMERIC 1
#define __LC_TIME 2
#define __LC_COLLATE 3
#define __LC_MONETARY 4
#define __LC_MESSAGES 5
#define __LC_ALL 6
#define __LC_PAPER 7
#define __LC_NAME 8
#define __LC_ADDRESS 9
#define __LC_TELEPHONE 10
#define __LC_MEASUREMENT 11
#define __LC_IDENTIFICATION 12
# 30 "/usr/include/locale.h" 2 3 4



/* These are the possibilities for the first argument to setlocale.
   The code assumes that the lowest LC_* symbol has the value zero.  */
#define LC_CTYPE __LC_CTYPE
#define LC_NUMERIC __LC_NUMERIC
#define LC_TIME __LC_TIME
#define LC_COLLATE __LC_COLLATE
#define LC_MONETARY __LC_MONETARY
#define LC_MESSAGES __LC_MESSAGES
#define LC_ALL __LC_ALL
#define LC_PAPER __LC_PAPER
#define LC_NAME __LC_NAME
#define LC_ADDRESS __LC_ADDRESS
#define LC_TELEPHONE __LC_TELEPHONE
#define LC_MEASUREMENT __LC_MEASUREMENT
#define LC_IDENTIFICATION __LC_IDENTIFICATION




/* Structure giving information about numeric and monetary notation.  */
struct lconv
{
  /* Numeric (non-monetary) information.  */

  char *decimal_point; /* Decimal point character.  */
  char *thousands_sep; /* Thousands separator.  */
  /* Each element is the number of digits in each group;
     elements with higher indices are farther left.
     An element with value CHAR_MAX means that no further grouping is done.
     An element with value 0 means that the previous element is used
     for all groups farther left.  */
  char *grouping;

  /* Monetary information.  */

  /* First three chars are a currency symbol from ISO 4217.
     Fourth char is the separator.  Fifth char is '\0'.  */
  char *int_curr_symbol;
  char *currency_symbol; /* Local currency symbol.  */
  char *mon_decimal_point; /* Decimal point character.  */
  char *mon_thousands_sep; /* Thousands separator.  */
  char *mon_grouping; /* Like `grouping' element (above).  */
  char *positive_sign; /* Sign for positive values.  */
  char *negative_sign; /* Sign for negative values.  */
  char int_frac_digits; /* Int'l fractional digits.  */
  char frac_digits; /* Local fractional digits.  */
  /* 1 if currency_symbol precedes a positive value, 0 if succeeds.  */
  char p_cs_precedes;
  /* 1 iff a space separates currency_symbol from a positive value.  */
  char p_sep_by_space;
  /* 1 if currency_symbol precedes a negative value, 0 if succeeds.  */
  char n_cs_precedes;
  /* 1 iff a space separates currency_symbol from a negative value.  */
  char n_sep_by_space;
  /* Positive and negative sign positions:
     0 Parentheses surround the quantity and currency_symbol.
     1 The sign string precedes the quantity and currency_symbol.
     2 The sign string follows the quantity and currency_symbol.
     3 The sign string immediately precedes the currency_symbol.
     4 The sign string immediately follows the currency_symbol.  */
  char p_sign_posn;
  char n_sign_posn;

  /* 1 if int_curr_symbol precedes a positive value, 0 if succeeds.  */
  char int_p_cs_precedes;
  /* 1 iff a space separates int_curr_symbol from a positive value.  */
  char int_p_sep_by_space;
  /* 1 if int_curr_symbol precedes a negative value, 0 if succeeds.  */
  char int_n_cs_precedes;
  /* 1 iff a space separates int_curr_symbol from a negative value.  */
  char int_n_sep_by_space;
  /* Positive and negative sign positions:
     0 Parentheses surround the quantity and int_curr_symbol.
     1 The sign string precedes the quantity and int_curr_symbol.
     2 The sign string follows the quantity and int_curr_symbol.
     3 The sign string immediately precedes the int_curr_symbol.
     4 The sign string immediately follows the int_curr_symbol.  */
  char int_p_sign_posn;
  char int_n_sign_posn;
# 120 "/usr/include/locale.h" 3 4
};


/* Set and/or return the current locale.  */
extern char *setlocale (int __category, const char *__locale) __attribute__ ((__nothrow__ , __leaf__));

/* Return the numeric/monetary information for the current locale.  */
extern struct lconv *localeconv (void) __attribute__ ((__nothrow__ , __leaf__));





/* The concept of one static locale per category is not very well
   thought out.  Many applications will need to process its data using
   information from several different locales.  Another application is
   the implementation of the internationalization handling in the
   upcoming ISO C++ standard library.  To support this another set of
   the functions using locale data exist which have an additional
   argument.

   Attention: all these functions are *not* standardized in any form.
   This is a proof-of-concept implementation.  */

/* Get locale datatype definition.  */
# 1 "/usr/include/xlocale.h" 1 3 4
/* Definition of locale datatype.
   Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 146 "/usr/include/locale.h" 2 3 4

/* Return a reference to a data structure representing a set of locale
   datasets.  Unlike for the CATEGORY parameter for `setlocale' the
   CATEGORY_MASK parameter here uses a single bit for each category,
   made by OR'ing together LC_*_MASK bits above.  */
extern __locale_t newlocale (int __category_mask, const char *__locale,
        __locale_t __base) __attribute__ ((__nothrow__ , __leaf__));

/* These are the bits that can be set in the CATEGORY_MASK argument to
   `newlocale'.  In the GNU implementation, LC_FOO_MASK has the value
   of (1 << LC_FOO), but this is not a part of the interface that
   callers can assume will be true.  */
#define LC_CTYPE_MASK (1 << __LC_CTYPE)
#define LC_NUMERIC_MASK (1 << __LC_NUMERIC)
#define LC_TIME_MASK (1 << __LC_TIME)
#define LC_COLLATE_MASK (1 << __LC_COLLATE)
#define LC_MONETARY_MASK (1 << __LC_MONETARY)
#define LC_MESSAGES_MASK (1 << __LC_MESSAGES)
#define LC_PAPER_MASK (1 << __LC_PAPER)
#define LC_NAME_MASK (1 << __LC_NAME)
#define LC_ADDRESS_MASK (1 << __LC_ADDRESS)
#define LC_TELEPHONE_MASK (1 << __LC_TELEPHONE)
#define LC_MEASUREMENT_MASK (1 << __LC_MEASUREMENT)
#define LC_IDENTIFICATION_MASK (1 << __LC_IDENTIFICATION)
#define LC_ALL_MASK (LC_CTYPE_MASK | LC_NUMERIC_MASK | LC_TIME_MASK | LC_COLLATE_MASK | LC_MONETARY_MASK | LC_MESSAGES_MASK | LC_PAPER_MASK | LC_NAME_MASK | LC_ADDRESS_MASK | LC_TELEPHONE_MASK | LC_MEASUREMENT_MASK | LC_IDENTIFICATION_MASK )
# 184 "/usr/include/locale.h" 3 4
/* Return a duplicate of the set of locale in DATASET.  All usage
   counters are increased if necessary.  */
extern __locale_t duplocale (__locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));

/* Free the data associated with a locale dataset previously returned
   by a call to `setlocale_r'.  */
extern void freelocale (__locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));

/* Switch the current thread's locale to DATASET.
   If DATASET is null, instead just return the current setting.
   The special value LC_GLOBAL_LOCALE is the initial setting
   for all threads and can also be installed any time, meaning
   the thread uses the global settings controlled by `setlocale'.  */
extern __locale_t uselocale (__locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));

/* This value can be passed to `uselocale' and may be returned by it.
   Passing this value to any other function has undefined behavior.  */
#define LC_GLOBAL_LOCALE ((__locale_t) -1L)




# 82 "pifunk.c" 2
# 1 "/usr/include/errno.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.5 Errors	<errno.h>
 */
# 62 "/usr/include/errno.h" 3 4
/* The Hurd <bits/errno.h> defines `error_t' as an enumerated type so
   that printing `error_t' values in the debugger shows the names.  We
   might need this definition sometimes even if this file was included
   before.  */





#undef __need_error_t
# 83 "pifunk.c" 2
# 1 "/usr/include/ctype.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard 7.4: Character handling	<ctype.h>
 */
# 84 "pifunk.c" 2
# 1 "/usr/include/wchar.h" 1 3 4
/* Copyright (C) 1995-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *      ISO C99 Standard: 7.24
 *	Extended multibyte and wide character utilities	<wchar.h>
 */




#define _WCHAR_H 1
# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 28 "/usr/include/wchar.h" 2 3 4



/* Get FILE definition.  */
#define __need___FILE 

#define __need_FILE 

# 1 "/usr/include/stdio.h" 1 3 4
/* Define ISO C stdio on top of C++ iostreams.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.19 Input/output	<stdio.h>
 */
# 37 "/usr/include/wchar.h" 2 3 4
/* Get va_list definition.  */
#define __need___va_list 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stdarg.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */
# 40 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/include/arm-linux-gnueabihf/bits/wchar.h" 1 3 4
/* wchar_t type related definitions.
   Copyright (C) 2000-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 42 "/usr/include/wchar.h" 2 3 4

/* Get size_t, wchar_t, wint_t and NULL from <stddef.h>.  */
#define __need_size_t 
#define __need_wchar_t 
#define __need_NULL 


#undef __need_wint_t
#define __need_wint_t 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 160 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 347 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_wchar_t




#define _WINT_T 




typedef unsigned int wint_t;

#undef __need_wint_t


/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 52 "/usr/include/wchar.h" 2 3 4

/* We try to get wint_t from <stddef.h>, but not all GCC versions define it
   there.  So define it ourselves if it remains undefined.  */
# 63 "/usr/include/wchar.h" 3 4
/* Work around problems with the <stddef.h> file which doesn't put
   wint_t in the std namespace.  */
# 73 "/usr/include/wchar.h" 3 4
/* Tell the caller that we provide correct C++ prototypes.  */
# 96 "/usr/include/wchar.h" 3 4
#undef __need_mbstate_t


/* The rest of the file is only used if used if __need_mbstate_t is not
   defined.  */




/* Public type.  */
typedef __mbstate_t mbstate_t;

#define __mbstate_t_defined 1




# 122 "/usr/include/wchar.h" 3 4
#define WEOF (0xffffffffu)


/* For XPG4 compliance we have to define the stuff from <wctype.h> here
   as well.  */








/* This incomplete type is defined in <time.h> but needed here because
   of `wcsftime'.  */
struct tm;

/* XXX We have to clean this up at some point.  Since tm is in the std
   namespace but wcsftime is in __c99 the type wouldn't be found
   without inserting it in the global namespace.  */




/* Copy SRC to DEST.  */
extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Copy no more than N wide-characters of SRC to DEST.  */
extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Append SRC onto DEST.  */
extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
/* Append no more than N wide-characters of SRC onto DEST.  */
extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Compare S1 and S2.  */
extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
/* Compare N wide-characters of S1 and S2.  */
extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



/* Compare S1 and S2, ignoring case.  */
extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) __attribute__ ((__nothrow__ , __leaf__));

/* Compare no more than N chars of S1 and S2, ignoring case.  */
extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) __attribute__ ((__nothrow__ , __leaf__));

/* Similar to the two functions above but take the information from
   the provided locale and not the global locale.  */
# 1 "/usr/include/xlocale.h" 1 3 4
/* Definition of locale datatype.
   Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 184 "/usr/include/wchar.h" 2 3 4

extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



/* Compare S1 and S2, both interpreted as appropriate to the
   LC_COLLATE category of the current locale.  */
extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) __attribute__ ((__nothrow__ , __leaf__));
/* Transform S2 into array pointed to by S1 such that if wcscmp is
   applied to two transformed strings the result is the as applying
   `wcscoll' to the original strings.  */
extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) __attribute__ ((__nothrow__ , __leaf__));



/* Similar to the two functions above but take the information from
   the provided locale and not the global locale.  */

/* Compare S1 and S2, both interpreted as appropriate to the
   LC_COLLATE category of the given locale.  */
extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));

/* Transform S2 into array pointed to by S1 such that if wcscmp is
   applied to two transformed strings the result is the as applying
   `wcscoll' to the original strings.  */
extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));

/* Duplicate S, returning an identical malloc'd string.  */
extern wchar_t *wcsdup (const wchar_t *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__));



/* Find the first occurrence of WC in WCS.  */






extern wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));

/* Find the last occurrence of WC in WCS.  */






extern wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));




/* This function is similar to `wcschr'.  But it returns a pointer to
   the closing NUL wide character in case C is not found in S.  */
extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));



/* Return the length of the initial segmet of WCS which
   consists entirely of wide characters not in REJECT.  */
extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));
/* Return the length of the initial segmet of WCS which
   consists entirely of wide characters in  ACCEPT.  */
extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));
/* Find the first occurrence in WCS of any character in ACCEPT.  */







extern wchar_t *wcspbrk (const wchar_t *__wcs, const wchar_t *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));

/* Find the first occurrence of NEEDLE in HAYSTACK.  */







extern wchar_t *wcsstr (const wchar_t *__haystack, const wchar_t *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));


/* Divide WCS into tokens separated by characters in DELIM.  */
extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) __attribute__ ((__nothrow__ , __leaf__));

/* Return the number of wide characters in S.  */
extern size_t wcslen (const wchar_t *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));



/* Another name for `wcsstr' from XPG4.  */







extern wchar_t *wcswcs (const wchar_t *__haystack, const wchar_t *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));




/* Return the number of wide characters in S, but at most MAXLEN.  */
extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));




/* Search N wide characters of S for C.  */







extern wchar_t *wmemchr (const wchar_t *__s, wchar_t __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));


/* Compare N wide characters of S1 and S2.  */
extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));

/* Copy N wide characters of SRC to DEST.  */
extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

/* Copy N wide characters of SRC to DEST, guaranteeing
   correct behavior for overlapping strings.  */
extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));

/* Set N wide characters of S to C.  */
extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__));



/* Copy N wide characters of SRC to DEST and return pointer to following
   wide character.  */
extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));




/* Determine whether C constitutes a valid (one-byte) multibyte
   character.  */
extern wint_t btowc (int __c) __attribute__ ((__nothrow__ , __leaf__));

/* Determine whether C corresponds to a member of the extended
   character set whose multibyte representation is a single byte.  */
extern int wctob (wint_t __c) __attribute__ ((__nothrow__ , __leaf__));

/* Determine whether PS points to an object representing the initial
   state.  */
extern int mbsinit (const mbstate_t *__ps) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));

/* Write wide character representation of multibyte character pointed
   to by S to PWC.  */
extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) __attribute__ ((__nothrow__ , __leaf__));

/* Write multibyte representation of wide character WC to S.  */
extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));

/* Return number of bytes in multibyte character pointed to by S.  */
extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));



/* Define inline function as optimization.  */

/* We can use the BTOWC and WCTOB optimizations since we know that all
   locales must use ASCII encoding for the values in the ASCII range
   and because the wchar_t encoding is always ISO 10646.  */
extern wint_t __btowc_alias (int __c) __asm ("btowc");
extern __inline __attribute__ ((__gnu_inline__)) wint_t
__attribute__ ((__nothrow__ , __leaf__)) btowc (int __c)
{ return (__builtin_constant_p (__c) && __c >= '\0' && __c <= '\x7f'
   ? (wint_t) __c : __btowc_alias (__c)); }

extern int __wctob_alias (wint_t __c) __asm ("wctob");
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) wctob (wint_t __wc)
{ return (__builtin_constant_p (__wc) && __wc >= L'\0' && __wc <= L'\x7f'
   ? (int) __wc : __wctob_alias (__wc)); }

extern __inline __attribute__ ((__gnu_inline__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) mbrlen (const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps)

{ return (__ps != ((void *)0)
   ? mbrtowc (((void *)0), __s, __n, __ps) : __mbrlen (__s, __n, ((void *)0))); }



/* Write wide character representation of multibyte character string
   SRC to DST.  */
extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));

/* Write multibyte character representation of wide character string
   SRC to DST.  */
extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));




/* Write wide character representation of at most NMC bytes of the
   multibyte character string SRC to DST.  */
extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));

/* Write multibyte character representation of at most NWC characters
   from the wide character string SRC to DST.  */
extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));



/* The following functions are extensions found in X/Open CAE.  */

/* Determine number of column positions required for C.  */
extern int wcwidth (wchar_t __c) __attribute__ ((__nothrow__ , __leaf__));

/* Determine number of column positions required for first N wide
   characters (or fewer if S ends before this) in S.  */
extern int wcswidth (const wchar_t *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));




/* Convert initial portion of the wide string NPTR to `double'
   representation.  */
extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));




/* Likewise for `float' and `long double' sizes of floating-point numbers.  */
extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));





/* Convert initial portion of wide string NPTR to `long int'
   representation.  */
extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));

/* Convert initial portion of wide string NPTR to `unsigned long int'
   representation.  */
extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));




/* Convert initial portion of wide string NPTR to `long long int'
   representation.  */
__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));

/* Convert initial portion of wide string NPTR to `unsigned long long int'
   representation.  */
__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) __attribute__ ((__nothrow__ , __leaf__));




/* Convert initial portion of wide string NPTR to `long long int'
   representation.  */
__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));

/* Convert initial portion of wide string NPTR to `unsigned long long int'
   representation.  */
__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) __attribute__ ((__nothrow__ , __leaf__));



/* The concept of one static locale per category is not very well
   thought out.  Many applications will need to process its data using
   information from several different locales.  Another application is
   the implementation of the internationalization handling in the
   upcoming ISO C++ standard library.  To support this another set of
   the functions using locale data exist which have an additional
   argument.

   Attention: all these functions are *not* standardized in any form.
   This is a proof-of-concept implementation.  */

/* Structure for reentrant locale using functions.  This is an
   (almost) opaque type for the user level programs.  */
# 1 "/usr/include/xlocale.h" 1 3 4
/* Definition of locale datatype.
   Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 530 "/usr/include/wchar.h" 2 3 4

/* Special versions of the functions above which take the locale to
   use as an additional parameter.  */
extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__));

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__));

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__));

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));




/* Copy SRC to DEST, returning the address of the terminating L'\0' in
   DEST.  */
extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) __attribute__ ((__nothrow__ , __leaf__));

/* Copy no more than N characters of SRC to DEST, returning the address of
   the last character written into DEST.  */
extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));


/* Wide character I/O functions.  */

/* Like OPEN_MEMSTREAM, but the stream is wide oriented and produces
   a wide character string.  */
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__));





/* Select orientation for stream.  */
extern int fwide (__FILE *__fp, int __mode) __attribute__ ((__nothrow__ , __leaf__));


/* Write formatted output to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
     /* __attribute__ ((__format__ (__wprintf__, 2, 3))) */;
/* Write formatted output to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int wprintf (const wchar_t *__restrict __format, ...)
     /* __attribute__ ((__format__ (__wprintf__, 1, 2))) */;
/* Write formatted output of at most N characters to S.  */
extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     __attribute__ ((__nothrow__ , __leaf__)) /* __attribute__ ((__format__ (__wprintf__, 3, 4))) */;

/* Write formatted output to S from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     /* __attribute__ ((__format__ (__wprintf__, 2, 0))) */;
/* Write formatted output to stdout from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     /* __attribute__ ((__format__ (__wprintf__, 1, 0))) */;
/* Write formatted output of at most N character to S from argument
   list ARG.  */
extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) /* __attribute__ ((__format__ (__wprintf__, 3, 0))) */;


/* Read formatted input from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
     /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;
/* Read formatted input from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int wscanf (const wchar_t *__restrict __format, ...)
     /* __attribute__ ((__format__ (__wscanf__, 1, 2))) */;
/* Read formatted input from S.  */
extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     __attribute__ ((__nothrow__ , __leaf__)) /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;
# 683 "/usr/include/wchar.h" 3 4





/* Read formatted input from S into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;
/* Read formatted input from stdin into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
     /* __attribute__ ((__format__ (__wscanf__, 1, 0))) */;
/* Read formatted input from S into argument list ARG.  */
extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;
# 739 "/usr/include/wchar.h" 3 4





/* Read a character from STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);

/* Read a character from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern wint_t getwchar (void);


/* Write a character to STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);

/* Write a character to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern wint_t putwchar (wchar_t __wc);


/* Get a newline-terminated wide character string of finite length
   from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);

/* Write a string to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);


/* Push a character back onto the input buffer of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern wint_t ungetwc (wint_t __wc, __FILE *__stream);




/* These are defined to be equivalent to the `char' functions defined
   in POSIX.1:1996.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);

/* This is the wide character version of a GNU extension.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern wint_t fgetwc_unlocked (__FILE *__stream);

/* Faster version when locking is not necessary.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);

/* These are defined to be equivalent to the `char' functions defined
   in POSIX.1:1996.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);


/* This function does the same as `fgetws' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);

/* This function does the same as `fputws' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);




/* Format TP into S according to FORMAT.
   Write no more than MAXSIZE wide characters and return the number
   of wide characters written, or 0 if it would exceed MAXSIZE.  */
extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/xlocale.h" 1 3 4
/* Definition of locale datatype.
   Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 865 "/usr/include/wchar.h" 2 3 4

/* Similar to `wcsftime' but takes the information from
   the provided locale and not the global locale.  */
extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));


/* The X/Open standard demands that most of the functions defined in
   the <wctype.h> header must also appear here.  This is probably
   because some X/Open members wrote their implementation before the
   ISO C standard was published and introduced the better solution.
   We have to provide these definitions for compliance reasons but we
   do this nonsense only if really necessary.  */





/* Define some macros helping to catch buffer overflows.  */
# 894 "/usr/include/wchar.h" 3 4






/* Undefine all __need_* constants in case we are included to get those
   constants but the whole file was already read.  */
#undef __need_mbstate_t
#undef __need_wint_t
# 85 "pifunk.c" 2
# 1 "/usr/include/wctype.h" 1 3 4
/* Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.25
 *	Wide character classification and mapping utilities  <wctype.h>
 */



# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/wctype.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 27 "/usr/include/wctype.h" 2 3 4


#define _WCTYPE_H 1

/* Get wint_t from <wchar.h>.  */
#define __need_wint_t 
# 1 "/usr/include/wchar.h" 1 3 4
/* Copyright (C) 1995-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *      ISO C99 Standard: 7.24
 *	Extended multibyte and wide character utilities	<wchar.h>
 */
# 900 "/usr/include/wchar.h" 3 4
/* Undefine all __need_* constants in case we are included to get those
   constants but the whole file was already read.  */
#undef __need_mbstate_t
#undef __need_wint_t
# 34 "/usr/include/wctype.h" 2 3 4

/* Constant expression of type `wint_t' whose value does not correspond
   to any member of the extended character set.  */




#undef __need_iswxxx


/* The following part is also used in the <wcsmbs.h> header when compiled
   in the Unix98 compatibility mode.  */

#define __iswxxx_defined 1


/* Scalar type that can hold values which represent locale-specific
   character classifications.  */
typedef unsigned long int wctype_t;



/* The characteristics are stored always in network byte order (big
   endian).  We define the bit value interpretations here dependent on the
   machine's byte order.  */

# 1 "/usr/include/endian.h" 1 3 4
/* Copyright (C) 1992-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 61 "/usr/include/wctype.h" 2 3 4



#define _ISwbit(bit) ((bit) < 8 ? (int) ((1UL << (bit)) << 24) : ((bit) < 16 ? (int) ((1UL << (bit)) << 8) : ((bit) < 24 ? (int) ((1UL << (bit)) >> 8) : (int) ((1UL << (bit)) >> 24))))






enum
{
  __ISwupper = 0, /* UPPERCASE.  */
  __ISwlower = 1, /* lowercase.  */
  __ISwalpha = 2, /* Alphabetic.  */
  __ISwdigit = 3, /* Numeric.  */
  __ISwxdigit = 4, /* Hexadecimal numeric.  */
  __ISwspace = 5, /* Whitespace.  */
  __ISwprint = 6, /* Printing.  */
  __ISwgraph = 7, /* Graphical.  */
  __ISwblank = 8, /* Blank (usually SPC and TAB).  */
  __ISwcntrl = 9, /* Control character.  */
  __ISwpunct = 10, /* Punctuation.  */
  __ISwalnum = 11, /* Alphanumeric.  */

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))), /* UPPERCASE.  */
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))), /* lowercase.  */
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))), /* Alphabetic.  */
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))), /* Numeric.  */
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))), /* Hexadecimal numeric.  */
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))), /* Whitespace.  */
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))), /* Printing.  */
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))), /* Graphical.  */
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))), /* Blank (usually SPC and TAB).  */
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))), /* Control character.  */
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))), /* Punctuation.  */
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24)))) /* Alphanumeric.  */
};






/*
 * Wide-character classification functions: 7.15.2.1.
 */

/* Test for any wide character for which `iswalpha' or `iswdigit' is
   true.  */
extern int iswalnum (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));

/* Test for any wide character for which `iswupper' or 'iswlower' is
   true, or any wide character that is one of a locale-specific set of
   wide-characters for which none of `iswcntrl', `iswdigit',
   `iswpunct', or `iswspace' is true.  */
extern int iswalpha (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));

/* Test for any control wide character.  */
extern int iswcntrl (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));

/* Test for any wide character that corresponds to a decimal-digit
   character.  */
extern int iswdigit (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));

/* Test for any wide character for which `iswprint' is true and
   `iswspace' is false.  */
extern int iswgraph (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));

/* Test for any wide character that corresponds to a lowercase letter
   or is one of a locale-specific set of wide characters for which
   none of `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true.  */
extern int iswlower (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));

/* Test for any printing wide character.  */
extern int iswprint (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));

/* Test for any printing wide character that is one of a
   locale-specific et of wide characters for which neither `iswspace'
   nor `iswalnum' is true.  */
extern int iswpunct (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));

/* Test for any wide character that corresponds to a locale-specific
   set of wide characters for which none of `iswalnum', `iswgraph', or
   `iswpunct' is true.  */
extern int iswspace (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));

/* Test for any wide character that corresponds to an uppercase letter
   or is one of a locale-specific set of wide character for which none
   of `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true.  */
extern int iswupper (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));

/* Test for any wide character that corresponds to a hexadecimal-digit
   character equivalent to that performed be the functions described
   in the previous subclause.  */
extern int iswxdigit (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));

/* Test for any wide character that corresponds to a standard blank
   wide character or a locale-specific set of wide characters for
   which `iswalnum' is false.  */

extern int iswblank (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));


/*
 * Extensible wide-character classification functions: 7.15.2.2.
 */

/* Construct value that describes a class of wide characters identified
   by the string argument PROPERTY.  */
extern wctype_t wctype (const char *__property) __attribute__ ((__nothrow__ , __leaf__));

/* Determine whether the wide-character WC has the property described by
   DESC.  */
extern int iswctype (wint_t __wc, wctype_t __desc) __attribute__ ((__nothrow__ , __leaf__));



/*
 * Wide-character case-mapping functions: 7.15.3.1.
 */


/* Scalar type that can hold values which represent locale-specific
   character mappings.  */
typedef const __int32_t *wctrans_t;






/* Converts an uppercase letter to the corresponding lowercase letter.  */
extern wint_t towlower (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));

/* Converts an lowercase letter to the corresponding uppercase letter.  */
extern wint_t towupper (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));







/* The remaining definitions and declarations must not appear in the
   <wchar.h> header.  */


/*
 * Extensible wide-character mapping functions: 7.15.3.2.
 */




/* Construct value that describes a mapping between wide characters
   identified by the string argument PROPERTY.  */
extern wctrans_t wctrans (const char *__property) __attribute__ ((__nothrow__ , __leaf__));

/* Map the wide character WC using the mapping described by DESC.  */
extern wint_t towctrans (wint_t __wc, wctrans_t __desc) __attribute__ ((__nothrow__ , __leaf__));



/* Declare the interface to extended locale model.  */
# 1 "/usr/include/xlocale.h" 1 3 4
/* Definition of locale datatype.
   Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 227 "/usr/include/wctype.h" 2 3 4

/* Test for any wide character for which `iswalpha' or `iswdigit' is
   true.  */
extern int iswalnum_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));

/* Test for any wide character for which `iswupper' or 'iswlower' is
   true, or any wide character that is one of a locale-specific set of
   wide-characters for which none of `iswcntrl', `iswdigit',
   `iswpunct', or `iswspace' is true.  */
extern int iswalpha_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));

/* Test for any control wide character.  */
extern int iswcntrl_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));

/* Test for any wide character that corresponds to a decimal-digit
   character.  */
extern int iswdigit_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));

/* Test for any wide character for which `iswprint' is true and
   `iswspace' is false.  */
extern int iswgraph_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));

/* Test for any wide character that corresponds to a lowercase letter
   or is one of a locale-specific set of wide characters for which
   none of `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true.  */
extern int iswlower_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));

/* Test for any printing wide character.  */
extern int iswprint_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));

/* Test for any printing wide character that is one of a
   locale-specific et of wide characters for which neither `iswspace'
   nor `iswalnum' is true.  */
extern int iswpunct_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));

/* Test for any wide character that corresponds to a locale-specific
   set of wide characters for which none of `iswalnum', `iswgraph', or
   `iswpunct' is true.  */
extern int iswspace_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));

/* Test for any wide character that corresponds to an uppercase letter
   or is one of a locale-specific set of wide character for which none
   of `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true.  */
extern int iswupper_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));

/* Test for any wide character that corresponds to a hexadecimal-digit
   character equivalent to that performed be the functions described
   in the previous subclause.  */
extern int iswxdigit_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));

/* Test for any wide character that corresponds to a standard blank
   wide character or a locale-specific set of wide characters for
   which `iswalnum' is false.  */
extern int iswblank_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));

/* Construct value that describes a class of wide characters identified
   by the string argument PROPERTY.  */
extern wctype_t wctype_l (const char *__property, __locale_t __locale)
     __attribute__ ((__nothrow__ , __leaf__));

/* Determine whether the wide-character WC has the property described by
   DESC.  */
extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
     __attribute__ ((__nothrow__ , __leaf__));


/*
 * Wide-character case-mapping functions.
 */

/* Converts an uppercase letter to the corresponding lowercase letter.  */
extern wint_t towlower_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));

/* Converts an lowercase letter to the corresponding uppercase letter.  */
extern wint_t towupper_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));

/* Construct value that describes a mapping between wide characters
   identified by the string argument PROPERTY.  */
extern wctrans_t wctrans_l (const char *__property, __locale_t __locale)
     __attribute__ ((__nothrow__ , __leaf__));

/* Map the wide character WC using the mapping described by DESC.  */
extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));




# 86 "pifunk.c" 2
# 1 "/usr/include/fcntl.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 6.5 File Control Operations	<fcntl.h>
 */


#define _FCNTL_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/fcntl.h" 2 3 4

/* This must be early so <bits/fcntl.h> can define types winningly.  */


/* Get __mode_t, __dev_t and __off_t  .*/
# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 32 "/usr/include/fcntl.h" 2 3 4

/* Get the definitions of O_*, F_*, FD_*: all the
   numbers and flag bits for `open', `fcntl', et al.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/fcntl.h" 1 3 4
/* O_*, F_*, FD_* bit values for Linux.
   Copyright (C) 1995-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */





#define __O_DIRECTORY 040000
#define __O_NOFOLLOW 0100000
#define __O_DIRECT 0200000
#define __O_LARGEFILE 0400000

struct flock
  {
    short int l_type; /* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
    short int l_whence; /* Where `l_start' is relative to (like `lseek').  */

    __off_t l_start; /* Offset where the lock begins.  */
    __off_t l_len; /* Size of the locked area; zero means until EOF.  */




    __pid_t l_pid; /* Process holding the lock.  */
  };


struct flock64
  {
    short int l_type; /* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
    short int l_whence; /* Where `l_start' is relative to (like `lseek').  */
    __off64_t l_start; /* Offset where the lock begins.  */
    __off64_t l_len; /* Size of the locked area; zero means until EOF.  */
    __pid_t l_pid; /* Process holding the lock.  */
  };


/* Include generic Linux declarations.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/fcntl-linux.h" 1 3 4
/* O_*, F_*, FD_* bit values for Linux.
   Copyright (C) 2001-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* This file contains shared definitions between Linux architectures
   and is included by <bits/fcntl.h> to declare them.  The various
   #ifndef cases allow the architecture specific file to define those
   values with different values.

   A minimal <bits/fcntl.h> contains just:

   struct flock {...}
   #ifdef __USE_LARGEFILE64
   struct flock64 {...}
   #endif
   #include <bits/fcntl-linux.h>
*/


# 1 "/usr/include/arm-linux-gnueabihf/bits/uio.h" 1 3 4
/* Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






#define _BITS_UIO_H 1

# 1 "/usr/include/arm-linux-gnueabihf/sys/types.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */
# 26 "/usr/include/arm-linux-gnueabihf/bits/uio.h" 2 3 4


/* We should normally use the Linux kernel header file to define this
   type and macros but this calls for trouble because of the header
   includes other kernel headers.  */

/* Size of object which can be written atomically.

   This macro has different values in different kernel versions.  The
   latest versions of the kernel use 1024 and this is good choice.  Since
   the C library implementation of readv/writev is able to emulate the
   functionality even if the currently running kernel does not support
   this large value the readv/writev call will not fail because of this.  */
#define UIO_MAXIOV 1024


/* Structure for scatter/gather I/O.  */
struct iovec
  {
    void *iov_base; /* Pointer to data.  */
    size_t iov_len; /* Length of data.  */
  };
# 39 "/usr/include/arm-linux-gnueabihf/bits/fcntl-linux.h" 2 3 4


/* open/fcntl.  */
#define O_ACCMODE 0003
#define O_RDONLY 00
#define O_WRONLY 01
#define O_RDWR 02

#define O_CREAT 0100


#define O_EXCL 0200


#define O_NOCTTY 0400


#define O_TRUNC 01000


#define O_APPEND 02000


#define O_NONBLOCK 04000


#define O_NDELAY O_NONBLOCK


#define O_SYNC 04010000

#define O_FSYNC O_SYNC

#define O_ASYNC 020000
# 85 "/usr/include/arm-linux-gnueabihf/bits/fcntl-linux.h" 3 4
#define __O_CLOEXEC 02000000





#define __O_NOATIME 01000000


#define __O_PATH 010000000


#define __O_DSYNC 010000


#define __O_TMPFILE (020000000 | __O_DIRECTORY)




#define F_GETLK 5
#define F_SETLK 6
#define F_SETLKW 7







#define F_GETLK64 12
#define F_SETLK64 13
#define F_SETLKW64 14


/* open file description locks.

   Usually record locks held by a process are released on *any* close and are
   not inherited across a fork.

   These cmd values will set locks that conflict with process-associated record
   locks, but are "owned" by the opened file description, not the process.
   This means that they are inherited across fork or clone with CLONE_FILES
   like BSD (flock) locks, and they are only released automatically when the
   last reference to the the file description against which they were acquired
   is put. */

#define F_OFD_GETLK 36
#define F_OFD_SETLK 37
#define F_OFD_SETLKW 38



#define O_LARGEFILE __O_LARGEFILE



#define O_DIRECTORY __O_DIRECTORY
#define O_NOFOLLOW __O_NOFOLLOW
#define O_CLOEXEC __O_CLOEXEC



#define O_DIRECT __O_DIRECT
#define O_NOATIME __O_NOATIME
#define O_PATH __O_PATH
#define O_TMPFILE __O_TMPFILE


/* For now, Linux has no separate synchronicitiy options for read
   operations.  We define O_RSYNC therefore as the same as O_SYNC
   since this is a superset.  */

#define O_DSYNC __O_DSYNC



#define O_RSYNC O_SYNC



/* Values for the second argument to `fcntl'.  */
#define F_DUPFD 0
#define F_GETFD 1
#define F_SETFD 2
#define F_GETFL 3
#define F_SETFL 4


#define __F_SETOWN 8
#define __F_GETOWN 9



#define F_SETOWN __F_SETOWN
#define F_GETOWN __F_GETOWN



#define __F_SETSIG 10
#define __F_GETSIG 11


#define __F_SETOWN_EX 15
#define __F_GETOWN_EX 16



#define F_SETSIG __F_SETSIG
#define F_GETSIG __F_GETSIG
#define F_SETOWN_EX __F_SETOWN_EX
#define F_GETOWN_EX __F_GETOWN_EX



#define F_SETLEASE 1024
#define F_GETLEASE 1025
#define F_NOTIFY 1026
#define F_SETPIPE_SZ 1031
#define F_GETPIPE_SZ 1032


#define F_DUPFD_CLOEXEC 1030



/* For F_[GET|SET]FD.  */
#define FD_CLOEXEC 1


/* For posix fcntl() and `l_type' field of a `struct flock' for lockf().  */
#define F_RDLCK 0
#define F_WRLCK 1
#define F_UNLCK 2



/* For old implementation of BSD flock.  */

#define F_EXLCK 4
#define F_SHLCK 8



/* Operations for BSD flock, also used by the kernel implementation.  */
#define LOCK_SH 1
#define LOCK_EX 2
#define LOCK_NB 4

#define LOCK_UN 8



#define LOCK_MAND 32
#define LOCK_READ 64
#define LOCK_WRITE 128
#define LOCK_RW 192



/* Types of directory notifications that may be requested with F_NOTIFY.  */
#define DN_ACCESS 0x00000001
#define DN_MODIFY 0x00000002
#define DN_CREATE 0x00000004
#define DN_DELETE 0x00000008
#define DN_RENAME 0x00000010
#define DN_ATTRIB 0x00000020
#define DN_MULTISHOT 0x80000000




/* Owner types.  */
enum __pid_type
  {
    F_OWNER_TID = 0, /* Kernel thread.  */
    F_OWNER_PID, /* Process.  */
    F_OWNER_PGRP, /* Process group.  */
    F_OWNER_GID = F_OWNER_PGRP /* Alternative, obsolete name.  */
  };

/* Structure to use with F_GETOWN_EX and F_SETOWN_EX.  */
struct f_owner_ex
  {
    enum __pid_type type; /* Owner type of ID.  */
    __pid_t pid; /* ID of owner.  */
  };


/* Define some more compatibility macros to be backward compatible with
   BSD systems which did not managed to hide these kernel macros.  */

#define FAPPEND O_APPEND
#define FFSYNC O_FSYNC
#define FASYNC O_ASYNC
#define FNONBLOCK O_NONBLOCK
#define FNDELAY O_NDELAY



#define __POSIX_FADV_DONTNEED 4
#define __POSIX_FADV_NOREUSE 5

/* Advise to `posix_fadvise'.  */

#define POSIX_FADV_NORMAL 0
#define POSIX_FADV_RANDOM 1
#define POSIX_FADV_SEQUENTIAL 2
#define POSIX_FADV_WILLNEED 3
#define POSIX_FADV_DONTNEED __POSIX_FADV_DONTNEED
#define POSIX_FADV_NOREUSE __POSIX_FADV_NOREUSE




/* Flags for SYNC_FILE_RANGE.  */
#define SYNC_FILE_RANGE_WAIT_BEFORE 1


#define SYNC_FILE_RANGE_WRITE 2


#define SYNC_FILE_RANGE_WAIT_AFTER 4



/* Flags for SPLICE and VMSPLICE.  */
#define SPLICE_F_MOVE 1
#define SPLICE_F_NONBLOCK 2


#define SPLICE_F_MORE 4
#define SPLICE_F_GIFT 8


/* Flags for fallocate.  */
#define FALLOC_FL_KEEP_SIZE 1


#define FALLOC_FL_PUNCH_HOLE 2
#define FALLOC_FL_COLLAPSE_RANGE 8


#define FALLOC_FL_ZERO_RANGE 16



/* File handle structure.  */
struct file_handle
{
  unsigned int handle_bytes;
  int handle_type;
  /* File identifier.  */
  unsigned char f_handle[0];
};

/* Maximum handle size (for now).  */
#define MAX_HANDLE_SZ 128


/* Values for `*at' functions.  */

#define AT_FDCWD -100


#define AT_SYMLINK_NOFOLLOW 0x100
#define AT_REMOVEDIR 0x200

#define AT_SYMLINK_FOLLOW 0x400

#define AT_NO_AUTOMOUNT 0x800

#define AT_EMPTY_PATH 0x1000

#define AT_EACCESS 0x200







/* Provide kernel hint to read ahead.  */
extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    __attribute__ ((__nothrow__ , __leaf__));


/* Selective file content synch'ing.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
       unsigned int __flags);


/* Splice address range into a pipe.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern ssize_t vmsplice (int __fdout, const struct iovec *__iov,
    size_t __count, unsigned int __flags);

/* Splice two files together.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
         __off64_t *__offout, size_t __len,
         unsigned int __flags);

/* In-kernel implementation of tee for pipe buffers.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern ssize_t tee (int __fdin, int __fdout, size_t __len,
      unsigned int __flags);

/* Reserve storage for the data of the file associated with FD.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern int fallocate (int __fd, int __mode, __off_t __offset, __off_t __len);
# 418 "/usr/include/arm-linux-gnueabihf/bits/fcntl-linux.h" 3 4
extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);



/* Map file name to file handle.  */
extern int name_to_handle_at (int __dfd, const char *__name,
         struct file_handle *__handle, int *__mnt_id,
         int __flags) __attribute__ ((__nothrow__ , __leaf__));

/* Open file using the file handle.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int open_by_handle_at (int __mountdirfd, struct file_handle *__handle,
         int __flags);




# 54 "/usr/include/arm-linux-gnueabihf/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4

/* Detect if open needs mode as a third argument (or for openat as a fourth
   argument).  */

#define __OPEN_NEEDS_MODE(oflag) (((oflag) & O_CREAT) != 0 || ((oflag) & __O_TMPFILE) == __O_TMPFILE)





/* POSIX.1-2001 specifies that these types are defined by <fcntl.h>.
   Earlier POSIX standards permitted any type ending in `_t' to be defined
   by any POSIX header, so we don't conditionalize the definitions here.  */
# 73 "/usr/include/fcntl.h" 3 4
/* For XPG all symbols from <sys/stat.h> should also be available.  */

#define __need_timespec 
# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 77 "/usr/include/fcntl.h" 2 3 4


# 1 "/usr/include/arm-linux-gnueabihf/bits/stat.h" 1 3 4
/* Copyright (C) 1992-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






#define _BITS_STAT_H 1

/* Versions of the `struct stat' data structure.  */
#define _STAT_VER_LINUX_OLD 1
#define _STAT_VER_KERNEL 1
#define _STAT_VER_SVR4 2
#define _STAT_VER_LINUX 3
#define _STAT_VER _STAT_VER_LINUX

/* Versions of the `xmknod' interface.  */
#define _MKNOD_VER_LINUX 1
#define _MKNOD_VER_SVR4 2
#define _MKNOD_VER _MKNOD_VER_LINUX


struct stat
  {
    __dev_t st_dev; /* Device.  */
    unsigned short int __pad1;

    __ino_t st_ino; /* File serial number.	*/



    __mode_t st_mode; /* File mode.  */
    __nlink_t st_nlink; /* Link count.  */
    __uid_t st_uid; /* User ID of the file's owner.	*/
    __gid_t st_gid; /* Group ID of the file's group.*/
    __dev_t st_rdev; /* Device number, if device.  */
    unsigned short int __pad2;

    __off_t st_size; /* Size of file, in bytes.  */



    __blksize_t st_blksize; /* Optimal block size for I/O.  */


    __blkcnt_t st_blocks; /* Number 512-byte blocks allocated. */




    /* Nanosecond resolution timestamps are stored in a format
       equivalent to 'struct timespec'.  This is the type used
       whenever possible but the Unix namespace rules do not allow the
       identifier 'timespec' to appear in the <sys/stat.h> header.
       Therefore we have to handle the use of this header in strictly
       standard-compliant sources special.  */
    struct timespec st_atim; /* Time of last access.  */
    struct timespec st_mtim; /* Time of last modification.  */
    struct timespec st_ctim; /* Time of last status change.  */
#define st_atime st_atim.tv_sec
#define st_mtime st_mtim.tv_sec
#define st_ctime st_ctim.tv_sec
# 87 "/usr/include/arm-linux-gnueabihf/bits/stat.h" 3 4
    unsigned long int __glibc_reserved4;
    unsigned long int __glibc_reserved5;



  };


struct stat64
  {
    __dev_t st_dev; /* Device.  */
    unsigned int __pad1;

    __ino_t __st_ino; /* 32bit file serial number.	*/
    __mode_t st_mode; /* File mode.  */
    __nlink_t st_nlink; /* Link count.  */
    __uid_t st_uid; /* User ID of the file's owner.	*/
    __gid_t st_gid; /* Group ID of the file's group.*/
    __dev_t st_rdev; /* Device number, if device.  */
    unsigned int __pad2;
    __off64_t st_size; /* Size of file, in bytes.  */
    __blksize_t st_blksize; /* Optimal block size for I/O.  */

    __blkcnt64_t st_blocks; /* Number 512-byte blocks allocated. */

    /* Nanosecond resolution timestamps are stored in a format
       equivalent to 'struct timespec'.  This is the type used
       whenever possible but the Unix namespace rules do not allow the
       identifier 'timespec' to appear in the <sys/stat.h> header.
       Therefore we have to handle the use of this header in strictly
       standard-compliant sources special.  */
    struct timespec st_atim; /* Time of last access.  */
    struct timespec st_mtim; /* Time of last modification.  */
    struct timespec st_ctim; /* Time of last status change.  */
# 129 "/usr/include/arm-linux-gnueabihf/bits/stat.h" 3 4
    __ino64_t st_ino; /* File serial number.		*/
  };


/* Tell code we have these members.  */
#define _STATBUF_ST_BLKSIZE 
#define _STATBUF_ST_RDEV 
/* Nanosecond resolution time values are supported.  */
#define _STATBUF_ST_NSEC 

/* Encoding of the file mode.  */

#define __S_IFMT 0170000

/* File types.  */
#define __S_IFDIR 0040000
#define __S_IFCHR 0020000
#define __S_IFBLK 0060000
#define __S_IFREG 0100000
#define __S_IFIFO 0010000
#define __S_IFLNK 0120000
#define __S_IFSOCK 0140000

/* POSIX.1b objects.  Note that these macros always evaluate to zero.  But
   they do it by enforcing the correct use of the macros.  */
#define __S_TYPEISMQ(buf) ((buf)->st_mode - (buf)->st_mode)
#define __S_TYPEISSEM(buf) ((buf)->st_mode - (buf)->st_mode)
#define __S_TYPEISSHM(buf) ((buf)->st_mode - (buf)->st_mode)

/* Protection bits.  */

#define __S_ISUID 04000
#define __S_ISGID 02000
#define __S_ISVTX 01000
#define __S_IREAD 0400
#define __S_IWRITE 0200
#define __S_IEXEC 0100


#define UTIME_NOW ((1l << 30) - 1l)
#define UTIME_OMIT ((1l << 30) - 2l)
# 80 "/usr/include/fcntl.h" 2 3 4

#define S_IFMT __S_IFMT
#define S_IFDIR __S_IFDIR
#define S_IFCHR __S_IFCHR
#define S_IFBLK __S_IFBLK
#define S_IFREG __S_IFREG

#define S_IFIFO __S_IFIFO


#define S_IFLNK __S_IFLNK


#define S_IFSOCK __S_IFSOCK


/* Protection bits.  */

#define S_ISUID __S_ISUID
#define S_ISGID __S_ISGID


/* Save swapped text after use (sticky bit).  This is pretty well obsolete.  */
#define S_ISVTX __S_ISVTX


#define S_IRUSR __S_IREAD
#define S_IWUSR __S_IWRITE
#define S_IXUSR __S_IEXEC
/* Read, write, and execute by owner.  */
#define S_IRWXU (__S_IREAD|__S_IWRITE|__S_IEXEC)

#define S_IRGRP (S_IRUSR >> 3)
#define S_IWGRP (S_IWUSR >> 3)
#define S_IXGRP (S_IXUSR >> 3)
/* Read, write, and execute by group.  */
#define S_IRWXG (S_IRWXU >> 3)

#define S_IROTH (S_IRGRP >> 3)
#define S_IWOTH (S_IWGRP >> 3)
#define S_IXOTH (S_IXGRP >> 3)
/* Read, write, and execute by others.  */
#define S_IRWXO (S_IRWXG >> 3)
# 136 "/usr/include/fcntl.h" 3 4
/* XPG wants the following symbols.   <stdio.h> has the same definitions.  */

#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2


/* Do the file control operation described by CMD on FD.
   The remaining arguments are interpreted depending on CMD.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int fcntl (int __fd, int __cmd, ...);

/* Open FILE and return a new file descriptor for it, or -1 on error.
   OFLAG determines the type of access used.  If O_CREAT or O_TMPFILE is set
   in OFLAG, the third argument is taken as a `mode_t', the mode of the
   created file.

   This function is a cancellation point and therefore not marked with
   __THROW.  */

extern int open (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 168 "/usr/include/fcntl.h" 3 4
extern int open64 (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));



/* Similar to `open' but a relative path name is interpreted relative to
   the directory for which FD is a descriptor.

   NOTE: some other `openat' implementation support additional functionality
   through this interface, especially using the O_XATTR flag.  This is not
   yet supported here.

   This function is a cancellation point and therefore not marked with
   __THROW.  */

extern int openat (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 193 "/usr/include/fcntl.h" 3 4
extern int openat64 (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));



/* Create and open FILE, with mode MODE.  This takes an `int' MODE
   argument because that is what `mode_t' will be widened to.

   This function is a cancellation point and therefore not marked with
   __THROW.  */

extern int creat (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 214 "/usr/include/fcntl.h" 3 4
extern int creat64 (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 247 "/usr/include/fcntl.h" 3 4
/* Advice the system about the expected behaviour of the application with
   respect to the file associated with FD.  */

extern int posix_fadvise (int __fd, off_t __offset, off_t __len,
     int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 262 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise64 (int __fd, off64_t __offset, off64_t __len,
       int __advise) __attribute__ ((__nothrow__ , __leaf__));



/* Reserve storage for the data of the file associated with FD.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern int posix_fallocate (int __fd, off_t __offset, off_t __len);
# 283 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate64 (int __fd, off64_t __offset, off64_t __len);




/* Define some inlines helping to catch common problems.  */






# 87 "pifunk.c" 2
# 1 "/usr/include/malloc.h" 1 3 4
/* Prototypes and definition for malloc implementation.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _MALLOC_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 23 "/usr/include/malloc.h" 2 3 4
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
# 24 "/usr/include/malloc.h" 2 3 4
# 1 "/usr/include/stdio.h" 1 3 4
/* Define ISO C stdio on top of C++ iostreams.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.19 Input/output	<stdio.h>
 */
# 25 "/usr/include/malloc.h" 2 3 4





#define __MALLOC_HOOK_VOLATILE volatile
#define __MALLOC_DEPRECATED __attribute_deprecated__





/* Allocate SIZE bytes of memory.  */
extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;

/* Allocate NMEMB elements of SIZE bytes each, all initialized to 0.  */
extern void *calloc (size_t __nmemb, size_t __size)
__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;

/* Re-allocate the previously allocated block in __ptr, making the new
   block SIZE bytes long.  */
/* __attribute_malloc__ is not used, because if realloc returns
   the same pointer that was passed to it, aliasing needs to be allowed
   between objects pointed by the old and new pointers.  */
extern void *realloc (void *__ptr, size_t __size)
__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

/* Free a block allocated by `malloc', `realloc' or `calloc'.  */
extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));

/* Free a block allocated by `calloc'. */
extern void cfree (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));

/* Allocate SIZE bytes allocated to ALIGNMENT bytes.  */
extern void *memalign (size_t __alignment, size_t __size)
__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;

/* Allocate SIZE bytes on a page boundary.  */
extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;

/* Equivalent to valloc(minimum-page-that-holds(n)), that is, round up
   __size to nearest pagesize. */
extern void *pvalloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;

/* Underlying allocation function; successive calls should return
   contiguous pieces of memory.  */
extern void *(*__morecore) (ptrdiff_t __size);

/* Default value of `__morecore'.  */
extern void *__default_morecore (ptrdiff_t __size)
__attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__));

/* SVID2/XPG mallinfo structure */

struct mallinfo
{
  int arena; /* non-mmapped space allocated from system */
  int ordblks; /* number of free chunks */
  int smblks; /* number of fastbin blocks */
  int hblks; /* number of mmapped regions */
  int hblkhd; /* space in mmapped regions */
  int usmblks; /* always 0, preserved for backwards compatibility */
  int fsmblks; /* space available in freed fastbin blocks */
  int uordblks; /* total allocated space */
  int fordblks; /* total free space */
  int keepcost; /* top-most, releasable (via malloc_trim) space */
};

/* Returns a copy of the updated current mallinfo. */
extern struct mallinfo mallinfo (void) __attribute__ ((__nothrow__ , __leaf__));

/* SVID2/XPG mallopt options */

#define M_MXFAST 1


#define M_NLBLKS 2


#define M_GRAIN 3


#define M_KEEP 4


/* mallopt options that actually do something */
#define M_TRIM_THRESHOLD -1
#define M_TOP_PAD -2
#define M_MMAP_THRESHOLD -3
#define M_MMAP_MAX -4
#define M_CHECK_ACTION -5
#define M_PERTURB -6
#define M_ARENA_TEST -7
#define M_ARENA_MAX -8

/* General SVID/XPG interface to tunable parameters. */
extern int mallopt (int __param, int __val) __attribute__ ((__nothrow__ , __leaf__));

/* Release all but __pad bytes of freed top-most memory back to the
   system. Return 1 if successful, else 0. */
extern int malloc_trim (size_t __pad) __attribute__ ((__nothrow__ , __leaf__));

/* Report the number of usable allocated bytes associated with allocated
   chunk __ptr. */
extern size_t malloc_usable_size (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));

/* Prints brief summary statistics on stderr. */
extern void malloc_stats (void) __attribute__ ((__nothrow__ , __leaf__));

/* Output information about state of allocator to stream FP.  */
extern int malloc_info (int __options, FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));

/* Record the state of all malloc variables in an opaque data structure. */
extern void *malloc_get_state (void) __attribute__ ((__nothrow__ , __leaf__));

/* Restore the state of all malloc variables from data obtained with
   malloc_get_state(). */
extern int malloc_set_state (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));

/* Hooks for debugging and user-defined versions. */
extern void (*volatile __free_hook) (void *__ptr,
                                                   const void *)
__attribute__ ((__deprecated__));
extern void *(*volatile __malloc_hook)(size_t __size,
                                                     const void *)
__attribute__ ((__deprecated__));
extern void *(*volatile __realloc_hook)(void *__ptr,
                                                      size_t __size,
                                                      const void *)
__attribute__ ((__deprecated__));
extern void *(*volatile __memalign_hook)(size_t __alignment,
                                                       size_t __size,
                                                       const void *)
__attribute__ ((__deprecated__));
extern void (*volatile __after_morecore_hook) (void);

/* Activate a standard set of debugging hooks. */
extern void __malloc_check_init (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));



# 88 "pifunk.c" 2
# 1 "/usr/include/dirent.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 5.1.2 Directory Operations	<dirent.h>
 */


#define _DIRENT_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/dirent.h" 2 3 4



# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 30 "/usr/include/dirent.h" 2 3 4
# 46 "/usr/include/dirent.h" 3 4
/* This file defines `struct dirent'.

   It defines the macro `_DIRENT_HAVE_D_NAMLEN' iff there is a `d_namlen'
   member that gives the length of `d_name'.

   It defines the macro `_DIRENT_HAVE_D_RECLEN' iff there is a `d_reclen'
   member that gives the size of the entire directory entry.

   It defines the macro `_DIRENT_HAVE_D_OFF' iff there is a `d_off'
   member that gives the file offset of the next directory entry.

   It defines the macro `_DIRENT_HAVE_D_TYPE' iff there is a `d_type'
   member that gives the type of the file.
 */

# 1 "/usr/include/arm-linux-gnueabihf/bits/dirent.h" 1 3 4
/* Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





struct dirent
  {

    __ino_t d_ino;
    __off_t d_off;




    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256]; /* We must not include limits.h! */
  };


struct dirent64
  {
    __ino64_t d_ino;
    __off64_t d_off;
    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256]; /* We must not include limits.h! */
  };


#define d_fileno d_ino

#undef _DIRENT_HAVE_D_NAMLEN
#define _DIRENT_HAVE_D_RECLEN 
#define _DIRENT_HAVE_D_OFF 
#define _DIRENT_HAVE_D_TYPE 
# 62 "/usr/include/dirent.h" 2 3 4





/* These macros extract size information from a `struct dirent *'.
   They may evaluate their argument multiple times, so it must not
   have side effects.  Each of these may involve a relatively costly
   call to `strlen' on some systems, so these values should be cached.

   _D_EXACT_NAMLEN (DP)	returns the length of DP->d_name, not including
   its terminating null character.

   _D_ALLOC_NAMLEN (DP)	returns a size at least (_D_EXACT_NAMLEN (DP) + 1);
   that is, the allocation size needed to hold the DP->d_name string.
   Use this macro when you don't need the exact length, just an upper bound.
   This macro is less likely to require calling `strlen' than _D_EXACT_NAMLEN.
   */





#define _D_EXACT_NAMLEN(d) (strlen ((d)->d_name))

#define _D_ALLOC_NAMLEN(d) (((char *) (d) + (d)->d_reclen) - &(d)->d_name[0])
# 96 "/usr/include/dirent.h" 3 4
/* File types for `d_type'.  */
enum
  {
    DT_UNKNOWN = 0,
#define DT_UNKNOWN DT_UNKNOWN
    DT_FIFO = 1,
#define DT_FIFO DT_FIFO
    DT_CHR = 2,
#define DT_CHR DT_CHR
    DT_DIR = 4,
#define DT_DIR DT_DIR
    DT_BLK = 6,
#define DT_BLK DT_BLK
    DT_REG = 8,
#define DT_REG DT_REG
    DT_LNK = 10,
#define DT_LNK DT_LNK
    DT_SOCK = 12,
#define DT_SOCK DT_SOCK
    DT_WHT = 14
#define DT_WHT DT_WHT
  };

/* Convert between stat structure types and directory types.  */
#define IFTODT(mode) (((mode) & 0170000) >> 12)
#define DTTOIF(dirtype) ((dirtype) << 12)



/* This is the data type of directory stream objects.
   The actual structure is opaque to users.  */
typedef struct __dirstream DIR;

/* Open a directory stream on NAME.
   Return a DIR stream on the directory, or NULL if it could not be opened.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern DIR *opendir (const char *__name) __attribute__ ((__nonnull__ (1)));


/* Same as opendir, but open the stream on the file descriptor FD.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern DIR *fdopendir (int __fd);


/* Close the directory stream DIRP.
   Return 0 if successful, -1 if not.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int closedir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));

/* Read a directory entry from DIRP.  Return a pointer to a `struct
   dirent' describing the entry, or NULL for EOF or error.  The
   storage returned may be overwritten by a later readdir call on the
   same DIR stream.

   If the Large File Support API is selected we have to use the
   appropriate interface.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern struct dirent *readdir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
# 173 "/usr/include/dirent.h" 3 4
extern struct dirent64 *readdir64 (DIR *__dirp) __attribute__ ((__nonnull__ (1)));



/* Reentrant version of `readdir'.  Return in RESULT a pointer to the
   next entry.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern int readdir_r (DIR *__restrict __dirp,
        struct dirent *__restrict __entry,
        struct dirent **__restrict __result)
     __attribute__ ((__nonnull__ (1, 2, 3))) __attribute__ ((__deprecated__));
# 201 "/usr/include/dirent.h" 3 4
extern int readdir64_r (DIR *__restrict __dirp,
   struct dirent64 *__restrict __entry,
   struct dirent64 **__restrict __result)
  __attribute__ ((__nonnull__ (1, 2, 3))) __attribute__ ((__deprecated__));



/* Rewind DIRP to the beginning of the directory.  */
extern void rewinddir (DIR *__dirp) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 213 "/usr/include/dirent.h" 2 3 4

/* Seek to position POS on DIRP.  */
extern void seekdir (DIR *__dirp, long int __pos) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Return the current position of DIRP.  */
extern long int telldir (DIR *__dirp) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




/* Return the file descriptor used by DIRP.  */
extern int dirfd (DIR *__dirp) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







/* Get the definitions of the POSIX.1 limits.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/posix1_lim.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.9.2 Minimum Values	Added to <limits.h>
 *
 *	Never include this file directly; use <limits.h> instead.
 */
# 234 "/usr/include/dirent.h" 2 3 4

/* `MAXNAMLEN' is the BSD name for what POSIX calls `NAME_MAX'.  */

#define MAXNAMLEN NAME_MAX






#define __need_size_t 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 160 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 347 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_wchar_t
# 362 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 246 "/usr/include/dirent.h" 2 3 4

/* Scan the directory DIR, calling SELECTOR on each directory entry.
   Entries for which SELECT returns nonzero are individually malloc'd,
   sorted using qsort with CMP, and collected in a malloc'd array in
   *NAMELIST.  Returns the number of entries selected, or -1 on error.

   This function is a cancellation point and therefore not marked with
   __THROW.  */

extern int scandir (const char *__restrict __dir,
      struct dirent ***__restrict __namelist,
      int (*__selector) (const struct dirent *),
      int (*__cmp) (const struct dirent **,
      const struct dirent **))
     __attribute__ ((__nonnull__ (1, 2)));
# 276 "/usr/include/dirent.h" 3 4
/* This function is like `scandir' but it uses the 64bit dirent structure.
   Please note that the CMP function must now work with struct dirent64 **.  */
extern int scandir64 (const char *__restrict __dir,
        struct dirent64 ***__restrict __namelist,
        int (*__selector) (const struct dirent64 *),
        int (*__cmp) (const struct dirent64 **,
        const struct dirent64 **))
     __attribute__ ((__nonnull__ (1, 2)));



/* Similar to `scandir' but a relative DIR name is interpreted relative
   to the directory for which DFD is a descriptor.

   This function is a cancellation point and therefore not marked with
   __THROW.  */

extern int scandirat (int __dfd, const char *__restrict __dir,
        struct dirent ***__restrict __namelist,
        int (*__selector) (const struct dirent *),
        int (*__cmp) (const struct dirent **,
        const struct dirent **))
     __attribute__ ((__nonnull__ (2, 3)));
# 313 "/usr/include/dirent.h" 3 4
/* This function is like `scandir' but it uses the 64bit dirent structure.
   Please note that the CMP function must now work with struct dirent64 **.  */
extern int scandirat64 (int __dfd, const char *__restrict __dir,
   struct dirent64 ***__restrict __namelist,
   int (*__selector) (const struct dirent64 *),
   int (*__cmp) (const struct dirent64 **,
          const struct dirent64 **))
     __attribute__ ((__nonnull__ (2, 3)));


/* Function to compare two `struct dirent's alphabetically.  */

extern int alphasort (const struct dirent **__e1,
        const struct dirent **__e2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 340 "/usr/include/dirent.h" 3 4
extern int alphasort64 (const struct dirent64 **__e1,
   const struct dirent64 **__e2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





/* Read directory entries from FD into BUF, reading at most NBYTES.
   Reading starts at offset *BASEP, and *BASEP is updated with the new
   position after reading.  Returns the number of bytes read; zero when at
   end of directory; or -1 for errors.  */

extern __ssize_t getdirentries (int __fd, char *__restrict __buf,
    size_t __nbytes,
    __off_t *__restrict __basep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));
# 370 "/usr/include/dirent.h" 3 4
extern __ssize_t getdirentries64 (int __fd, char *__restrict __buf,
      size_t __nbytes,
      __off64_t *__restrict __basep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));




/* Function to compare two `struct dirent's by name & version.  */

extern int versionsort (const struct dirent **__e1,
   const struct dirent **__e2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 396 "/usr/include/dirent.h" 3 4
extern int versionsort64 (const struct dirent64 **__e1,
     const struct dirent64 **__e2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




# 89 "pifunk.c" 2
# 1 "/usr/include/signal.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.14 Signal handling <signal.h>
 */




#define _SIGNAL_H 


# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 29 "/usr/include/signal.h" 2 3 4



# 1 "/usr/include/arm-linux-gnueabihf/bits/sigset.h" 1 3 4
/* __sig_atomic_t, __sigset_t, and related definitions.  Linux version.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 35 "/usr/include/arm-linux-gnueabihf/bits/sigset.h" 3 4
/* We only want to define these functions if <signal.h> was actually
   included; otherwise we were included just to define the types.  Since we
   are namespace-clean, it wouldn't hurt to define extra macros.  But
   trouble can be caused by functions being defined (e.g., any global
   register vars declared later will cause compilation errors).  */


#define _SIGSET_H_fns 1


#define _EXTERN_INLINE __extern_inline


/* Return a mask that includes the bit for SIG only.  */
#define __sigmask(sig) (((unsigned long int) 1) << (((sig) - 1) % (8 * sizeof (unsigned long int))))


/* Return the word index for SIG.  */
#define __sigword(sig) (((sig) - 1) / (8 * sizeof (unsigned long int)))


#define __sigemptyset(set) (__extension__ ({ int __cnt = _SIGSET_NWORDS; sigset_t *__set = (set); while (--__cnt >= 0) __set->__val[__cnt] = 0; 0; }))




#define __sigfillset(set) (__extension__ ({ int __cnt = _SIGSET_NWORDS; sigset_t *__set = (set); while (--__cnt >= 0) __set->__val[__cnt] = ~0UL; 0; }))






/* The POSIX does not specify for handling the whole signal set in one
   command.  This is often wanted and so we define three more functions
   here.  */
#define __sigisemptyset(set) (__extension__ ({ int __cnt = _SIGSET_NWORDS; const sigset_t *__set = (set); int __ret = __set->__val[--__cnt]; while (!__ret && --__cnt >= 0) __ret = __set->__val[__cnt]; __ret == 0; }))






#define __sigandset(dest,left,right) (__extension__ ({ int __cnt = _SIGSET_NWORDS; sigset_t *__dest = (dest); const sigset_t *__left = (left); const sigset_t *__right = (right); while (--__cnt >= 0) __dest->__val[__cnt] = (__left->__val[__cnt] & __right->__val[__cnt]); 0; }))
# 87 "/usr/include/arm-linux-gnueabihf/bits/sigset.h" 3 4
#define __sigorset(dest,left,right) (__extension__ ({ int __cnt = _SIGSET_NWORDS; sigset_t *__dest = (dest); const sigset_t *__left = (left); const sigset_t *__right = (right); while (--__cnt >= 0) __dest->__val[__cnt] = (__left->__val[__cnt] | __right->__val[__cnt]); 0; }))
# 99 "/usr/include/arm-linux-gnueabihf/bits/sigset.h" 3 4
/* These functions needn't check for a bogus signal number -- error
   checking is done in the non __ versions.  */

extern int __sigismember (const __sigset_t *, int);
extern int __sigaddset (__sigset_t *, int);
extern int __sigdelset (__sigset_t *, int);


#define __SIGSETFN(NAME,BODY,CONST) _EXTERN_INLINE int NAME (CONST __sigset_t *__set, int __sig) { unsigned long int __mask = __sigmask (__sig); unsigned long int __word = __sigword (__sig); return BODY; }
# 116 "/usr/include/arm-linux-gnueabihf/bits/sigset.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int __sigismember (const __sigset_t *__set, int __sig) { unsigned long int __mask = (((unsigned long int) 1) << (((__sig) - 1) % (8 * sizeof (unsigned long int)))); unsigned long int __word = (((__sig) - 1) / (8 * sizeof (unsigned long int))); return (__set->__val[__word] & __mask) ? 1 : 0; }
extern __inline __attribute__ ((__gnu_inline__)) int __sigaddset ( __sigset_t *__set, int __sig) { unsigned long int __mask = (((unsigned long int) 1) << (((__sig) - 1) % (8 * sizeof (unsigned long int)))); unsigned long int __word = (((__sig) - 1) / (8 * sizeof (unsigned long int))); return ((__set->__val[__word] |= __mask), 0); }
extern __inline __attribute__ ((__gnu_inline__)) int __sigdelset ( __sigset_t *__set, int __sig) { unsigned long int __mask = (((unsigned long int) 1) << (((__sig) - 1) % (8 * sizeof (unsigned long int)))); unsigned long int __word = (((__sig) - 1) / (8 * sizeof (unsigned long int))); return ((__set->__val[__word] &= ~__mask), 0); }

#undef __SIGSETFN
# 33 "/usr/include/signal.h" 2 3 4

/* An integral type that can be modified atomically, without the
   possibility of a signal arriving in the middle of the operation.  */


#define __sig_atomic_t_defined 

typedef __sig_atomic_t sig_atomic_t;


#undef __need_sig_atomic_t







#undef __need_sigset_t




# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 57 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/signum.h" 1 3 4
/* Signal number definitions.  Linux version.
   Copyright (C) 1995-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */



/* Fake signal functions.  */
#define SIG_ERR ((__sighandler_t) -1)
#define SIG_DFL ((__sighandler_t) 0)
#define SIG_IGN ((__sighandler_t) 1)


#define SIG_HOLD ((__sighandler_t) 2)



/* Signals.  */
#define SIGHUP 1
#define SIGINT 2
#define SIGQUIT 3
#define SIGILL 4
#define SIGTRAP 5
#define SIGABRT 6
#define SIGIOT 6
#define SIGBUS 7
#define SIGFPE 8
#define SIGKILL 9
#define SIGUSR1 10
#define SIGSEGV 11
#define SIGUSR2 12
#define SIGPIPE 13
#define SIGALRM 14
#define SIGTERM 15
#define SIGSTKFLT 16
#define SIGCLD SIGCHLD
#define SIGCHLD 17
#define SIGCONT 18
#define SIGSTOP 19
#define SIGTSTP 20
#define SIGTTIN 21
#define SIGTTOU 22
#define SIGURG 23
#define SIGXCPU 24
#define SIGXFSZ 25
#define SIGVTALRM 26
#define SIGPROF 27
#define SIGWINCH 28
#define SIGPOLL SIGIO
#define SIGIO 29
#define SIGPWR 30
#define SIGSYS 31
#define SIGUNUSED 31

#define _NSIG 65


#define SIGRTMIN (__libc_current_sigrtmin ())
#define SIGRTMAX (__libc_current_sigrtmax ())

/* These are the hard limits of the kernel.  These values should not be
   used directly at user level.  */
#define __SIGRTMIN 32
#define __SIGRTMAX (_NSIG - 1)
# 58 "/usr/include/signal.h" 2 3 4
# 73 "/usr/include/signal.h" 3 4
/* We need `struct timespec' later on.  */
#define __need_timespec 
# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 76 "/usr/include/signal.h" 2 3 4



/* Get the `siginfo_t' type plus the needed symbols.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/siginfo.h" 1 3 4
/* siginfo_t, sigevent and constants.  Linux version.
   Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






# 1 "/usr/include/arm-linux-gnueabihf/bits/wordsize.h" 1 3 4
/* Copyright (C) 1999-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#define __WORDSIZE 32
# 25 "/usr/include/arm-linux-gnueabihf/bits/siginfo.h" 2 3 4




#define __have_sigval_t 1

/* Type for data associated with a signal.  */
typedef union sigval
  {
    int sival_int;
    void *sival_ptr;
  } sigval_t;




#define __have_siginfo_t 1

#define __SI_MAX_SIZE 128



#define __SI_PAD_SIZE ((__SI_MAX_SIZE / sizeof (int)) - 3)


typedef struct
  {
    int si_signo; /* Signal number.  */
    int si_errno; /* If non-zero, an errno value associated with
				   this signal, as defined in <errno.h>.  */
    int si_code; /* Signal code.  */

    union
      {
 int _pad[((128 / sizeof (int)) - 3)];

  /* kill().  */
 struct
   {
     __pid_t si_pid; /* Sending process ID.  */
     __uid_t si_uid; /* Real user ID of sending process.  */
   } _kill;

 /* POSIX.1b timers.  */
 struct
   {
     int si_tid; /* Timer ID.  */
     int si_overrun; /* Overrun count.  */
     sigval_t si_sigval; /* Signal value.  */
   } _timer;

 /* POSIX.1b signals.  */
 struct
   {
     __pid_t si_pid; /* Sending process ID.  */
     __uid_t si_uid; /* Real user ID of sending process.  */
     sigval_t si_sigval; /* Signal value.  */
   } _rt;

 /* SIGCHLD.  */
 struct
   {
     __pid_t si_pid; /* Which child.  */
     __uid_t si_uid; /* Real user ID of sending process.  */
     int si_status; /* Exit value or signal.  */
     __clock_t si_utime;
     __clock_t si_stime;
   } _sigchld;

 /* SIGILL, SIGFPE, SIGSEGV, SIGBUS.  */
 struct
   {
     void *si_addr; /* Faulting insn/memory ref.  */
     short int si_addr_lsb; /* Valid LSB of the reported address.  */
   } _sigfault;

 /* SIGPOLL.  */
 struct
   {
     long int si_band; /* Band event for SIGPOLL.  */
     int si_fd;
   } _sigpoll;

 /* SIGSYS.  */
 struct
   {
     void *_call_addr; /* Calling user insn.  */
     int _syscall; /* Triggering system call number.  */
     unsigned int _arch; /* AUDIT_ARCH_* of syscall.  */
   } _sigsys;
      } _sifields;
  } siginfo_t;


/* X/Open requires some more fields with fixed names.  */
#define si_pid _sifields._kill.si_pid
#define si_uid _sifields._kill.si_uid
#define si_timerid _sifields._timer.si_tid
#define si_overrun _sifields._timer.si_overrun
#define si_status _sifields._sigchld.si_status
#define si_utime _sifields._sigchld.si_utime
#define si_stime _sifields._sigchld.si_stime
#define si_value _sifields._rt.si_sigval
#define si_int _sifields._rt.si_sigval.sival_int
#define si_ptr _sifields._rt.si_sigval.sival_ptr
#define si_addr _sifields._sigfault.si_addr
#define si_addr_lsb _sifields._sigfault.si_addr_lsb
#define si_band _sifields._sigpoll.si_band
#define si_fd _sifields._sigpoll.si_fd
#define si_call_addr _sifields._sigsys._call_addr
#define si_syscall _sifields._sigsys._syscall
#define si_arch _sifields._sigsys._arch


/* Values for `si_code'.  Positive values are reserved for kernel-generated
   signals.  */
enum
{
  SI_ASYNCNL = -60, /* Sent by asynch name lookup completion.  */
#define SI_ASYNCNL SI_ASYNCNL
  SI_TKILL = -6, /* Sent by tkill.  */
#define SI_TKILL SI_TKILL
  SI_SIGIO, /* Sent by queued SIGIO. */
#define SI_SIGIO SI_SIGIO
  SI_ASYNCIO, /* Sent by AIO completion.  */
#define SI_ASYNCIO SI_ASYNCIO
  SI_MESGQ, /* Sent by real time mesq state change.  */
#define SI_MESGQ SI_MESGQ
  SI_TIMER, /* Sent by timer expiration.  */
#define SI_TIMER SI_TIMER
  SI_QUEUE, /* Sent by sigqueue.  */
#define SI_QUEUE SI_QUEUE
  SI_USER, /* Sent by kill, sigsend.  */
#define SI_USER SI_USER
  SI_KERNEL = 0x80 /* Send by kernel.  */
#define SI_KERNEL SI_KERNEL
};



/* `si_code' values for SIGILL signal.  */
enum
{
  ILL_ILLOPC = 1, /* Illegal opcode.  */
#define ILL_ILLOPC ILL_ILLOPC
  ILL_ILLOPN, /* Illegal operand.  */
#define ILL_ILLOPN ILL_ILLOPN
  ILL_ILLADR, /* Illegal addressing mode.  */
#define ILL_ILLADR ILL_ILLADR
  ILL_ILLTRP, /* Illegal trap. */
#define ILL_ILLTRP ILL_ILLTRP
  ILL_PRVOPC, /* Privileged opcode.  */
#define ILL_PRVOPC ILL_PRVOPC
  ILL_PRVREG, /* Privileged register.  */
#define ILL_PRVREG ILL_PRVREG
  ILL_COPROC, /* Coprocessor error.  */
#define ILL_COPROC ILL_COPROC
  ILL_BADSTK /* Internal stack error.  */
#define ILL_BADSTK ILL_BADSTK
};

/* `si_code' values for SIGFPE signal.  */
enum
{
  FPE_INTDIV = 1, /* Integer divide by zero.  */
#define FPE_INTDIV FPE_INTDIV
  FPE_INTOVF, /* Integer overflow.  */
#define FPE_INTOVF FPE_INTOVF
  FPE_FLTDIV, /* Floating point divide by zero.  */
#define FPE_FLTDIV FPE_FLTDIV
  FPE_FLTOVF, /* Floating point overflow.  */
#define FPE_FLTOVF FPE_FLTOVF
  FPE_FLTUND, /* Floating point underflow.  */
#define FPE_FLTUND FPE_FLTUND
  FPE_FLTRES, /* Floating point inexact result.  */
#define FPE_FLTRES FPE_FLTRES
  FPE_FLTINV, /* Floating point invalid operation.  */
#define FPE_FLTINV FPE_FLTINV
  FPE_FLTSUB /* Subscript out of range.  */
#define FPE_FLTSUB FPE_FLTSUB
};

/* `si_code' values for SIGSEGV signal.  */
enum
{
  SEGV_MAPERR = 1, /* Address not mapped to object.  */
#define SEGV_MAPERR SEGV_MAPERR
  SEGV_ACCERR /* Invalid permissions for mapped object.  */
#define SEGV_ACCERR SEGV_ACCERR
};

/* `si_code' values for SIGBUS signal.  */
enum
{
  BUS_ADRALN = 1, /* Invalid address alignment.  */
#define BUS_ADRALN BUS_ADRALN
  BUS_ADRERR, /* Non-existant physical address.  */
#define BUS_ADRERR BUS_ADRERR
  BUS_OBJERR, /* Object specific hardware error.  */
#define BUS_OBJERR BUS_OBJERR
  BUS_MCEERR_AR, /* Hardware memory error: action required.  */
#define BUS_MCEERR_AR BUS_MCEERR_AR
  BUS_MCEERR_AO /* Hardware memory error: action optional.  */
#define BUS_MCEERR_AO BUS_MCEERR_AO
};



/* `si_code' values for SIGTRAP signal.  */
enum
{
  TRAP_BRKPT = 1, /* Process breakpoint.  */
#define TRAP_BRKPT TRAP_BRKPT
  TRAP_TRACE /* Process trace trap.  */
#define TRAP_TRACE TRAP_TRACE
};



/* `si_code' values for SIGCHLD signal.  */
enum
{
  CLD_EXITED = 1, /* Child has exited.  */
#define CLD_EXITED CLD_EXITED
  CLD_KILLED, /* Child was killed.  */
#define CLD_KILLED CLD_KILLED
  CLD_DUMPED, /* Child terminated abnormally.  */
#define CLD_DUMPED CLD_DUMPED
  CLD_TRAPPED, /* Traced child has trapped.  */
#define CLD_TRAPPED CLD_TRAPPED
  CLD_STOPPED, /* Child has stopped.  */
#define CLD_STOPPED CLD_STOPPED
  CLD_CONTINUED /* Stopped child has continued.  */
#define CLD_CONTINUED CLD_CONTINUED
};

/* `si_code' values for SIGPOLL signal.  */
enum
{
  POLL_IN = 1, /* Data input available.  */
#define POLL_IN POLL_IN
  POLL_OUT, /* Output buffers available.  */
#define POLL_OUT POLL_OUT
  POLL_MSG, /* Input message available.   */
#define POLL_MSG POLL_MSG
  POLL_ERR, /* I/O error.  */
#define POLL_ERR POLL_ERR
  POLL_PRI, /* High priority input available.  */
#define POLL_PRI POLL_PRI
  POLL_HUP /* Device disconnected.  */
#define POLL_HUP POLL_HUP
};


#undef __need_siginfo_t





#define __have_sigevent_t 1

/* Structure to transport application-defined values with signals.  */
#define __SIGEV_MAX_SIZE 64



#define __SIGEV_PAD_SIZE ((__SIGEV_MAX_SIZE / sizeof (int)) - 3)


/* Forward declaration.  */





typedef struct sigevent
  {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 3)];

 /* When SIGEV_SIGNAL and SIGEV_THREAD_ID set, LWP ID of the
	   thread to receive the signal.  */
 __pid_t _tid;

 struct
   {
     void (*_function) (sigval_t); /* Function to start.  */
     pthread_attr_t *_attribute; /* Thread attributes.  */
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;

/* POSIX names to access some of the members.  */
#define sigev_notify_function _sigev_un._sigev_thread._function
#define sigev_notify_attributes _sigev_un._sigev_thread._attribute

/* `sigev_notify' values.  */
enum
{
  SIGEV_SIGNAL = 0, /* Notify via signal.  */
#define SIGEV_SIGNAL SIGEV_SIGNAL
  SIGEV_NONE, /* Other notification: meaningless.  */
#define SIGEV_NONE SIGEV_NONE
  SIGEV_THREAD, /* Deliver via thread creation.  */
#define SIGEV_THREAD SIGEV_THREAD

  SIGEV_THREAD_ID = 4 /* Send signal to specific thread.  */
#define SIGEV_THREAD_ID SIGEV_THREAD_ID
};
# 81 "/usr/include/signal.h" 2 3 4



/* Type of a signal handler.  */
typedef void (*__sighandler_t) (int);

/* The X/Open definition of `signal' specifies the SVID semantic.  Use
   the additional function `sysv_signal' when X/Open compatibility is
   requested.  */
extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));

extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));


/* Set the handler for the signal SIG to HANDLER, returning the old
   handler, or SIG_ERR on error.
   By default `signal' has the BSD semantic.  */


extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
# 114 "/usr/include/signal.h" 3 4



/* The X/Open definition of `signal' conflicts with the BSD version.
   So they defined another function `bsd_signal'.  */
extern __sighandler_t bsd_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));


/* Send signal SIG to process number PID.  If PID is zero,
   send SIG to all processes in the current process's process group.
   If PID is < -1, send SIG to all processes in process group - PID.  */

extern int kill (__pid_t __pid, int __sig) __attribute__ ((__nothrow__ , __leaf__));



/* Send SIG to all processes in process group PGRP.
   If PGRP is zero, send SIG to all processes in
   the current process's process group.  */
extern int killpg (__pid_t __pgrp, int __sig) __attribute__ ((__nothrow__ , __leaf__));



/* Raise signal SIG, i.e., send SIG to yourself.  */
extern int raise (int __sig) __attribute__ ((__nothrow__ , __leaf__));



/* SVID names for the same things.  */
extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
extern int gsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));



/* Print a message describing the meaning of the given signal number.  */
extern void psignal (int __sig, const char *__s);

/* Print a message describing the meaning of the given signal information.  */
extern void psiginfo (const siginfo_t *__pinfo, const char *__s);




/* The `sigpause' function in X/Open defines the argument as the
   signal number.  This requires redirecting to another function
   because the default version in glibc uses an old BSD interface.

   This function is a cancellation point and therefore not marked with
   __THROW.  */



extern int sigpause (int __sig) __asm__ ("__xpg_sigpause");
# 178 "/usr/include/signal.h" 3 4
/* None of the following functions should be used anymore.  They are here
   only for compatibility.  A single word (`int') is not guaranteed to be
   enough to hold a complete signal mask and therefore these functions
   simply do not work in many situations.  Use `sigprocmask' instead.  */

/* Compute mask for signal SIG.  */
#define sigmask(sig) __sigmask(sig)

/* Block signals in MASK, returning the old mask.  */
extern int sigblock (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));

/* Set the mask of blocked signals to MASK, returning the old mask.  */
extern int sigsetmask (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));

/* Return currently selected signal mask.  */
extern int siggetmask (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));




#define NSIG _NSIG



typedef __sighandler_t sighandler_t;


/* 4.4 BSD uses the name `sig_t' for this.  */

typedef __sighandler_t sig_t;




/* Clear all signals from SET.  */
extern int sigemptyset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Set all signals in SET.  */
extern int sigfillset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Add SIGNO to SET.  */
extern int sigaddset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Remove SIGNO from SET.  */
extern int sigdelset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Return 1 if SIGNO is in SET, 0 if not.  */
extern int sigismember (const sigset_t *__set, int __signo)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Return non-empty value is SET is not empty.  */
extern int sigisemptyset (const sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Build new signal set by combining the two inputs set using logical AND.  */
extern int sigandset (sigset_t *__set, const sigset_t *__left,
        const sigset_t *__right) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));

/* Build new signal set by combining the two inputs set using logical OR.  */
extern int sigorset (sigset_t *__set, const sigset_t *__left,
       const sigset_t *__right) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));


/* Get the system-specific definitions of `struct sigaction'
   and the `SA_*' and `SIG_*'. constants.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/sigaction.h" 1 3 4
/* The proper definitions for Linux's sigaction.
   Copyright (C) 1993-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* Structure describing the action to be taken when a signal arrives.  */
struct sigaction
  {
    /* Signal handler.  */

    union
      {
 /* Used if SA_SIGINFO is not set.  */
 __sighandler_t sa_handler;
 /* Used if SA_SIGINFO is set.  */
 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;
#define sa_handler __sigaction_handler.sa_handler
#define sa_sigaction __sigaction_handler.sa_sigaction




    /* Additional set of signals to be blocked.  */
    __sigset_t sa_mask;

    /* Special flags.  */
    int sa_flags;

    /* Restore handler.  */
    void (*sa_restorer) (void);
  };

/* Bits in `sa_flags'.  */
#define SA_NOCLDSTOP 1
#define SA_NOCLDWAIT 2
#define SA_SIGINFO 4


#define SA_ONSTACK 0x08000000


#define SA_RESTART 0x10000000
#define SA_NODEFER 0x40000000

#define SA_RESETHAND 0x80000000


#define SA_INTERRUPT 0x20000000

/* Some aliases for the SA_ constants.  */
#define SA_NOMASK SA_NODEFER
#define SA_ONESHOT SA_RESETHAND
#define SA_STACK SA_ONSTACK


/* Values for the HOW argument to `sigprocmask'.  */
#define SIG_BLOCK 0
#define SIG_UNBLOCK 1
#define SIG_SETMASK 2
# 244 "/usr/include/signal.h" 2 3 4

/* Get and/or change the set of blocked signals.  */
extern int sigprocmask (int __how, const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) __attribute__ ((__nothrow__ , __leaf__));

/* Change the set of blocked signals to SET,
   wait until a signal arrives, and restore the set of blocked signals.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int sigsuspend (const sigset_t *__set) __attribute__ ((__nonnull__ (1)));

/* Get and/or set the action for signal SIG.  */
extern int sigaction (int __sig, const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) __attribute__ ((__nothrow__ , __leaf__));

/* Put in SET all signals that are blocked and waiting to be delivered.  */
extern int sigpending (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Select any of pending signals from SET or wait for any to arrive.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int sigwait (const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));


/* Select any of pending signals from SET and place information in INFO.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int sigwaitinfo (const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));

/* Select any of pending signals from SET and place information in INFO.
   Wait the time specified by TIMEOUT if no signal is pending.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int sigtimedwait (const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));

/* Send signal SIG to the process PID.  Associate data in VAL with the
   signal.  */
extern int sigqueue (__pid_t __pid, int __sig, const union sigval __val)
     __attribute__ ((__nothrow__ , __leaf__));






/* Names of the signals.  This variable exists only for compatibility.
   Use `strsignal' instead (see <string.h>).  */
extern const char *const _sys_siglist[65];
extern const char *const sys_siglist[65];


/* Get machine-dependent `struct sigcontext' and signal subcodes.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/sigcontext.h" 1 3 4
/* Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






/* Kernel headers before 2.1.1 define a struct sigcontext_struct, but
   we need sigcontext.  */
#define sigcontext_struct sigcontext

# 1 "/usr/include/arm-linux-gnueabihf/asm/sigcontext.h" 1 3 4

#define _ASMARM_SIGCONTEXT_H 

/*
 * Signal context structure - contains all info to do with the state
 * before the signal handler was invoked.  Note: only add new entries
 * to the end of the structure.
 */
struct sigcontext {
 unsigned long trap_no;
 unsigned long error_code;
 unsigned long oldmask;
 unsigned long arm_r0;
 unsigned long arm_r1;
 unsigned long arm_r2;
 unsigned long arm_r3;
 unsigned long arm_r4;
 unsigned long arm_r5;
 unsigned long arm_r6;
 unsigned long arm_r7;
 unsigned long arm_r8;
 unsigned long arm_r9;
 unsigned long arm_r10;
 unsigned long arm_fp;
 unsigned long arm_ip;
 unsigned long arm_sp;
 unsigned long arm_lr;
 unsigned long arm_pc;
 unsigned long arm_cpsr;
 unsigned long fault_address;
};
# 28 "/usr/include/arm-linux-gnueabihf/bits/sigcontext.h" 2 3 4

/* The Linux kernel headers redefine NULL wrongly, so cleanup afterwards.  */
#define __need_NULL 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 160 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 347 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_wchar_t
# 362 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 32 "/usr/include/arm-linux-gnueabihf/bits/sigcontext.h" 2 3 4
# 307 "/usr/include/signal.h" 2 3 4

/* Restore the state saved in SCP.  */
extern int sigreturn (struct sigcontext *__scp) __attribute__ ((__nothrow__ , __leaf__));





#define __need_size_t 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 160 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 347 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_wchar_t
# 362 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 317 "/usr/include/signal.h" 2 3 4

/* If INTERRUPT is nonzero, make signal SIG interrupt system calls
   (causing them to fail with EINTR); if INTERRUPT is zero, make system
   calls be restarted after signal SIG.  */
extern int siginterrupt (int __sig, int __interrupt) __attribute__ ((__nothrow__ , __leaf__));

# 1 "/usr/include/arm-linux-gnueabihf/bits/sigstack.h" 1 3 4
/* sigstack, sigaltstack definitions.
   Copyright (C) 1998-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






/* Structure describing a signal stack (obsolete).  */
struct sigstack
  {
    void *ss_sp; /* Signal stack pointer.  */
    int ss_onstack; /* Nonzero if executing on this stack.  */
  };


/* Possible values for `ss_flags.'.  */
enum
{
  SS_ONSTACK = 1,
#define SS_ONSTACK SS_ONSTACK
  SS_DISABLE
#define SS_DISABLE SS_DISABLE
};

/* Minimum stack size for a signal handler.  */
#define MINSIGSTKSZ 2048

/* System default stack size.  */
#define SIGSTKSZ 8192


/* Alternate, preferred interface.  */
typedef struct sigaltstack
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 324 "/usr/include/signal.h" 2 3 4

/* This will define `ucontext_t' and `mcontext_t'.  */
# 1 "/usr/include/arm-linux-gnueabihf/sys/ucontext.h" 1 3 4
/* Copyright (C) 1998-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */

/* System V/ARM ABI compliant context switching support.  */


#define _SYS_UCONTEXT_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 24 "/usr/include/arm-linux-gnueabihf/sys/ucontext.h" 2 3 4
# 1 "/usr/include/signal.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.14 Signal handling <signal.h>
 */
# 25 "/usr/include/arm-linux-gnueabihf/sys/ucontext.h" 2 3 4

/* We need the signal context definitions even if they are not used
   included in <signal.h>.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/sigcontext.h" 1 3 4
/* Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 29 "/usr/include/arm-linux-gnueabihf/sys/ucontext.h" 2 3 4

typedef int greg_t;

/* Number of general registers.  */
#define NGREG 18

/* Container for all general registers.  */
typedef greg_t gregset_t[18];

/* Number of each register is the `gregset_t' array.  */
enum
{
  REG_R0 = 0,
#define REG_R0 REG_R0
  REG_R1 = 1,
#define REG_R1 REG_R1
  REG_R2 = 2,
#define REG_R2 REG_R2
  REG_R3 = 3,
#define REG_R3 REG_R3
  REG_R4 = 4,
#define REG_R4 REG_R4
  REG_R5 = 5,
#define REG_R5 REG_R5
  REG_R6 = 6,
#define REG_R6 REG_R6
  REG_R7 = 7,
#define REG_R7 REG_R7
  REG_R8 = 8,
#define REG_R8 REG_R8
  REG_R9 = 9,
#define REG_R9 REG_R9
  REG_R10 = 10,
#define REG_R10 REG_R10
  REG_R11 = 11,
#define REG_R11 REG_R11
  REG_R12 = 12,
#define REG_R12 REG_R12
  REG_R13 = 13,
#define REG_R13 REG_R13
  REG_R14 = 14,
#define REG_R14 REG_R14
  REG_R15 = 15
#define REG_R15 REG_R15
};

struct _libc_fpstate
{
  struct
  {
    unsigned int sign1:1;
    unsigned int unused:15;
    unsigned int sign2:1;
    unsigned int exponent:14;
    unsigned int j:1;
    unsigned int mantissa1:31;
    unsigned int mantissa0:32;
  } fpregs[8];
  unsigned int fpsr:32;
  unsigned int fpcr:32;
  unsigned char ftype[8];
  unsigned int init_flag;
};
/* Structure to describe FPU registers.  */
typedef struct _libc_fpstate fpregset_t;

/* Context to describe whole processor state.  This only describes
   the core registers; coprocessor registers get saved elsewhere
   (e.g. in uc_regspace, or somewhere unspecified on the stack
   during non-RT signal handlers).  */
typedef struct sigcontext mcontext_t;

/* Userlevel context.  */
typedef struct ucontext
  {
    unsigned long uc_flags;
    struct ucontext *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    __sigset_t uc_sigmask;
    unsigned long uc_regspace[128] __attribute__((__aligned__(8)));
  } ucontext_t;
# 327 "/usr/include/signal.h" 2 3 4


/* Run signals handlers on the stack specified by SS (if not NULL).
   If OSS is not NULL, it is filled in with the old signal stack status.
   This interface is obsolete and on many platform not implemented.  */
extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));

/* Alternate signal handler stack interface.
   This interface should always be preferred over `sigstack'.  */
extern int sigaltstack (const struct sigaltstack *__restrict __ss,
   struct sigaltstack *__restrict __oss) __attribute__ ((__nothrow__ , __leaf__));




/* Simplified interface for signal management.  */

/* Add SIG to the calling process' signal mask.  */
extern int sighold (int __sig) __attribute__ ((__nothrow__ , __leaf__));

/* Remove SIG from the calling process' signal mask.  */
extern int sigrelse (int __sig) __attribute__ ((__nothrow__ , __leaf__));

/* Set the disposition of SIG to SIG_IGN.  */
extern int sigignore (int __sig) __attribute__ ((__nothrow__ , __leaf__));

/* Set the disposition of SIG.  */
extern __sighandler_t sigset (int __sig, __sighandler_t __disp) __attribute__ ((__nothrow__ , __leaf__));



/* Some of the functions for handling signals in threaded programs must
   be defined here.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/pthreadtypes.h" 1 3 4
/* Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */
# 362 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/sigthread.h" 1 3 4
/* Signal handling function for threaded programs.
   Copyright (C) 1998-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If
   not, see <http://www.gnu.org/licenses/>.  */


#define _BITS_SIGTHREAD_H 1





/* Functions for handling signals. */

/* Modify the signal mask for the calling thread.  The arguments have
   the same meaning as for sigprocmask(2). */
extern int pthread_sigmask (int __how,
       const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)__attribute__ ((__nothrow__ , __leaf__));

/* Send signal SIGNO to the given thread. */
extern int pthread_kill (pthread_t __threadid, int __signo) __attribute__ ((__nothrow__ , __leaf__));


/* Queue signal and data to a thread.  */
extern int pthread_sigqueue (pthread_t __threadid, int __signo,
        const union sigval __value) __attribute__ ((__nothrow__ , __leaf__));
# 363 "/usr/include/signal.h" 2 3 4


/* The following functions are used internally in the C library and in
   other code which need deep insights.  */

/* Return number of available real-time signal with highest priority.  */
extern int __libc_current_sigrtmin (void) __attribute__ ((__nothrow__ , __leaf__));
/* Return number of available real-time signal with lowest priority.  */
extern int __libc_current_sigrtmax (void) __attribute__ ((__nothrow__ , __leaf__));




# 90 "pifunk.c" 2
# 1 "/usr/include/assert.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.2 Diagnostics	<assert.h>
 */
# 34 "/usr/include/assert.h" 3 4
#define _ASSERT_H 1
# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 36 "/usr/include/assert.h" 2 3 4




#define __ASSERT_VOID_CAST (void)


/* void assert (int expression);

   If NDEBUG is defined, do nothing.
   If not, and EXPRESSION is zero, print an error message and abort.  */
# 65 "/usr/include/assert.h" 3 4
#define _ASSERT_H_DECLS 


/* This prints an "Assertion failed" message and aborts.  */
extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));

/* Likewise, but prints the error text for ERRNUM.  */
extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));


/* The following is not at all used here but needed for standard
   compliance.  */
extern void __assert (const char *__assertion, const char *__file, int __line)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





#define assert(expr) ((expr) ? __ASSERT_VOID_CAST (0) : __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))





#define assert_perror(errnum) (!(errnum) ? __ASSERT_VOID_CAST (0) : __assert_perror_fail ((errnum), __FILE__, __LINE__, __ASSERT_FUNCTION))





/* Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
   which contains the name of the function currently being defined.
   This is broken in G++ before version 2.6.
   C9x has a similar variable called __func__, but prefer the GCC one since
   it demangles C++ function names.  */

#define __ASSERT_FUNCTION __PRETTY_FUNCTION__
# 119 "/usr/include/assert.h" 3 4
#undef static_assert
#define static_assert _Static_assert
# 91 "pifunk.c" 2
# 1 "/usr/include/setjmp.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.13 Nonlocal jumps	<setjmp.h>
 */


#define _SETJMP_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/setjmp.h" 2 3 4



# 1 "/usr/include/arm-linux-gnueabihf/bits/setjmp.h" 1 3 4
/* Copyright (C) 2004-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */

/* Define the machine-dependent type `jmp_buf'.  ARM EABI version.  */


#define _BITS_SETJMP_H 1






/* The exact set of registers saved may depend on the particular core
   in use, as some coprocessor registers may need to be saved.  The C
   Library ABI requires that the buffer be 8-byte aligned, and
   recommends that the buffer contain 64 words.  The first 26 words
   are occupied by sp, lr, v1-v6, sl, fp, and d8-d15.  */
typedef int __jmp_buf[64] __attribute__((__aligned__ (8)));
# 30 "/usr/include/setjmp.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/sigset.h" 1 3 4
/* __sig_atomic_t, __sigset_t, and related definitions.  Linux version.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 35 "/usr/include/arm-linux-gnueabihf/bits/sigset.h" 3 4
/* We only want to define these functions if <signal.h> was actually
   included; otherwise we were included just to define the types.  Since we
   are namespace-clean, it wouldn't hurt to define extra macros.  But
   trouble can be caused by functions being defined (e.g., any global
   register vars declared later will cause compilation errors).  */
# 31 "/usr/include/setjmp.h" 2 3 4


/* Calling environment, plus possibly a saved signal mask.  */
struct __jmp_buf_tag
  {
    /* NOTE: The machine-dependent definitions of `__sigsetjmp'
       assume that a `jmp_buf' begins with a `__jmp_buf' and that
       `__mask_was_saved' follows it.  Do not move these members
       or add others before it.  */
    __jmp_buf __jmpbuf; /* Calling environment.  */
    int __mask_was_saved; /* Saved the signal mask?  */
    __sigset_t __saved_mask; /* Saved signal mask.  */
  };




typedef struct __jmp_buf_tag jmp_buf[1];

/* Store the calling environment in ENV, also saving the signal mask.
   Return 0.  */
extern int setjmp (jmp_buf __env) __attribute__ ((__nothrow__));



/* Store the calling environment in ENV, also saving the
   signal mask if SAVEMASK is nonzero.  Return 0.
   This is the internal name for `sigsetjmp'.  */
extern int __sigsetjmp (struct __jmp_buf_tag __env[1], int __savemask) __attribute__ ((__nothrow__));

/* Store the calling environment in ENV, not saving the signal mask.
   Return 0.  */
extern int _setjmp (struct __jmp_buf_tag __env[1]) __attribute__ ((__nothrow__));

/* Do not save the signal mask.  This is equivalent to the `_setjmp'
   BSD function.  */
#define setjmp(env) _setjmp (env)




/* Jump to the environment saved in ENV, making the
   `setjmp' call there return VAL, or 1 if VAL is 0.  */
extern void longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));




/* Same.  Usually `_longjmp' is used with `_setjmp', which does not save
   the signal mask.  But it is how ENV was saved that determines whether
   `longjmp' restores the mask; `_longjmp' is just an alias.  */
extern void _longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));




/* Use the same type for `jmp_buf' and `sigjmp_buf'.
   The `__mask_was_saved' flag determines whether
   or not `longjmp' will restore the signal mask.  */
typedef struct __jmp_buf_tag sigjmp_buf[1];

/* Store the calling environment in ENV, also saving the
   signal mask if SAVEMASK is nonzero.  Return 0.  */
#define sigsetjmp(env,savemask) __sigsetjmp (env, savemask)

/* Jump to the environment saved in ENV, making the
   sigsetjmp call there return VAL, or 1 if VAL is 0.
   Restore the signal mask if that sigsetjmp call saved it.
   This is just an alias `longjmp'.  */
extern void siglongjmp (sigjmp_buf __env, int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));



/* Define helper functions to catch unsafe code.  */





# 92 "pifunk.c" 2
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include-fixed/limits.h" 1 3 4
/* Copyright (C) 1992-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */
# 93 "pifunk.c" 2
# 1 "/usr/include/termios.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 7.1-2 General Terminal Interface	<termios.h>
 */


#define _TERMIOS_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/termios.h" 2 3 4

/* We need `pid_t'.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 29 "/usr/include/termios.h" 2 3 4








/* Get the system-dependent definitions of `struct termios', `tcflag_t',
   `cc_t', `speed_t', and all the macros specifying the flag bits.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/termios.h" 1 3 4
/* termios type and macro definitions.  Linux version.
   Copyright (C) 1993-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;

#define NCCS 32
struct termios
  {
    tcflag_t c_iflag; /* input mode flags */
    tcflag_t c_oflag; /* output mode flags */
    tcflag_t c_cflag; /* control mode flags */
    tcflag_t c_lflag; /* local mode flags */
    cc_t c_line; /* line discipline */
    cc_t c_cc[32]; /* control characters */
    speed_t c_ispeed; /* input speed */
    speed_t c_ospeed; /* output speed */
#define _HAVE_STRUCT_TERMIOS_C_ISPEED 1
#define _HAVE_STRUCT_TERMIOS_C_OSPEED 1
  };

/* c_cc characters */
#define VINTR 0
#define VQUIT 1
#define VERASE 2
#define VKILL 3
#define VEOF 4
#define VTIME 5
#define VMIN 6
#define VSWTC 7
#define VSTART 8
#define VSTOP 9
#define VSUSP 10
#define VEOL 11
#define VREPRINT 12
#define VDISCARD 13
#define VWERASE 14
#define VLNEXT 15
#define VEOL2 16

/* c_iflag bits */
#define IGNBRK 0000001
#define BRKINT 0000002
#define IGNPAR 0000004
#define PARMRK 0000010
#define INPCK 0000020
#define ISTRIP 0000040
#define INLCR 0000100
#define IGNCR 0000200
#define ICRNL 0000400
#define IUCLC 0001000
#define IXON 0002000
#define IXANY 0004000
#define IXOFF 0010000
#define IMAXBEL 0020000
#define IUTF8 0040000

/* c_oflag bits */
#define OPOST 0000001
#define OLCUC 0000002
#define ONLCR 0000004
#define OCRNL 0000010
#define ONOCR 0000020
#define ONLRET 0000040
#define OFILL 0000100
#define OFDEL 0000200

#define NLDLY 0000400
#define NL0 0000000
#define NL1 0000400
#define CRDLY 0003000
#define CR0 0000000
#define CR1 0001000
#define CR2 0002000
#define CR3 0003000
#define TABDLY 0014000
#define TAB0 0000000
#define TAB1 0004000
#define TAB2 0010000
#define TAB3 0014000
#define BSDLY 0020000
#define BS0 0000000
#define BS1 0020000
#define FFDLY 0100000
#define FF0 0000000
#define FF1 0100000


#define VTDLY 0040000
#define VT0 0000000
#define VT1 0040000


#define XTABS 0014000


/* c_cflag bit meaning */

#define CBAUD 0010017

#define B0 0000000
#define B50 0000001
#define B75 0000002
#define B110 0000003
#define B134 0000004
#define B150 0000005
#define B200 0000006
#define B300 0000007
#define B600 0000010
#define B1200 0000011
#define B1800 0000012
#define B2400 0000013
#define B4800 0000014
#define B9600 0000015
#define B19200 0000016
#define B38400 0000017

#define EXTA B19200
#define EXTB B38400

#define CSIZE 0000060
#define CS5 0000000
#define CS6 0000020
#define CS7 0000040
#define CS8 0000060
#define CSTOPB 0000100
#define CREAD 0000200
#define PARENB 0000400
#define PARODD 0001000
#define HUPCL 0002000
#define CLOCAL 0004000

#define CBAUDEX 0010000

#define B57600 0010001
#define B115200 0010002
#define B230400 0010003
#define B460800 0010004
#define B500000 0010005
#define B576000 0010006
#define B921600 0010007
#define B1000000 0010010
#define B1152000 0010011
#define B1500000 0010012
#define B2000000 0010013
#define B2500000 0010014
#define B3000000 0010015
#define B3500000 0010016
#define B4000000 0010017
#define __MAX_BAUD B4000000

#define CIBAUD 002003600000
#define CMSPAR 010000000000
#define CRTSCTS 020000000000


/* c_lflag bits */
#define ISIG 0000001
#define ICANON 0000002

#define XCASE 0000004

#define ECHO 0000010
#define ECHOE 0000020
#define ECHOK 0000040
#define ECHONL 0000100
#define NOFLSH 0000200
#define TOSTOP 0000400

#define ECHOCTL 0001000
#define ECHOPRT 0002000
#define ECHOKE 0004000
#define FLUSHO 0010000
#define PENDIN 0040000

#define IEXTEN 0100000

#define EXTPROC 0200000


/* tcflow() and TCXONC use these */
#define TCOOFF 0
#define TCOON 1
#define TCIOFF 2
#define TCION 3

/* tcflush() and TCFLSH use these */
#define TCIFLUSH 0
#define TCOFLUSH 1
#define TCIOFLUSH 2

/* tcsetattr uses these */
#define TCSANOW 0
#define TCSADRAIN 1
#define TCSAFLUSH 2


#define _IOT_termios _IOT (_IOTS (cflag_t), 4, _IOTS (cc_t), NCCS, _IOTS (speed_t), 2)
# 40 "/usr/include/termios.h" 2 3 4


/* Compare a character C to a value VAL from the `c_cc' array in a
   `struct termios'.  If VAL is _POSIX_VDISABLE, no character can match it.  */
#define CCEQ(val,c) ((c) == (val) && (val) != _POSIX_VDISABLE)


/* Return the output baud rate stored in *TERMIOS_P.  */
extern speed_t cfgetospeed (const struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));

/* Return the input baud rate stored in *TERMIOS_P.  */
extern speed_t cfgetispeed (const struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));

/* Set the output baud rate stored in *TERMIOS_P to SPEED.  */
extern int cfsetospeed (struct termios *__termios_p, speed_t __speed) __attribute__ ((__nothrow__ , __leaf__));

/* Set the input baud rate stored in *TERMIOS_P to SPEED.  */
extern int cfsetispeed (struct termios *__termios_p, speed_t __speed) __attribute__ ((__nothrow__ , __leaf__));


/* Set both the input and output baud rates in *TERMIOS_OP to SPEED.  */
extern int cfsetspeed (struct termios *__termios_p, speed_t __speed) __attribute__ ((__nothrow__ , __leaf__));



/* Put the state of FD into *TERMIOS_P.  */
extern int tcgetattr (int __fd, struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));

/* Set the state of FD to *TERMIOS_P.
   Values for OPTIONAL_ACTIONS (TCSA*) are in <bits/termios.h>.  */
extern int tcsetattr (int __fd, int __optional_actions,
        const struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));



/* Set *TERMIOS_P to indicate raw mode.  */
extern void cfmakeraw (struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));


/* Send zero bits on FD.  */
extern int tcsendbreak (int __fd, int __duration) __attribute__ ((__nothrow__ , __leaf__));

/* Wait for pending output to be written on FD.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int tcdrain (int __fd);

/* Flush pending data on FD.
   Values for QUEUE_SELECTOR (TC{I,O,IO}FLUSH) are in <bits/termios.h>.  */
extern int tcflush (int __fd, int __queue_selector) __attribute__ ((__nothrow__ , __leaf__));

/* Suspend or restart transmission on FD.
   Values for ACTION (TC[IO]{OFF,ON}) are in <bits/termios.h>.  */
extern int tcflow (int __fd, int __action) __attribute__ ((__nothrow__ , __leaf__));



/* Get process group ID for session leader for controlling terminal FD.  */
extern __pid_t tcgetsid (int __fd) __attribute__ ((__nothrow__ , __leaf__));




# 1 "/usr/include/arm-linux-gnueabihf/sys/ttydefaults.h" 1 3 4
/*-
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ttydefaults.h	8.4 (Berkeley) 1/21/94
 */

/*
 * System wide defaults for terminal state.  Linux version.
 */

#define _SYS_TTYDEFAULTS_H_ 

/*
 * Defaults on "first" open.
 */
#define TTYDEF_IFLAG (BRKINT | ISTRIP | ICRNL | IMAXBEL | IXON | IXANY)
#define TTYDEF_OFLAG (OPOST | ONLCR | XTABS)
#define TTYDEF_LFLAG (ECHO | ICANON | ISIG | IEXTEN | ECHOE|ECHOKE|ECHOCTL)
#define TTYDEF_CFLAG (CREAD | CS7 | PARENB | HUPCL)
#define TTYDEF_SPEED (B9600)

/*
 * Control Character Defaults
 */
#define CTRL(x) (x&037)
#define CEOF CTRL('d')

#define CEOL _POSIX_VDISABLE



#define CERASE 0177
#define CINTR CTRL('c')

#define CSTATUS _POSIX_VDISABLE



#define CKILL CTRL('u')
#define CMIN 1
#define CQUIT 034
#define CSUSP CTRL('z')
#define CTIME 0
#define CDSUSP CTRL('y')
#define CSTART CTRL('q')
#define CSTOP CTRL('s')
#define CLNEXT CTRL('v')
#define CDISCARD CTRL('o')
#define CWERASE CTRL('w')
#define CREPRINT CTRL('r')
#define CEOT CEOF
/* compat */
#define CBRK CEOL
#define CRPRNT CREPRINT
#define CFLUSH CDISCARD

/* PROTECTED INCLUSION ENDS HERE */


/*
 * #define TTYDEFCHARS to include an array of default control characters.
 */
# 105 "/usr/include/termios.h" 2 3 4



# 94 "pifunk.c" 2
# 1 "/usr/include/pthread.h" 1 3 4
/* Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _PTHREAD_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 22 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/endian.h" 1 3 4
/* Copyright (C) 1992-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 23 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sched.h" 1 3 4
/* Definitions for POSIX 1003.1b-1993 (aka POSIX.4) scheduling interface.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 24 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 25 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/arm-linux-gnueabihf/bits/pthreadtypes.h" 1 3 4
/* Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */
# 27 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/setjmp.h" 1 3 4
/* Copyright (C) 2004-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */

/* Define the machine-dependent type `jmp_buf'.  ARM EABI version.  */
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/wordsize.h" 1 3 4
/* Copyright (C) 1999-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#define __WORDSIZE 32
# 29 "/usr/include/pthread.h" 2 3 4


/* Detach state.  */
enum
{
  PTHREAD_CREATE_JOINABLE,
#define PTHREAD_CREATE_JOINABLE PTHREAD_CREATE_JOINABLE
  PTHREAD_CREATE_DETACHED
#define PTHREAD_CREATE_DETACHED PTHREAD_CREATE_DETACHED
};


/* Mutex types.  */
enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL


  /* For compatibility.  */
  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};



/* Robust mutex or not flags.  */
enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};




/* Mutex protocols.  */
enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 98 "/usr/include/pthread.h" 3 4
#define PTHREAD_MUTEX_INITIALIZER { { 0, 0, 0, 0, 0, { __PTHREAD_SPINS } } }


#define PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP { { 0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, 0, { __PTHREAD_SPINS } } }

#define PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP { { 0, 0, 0, PTHREAD_MUTEX_ERRORCHECK_NP, 0, { __PTHREAD_SPINS } } }

#define PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP { { 0, 0, 0, PTHREAD_MUTEX_ADAPTIVE_NP, 0, { __PTHREAD_SPINS } } }






/* Read-write lock types.  */

enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};

/* Define __PTHREAD_RWLOCK_INT_FLAGS_SHARED to 1 if pthread_rwlock_t
   has the shared field.  All 64-bit architectures have the shared field
   in pthread_rwlock_t.  */






/* Read-write lock initializers.  */
#define PTHREAD_RWLOCK_INITIALIZER { { 0, 0, 0, 0, 0, 0, 0, 0, __PTHREAD_RWLOCK_ELISION_EXTRA, 0, 0 } }
# 141 "/usr/include/pthread.h" 3 4
#define PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP { { 0, 0, 0, 0, 0, 0, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP, 0, __PTHREAD_RWLOCK_ELISION_EXTRA, 0, 0 } }
# 154 "/usr/include/pthread.h" 3 4
/* Scheduler inheritance.  */
enum
{
  PTHREAD_INHERIT_SCHED,
#define PTHREAD_INHERIT_SCHED PTHREAD_INHERIT_SCHED
  PTHREAD_EXPLICIT_SCHED
#define PTHREAD_EXPLICIT_SCHED PTHREAD_EXPLICIT_SCHED
};


/* Scope handling.  */
enum
{
  PTHREAD_SCOPE_SYSTEM,
#define PTHREAD_SCOPE_SYSTEM PTHREAD_SCOPE_SYSTEM
  PTHREAD_SCOPE_PROCESS
#define PTHREAD_SCOPE_PROCESS PTHREAD_SCOPE_PROCESS
};


/* Process shared or private flag.  */
enum
{
  PTHREAD_PROCESS_PRIVATE,
#define PTHREAD_PROCESS_PRIVATE PTHREAD_PROCESS_PRIVATE
  PTHREAD_PROCESS_SHARED
#define PTHREAD_PROCESS_SHARED PTHREAD_PROCESS_SHARED
};



/* Conditional variable handling.  */
#define PTHREAD_COND_INITIALIZER { { 0, 0, 0, 0, 0, (void *) 0, 0, 0 } }


/* Cleanup buffers */
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *); /* Function to call.  */
  void *__arg; /* Its argument.  */
  int __canceltype; /* Saved cancellation type. */
  struct _pthread_cleanup_buffer *__prev; /* Chaining of cleanup functions.  */
};

/* Cancellation */
enum
{
  PTHREAD_CANCEL_ENABLE,
#define PTHREAD_CANCEL_ENABLE PTHREAD_CANCEL_ENABLE
  PTHREAD_CANCEL_DISABLE
#define PTHREAD_CANCEL_DISABLE PTHREAD_CANCEL_DISABLE
};
enum
{
  PTHREAD_CANCEL_DEFERRED,
#define PTHREAD_CANCEL_DEFERRED PTHREAD_CANCEL_DEFERRED
  PTHREAD_CANCEL_ASYNCHRONOUS
#define PTHREAD_CANCEL_ASYNCHRONOUS PTHREAD_CANCEL_ASYNCHRONOUS
};
#define PTHREAD_CANCELED ((void *) -1)


/* Single execution handling.  */
#define PTHREAD_ONCE_INIT 0



/* Value returned by 'pthread_barrier_wait' for one of the threads after
   the required number of threads have called this function.
   -1 is distinct from 0 and all errno constants */
#define PTHREAD_BARRIER_SERIAL_THREAD -1





/* Create a new thread, starting with execution of START-ROUTINE
   getting passed ARG.  Creation attributed come from ATTR.  The new
   handle is stored in *NEWTHREAD.  */
extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));

/* Terminate calling thread.

   The registered cleanup handlers are called via exception handling
   so we cannot mark this function with __THROW.*/
extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));

/* Make calling thread wait for termination of the thread TH.  The
   exit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN
   is not NULL.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pthread_join (pthread_t __th, void **__thread_return);


/* Check whether thread TH has terminated.  If yes return the status of
   the thread in *THREAD_RETURN, if THREAD_RETURN is not NULL.  */
extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) __attribute__ ((__nothrow__ , __leaf__));

/* Make calling thread wait for termination of the thread TH, but only
   until TIMEOUT.  The exit status of the thread is stored in
   *THREAD_RETURN, if THREAD_RETURN is not NULL.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);


/* Indicate that the thread TH is never to be joined with PTHREAD_JOIN.
   The resources of TH will therefore be freed immediately when it
   terminates, instead of waiting for another thread to perform PTHREAD_JOIN
   on it.  */
extern int pthread_detach (pthread_t __th) __attribute__ ((__nothrow__ , __leaf__));


/* Obtain the identifier of the current thread.  */
extern pthread_t pthread_self (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Compare two thread identifiers.  */
extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


/* Thread attribute handling.  */

/* Initialize thread attribute *ATTR with default attributes
   (detachstate is PTHREAD_JOINABLE, scheduling policy is SCHED_OTHER,
    no user-provided stack).  */
extern int pthread_attr_init (pthread_attr_t *__attr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Destroy thread attribute *ATTR.  */
extern int pthread_attr_destroy (pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Get detach state attribute.  */
extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set detach state attribute.  */
extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Get the size of the guard area created for stack overflow protection.  */
extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set the size of the guard area created for stack overflow protection.  */
extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Return in *PARAM the scheduling parameters of *ATTR.  */
extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set scheduling parameters (priority, etc) in *ATTR according to PARAM.  */
extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Return in *POLICY the scheduling policy of *ATTR.  */
extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set scheduling policy in *ATTR according to POLICY.  */
extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Return in *INHERIT the scheduling inheritance mode of *ATTR.  */
extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set scheduling inheritance mode in *ATTR according to INHERIT.  */
extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Return in *SCOPE the scheduling contention scope of *ATTR.  */
extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set scheduling contention scope in *ATTR according to SCOPE.  */
extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Return the previously set address for the stack.  */
extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));

/* Set the starting address of the stack of the thread to be created.
   Depending on whether the stack grows up or down the value must either
   be higher or lower than all the address in the memory block.  The
   minimal size of the block must be PTHREAD_STACK_MIN.  */
extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));

/* Return the currently used minimal stack size.  */
extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Add information about the minimum stack size needed for the thread
   to be started.  This size must never be less than PTHREAD_STACK_MIN
   and must also not exceed the system limits.  */
extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Return the previously set address for the stack.  */
extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));

/* The following two interfaces are intended to replace the last two.  They
   require setting the address as well as the size since only setting the
   address will make the implementation on some architectures impossible.  */
extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



/* Thread created with attribute ATTR will be limited to run only on
   the processors represented in CPUSET.  */
extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

/* Get bit set in CPUSET representing the processors threads created with
   ATTR can run on.  */
extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

/* Get the default attributes used by pthread_create in this process.  */
extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Set the default attributes to be used by pthread_create in this
   process.  */
extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Initialize thread attribute *ATTR with attributes corresponding to the
   already running thread TH.  It shall be called on uninitialized ATTR
   and destroyed with pthread_attr_destroy when no longer needed.  */
extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



/* Functions for scheduling control.  */

/* Set the scheduling parameters for TARGET_THREAD according to POLICY
   and *PARAM.  */
extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

/* Return in *POLICY and *PARAM the scheduling parameters for TARGET_THREAD. */
extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

/* Set the scheduling priority for TARGET_THREAD.  */
extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     __attribute__ ((__nothrow__ , __leaf__));



/* Get thread name visible in the kernel and its interfaces.  */
extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

/* Set thread name visible in the kernel and its interfaces.  */
extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




/* Determine level of concurrency.  */
extern int pthread_getconcurrency (void) __attribute__ ((__nothrow__ , __leaf__));

/* Set new concurrency level to LEVEL.  */
extern int pthread_setconcurrency (int __level) __attribute__ ((__nothrow__ , __leaf__));



/* Yield the processor to another thread or process.
   This function is similar to the POSIX `sched_yield' function but
   might be differently implemented in the case of a m-on-n thread
   implementation.  */
extern int pthread_yield (void) __attribute__ ((__nothrow__ , __leaf__));


/* Limit specified thread TH to run only on the processors represented
   in CPUSET.  */
extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

/* Get bit set in CPUSET representing the processors TH can run on.  */
extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



/* Functions for handling initialization.  */

/* Guarantee that the initialization function INIT_ROUTINE will be called
   only once, even if pthread_once is executed several times with the
   same ONCE_CONTROL argument. ONCE_CONTROL must point to a static or
   extern variable initialized to PTHREAD_ONCE_INIT.

   The initialization functions might throw exception which is why
   this function is not marked with __THROW.  */
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));


/* Functions for handling cancellation.

   Note that these functions are explicitly not marked to not throw an
   exception in C++ code.  If cancellation is implemented by unwinding
   this is necessary to have the compiler generate the unwind information.  */

/* Set cancelability state of current thread to STATE, returning old
   state in *OLDSTATE if OLDSTATE is not NULL.  */
extern int pthread_setcancelstate (int __state, int *__oldstate);

/* Set cancellation state of current thread to TYPE, returning the old
   type in *OLDTYPE if OLDTYPE is not NULL.  */
extern int pthread_setcanceltype (int __type, int *__oldtype);

/* Cancel THREAD immediately or at the next possibility.  */
extern int pthread_cancel (pthread_t __th);

/* Test for pending cancellation for the current thread and terminate
   the thread as per pthread_exit(PTHREAD_CANCELED) if it has been
   cancelled.  */
extern void pthread_testcancel (void);


/* Cancellation handling with integration into exception handling.  */

typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));

/* No special attributes by default.  */

#define __cleanup_fct_attribute 



/* Structure to hold the cleanup handler information.  */
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};
# 657 "/usr/include/pthread.h" 3 4
/* Install a cleanup handler: ROUTINE will be called with arguments ARG
   when the thread is canceled or calls pthread_exit.  ROUTINE will also
   be called with arguments ARG when the matching pthread_cleanup_pop
   is executed with non-zero EXECUTE argument.

   pthread_cleanup_push and pthread_cleanup_pop are macros and must always
   be used in matching pairs at the same nesting level of braces.  */
#define pthread_cleanup_push(routine,arg) do { __pthread_unwind_buf_t __cancel_buf; void (*__cancel_routine) (void *) = (routine); void *__cancel_arg = (arg); int __not_first_call = __sigsetjmp ((struct __jmp_buf_tag *) (void *) __cancel_buf.__cancel_jmp_buf, 0); if (__glibc_unlikely (__not_first_call)) { __cancel_routine (__cancel_arg); __pthread_unwind_next (&__cancel_buf); } __pthread_register_cancel (&__cancel_buf); do {
# 680 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)
     ;

/* Remove a cleanup handler installed by the matching pthread_cleanup_push.
   If EXECUTE is non-zero, the handler function is called. */
#define pthread_cleanup_pop(execute) do { } while (0); } while (0); __pthread_unregister_cancel (&__cancel_buf); if (execute) __cancel_routine (__cancel_arg); } while (0)






extern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)
  ;


/* Install a cleanup handler as pthread_cleanup_push does, but also
   saves the current cancellation type and sets it to deferred
   cancellation.  */
#define pthread_cleanup_push_defer_np(routine,arg) do { __pthread_unwind_buf_t __cancel_buf; void (*__cancel_routine) (void *) = (routine); void *__cancel_arg = (arg); int __not_first_call = __sigsetjmp ((struct __jmp_buf_tag *) (void *) __cancel_buf.__cancel_jmp_buf, 0); if (__glibc_unlikely (__not_first_call)) { __cancel_routine (__cancel_arg); __pthread_unwind_next (&__cancel_buf); } __pthread_register_cancel_defer (&__cancel_buf); do {
# 715 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel_defer (__pthread_unwind_buf_t *__buf)
     ;

/* Remove a cleanup handler as pthread_cleanup_pop does, but also
   restores the cancellation type that was in effect when the matching
   pthread_cleanup_push_defer was called.  */
#define pthread_cleanup_pop_restore_np(execute) do { } while (0); } while (0); __pthread_unregister_cancel_restore (&__cancel_buf); if (execute) __cancel_routine (__cancel_arg); } while (0)






extern void __pthread_unregister_cancel_restore (__pthread_unwind_buf_t *__buf)
  ;


/* Internal interface to initiate cleanup.  */
extern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)
     __attribute__ ((__noreturn__))

     __attribute__ ((__weak__))

     ;


/* Function used in the macros.  */
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) __attribute__ ((__nothrow__));


/* Mutex handling.  */

/* Initialize a mutex.  */
extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Destroy a mutex.  */
extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Try locking a mutex.  */
extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));

/* Lock a mutex.  */
extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


/* Wait until lock becomes available, or specified time passes. */
extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


/* Unlock a mutex.  */
extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


/* Get the priority ceiling of MUTEX.  */
extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set the priority ceiling of MUTEX to PRIOCEILING, return old
   priority ceiling value in *OLD_CEILING.  */
extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



/* Declare the state protected by MUTEX as consistent.  */
extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




/* Functions for handling mutex attributes.  */

/* Initialize mutex attribute object ATTR with default attributes
   (kind is PTHREAD_MUTEX_TIMED_NP).  */
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Destroy mutex attribute object ATTR.  */
extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Get the process-shared flag of the mutex attribute ATTR.  */
extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set the process-shared flag of the mutex attribute ATTR.  */
extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Return in *KIND the mutex kind attribute in *ATTR.  */
extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set the mutex kind attribute in *ATTR to KIND (either PTHREAD_MUTEX_NORMAL,
   PTHREAD_MUTEX_RECURSIVE, PTHREAD_MUTEX_ERRORCHECK, or
   PTHREAD_MUTEX_DEFAULT).  */
extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Return in *PROTOCOL the mutex protocol attribute in *ATTR.  */
extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set the mutex protocol attribute in *ATTR to PROTOCOL (either
   PTHREAD_PRIO_NONE, PTHREAD_PRIO_INHERIT, or PTHREAD_PRIO_PROTECT).  */
extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Return in *PRIOCEILING the mutex prioceiling attribute in *ATTR.  */
extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set the mutex prioceiling attribute in *ATTR to PRIOCEILING.  */
extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Get the robustness flag of the mutex attribute ATTR.  */
extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


/* Set the robustness flag of the mutex attribute ATTR.  */
extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





/* Functions for handling read-write locks.  */

/* Initialize read-write lock RWLOCK using attributes ATTR, or use
   the default values if later is NULL.  */
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Destroy read-write lock RWLOCK.  */
extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Acquire read lock for RWLOCK.  */
extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));

/* Try to acquire read lock for RWLOCK.  */
extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


/* Try to acquire read lock for RWLOCK or return after specfied time.  */
extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


/* Acquire write lock for RWLOCK.  */
extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));

/* Try to acquire write lock for RWLOCK.  */
extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


/* Try to acquire write lock for RWLOCK or return after specfied time.  */
extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


/* Unlock RWLOCK.  */
extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


/* Functions for handling read-write lock attributes.  */

/* Initialize attribute object ATTR with default values.  */
extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Destroy attribute object ATTR.  */
extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Return current setting of process-shared attribute of ATTR in PSHARED.  */
extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set process-shared attribute of ATTR to PSHARED.  */
extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Return current setting of reader/writer preference.  */
extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set reader/write preference.  */
extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



/* Functions for handling conditional variables.  */

/* Initialize condition variable COND using attributes ATTR, or use
   the default values if later is NULL.  */
extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Destroy condition variable COND.  */
extern int pthread_cond_destroy (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Wake up one thread waiting for condition variable COND.  */
extern int pthread_cond_signal (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));

/* Wake up all threads waiting for condition variables COND.  */
extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));

/* Wait for condition variable COND to be signaled or broadcast.
   MUTEX is assumed to be locked before.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));

/* Wait for condition variable COND to be signaled or broadcast until
   ABSTIME.  MUTEX is assumed to be locked before.  ABSTIME is an
   absolute time specification; zero is the beginning of the epoch
   (00:00:00 GMT, January 1, 1970).

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));

/* Functions for handling condition variable attributes.  */

/* Initialize condition variable attribute ATTR.  */
extern int pthread_condattr_init (pthread_condattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Destroy condition variable attribute ATTR.  */
extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Get the process-shared flag of the condition variable attribute ATTR.  */
extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set the process-shared flag of the condition variable attribute ATTR.  */
extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Get the clock selected for the condition variable attribute ATTR.  */
extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set the clock selected for the condition variable attribute ATTR.  */
extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




/* Functions to handle spinlocks.  */

/* Initialize the spinlock LOCK.  If PSHARED is nonzero the spinlock can
   be shared between different processes.  */
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Destroy the spinlock LOCK.  */
extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Wait until spinlock LOCK is retrieved.  */
extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));

/* Try to lock spinlock LOCK.  */
extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));

/* Release spinlock LOCK.  */
extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


/* Functions to handle barriers.  */

/* Initialize BARRIER with the attributes in ATTR.  The barrier is
   opened when COUNT waiters arrived.  */
extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Destroy a previously dynamically initialized barrier BARRIER.  */
extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Wait on barrier BARRIER.  */
extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


/* Initialize barrier attribute ATTR.  */
extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Destroy previously dynamically initialized barrier attribute ATTR.  */
extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Get the process-shared flag of the barrier attribute ATTR.  */
extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Set the process-shared flag of the barrier attribute ATTR.  */
extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



/* Functions for handling thread-specific data.  */

/* Create a key value identifying a location in the thread-specific
   data area.  Each thread maintains a distinct thread-specific data
   area.  DESTR_FUNCTION, if non-NULL, is called with the value
   associated to that key when the key is destroyed.
   DESTR_FUNCTION is not called if the value associated is NULL when
   the key is destroyed.  */
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Destroy KEY.  */
extern int pthread_key_delete (pthread_key_t __key) __attribute__ ((__nothrow__ , __leaf__));

/* Return current value of the thread-specific data slot identified by KEY.  */
extern void *pthread_getspecific (pthread_key_t __key) __attribute__ ((__nothrow__ , __leaf__));

/* Store POINTER in the thread-specific data slot identified by KEY. */
extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) __attribute__ ((__nothrow__ , __leaf__)) ;



/* Get ID of CPU-time clock for thread THREAD_ID.  */
extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



/* Install handlers to be called when a new process is created with FORK.
   The PREPARE handler is called in the parent process just before performing
   FORK. The PARENT handler is called in the parent process just after FORK.
   The CHILD handler is called in the child process.  Each of the three
   handlers can be NULL, meaning that no handler needs to be called at that
   point.
   PTHREAD_ATFORK can be called several times, in which case the PREPARE
   handlers are called in LIFO order (last added with PTHREAD_ATFORK,
   first called before FORK), and the PARENT and CHILD handlers are called
   in FIFO (first added, first called).  */

extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) __attribute__ ((__nothrow__ , __leaf__));



/* Optimizations.  */
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) pthread_equal (pthread_t __thread1, pthread_t __thread2)
{
  return __thread1 == __thread2;
}



# 95 "pifunk.c" 2
# 1 "/usr/include/inttypes.h" 1 3 4
/* Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99: 7.8 Format conversion of integer types	<inttypes.h>
 */


#define _INTTYPES_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/inttypes.h" 2 3 4
/* Get the type definitions.  */


/* Get a definition for wchar_t.  But we must not define wchar_t itself.  */




typedef unsigned int __gwchar_t;





#define ____gwchar_t_defined 1






#define __PRI64_PREFIX "ll"
#define __PRIPTR_PREFIX 


/* Macros for printing format specifiers.  */

/* Decimal notation.  */
#define PRId8 "d"
#define PRId16 "d"
#define PRId32 "d"
#define PRId64 __PRI64_PREFIX "d"

#define PRIdLEAST8 "d"
#define PRIdLEAST16 "d"
#define PRIdLEAST32 "d"
#define PRIdLEAST64 __PRI64_PREFIX "d"

#define PRIdFAST8 "d"
#define PRIdFAST16 __PRIPTR_PREFIX "d"
#define PRIdFAST32 __PRIPTR_PREFIX "d"
#define PRIdFAST64 __PRI64_PREFIX "d"


#define PRIi8 "i"
#define PRIi16 "i"
#define PRIi32 "i"
#define PRIi64 __PRI64_PREFIX "i"

#define PRIiLEAST8 "i"
#define PRIiLEAST16 "i"
#define PRIiLEAST32 "i"
#define PRIiLEAST64 __PRI64_PREFIX "i"

#define PRIiFAST8 "i"
#define PRIiFAST16 __PRIPTR_PREFIX "i"
#define PRIiFAST32 __PRIPTR_PREFIX "i"
#define PRIiFAST64 __PRI64_PREFIX "i"

/* Octal notation.  */
#define PRIo8 "o"
#define PRIo16 "o"
#define PRIo32 "o"
#define PRIo64 __PRI64_PREFIX "o"

#define PRIoLEAST8 "o"
#define PRIoLEAST16 "o"
#define PRIoLEAST32 "o"
#define PRIoLEAST64 __PRI64_PREFIX "o"

#define PRIoFAST8 "o"
#define PRIoFAST16 __PRIPTR_PREFIX "o"
#define PRIoFAST32 __PRIPTR_PREFIX "o"
#define PRIoFAST64 __PRI64_PREFIX "o"

/* Unsigned integers.  */
#define PRIu8 "u"
#define PRIu16 "u"
#define PRIu32 "u"
#define PRIu64 __PRI64_PREFIX "u"

#define PRIuLEAST8 "u"
#define PRIuLEAST16 "u"
#define PRIuLEAST32 "u"
#define PRIuLEAST64 __PRI64_PREFIX "u"

#define PRIuFAST8 "u"
#define PRIuFAST16 __PRIPTR_PREFIX "u"
#define PRIuFAST32 __PRIPTR_PREFIX "u"
#define PRIuFAST64 __PRI64_PREFIX "u"

/* lowercase hexadecimal notation.  */
#define PRIx8 "x"
#define PRIx16 "x"
#define PRIx32 "x"
#define PRIx64 __PRI64_PREFIX "x"

#define PRIxLEAST8 "x"
#define PRIxLEAST16 "x"
#define PRIxLEAST32 "x"
#define PRIxLEAST64 __PRI64_PREFIX "x"

#define PRIxFAST8 "x"
#define PRIxFAST16 __PRIPTR_PREFIX "x"
#define PRIxFAST32 __PRIPTR_PREFIX "x"
#define PRIxFAST64 __PRI64_PREFIX "x"

/* UPPERCASE hexadecimal notation.  */
#define PRIX8 "X"
#define PRIX16 "X"
#define PRIX32 "X"
#define PRIX64 __PRI64_PREFIX "X"

#define PRIXLEAST8 "X"
#define PRIXLEAST16 "X"
#define PRIXLEAST32 "X"
#define PRIXLEAST64 __PRI64_PREFIX "X"

#define PRIXFAST8 "X"
#define PRIXFAST16 __PRIPTR_PREFIX "X"
#define PRIXFAST32 __PRIPTR_PREFIX "X"
#define PRIXFAST64 __PRI64_PREFIX "X"


/* Macros for printing `intmax_t' and `uintmax_t'.  */
#define PRIdMAX __PRI64_PREFIX "d"
#define PRIiMAX __PRI64_PREFIX "i"
#define PRIoMAX __PRI64_PREFIX "o"
#define PRIuMAX __PRI64_PREFIX "u"
#define PRIxMAX __PRI64_PREFIX "x"
#define PRIXMAX __PRI64_PREFIX "X"


/* Macros for printing `intptr_t' and `uintptr_t'.  */
#define PRIdPTR __PRIPTR_PREFIX "d"
#define PRIiPTR __PRIPTR_PREFIX "i"
#define PRIoPTR __PRIPTR_PREFIX "o"
#define PRIuPTR __PRIPTR_PREFIX "u"
#define PRIxPTR __PRIPTR_PREFIX "x"
#define PRIXPTR __PRIPTR_PREFIX "X"


/* Macros for scanning format specifiers.  */

/* Signed decimal notation.  */
#define SCNd8 "hhd"
#define SCNd16 "hd"
#define SCNd32 "d"
#define SCNd64 __PRI64_PREFIX "d"

#define SCNdLEAST8 "hhd"
#define SCNdLEAST16 "hd"
#define SCNdLEAST32 "d"
#define SCNdLEAST64 __PRI64_PREFIX "d"

#define SCNdFAST8 "hhd"
#define SCNdFAST16 __PRIPTR_PREFIX "d"
#define SCNdFAST32 __PRIPTR_PREFIX "d"
#define SCNdFAST64 __PRI64_PREFIX "d"

/* Signed decimal notation.  */
#define SCNi8 "hhi"
#define SCNi16 "hi"
#define SCNi32 "i"
#define SCNi64 __PRI64_PREFIX "i"

#define SCNiLEAST8 "hhi"
#define SCNiLEAST16 "hi"
#define SCNiLEAST32 "i"
#define SCNiLEAST64 __PRI64_PREFIX "i"

#define SCNiFAST8 "hhi"
#define SCNiFAST16 __PRIPTR_PREFIX "i"
#define SCNiFAST32 __PRIPTR_PREFIX "i"
#define SCNiFAST64 __PRI64_PREFIX "i"

/* Unsigned decimal notation.  */
#define SCNu8 "hhu"
#define SCNu16 "hu"
#define SCNu32 "u"
#define SCNu64 __PRI64_PREFIX "u"

#define SCNuLEAST8 "hhu"
#define SCNuLEAST16 "hu"
#define SCNuLEAST32 "u"
#define SCNuLEAST64 __PRI64_PREFIX "u"

#define SCNuFAST8 "hhu"
#define SCNuFAST16 __PRIPTR_PREFIX "u"
#define SCNuFAST32 __PRIPTR_PREFIX "u"
#define SCNuFAST64 __PRI64_PREFIX "u"

/* Octal notation.  */
#define SCNo8 "hho"
#define SCNo16 "ho"
#define SCNo32 "o"
#define SCNo64 __PRI64_PREFIX "o"

#define SCNoLEAST8 "hho"
#define SCNoLEAST16 "ho"
#define SCNoLEAST32 "o"
#define SCNoLEAST64 __PRI64_PREFIX "o"

#define SCNoFAST8 "hho"
#define SCNoFAST16 __PRIPTR_PREFIX "o"
#define SCNoFAST32 __PRIPTR_PREFIX "o"
#define SCNoFAST64 __PRI64_PREFIX "o"

/* Hexadecimal notation.  */
#define SCNx8 "hhx"
#define SCNx16 "hx"
#define SCNx32 "x"
#define SCNx64 __PRI64_PREFIX "x"

#define SCNxLEAST8 "hhx"
#define SCNxLEAST16 "hx"
#define SCNxLEAST32 "x"
#define SCNxLEAST64 __PRI64_PREFIX "x"

#define SCNxFAST8 "hhx"
#define SCNxFAST16 __PRIPTR_PREFIX "x"
#define SCNxFAST32 __PRIPTR_PREFIX "x"
#define SCNxFAST64 __PRI64_PREFIX "x"


/* Macros for scanning `intmax_t' and `uintmax_t'.  */
#define SCNdMAX __PRI64_PREFIX "d"
#define SCNiMAX __PRI64_PREFIX "i"
#define SCNoMAX __PRI64_PREFIX "o"
#define SCNuMAX __PRI64_PREFIX "u"
#define SCNxMAX __PRI64_PREFIX "x"

/* Macros for scaning `intptr_t' and `uintptr_t'.  */
#define SCNdPTR __PRIPTR_PREFIX "d"
#define SCNiPTR __PRIPTR_PREFIX "i"
#define SCNoPTR __PRIPTR_PREFIX "o"
#define SCNuPTR __PRIPTR_PREFIX "u"
#define SCNxPTR __PRIPTR_PREFIX "x"



# 279 "/usr/include/inttypes.h" 3 4
/* We have to define the `uintmax_t' type using `lldiv_t'.  */
typedef struct
  {
    __extension__ long long int quot; /* Quotient.  */
    __extension__ long long int rem; /* Remainder.  */
  } imaxdiv_t;




/* Compute absolute value of N.  */
extern intmax_t imaxabs (intmax_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return the `imaxdiv_t' representation of the value of NUMER over DENOM. */
extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Like `strtol' but convert to `intmax_t'.  */
extern intmax_t strtoimax (const char *__restrict __nptr,
      char **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));

/* Like `strtoul' but convert to `uintmax_t'.  */
extern uintmax_t strtoumax (const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));

/* Like `wcstol' but convert to `intmax_t'.  */
extern intmax_t wcstoimax (const __gwchar_t *__restrict __nptr,
      __gwchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));

/* Like `wcstoul' but convert to `uintmax_t'.  */
extern uintmax_t wcstoumax (const __gwchar_t *__restrict __nptr,
       __gwchar_t ** __restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));
# 370 "/usr/include/inttypes.h" 3 4
__extension__
extern long long int __strtoll_internal (const char *__restrict __nptr,
      char **__restrict __endptr,
      int __base, int __group)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
/* Like `strtol' but convert to `intmax_t'.  */
extern __inline __attribute__ ((__gnu_inline__)) intmax_t
__attribute__ ((__nothrow__ , __leaf__)) strtoimax (const char *__restrict nptr, char **__restrict endptr, int base)

{
  return __strtoll_internal (nptr, endptr, base, 0);
}

__extension__
extern unsigned long long int __strtoull_internal (const char *
         __restrict __nptr,
         char **
         __restrict __endptr,
         int __base,
         int __group)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
/* Like `strtoul' but convert to `uintmax_t'.  */
extern __inline __attribute__ ((__gnu_inline__)) uintmax_t
__attribute__ ((__nothrow__ , __leaf__)) strtoumax (const char *__restrict nptr, char **__restrict endptr, int base)

{
  return __strtoull_internal (nptr, endptr, base, 0);
}

__extension__
extern long long int __wcstoll_internal (const __gwchar_t *__restrict __nptr,
      __gwchar_t **__restrict __endptr,
      int __base, int __group)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
/* Like `wcstol' but convert to `intmax_t'.  */
extern __inline __attribute__ ((__gnu_inline__)) intmax_t
__attribute__ ((__nothrow__ , __leaf__)) wcstoimax (const __gwchar_t *__restrict nptr, __gwchar_t **__restrict endptr, int base)

{
  return __wcstoll_internal (nptr, endptr, base, 0);
}


__extension__
extern unsigned long long int __wcstoull_internal (const __gwchar_t *
         __restrict __nptr,
         __gwchar_t **
         __restrict __endptr,
         int __base,
         int __group)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
/* Like `wcstoul' but convert to `uintmax_t'.  */
extern __inline __attribute__ ((__gnu_inline__)) uintmax_t
__attribute__ ((__nothrow__ , __leaf__)) wcstoumax (const __gwchar_t *__restrict nptr, __gwchar_t **__restrict endptr, int base)

{
  return __wcstoull_internal (nptr, endptr, base, 0);
}





# 96 "pifunk.c" 2
# 1 "/usr/include/math.h" 1 3 4
/* Declarations for math functions.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.12 Mathematics	<math.h>
 */


#define _MATH_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 27 "/usr/include/math.h" 2 3 4



/* Get machine-dependent vector math functions declarations.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/math-vector.h" 1 3 4
/* Platform-specific SIMD declarations of math functions.
   Copyright (C) 2014-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License  published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






/* Get default empty definitions required for __MATHCALL_VEC unfolding.
   Plaform-specific analogue of this header should redefine them with specific
   SIMD declarations.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/libm-simd-decl-stubs.h" 1 3 4
/* Empty definitions required for __MATHCALL_VEC unfolding in mathcalls.h.
   Copyright (C) 2014-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






/* Needed definitions could be generated with:
   for func in $(grep __MATHCALL_VEC math/bits/mathcalls.h |		 sed -r "s|__MATHCALL_VEC.?\(||; s|,.*||"); do
o
     echo "#define __DECL_SIMD_${func}";
     echo "#define __DECL_SIMD_${func}f";
     echo "#define __DECL_SIMD_${func}l";
   done
 */


#define _BITS_LIBM_SIMD_DECL_STUBS_H 1

#define __DECL_SIMD_cos 
#define __DECL_SIMD_cosf 
#define __DECL_SIMD_cosl 

#define __DECL_SIMD_sin 
#define __DECL_SIMD_sinf 
#define __DECL_SIMD_sinl 

#define __DECL_SIMD_sincos 
#define __DECL_SIMD_sincosf 
#define __DECL_SIMD_sincosl 

#define __DECL_SIMD_log 
#define __DECL_SIMD_logf 
#define __DECL_SIMD_logl 

#define __DECL_SIMD_exp 
#define __DECL_SIMD_expf 
#define __DECL_SIMD_expl 

#define __DECL_SIMD_pow 
#define __DECL_SIMD_powf 
#define __DECL_SIMD_powl 
# 27 "/usr/include/arm-linux-gnueabihf/bits/math-vector.h" 2 3 4
# 32 "/usr/include/math.h" 2 3 4

/* Get machine-dependent HUGE_VAL value (returned on overflow).
   On all IEEE754 machines, this is +Infinity.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/huge_val.h" 1 3 4
/* `HUGE_VAL' constant for IEEE 754 machines (where it is infinity).
   Used by <stdlib.h> and <math.h> functions for overflow.
   Copyright (C) 1992-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* IEEE positive infinity (-HUGE_VAL is negative infinity).  */


#define HUGE_VAL (__builtin_huge_val())
# 36 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/arm-linux-gnueabihf/bits/huge_valf.h" 1 3 4
/* `HUGE_VALF' constant for IEEE 754 machines (where it is infinity).
   Used by <stdlib.h> and <math.h> functions for overflow.
   Copyright (C) 1992-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* IEEE positive infinity (-HUGE_VAL is negative infinity).  */


#define HUGE_VALF (__builtin_huge_valf())
# 38 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/huge_vall.h" 1 3 4
/* Default `HUGE_VALL' constant.
   Used by <stdlib.h> and <math.h> functions for overflow.
   Copyright (C) 1992-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






#define HUGE_VALL (__builtin_huge_vall())
# 39 "/usr/include/math.h" 2 3 4

/* Get machine-dependent INFINITY value.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/inf.h" 1 3 4
/* `INFINITY' constant for IEEE 754 machines.
   Copyright (C) 2004-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* IEEE positive infinity.  */


#define INFINITY (__builtin_inff())
# 42 "/usr/include/math.h" 2 3 4

/* Get machine-dependent NAN value (returned for some domain errors).  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/nan.h" 1 3 4
/* `NAN' constant for IEEE 754 machines.
   Copyright (C) 1992-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






/* IEEE Not A Number.  */



#define NAN (__builtin_nanf (""))
# 45 "/usr/include/math.h" 2 3 4


/* Get general and ISO C99 specific information.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/mathdef.h" 1 3 4
/* Copyright (C) 1999-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */






#define _MATH_H_MATHDEF 1

/* GCC does not promote `float' values to `double'.  */
typedef float float_t; /* `float' expressions are evaluated as
				   `float'.  */
typedef double double_t; /* `double' expressions are evaluated as
				   `double'.  */

/* The values returned by `ilogb' for 0 and NaN respectively.  */
#define FP_ILOGB0 (-2147483647)
#define FP_ILOGBNAN (2147483647)

/* The GCC 4.6 compiler will define __FP_FAST_FMA{,F,L} if the fma{,f,l}
   builtins are supported.  */
# 52 "/usr/include/arm-linux-gnueabihf/bits/mathdef.h" 3 4
/* Signal that we do not really have a `long double'.  This disables the
   declaration of all the `long double' function variants.  */
#define __NO_LONG_DOUBLE_MATH 1
# 49 "/usr/include/math.h" 2 3 4

/* The file <bits/mathcalls.h> contains the prototypes for all the
   actual math functions.  These macros are used for those prototypes,
   so we can easily declare each function as both `name' and `__name',
   and can declare the float versions `namef' and `__namef'.  */

#define __SIMD_DECL(function) __CONCAT (__DECL_SIMD_, function)

#define __MATHCALL_VEC(function,suffix,args) __SIMD_DECL (__MATH_PRECNAME (function, suffix)) __MATHCALL (function, suffix, args)



#define __MATHDECL_VEC(type,function,suffix,args) __SIMD_DECL (__MATH_PRECNAME (function, suffix)) __MATHDECL(type, function,suffix, args)



#define __MATHCALL(function,suffix,args) __MATHDECL (_Mdouble_,function,suffix, args)

#define __MATHDECL(type,function,suffix,args) __MATHDECL_1(type, function,suffix, args); __MATHDECL_1(type, __CONCAT(__,function),suffix, args)


#define __MATHCALLX(function,suffix,args,attrib) __MATHDECLX (_Mdouble_,function,suffix, args, attrib)

#define __MATHDECLX(type,function,suffix,args,attrib) __MATHDECL_1(type, function,suffix, args) __attribute__ (attrib); __MATHDECL_1(type, __CONCAT(__,function),suffix, args) __attribute__ (attrib)


#define __MATHDECL_1(type,function,suffix,args) extern type __MATH_PRECNAME(function,suffix) args __THROW


#define _Mdouble_ double
#define __MATH_PRECNAME(name,r) __CONCAT(name,r)
#define __MATH_DECLARING_DOUBLE 1
#define _Mdouble_BEGIN_NAMESPACE __BEGIN_NAMESPACE_STD
#define _Mdouble_END_NAMESPACE __END_NAMESPACE_STD
# 1 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h" 1 3 4
/* Prototype declarations for math functions; helper file for <math.h>.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* NOTE: Because of the special way this file is used by <math.h>, this
   file must NOT be protected from multiple inclusion as header files
   usually are.

   This file provides prototype declarations for the math functions.
   Most functions are declared using the macro:

   __MATHCALL (NAME,[_r], (ARGS...));

   This means there is a function `NAME' returning `double' and a function
   `NAMEf' returning `float'.  Each place `_Mdouble_' appears in the
   prototype, that is actually `double' in the prototype for `NAME' and
   `float' in the prototype for `NAMEf'.  Reentrant variant functions are
   called `NAME_r' and `NAMEf_r'.

   Functions returning other types like `int' are declared using the macro:

   __MATHDECL (TYPE, NAME,[_r], (ARGS...));

   This is just like __MATHCALL but for a function returning `TYPE'
   instead of `_Mdouble_'.  In all of these cases, there is still
   both a `NAME' and a `NAMEf' that takes `float' arguments.

   Note that there must be no whitespace before the argument passed for
   NAME, to make token pasting work with -traditional.  */






/* Trigonometric functions.  */


/* Arc cosine of X.  */
extern double acos (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __acos (double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Arc sine of X.  */
extern double asin (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __asin (double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Arc tangent of X.  */
extern double atan (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atan (double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Arc tangent of Y/X.  */
extern double atan2 (double __y, double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atan2 (double __y, double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Cosine of X.  */
 extern double cos (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cos (double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Sine of X.  */
 extern double sin (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sin (double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Tangent of X.  */
extern double tan (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __tan (double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Hyperbolic functions.  */

/* Hyperbolic cosine of X.  */
extern double cosh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cosh (double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic sine of X.  */
extern double sinh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sinh (double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic tangent of X.  */
extern double tanh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __tanh (double __x) __attribute__ ((__nothrow__ , __leaf__));



/* Cosine and sine of X.  */
 extern void sincos (double __x, double *__sinx, double *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincos (double __x, double *__sinx, double *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




/* Hyperbolic arc cosine of X.  */
extern double acosh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __acosh (double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic arc sine of X.  */
extern double asinh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __asinh (double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic arc tangent of X.  */
extern double atanh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atanh (double __x) __attribute__ ((__nothrow__ , __leaf__));



/* Exponential and logarithmic functions.  */


/* Exponential function of X.  */
 extern double exp (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp (double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Break VALUE into a normalized fraction and an integral power of 2.  */
extern double frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern double __frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));

/* X times (two to the EXP power).  */
extern double ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern double __ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));

/* Natural logarithm of X.  */
 extern double log (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log (double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Base-ten logarithm of X.  */
extern double log10 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log10 (double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Break VALUE into integral and fractional parts.  */
extern double modf (double __x, double *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern double __modf (double __x, double *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



/* A function missing in all standards: compute exponent to base ten.  */
extern double exp10 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp10 (double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Another name occasionally used.  */
extern double pow10 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __pow10 (double __x) __attribute__ ((__nothrow__ , __leaf__));




/* Return exp(X) - 1.  */
extern double expm1 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __expm1 (double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Return log(1 + X).  */
extern double log1p (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log1p (double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Return the base 2 signed integral exponent of X.  */
extern double logb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __logb (double __x) __attribute__ ((__nothrow__ , __leaf__));





/* Compute base-2 exponential of X.  */
extern double exp2 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp2 (double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Compute base-2 logarithm of X.  */
extern double log2 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log2 (double __x) __attribute__ ((__nothrow__ , __leaf__));




/* Power functions.  */


/* Return X to the Y power.  */
 extern double pow (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __pow (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));

/* Return the square root of X.  */
extern double sqrt (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sqrt (double __x) __attribute__ ((__nothrow__ , __leaf__));




/* Return `sqrt(X*X + Y*Y)'.  */
extern double hypot (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __hypot (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));





/* Return the cube root of X.  */
extern double cbrt (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cbrt (double __x) __attribute__ ((__nothrow__ , __leaf__));




/* Nearest integer, absolute value, and remainder functions.  */


/* Smallest integral value not less than X.  */
extern double ceil (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __ceil (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Absolute value of X.  */
extern double fabs (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fabs (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Largest integer not greater than X.  */
extern double floor (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __floor (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Floating-point modulo remainder of X/Y.  */
extern double fmod (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __fmod (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
extern int __isinf (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return nonzero if VALUE is finite and not NaN.  */
extern int __finite (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));






/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
extern int isinf (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


/* Return nonzero if VALUE is finite and not NaN.  */
extern int finite (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return the remainder of X/Y.  */
extern double drem (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __drem (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


/* Return the fractional part of X after dividing out `ilogb (X)'.  */
extern double significand (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __significand (double __x) __attribute__ ((__nothrow__ , __leaf__));




/* Return X with its signed changed to Y's.  */
extern double copysign (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





/* Return representation of qNaN for double type.  */
extern double nan (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __nan (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




/* Return nonzero if VALUE is not a number.  */
extern int __isnan (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





/* Return nonzero if VALUE is not a number.  */
extern int isnan (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




/* Bessel functions.  */
extern double j0 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __j0 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double j1 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __j1 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double jn (int, double) __attribute__ ((__nothrow__ , __leaf__)); extern double __jn (int, double) __attribute__ ((__nothrow__ , __leaf__));
extern double y0 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __y0 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double y1 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __y1 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double yn (int, double) __attribute__ ((__nothrow__ , __leaf__)); extern double __yn (int, double) __attribute__ ((__nothrow__ , __leaf__));





/* Error and gamma functions.  */
extern double erf (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __erf (double) __attribute__ ((__nothrow__ , __leaf__));
extern double erfc (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __erfc (double) __attribute__ ((__nothrow__ , __leaf__));
extern double lgamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __lgamma (double) __attribute__ ((__nothrow__ , __leaf__));





/* True gamma function.  */
extern double tgamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __tgamma (double) __attribute__ ((__nothrow__ , __leaf__));




/* Obsolete alias for `lgamma'.  */
extern double gamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __gamma (double) __attribute__ ((__nothrow__ , __leaf__));



/* Reentrant version of lgamma.  This function uses the global variable
   `signgam'.  The reentrant version instead takes a pointer and stores
   the value through it.  */
extern double lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern double __lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));





/* Return the integer nearest X in the direction of the
   prevailing rounding mode.  */
extern double rint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __rint (double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Return X + epsilon if X < Y, X - epsilon if X > Y.  */
extern double nextafter (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



/* Return X - epsilon.  */
extern double nextdown (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __nextdown (double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Return X + epsilon.  */
extern double nextup (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __nextup (double __x) __attribute__ ((__nothrow__ , __leaf__));


/* Return the remainder of integer divison X / Y with infinite precision.  */
extern double remainder (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __remainder (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


/* Return X times (2 to the Nth power).  */
extern double scalbn (double __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalbn (double __x, int __n) __attribute__ ((__nothrow__ , __leaf__));


/* Return the binary exponent of X, which must be nonzero.  */
extern int ilogb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogb (double __x) __attribute__ ((__nothrow__ , __leaf__));



/* Return X times (2 to the Nth power).  */
extern double scalbln (double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalbln (double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));

/* Round X to integral value in floating-point format using current
   rounding direction, but do not raise inexact exception.  */
extern double nearbyint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __nearbyint (double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
extern double round (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __round (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Round X to the integral value in floating-point format nearest but
   not larger in magnitude.  */
extern double trunc (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __trunc (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Compute remainder of X and Y and put in *QUO a value with sign of x/y
   and magnitude congruent `mod 2^n' to the magnitude of the integral
   quotient x/y, with n >= 3.  */
extern double remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern double __remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));


/* Conversion functions.  */

/* Round X to nearest integral value according to current rounding
   direction.  */
extern long int lrint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrint (double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrint (double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
extern long int lround (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lround (double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llround (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llround (double __x) __attribute__ ((__nothrow__ , __leaf__));


/* Return positive difference between X and Y.  */
extern double fdim (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __fdim (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));

/* Return maximum numeric value from X and Y.  */
extern double fmax (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmax (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return minimum numeric value from X and Y.  */
extern double fmin (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmin (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


/* Classify given number.  */
extern int __fpclassify (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));

/* Test for negative number.  */
extern int __signbit (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


/* Multiply-add function computed as a ternary operation.  */
extern double fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ , __leaf__)); extern double __fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ , __leaf__));







/* Test for signaling NaN.  */
extern int __issignaling (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));





/* Return X times (2 to the Nth power).  */
extern double scalb (double __x, double __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalb (double __x, double __n) __attribute__ ((__nothrow__ , __leaf__));
# 84 "/usr/include/math.h" 2 3 4
#undef _Mdouble_
#undef _Mdouble_BEGIN_NAMESPACE
#undef _Mdouble_END_NAMESPACE
#undef __MATH_PRECNAME
#undef __MATH_DECLARING_DOUBLE




/* Include the file of declarations again, this time using `float'
   instead of `double' and appending f to each function name.  */


#define _Mfloat_ float

#define _Mdouble_ _Mfloat_
#define __MATH_PRECNAME(name,r) name ##f ##r
#define __MATH_DECLARING_DOUBLE 0
#define _Mdouble_BEGIN_NAMESPACE __BEGIN_NAMESPACE_C99
#define _Mdouble_END_NAMESPACE __END_NAMESPACE_C99
# 1 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h" 1 3 4
/* Prototype declarations for math functions; helper file for <math.h>.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* NOTE: Because of the special way this file is used by <math.h>, this
   file must NOT be protected from multiple inclusion as header files
   usually are.

   This file provides prototype declarations for the math functions.
   Most functions are declared using the macro:

   __MATHCALL (NAME,[_r], (ARGS...));

   This means there is a function `NAME' returning `double' and a function
   `NAMEf' returning `float'.  Each place `_Mdouble_' appears in the
   prototype, that is actually `double' in the prototype for `NAME' and
   `float' in the prototype for `NAMEf'.  Reentrant variant functions are
   called `NAME_r' and `NAMEf_r'.

   Functions returning other types like `int' are declared using the macro:

   __MATHDECL (TYPE, NAME,[_r], (ARGS...));

   This is just like __MATHCALL but for a function returning `TYPE'
   instead of `_Mdouble_'.  In all of these cases, there is still
   both a `NAME' and a `NAMEf' that takes `float' arguments.

   Note that there must be no whitespace before the argument passed for
   NAME, to make token pasting work with -traditional.  */






/* Trigonometric functions.  */


/* Arc cosine of X.  */
extern float acosf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __acosf (float __x) __attribute__ ((__nothrow__ , __leaf__));
/* Arc sine of X.  */
extern float asinf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __asinf (float __x) __attribute__ ((__nothrow__ , __leaf__));
/* Arc tangent of X.  */
extern float atanf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atanf (float __x) __attribute__ ((__nothrow__ , __leaf__));
/* Arc tangent of Y/X.  */
extern float atan2f (float __y, float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atan2f (float __y, float __x) __attribute__ ((__nothrow__ , __leaf__));

/* Cosine of X.  */
 extern float cosf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __cosf (float __x) __attribute__ ((__nothrow__ , __leaf__));
/* Sine of X.  */
 extern float sinf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sinf (float __x) __attribute__ ((__nothrow__ , __leaf__));
/* Tangent of X.  */
extern float tanf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __tanf (float __x) __attribute__ ((__nothrow__ , __leaf__));

/* Hyperbolic functions.  */

/* Hyperbolic cosine of X.  */
extern float coshf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __coshf (float __x) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic sine of X.  */
extern float sinhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sinhf (float __x) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic tangent of X.  */
extern float tanhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __tanhf (float __x) __attribute__ ((__nothrow__ , __leaf__));



/* Cosine and sine of X.  */
 extern void sincosf (float __x, float *__sinx, float *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosf (float __x, float *__sinx, float *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




/* Hyperbolic arc cosine of X.  */
extern float acoshf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __acoshf (float __x) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic arc sine of X.  */
extern float asinhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __asinhf (float __x) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic arc tangent of X.  */
extern float atanhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atanhf (float __x) __attribute__ ((__nothrow__ , __leaf__));



/* Exponential and logarithmic functions.  */


/* Exponential function of X.  */
 extern float expf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __expf (float __x) __attribute__ ((__nothrow__ , __leaf__));

/* Break VALUE into a normalized fraction and an integral power of 2.  */
extern float frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern float __frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));

/* X times (two to the EXP power).  */
extern float ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern float __ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));

/* Natural logarithm of X.  */
 extern float logf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __logf (float __x) __attribute__ ((__nothrow__ , __leaf__));

/* Base-ten logarithm of X.  */
extern float log10f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log10f (float __x) __attribute__ ((__nothrow__ , __leaf__));

/* Break VALUE into integral and fractional parts.  */
extern float modff (float __x, float *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern float __modff (float __x, float *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



/* A function missing in all standards: compute exponent to base ten.  */
extern float exp10f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __exp10f (float __x) __attribute__ ((__nothrow__ , __leaf__));
/* Another name occasionally used.  */
extern float pow10f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __pow10f (float __x) __attribute__ ((__nothrow__ , __leaf__));




/* Return exp(X) - 1.  */
extern float expm1f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __expm1f (float __x) __attribute__ ((__nothrow__ , __leaf__));

/* Return log(1 + X).  */
extern float log1pf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log1pf (float __x) __attribute__ ((__nothrow__ , __leaf__));

/* Return the base 2 signed integral exponent of X.  */
extern float logbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __logbf (float __x) __attribute__ ((__nothrow__ , __leaf__));





/* Compute base-2 exponential of X.  */
extern float exp2f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __exp2f (float __x) __attribute__ ((__nothrow__ , __leaf__));

/* Compute base-2 logarithm of X.  */
extern float log2f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log2f (float __x) __attribute__ ((__nothrow__ , __leaf__));




/* Power functions.  */


/* Return X to the Y power.  */
 extern float powf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __powf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));

/* Return the square root of X.  */
extern float sqrtf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sqrtf (float __x) __attribute__ ((__nothrow__ , __leaf__));




/* Return `sqrt(X*X + Y*Y)'.  */
extern float hypotf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __hypotf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));





/* Return the cube root of X.  */
extern float cbrtf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __cbrtf (float __x) __attribute__ ((__nothrow__ , __leaf__));




/* Nearest integer, absolute value, and remainder functions.  */


/* Smallest integral value not less than X.  */
extern float ceilf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __ceilf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Absolute value of X.  */
extern float fabsf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fabsf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Largest integer not greater than X.  */
extern float floorf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __floorf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Floating-point modulo remainder of X/Y.  */
extern float fmodf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __fmodf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
extern int __isinff (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return nonzero if VALUE is finite and not NaN.  */
extern int __finitef (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));






/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
extern int isinff (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


/* Return nonzero if VALUE is finite and not NaN.  */
extern int finitef (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return the remainder of X/Y.  */
extern float dremf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __dremf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


/* Return the fractional part of X after dividing out `ilogb (X)'.  */
extern float significandf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __significandf (float __x) __attribute__ ((__nothrow__ , __leaf__));




/* Return X with its signed changed to Y's.  */
extern float copysignf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





/* Return representation of qNaN for double type.  */
extern float nanf (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __nanf (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




/* Return nonzero if VALUE is not a number.  */
extern int __isnanf (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





/* Return nonzero if VALUE is not a number.  */
extern int isnanf (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




/* Bessel functions.  */
extern float j0f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __j0f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float j1f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __j1f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float jnf (int, float) __attribute__ ((__nothrow__ , __leaf__)); extern float __jnf (int, float) __attribute__ ((__nothrow__ , __leaf__));
extern float y0f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __y0f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float y1f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __y1f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float ynf (int, float) __attribute__ ((__nothrow__ , __leaf__)); extern float __ynf (int, float) __attribute__ ((__nothrow__ , __leaf__));





/* Error and gamma functions.  */
extern float erff (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __erff (float) __attribute__ ((__nothrow__ , __leaf__));
extern float erfcf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __erfcf (float) __attribute__ ((__nothrow__ , __leaf__));
extern float lgammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __lgammaf (float) __attribute__ ((__nothrow__ , __leaf__));





/* True gamma function.  */
extern float tgammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __tgammaf (float) __attribute__ ((__nothrow__ , __leaf__));




/* Obsolete alias for `lgamma'.  */
extern float gammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __gammaf (float) __attribute__ ((__nothrow__ , __leaf__));



/* Reentrant version of lgamma.  This function uses the global variable
   `signgam'.  The reentrant version instead takes a pointer and stores
   the value through it.  */
extern float lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern float __lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));





/* Return the integer nearest X in the direction of the
   prevailing rounding mode.  */
extern float rintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __rintf (float __x) __attribute__ ((__nothrow__ , __leaf__));

/* Return X + epsilon if X < Y, X - epsilon if X > Y.  */
extern float nextafterf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



/* Return X - epsilon.  */
extern float nextdownf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __nextdownf (float __x) __attribute__ ((__nothrow__ , __leaf__));
/* Return X + epsilon.  */
extern float nextupf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __nextupf (float __x) __attribute__ ((__nothrow__ , __leaf__));


/* Return the remainder of integer divison X / Y with infinite precision.  */
extern float remainderf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __remainderf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


/* Return X times (2 to the Nth power).  */
extern float scalbnf (float __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalbnf (float __x, int __n) __attribute__ ((__nothrow__ , __leaf__));


/* Return the binary exponent of X, which must be nonzero.  */
extern int ilogbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf (float __x) __attribute__ ((__nothrow__ , __leaf__));



/* Return X times (2 to the Nth power).  */
extern float scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));

/* Round X to integral value in floating-point format using current
   rounding direction, but do not raise inexact exception.  */
extern float nearbyintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __nearbyintf (float __x) __attribute__ ((__nothrow__ , __leaf__));

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
extern float roundf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __roundf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Round X to the integral value in floating-point format nearest but
   not larger in magnitude.  */
extern float truncf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __truncf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Compute remainder of X and Y and put in *QUO a value with sign of x/y
   and magnitude congruent `mod 2^n' to the magnitude of the integral
   quotient x/y, with n >= 3.  */
extern float remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern float __remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));


/* Conversion functions.  */

/* Round X to nearest integral value according to current rounding
   direction.  */
extern long int lrintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf (float __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf (float __x) __attribute__ ((__nothrow__ , __leaf__));

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
extern long int lroundf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf (float __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf (float __x) __attribute__ ((__nothrow__ , __leaf__));


/* Return positive difference between X and Y.  */
extern float fdimf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __fdimf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));

/* Return maximum numeric value from X and Y.  */
extern float fmaxf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return minimum numeric value from X and Y.  */
extern float fminf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fminf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


/* Classify given number.  */
extern int __fpclassifyf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));

/* Test for negative number.  */
extern int __signbitf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


/* Multiply-add function computed as a ternary operation.  */
extern float fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ , __leaf__)); extern float __fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ , __leaf__));







/* Test for signaling NaN.  */
extern int __issignalingf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));





/* Return X times (2 to the Nth power).  */
extern float scalbf (float __x, float __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalbf (float __x, float __n) __attribute__ ((__nothrow__ , __leaf__));
# 105 "/usr/include/math.h" 2 3 4
#undef _Mdouble_
#undef _Mdouble_BEGIN_NAMESPACE
#undef _Mdouble_END_NAMESPACE
#undef __MATH_PRECNAME
#undef __MATH_DECLARING_DOUBLE
# 139 "/usr/include/math.h" 3 4
/* Include the file of declarations again, this time using `long double'
   instead of `double' and appending l to each function name.  */


#define _Mlong_double_ long double

#define _Mdouble_ _Mlong_double_
#define __MATH_PRECNAME(name,r) name ##l ##r
#define __MATH_DECLARING_DOUBLE 0
#define _Mdouble_BEGIN_NAMESPACE __BEGIN_NAMESPACE_C99
#define _Mdouble_END_NAMESPACE __END_NAMESPACE_C99
#define __MATH_DECLARE_LDOUBLE 1
# 1 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h" 1 3 4
/* Prototype declarations for math functions; helper file for <math.h>.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* NOTE: Because of the special way this file is used by <math.h>, this
   file must NOT be protected from multiple inclusion as header files
   usually are.

   This file provides prototype declarations for the math functions.
   Most functions are declared using the macro:

   __MATHCALL (NAME,[_r], (ARGS...));

   This means there is a function `NAME' returning `double' and a function
   `NAMEf' returning `float'.  Each place `_Mdouble_' appears in the
   prototype, that is actually `double' in the prototype for `NAME' and
   `float' in the prototype for `NAMEf'.  Reentrant variant functions are
   called `NAME_r' and `NAMEf_r'.

   Functions returning other types like `int' are declared using the macro:

   __MATHDECL (TYPE, NAME,[_r], (ARGS...));

   This is just like __MATHCALL but for a function returning `TYPE'
   instead of `_Mdouble_'.  In all of these cases, there is still
   both a `NAME' and a `NAMEf' that takes `float' arguments.

   Note that there must be no whitespace before the argument passed for
   NAME, to make token pasting work with -traditional.  */






/* Trigonometric functions.  */


/* Arc cosine of X.  */
extern long double acosl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __acosl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Arc sine of X.  */
extern long double asinl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __asinl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Arc tangent of X.  */
extern long double atanl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atanl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Arc tangent of Y/X.  */
extern long double atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Cosine of X.  */
 extern long double cosl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cosl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Sine of X.  */
 extern long double sinl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sinl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Tangent of X.  */
extern long double tanl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tanl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Hyperbolic functions.  */

/* Hyperbolic cosine of X.  */
extern long double coshl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __coshl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic sine of X.  */
extern long double sinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic tangent of X.  */
extern long double tanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



/* Cosine and sine of X.  */
 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




/* Hyperbolic arc cosine of X.  */
extern long double acoshl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __acoshl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic arc sine of X.  */
extern long double asinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __asinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic arc tangent of X.  */
extern long double atanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



/* Exponential and logarithmic functions.  */


/* Exponential function of X.  */
 extern long double expl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __expl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Break VALUE into a normalized fraction and an integral power of 2.  */
extern long double frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern long double __frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));

/* X times (two to the EXP power).  */
extern long double ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern long double __ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));

/* Natural logarithm of X.  */
 extern long double logl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __logl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Base-ten logarithm of X.  */
extern long double log10l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log10l (long double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Break VALUE into integral and fractional parts.  */
extern long double modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern long double __modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



/* A function missing in all standards: compute exponent to base ten.  */
extern long double exp10l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __exp10l (long double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Another name occasionally used.  */
extern long double pow10l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __pow10l (long double __x) __attribute__ ((__nothrow__ , __leaf__));




/* Return exp(X) - 1.  */
extern long double expm1l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __expm1l (long double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Return log(1 + X).  */
extern long double log1pl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log1pl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Return the base 2 signed integral exponent of X.  */
extern long double logbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __logbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));





/* Compute base-2 exponential of X.  */
extern long double exp2l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __exp2l (long double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Compute base-2 logarithm of X.  */
extern long double log2l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log2l (long double __x) __attribute__ ((__nothrow__ , __leaf__));




/* Power functions.  */


/* Return X to the Y power.  */
 extern long double powl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __powl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));

/* Return the square root of X.  */
extern long double sqrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sqrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




/* Return `sqrt(X*X + Y*Y)'.  */
extern long double hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));





/* Return the cube root of X.  */
extern long double cbrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cbrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




/* Nearest integer, absolute value, and remainder functions.  */


/* Smallest integral value not less than X.  */
extern long double ceill (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __ceill (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Absolute value of X.  */
extern long double fabsl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fabsl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Largest integer not greater than X.  */
extern long double floorl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __floorl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Floating-point modulo remainder of X/Y.  */
extern long double fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
extern int __isinfl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return nonzero if VALUE is finite and not NaN.  */
extern int __finitel (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));






/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
extern int isinfl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


/* Return nonzero if VALUE is finite and not NaN.  */
extern int finitel (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return the remainder of X/Y.  */
extern long double dreml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __dreml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


/* Return the fractional part of X after dividing out `ilogb (X)'.  */
extern long double significandl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __significandl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




/* Return X with its signed changed to Y's.  */
extern long double copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





/* Return representation of qNaN for double type.  */
extern long double nanl (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




/* Return nonzero if VALUE is not a number.  */
extern int __isnanl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





/* Return nonzero if VALUE is not a number.  */
extern int isnanl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




/* Bessel functions.  */
extern long double j0l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __j0l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double j1l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __j1l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double jnl (int, long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __jnl (int, long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double y0l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __y0l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double y1l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __y1l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double ynl (int, long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __ynl (int, long double) __attribute__ ((__nothrow__ , __leaf__));





/* Error and gamma functions.  */
extern long double erfl (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __erfl (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double erfcl (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __erfcl (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double lgammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __lgammal (long double) __attribute__ ((__nothrow__ , __leaf__));





/* True gamma function.  */
extern long double tgammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tgammal (long double) __attribute__ ((__nothrow__ , __leaf__));




/* Obsolete alias for `lgamma'.  */
extern long double gammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __gammal (long double) __attribute__ ((__nothrow__ , __leaf__));



/* Reentrant version of lgamma.  This function uses the global variable
   `signgam'.  The reentrant version instead takes a pointer and stores
   the value through it.  */
extern long double lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern long double __lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));





/* Return the integer nearest X in the direction of the
   prevailing rounding mode.  */
extern long double rintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __rintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Return X + epsilon if X < Y, X - epsilon if X > Y.  */
extern long double nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



/* Return X - epsilon.  */
extern long double nextdownl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nextdownl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
/* Return X + epsilon.  */
extern long double nextupl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nextupl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


/* Return the remainder of integer divison X / Y with infinite precision.  */
extern long double remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


/* Return X times (2 to the Nth power).  */
extern long double scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ , __leaf__));


/* Return the binary exponent of X, which must be nonzero.  */
extern int ilogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



/* Return X times (2 to the Nth power).  */
extern long double scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));

/* Round X to integral value in floating-point format using current
   rounding direction, but do not raise inexact exception.  */
extern long double nearbyintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nearbyintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
extern long double roundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __roundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Round X to the integral value in floating-point format nearest but
   not larger in magnitude.  */
extern long double truncl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __truncl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Compute remainder of X and Y and put in *QUO a value with sign of x/y
   and magnitude congruent `mod 2^n' to the magnitude of the integral
   quotient x/y, with n >= 3.  */
extern long double remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern long double __remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));


/* Conversion functions.  */

/* Round X to nearest integral value according to current rounding
   direction.  */
extern long int lrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
extern long int lroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


/* Return positive difference between X and Y.  */
extern long double fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));

/* Return maximum numeric value from X and Y.  */
extern long double fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

/* Return minimum numeric value from X and Y.  */
extern long double fminl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


/* Classify given number.  */
extern int __fpclassifyl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));

/* Test for negative number.  */
extern int __signbitl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


/* Multiply-add function computed as a ternary operation.  */
extern long double fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ , __leaf__));







/* Test for signaling NaN.  */
extern int __issignalingl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));





/* Return X times (2 to the Nth power).  */
extern long double scalbl (long double __x, long double __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalbl (long double __x, long double __n) __attribute__ ((__nothrow__ , __leaf__));
# 152 "/usr/include/math.h" 2 3 4
#undef _Mdouble_
#undef _Mdouble_BEGIN_NAMESPACE
#undef _Mdouble_END_NAMESPACE
#undef __MATH_PRECNAME
#undef __MATH_DECLARING_DOUBLE




#undef __MATHDECL_1
#undef __MATHDECL
#undef __MATHCALL



/* This variable is used by `gamma' and `lgamma'.  */
extern int signgam;



/* ISO C99 defines some generic macros which work on any data type.  */


/* Get the architecture specific values describing the floating-point
   evaluation.  The following symbols will get defined:

    float_t	floating-point type at least as wide as `float' used
		to evaluate `float' expressions
    double_t	floating-point type at least as wide as `double' used
		to evaluate `double' expressions

    FLT_EVAL_METHOD
		Defined to
		  0	if `float_t' is `float' and `double_t' is `double'
		  1	if `float_t' and `double_t' are `double'
		  2	if `float_t' and `double_t' are `long double'
		  else	`float_t' and `double_t' are unspecified

    INFINITY	representation of the infinity value of type `float'

    FP_FAST_FMA
    FP_FAST_FMAF
    FP_FAST_FMAL
		If defined it indicates that the `fma' function
		generally executes about as fast as a multiply and an add.
		This macro is defined only iff the `fma' function is
		implemented directly with a hardware multiply-add instructions.

    FP_ILOGB0	Expands to a value returned by `ilogb (0.0)'.
    FP_ILOGBNAN	Expands to a value returned by `ilogb (NAN)'.

    DECIMAL_DIG	Number of decimal digits supported by conversion between
		decimal and all internal floating-point formats.

*/

/* All floating-point numbers can be put in one of these categories.  */
enum
  {
    FP_NAN =
#define FP_NAN 0
      0,
    FP_INFINITE =
#define FP_INFINITE 1
      1,
    FP_ZERO =
#define FP_ZERO 2
      2,
    FP_SUBNORMAL =
#define FP_SUBNORMAL 3
      3,
    FP_NORMAL =
#define FP_NORMAL 4
      4
  };

/* GCC bug 66462 means we cannot use the math builtins with -fsignaling-nan,
   so disable builtins if this is enabled.  When fixed in a newer GCC,
   the __SUPPORT_SNAN__ check may be skipped for those versions.  */

/* Return number of classification appropriate for X.  */


#define fpclassify(x) __builtin_fpclassify (FP_NAN, FP_INFINITE, FP_NORMAL, FP_SUBNORMAL, FP_ZERO, x)
# 248 "/usr/include/math.h" 3 4
/* Return nonzero value if sign of X is negative.  */

#define signbit(x) (sizeof (x) == sizeof (float) ? __builtin_signbitf (x) : sizeof (x) == sizeof (double) ? __builtin_signbit (x) : __builtin_signbitl (x))
# 268 "/usr/include/math.h" 3 4
/* Return nonzero value if X is not +-Inf or NaN.  */

#define isfinite(x) __builtin_isfinite (x)
# 282 "/usr/include/math.h" 3 4
/* Return nonzero value if X is neither zero, subnormal, Inf, nor NaN.  */

#define isnormal(x) __builtin_isnormal (x)




/* Return nonzero value if X is a NaN.  We could use `fpclassify' but
   we already have this functions `__isnan' and it is faster.  */

#define isnan(x) __builtin_isnan (x)
# 304 "/usr/include/math.h" 3 4
/* Return nonzero value if X is positive or negative infinity.  */

#define isinf(x) __builtin_isinf_sign (x)
# 318 "/usr/include/math.h" 3 4
/* Bitmasks for the math_errhandling macro.  */
#define MATH_ERRNO 1
#define MATH_ERREXCEPT 2

/* By default all functions support both errno and exception handling.
   In gcc's fast math mode and if inline functions are defined this
   might not be true.  */







/* Return nonzero value if X is a signaling NaN.  */

#define issignaling(x) (sizeof (x) == sizeof (float) ? __issignalingf (x) : __issignaling (x))
# 346 "/usr/include/math.h" 3 4
/* Support for various different standard error handling behaviors.  */
typedef enum
{
  _IEEE_ = -1, /* According to IEEE 754/IEEE 854.  */
  _SVID_, /* According to System V, release 4.  */
  _XOPEN_, /* Nowadays also Unix98.  */
  _POSIX_,
  _ISOC_ /* Actually this is ISO C99.  */
} _LIB_VERSION_TYPE;

/* This variable can be changed at run-time to any of the values above to
   affect floating point error handling behavior (it may also be necessary
   to change the hardware FPU exception settings).  */
extern _LIB_VERSION_TYPE _LIB_VERSION;




/* In SVID error handling, `matherr' is called with this description
   of the exceptional condition.

   We have a problem when using C++ since `exception' is a reserved
   name in C++.  */



struct exception

  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };




extern int matherr (struct exception *__exc);


#define X_TLOSS 1.41484755040568800000e+16

/* Types of exceptions in the `type' field.  */
#define DOMAIN 1
#define SING 2
#define OVERFLOW 3
#define UNDERFLOW 4
#define TLOSS 5
#define PLOSS 6

/* SVID mode specifies returning this large value instead of infinity.  */
#define HUGE 3.40282347e+38F
# 411 "/usr/include/math.h" 3 4
/* Some useful constants.  */

#define M_E 2.7182818284590452354
#define M_LOG2E 1.4426950408889634074
#define M_LOG10E 0.43429448190325182765
#define M_LN2 0.69314718055994530942
#define M_LN10 2.30258509299404568402
#define M_PI 3.14159265358979323846
#define M_PI_2 1.57079632679489661923
#define M_PI_4 0.78539816339744830962
#define M_1_PI 0.31830988618379067154
#define M_2_PI 0.63661977236758134308
#define M_2_SQRTPI 1.12837916709551257390
#define M_SQRT2 1.41421356237309504880
#define M_SQRT1_2 0.70710678118654752440


/* The above constants are not adequate for computation using `long double's.
   Therefore we provide as an extension constants with similar names as a
   GNU extension.  Provide enough digits for the 128-bit IEEE quad.  */

#define M_El 2.718281828459045235360287471352662498L
#define M_LOG2El 1.442695040888963407359924681001892137L
#define M_LOG10El 0.434294481903251827651128918916605082L
#define M_LN2l 0.693147180559945309417232121458176568L
#define M_LN10l 2.302585092994045684017991454684364208L
#define M_PIl 3.141592653589793238462643383279502884L
#define M_PI_2l 1.570796326794896619231321691639751442L
#define M_PI_4l 0.785398163397448309615660845819875721L
#define M_1_PIl 0.318309886183790671537767526745028724L
#define M_2_PIl 0.636619772367581343075535053490057448L
#define M_2_SQRTPIl 1.128379167095512573896158903121545172L
#define M_SQRT2l 1.414213562373095048801688724209698079L
#define M_SQRT1_2l 0.707106781186547524400844362104849039L



/* When compiling in strict ISO C compatible mode we must not use the
   inline functions since they, among other things, do not set the
   `errno' variable correctly.  */

#define __NO_MATH_INLINES 1



/* ISO C99 defines some macros to compare number while taking care for
   unordered numbers.  Many FPUs provide special instructions to support
   these operations.  Generic support in GCC for these as builtins went
   in before 3.0.0, but not all cpus added their patterns.  We define
   versions that use the builtins here, and <bits/mathinline.h> will
   undef/redefine as appropriate for the specific GCC version in use.  */
#define isgreater(x,y) __builtin_isgreater(x, y)
#define isgreaterequal(x,y) __builtin_isgreaterequal(x, y)
#define isless(x,y) __builtin_isless(x, y)
#define islessequal(x,y) __builtin_islessequal(x, y)
#define islessgreater(x,y) __builtin_islessgreater(x, y)
#define isunordered(u,v) __builtin_isunordered(u, v)


/* Get machine-dependent inline versions (if there are any).  */

# 1 "/usr/include/arm-linux-gnueabihf/bits/mathinline.h" 1 3 4
/* This file should provide inline versions of math functions.

   Surround GCC-specific parts with #ifdef __GNUC__, and use `__extern_inline'.

   This file should define __MATH_INLINES if functions are actually defined as
   inlines.  */
# 473 "/usr/include/math.h" 2 3 4


/* Define special entry points to use when the compiler got told to
   only expect finite results.  */

# 1 "/usr/include/arm-linux-gnueabihf/bits/math-finite.h" 1 3 4
/* Entry points to finite-math-only compiler runs.
   Copyright (C) 2011-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* acos.  */
extern double acos (double) __asm__ ("" "__acos_finite") __attribute__ ((__nothrow__ , __leaf__));

extern float acosf (float) __asm__ ("" "__acosf_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double acosl (long double) __asm__ ("" "__acos_finite") __attribute__ ((__nothrow__ , __leaf__));







/* acosh.  */
extern double acosh (double) __asm__ ("" "__acosh_finite") __attribute__ ((__nothrow__ , __leaf__));


extern float acoshf (float) __asm__ ("" "__acoshf_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double acoshl (long double) __asm__ ("" "__acosh_finite") __attribute__ ((__nothrow__ , __leaf__));






/* asin.  */
extern double asin (double) __asm__ ("" "__asin_finite") __attribute__ ((__nothrow__ , __leaf__));

extern float asinf (float) __asm__ ("" "__asinf_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double asinl (long double) __asm__ ("" "__asin_finite") __attribute__ ((__nothrow__ , __leaf__));






/* atan2.  */
extern double atan2 (double, double) __asm__ ("" "__atan2_finite") __attribute__ ((__nothrow__ , __leaf__));

extern float atan2f (float, float) __asm__ ("" "__atan2f_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double atan2l (long double, long double) __asm__ ("" "__atan2_finite") __attribute__ ((__nothrow__ , __leaf__))
                      ;
# 80 "/usr/include/arm-linux-gnueabihf/bits/math-finite.h" 3 4
/* atanh.  */
extern double atanh (double) __asm__ ("" "__atanh_finite") __attribute__ ((__nothrow__ , __leaf__));


extern float atanhf (float) __asm__ ("" "__atanhf_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double atanhl (long double) __asm__ ("" "__atanh_finite") __attribute__ ((__nothrow__ , __leaf__));






/* cosh.  */
extern double cosh (double) __asm__ ("" "__cosh_finite") __attribute__ ((__nothrow__ , __leaf__));

extern float coshf (float) __asm__ ("" "__coshf_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double coshl (long double) __asm__ ("" "__cosh_finite") __attribute__ ((__nothrow__ , __leaf__));






/* exp.  */
extern double exp (double) __asm__ ("" "__exp_finite") __attribute__ ((__nothrow__ , __leaf__));

extern float expf (float) __asm__ ("" "__expf_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double expl (long double) __asm__ ("" "__exp_finite") __attribute__ ((__nothrow__ , __leaf__));







/* exp10.  */
extern double exp10 (double) __asm__ ("" "__exp10_finite") __attribute__ ((__nothrow__ , __leaf__));
extern float exp10f (float) __asm__ ("" "__exp10f_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double exp10l (long double) __asm__ ("" "__exp10_finite") __attribute__ ((__nothrow__ , __leaf__));





/* pow10.  */
extern double pow10 (double) __asm__ ("" "__exp10_finite") __attribute__ ((__nothrow__ , __leaf__));
extern float pow10f (float) __asm__ ("" "__exp10f_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double pow10l (long double) __asm__ ("" "__exp10_finite") __attribute__ ((__nothrow__ , __leaf__));







/* exp2.  */
extern double exp2 (double) __asm__ ("" "__exp2_finite") __attribute__ ((__nothrow__ , __leaf__));
extern float exp2f (float) __asm__ ("" "__exp2f_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double exp2l (long double) __asm__ ("" "__exp2_finite") __attribute__ ((__nothrow__ , __leaf__));






/* fmod.  */
extern double fmod (double, double) __asm__ ("" "__fmod_finite") __attribute__ ((__nothrow__ , __leaf__));

extern float fmodf (float, float) __asm__ ("" "__fmodf_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double fmodl (long double, long double) __asm__ ("" "__fmod_finite") __attribute__ ((__nothrow__ , __leaf__))
                     ;
# 173 "/usr/include/arm-linux-gnueabihf/bits/math-finite.h" 3 4
/* hypot.  */
extern double hypot (double, double) __asm__ ("" "__hypot_finite") __attribute__ ((__nothrow__ , __leaf__));


extern float hypotf (float, float) __asm__ ("" "__hypotf_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double hypotl (long double, long double) __asm__ ("" "__hypot_finite") __attribute__ ((__nothrow__ , __leaf__))
                      ;
# 190 "/usr/include/arm-linux-gnueabihf/bits/math-finite.h" 3 4
/* j0.  */
extern double j0 (double) __asm__ ("" "__j0_finite") __attribute__ ((__nothrow__ , __leaf__));


extern float j0f (float) __asm__ ("" "__j0f_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double j0l (long double) __asm__ ("" "__j0_finite") __attribute__ ((__nothrow__ , __leaf__));







/* y0.  */
extern double y0 (double) __asm__ ("" "__y0_finite") __attribute__ ((__nothrow__ , __leaf__));


extern float y0f (float) __asm__ ("" "__y0f_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double y0l (long double) __asm__ ("" "__y0_finite") __attribute__ ((__nothrow__ , __leaf__));







/* j1.  */
extern double j1 (double) __asm__ ("" "__j1_finite") __attribute__ ((__nothrow__ , __leaf__));


extern float j1f (float) __asm__ ("" "__j1f_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double j1l (long double) __asm__ ("" "__j1_finite") __attribute__ ((__nothrow__ , __leaf__));







/* y1.  */
extern double y1 (double) __asm__ ("" "__y1_finite") __attribute__ ((__nothrow__ , __leaf__));


extern float y1f (float) __asm__ ("" "__y1f_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double y1l (long double) __asm__ ("" "__y1_finite") __attribute__ ((__nothrow__ , __leaf__));







/* jn.  */
extern double jn (int, double) __asm__ ("" "__jn_finite") __attribute__ ((__nothrow__ , __leaf__));


extern float jnf (int, float) __asm__ ("" "__jnf_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double jnl (int, long double) __asm__ ("" "__jn_finite") __attribute__ ((__nothrow__ , __leaf__));







/* yn.  */
extern double yn (int, double) __asm__ ("" "__yn_finite") __attribute__ ((__nothrow__ , __leaf__));


extern float ynf (int, float) __asm__ ("" "__ynf_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double ynl (int, long double) __asm__ ("" "__yn_finite") __attribute__ ((__nothrow__ , __leaf__));







/* lgamma_r.  */
extern double lgamma_r (double, int *) __asm__ ("" "__lgamma_r_finite") __attribute__ ((__nothrow__ , __leaf__));

extern float lgammaf_r (float, int *) __asm__ ("" "__lgammaf_r_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double lgammal_r (long double, int *) __asm__ ("" "__lgamma_r_finite") __attribute__ ((__nothrow__ , __leaf__))
                         ;
# 296 "/usr/include/arm-linux-gnueabihf/bits/math-finite.h" 3 4
extern double __lgamma_r_finite (double, int *);
extern float __lgammaf_r_finite (float, int *);

extern long double __lgammal_r_finite (long double, int *) __asm__ ("" "__lgamma_r_finite") __attribute__ ((__nothrow__ , __leaf__))
                         ;






/* lgamma.  */
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) double __attribute__ ((__nothrow__ , __leaf__)) lgamma (double __d)
{

  return __lgamma_r_finite (__d, &signgam);




}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) float __attribute__ ((__nothrow__ , __leaf__)) lgammaf (float __d)
{

  return __lgammaf_r_finite (__d, &signgam);




}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) long double __attribute__ ((__nothrow__ , __leaf__)) lgammal (long double __d)
{

  return __lgammal_r_finite (__d, &signgam);




}





/* gamma.  */
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) double __attribute__ ((__nothrow__ , __leaf__)) gamma (double __d)
{
  return __lgamma_r_finite (__d, &signgam);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) float __attribute__ ((__nothrow__ , __leaf__)) gammaf (float __d)
{
  return __lgammaf_r_finite (__d, &signgam);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) long double __attribute__ ((__nothrow__ , __leaf__)) gammal (long double __d)
{
  return __lgammal_r_finite (__d, &signgam);
}




/* log.  */
extern double log (double) __asm__ ("" "__log_finite") __attribute__ ((__nothrow__ , __leaf__));

extern float logf (float) __asm__ ("" "__logf_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double logl (long double) __asm__ ("" "__log_finite") __attribute__ ((__nothrow__ , __leaf__));






/* log10.  */
extern double log10 (double) __asm__ ("" "__log10_finite") __attribute__ ((__nothrow__ , __leaf__));

extern float log10f (float) __asm__ ("" "__log10f_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double log10l (long double) __asm__ ("" "__log10_finite") __attribute__ ((__nothrow__ , __leaf__));







/* log2.  */
extern double log2 (double) __asm__ ("" "__log2_finite") __attribute__ ((__nothrow__ , __leaf__));
extern float log2f (float) __asm__ ("" "__log2f_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double log2l (long double) __asm__ ("" "__log2_finite") __attribute__ ((__nothrow__ , __leaf__));






/* pow.  */
extern double pow (double, double) __asm__ ("" "__pow_finite") __attribute__ ((__nothrow__ , __leaf__));

extern float powf (float, float) __asm__ ("" "__powf_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double powl (long double, long double) __asm__ ("" "__pow_finite") __attribute__ ((__nothrow__ , __leaf__))
                    ;
# 417 "/usr/include/arm-linux-gnueabihf/bits/math-finite.h" 3 4
/* remainder.  */
extern double remainder (double, double) __asm__ ("" "__remainder_finite") __attribute__ ((__nothrow__ , __leaf__));


extern float remainderf (float, float) __asm__ ("" "__remainderf_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double remainderl (long double, long double) __asm__ ("" "__remainder_finite") __attribute__ ((__nothrow__ , __leaf__))
                          ;
# 435 "/usr/include/arm-linux-gnueabihf/bits/math-finite.h" 3 4
/* scalb.  */
extern double scalb (double, double) __asm__ ("" "__scalb_finite") __attribute__ ((__nothrow__ , __leaf__));


extern float scalbf (float, float) __asm__ ("" "__scalbf_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double scalbl (long double, long double) __asm__ ("" "__scalb_finite") __attribute__ ((__nothrow__ , __leaf__))
                      ;







/* sinh.  */
extern double sinh (double) __asm__ ("" "__sinh_finite") __attribute__ ((__nothrow__ , __leaf__));

extern float sinhf (float) __asm__ ("" "__sinhf_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double sinhl (long double) __asm__ ("" "__sinh_finite") __attribute__ ((__nothrow__ , __leaf__));






/* sqrt.  */
extern double sqrt (double) __asm__ ("" "__sqrt_finite") __attribute__ ((__nothrow__ , __leaf__));

extern float sqrtf (float) __asm__ ("" "__sqrtf_finite") __attribute__ ((__nothrow__ , __leaf__));


extern long double sqrtl (long double) __asm__ ("" "__sqrt_finite") __attribute__ ((__nothrow__ , __leaf__));







/* tgamma.  */
extern double __gamma_r_finite (double, int *);
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) double __attribute__ ((__nothrow__ , __leaf__)) tgamma (double __d)
{
  int __local_signgam = 0;
  double __res = __gamma_r_finite (__d, &__local_signgam);
  return __local_signgam < 0 ? -__res : __res;
}
extern float __gammaf_r_finite (float, int *);
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) float __attribute__ ((__nothrow__ , __leaf__)) tgammaf (float __d)
{
  int __local_signgam = 0;
  float __res = __gammaf_r_finite (__d, &__local_signgam);
  return __local_signgam < 0 ? -__res : __res;
}

extern long double __gammal_r_finite (long double, int *);
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) long double __attribute__ ((__nothrow__ , __leaf__)) tgammal (long double __d)
{
  int __local_signgam = 0;

  long double __res = __gamma_r_finite (__d, &__local_signgam);



  return __local_signgam < 0 ? -__res : __res;
}
# 479 "/usr/include/math.h" 2 3 4



/* If we've still got undefined comparison macros, provide defaults.  */

/* Return nonzero value if X is greater than Y.  */







/* Return nonzero value if X is greater than or equal to Y.  */







/* Return nonzero value if X is less than Y.  */







/* Return nonzero value if X is less than or equal to Y.  */







/* Return nonzero value if either X is less than Y or Y is less than X.  */







/* Return nonzero value if arguments are unordered.  */
# 534 "/usr/include/math.h" 3 4

# 97 "pifunk.c" 2
# 1 "/usr/include/tgmath.h" 1 3 4
/* Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.22 Type-generic math	<tgmath.h>
 */


#define _TGMATH_H 1

/* Include the needed headers.  */
# 1 "/usr/include/math.h" 1 3 4
/* Declarations for math functions.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.12 Mathematics	<math.h>
 */
# 27 "/usr/include/tgmath.h" 2 3 4
# 1 "/usr/include/complex.h" 1 3 4
/* Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99:  7.3 Complex arithmetic	<complex.h>
 */


#define _COMPLEX_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/complex.h" 2 3 4

/* Get general and ISO C99 specific information.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/mathdef.h" 1 3 4
/* Copyright (C) 1999-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */
# 29 "/usr/include/complex.h" 2 3 4



/* We might need to add support for more compilers here.  But since ISO
   C99 is out hopefully all maintained compilers will soon provide the data
   types `float complex' and `double complex'.  */




#define complex _Complex

/* Narrowest imaginary unit.  This depends on the floating-point
   evaluation method.
   XXX This probably has to go into a gcc related file.  */
#define _Complex_I (__extension__ 1.0iF)

/* Another more descriptive name is `I'.
   XXX Once we have the imaginary support switch this to _Imaginary_I.  */
#undef I
#define I _Complex_I


/* Macros to expand into expression of specified complex type.  */
#define CMPLX(x,y) __builtin_complex ((double) (x), (double) (y))
#define CMPLXF(x,y) __builtin_complex ((float) (x), (float) (y))
#define CMPLXL(x,y) __builtin_complex ((long double) (x), (long double) (y))


/* The file <bits/cmathcalls.h> contains the prototypes for all the
   actual math functions.  These macros are used for those prototypes,
   so we can easily declare each function as both `name' and `__name',
   and can declare the float versions `namef' and `__namef'.  */

#define __MATHCALL(function,args) __MATHDECL (_Mdouble_complex_,function, args)

#define __MATHDECL(type,function,args) __MATHDECL_1(type, function, args); __MATHDECL_1(type, __CONCAT(__,function), args)


#define __MATHDECL_1(type,function,args) extern type __MATH_PRECNAME(function) args __THROW


#define _Mdouble_ double
#define __MATH_PRECNAME(name) name
# 1 "/usr/include/arm-linux-gnueabihf/bits/cmathcalls.h" 1 3 4
/* Prototype declarations for complex math functions;
   helper file for <complex.h>.
   Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* NOTE: Because of the special way this file is used by <complex.h>, this
   file must NOT be protected from multiple inclusion as header files
   usually are.

   This file provides prototype declarations for the math functions.
   Most functions are declared using the macro:

   __MATHCALL (NAME, (ARGS...));

   This means there is a function `NAME' returning `double' and a function
   `NAMEf' returning `float'.  Each place `_Mdouble_' appears in the
   prototype, that is actually `double' in the prototype for `NAME' and
   `float' in the prototype for `NAMEf'.  Reentrant variant functions are
   called `NAME_r' and `NAMEf_r'.

   Functions returning other types like `int' are declared using the macro:

   __MATHDECL (TYPE, NAME, (ARGS...));

   This is just like __MATHCALL but for a function returning `TYPE'
   instead of `_Mdouble_'.  In all of these cases, there is still
   both a `NAME' and a `NAMEf' that takes `float' arguments.  */





#define _Mdouble_complex_ _Mdouble_ _Complex


/* Trigonometric functions.  */

/* Arc cosine of Z.  */
extern double _Complex cacos (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern double _Complex __cacos (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));
/* Arc sine of Z.  */
extern double _Complex casin (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern double _Complex __casin (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));
/* Arc tangent of Z.  */
extern double _Complex catan (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern double _Complex __catan (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));

/* Cosine of Z.  */
extern double _Complex ccos (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern double _Complex __ccos (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));
/* Sine of Z.  */
extern double _Complex csin (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern double _Complex __csin (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));
/* Tangent of Z.  */
extern double _Complex ctan (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern double _Complex __ctan (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));


/* Hyperbolic functions.  */

/* Hyperbolic arc cosine of Z.  */
extern double _Complex cacosh (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern double _Complex __cacosh (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic arc sine of Z.  */
extern double _Complex casinh (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern double _Complex __casinh (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic arc tangent of Z.  */
extern double _Complex catanh (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern double _Complex __catanh (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));

/* Hyperbolic cosine of Z.  */
extern double _Complex ccosh (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern double _Complex __ccosh (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic sine of Z.  */
extern double _Complex csinh (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern double _Complex __csinh (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic tangent of Z.  */
extern double _Complex ctanh (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern double _Complex __ctanh (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));


/* Exponential and logarithmic functions.  */

/* Exponential function of Z.  */
extern double _Complex cexp (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern double _Complex __cexp (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));

/* Natural logarithm of Z.  */
extern double _Complex clog (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern double _Complex __clog (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));


/* The base 10 logarithm is not defined by the standard but to implement
   the standard C++ library it is handy.  */
extern double _Complex clog10 (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern double _Complex __clog10 (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));


/* Power functions.  */

/* Return X to the Y power.  */
extern double _Complex cpow (double _Complex __x, double _Complex __y) __attribute__ ((__nothrow__ , __leaf__)); extern double _Complex __cpow (double _Complex __x, double _Complex __y) __attribute__ ((__nothrow__ , __leaf__));

/* Return the square root of Z.  */
extern double _Complex csqrt (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern double _Complex __csqrt (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));


/* Absolute value, conjugates, and projection.  */

/* Absolute value of Z.  */
extern double cabs (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern double __cabs (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));

/* Argument value of Z.  */
extern double carg (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern double __carg (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));

/* Complex conjugate of Z.  */
extern double _Complex conj (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern double _Complex __conj (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));

/* Projection of Z onto the Riemann sphere.  */
extern double _Complex cproj (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern double _Complex __cproj (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));


/* Decomposing complex values.  */

/* Imaginary part of Z.  */
extern double cimag (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern double __cimag (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));

/* Real part of Z.  */
extern double creal (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern double __creal (double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));


/* Now some optimized versions.  GCC has handy notations for these
   functions.  Recent GCC handles these as builtin functions so does
   not need inlines.  */
# 74 "/usr/include/complex.h" 2 3 4
#undef _Mdouble_
#undef __MATH_PRECNAME

/* Now the float versions.  */



#define _Mdouble_ _Mfloat_
#define __MATH_PRECNAME(name) name ##f
# 1 "/usr/include/arm-linux-gnueabihf/bits/cmathcalls.h" 1 3 4
/* Prototype declarations for complex math functions;
   helper file for <complex.h>.
   Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* NOTE: Because of the special way this file is used by <complex.h>, this
   file must NOT be protected from multiple inclusion as header files
   usually are.

   This file provides prototype declarations for the math functions.
   Most functions are declared using the macro:

   __MATHCALL (NAME, (ARGS...));

   This means there is a function `NAME' returning `double' and a function
   `NAMEf' returning `float'.  Each place `_Mdouble_' appears in the
   prototype, that is actually `double' in the prototype for `NAME' and
   `float' in the prototype for `NAMEf'.  Reentrant variant functions are
   called `NAME_r' and `NAMEf_r'.

   Functions returning other types like `int' are declared using the macro:

   __MATHDECL (TYPE, NAME, (ARGS...));

   This is just like __MATHCALL but for a function returning `TYPE'
   instead of `_Mdouble_'.  In all of these cases, there is still
   both a `NAME' and a `NAMEf' that takes `float' arguments.  */





#define _Mdouble_complex_ _Mdouble_ _Complex


/* Trigonometric functions.  */

/* Arc cosine of Z.  */
extern float _Complex cacosf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern float _Complex __cacosf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__));
/* Arc sine of Z.  */
extern float _Complex casinf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern float _Complex __casinf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__));
/* Arc tangent of Z.  */
extern float _Complex catanf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern float _Complex __catanf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__));

/* Cosine of Z.  */
extern float _Complex ccosf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern float _Complex __ccosf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__));
/* Sine of Z.  */
extern float _Complex csinf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern float _Complex __csinf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__));
/* Tangent of Z.  */
extern float _Complex ctanf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern float _Complex __ctanf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__));


/* Hyperbolic functions.  */

/* Hyperbolic arc cosine of Z.  */
extern float _Complex cacoshf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern float _Complex __cacoshf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic arc sine of Z.  */
extern float _Complex casinhf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern float _Complex __casinhf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic arc tangent of Z.  */
extern float _Complex catanhf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern float _Complex __catanhf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__));

/* Hyperbolic cosine of Z.  */
extern float _Complex ccoshf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern float _Complex __ccoshf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic sine of Z.  */
extern float _Complex csinhf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern float _Complex __csinhf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic tangent of Z.  */
extern float _Complex ctanhf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern float _Complex __ctanhf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__));


/* Exponential and logarithmic functions.  */

/* Exponential function of Z.  */
extern float _Complex cexpf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern float _Complex __cexpf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__));

/* Natural logarithm of Z.  */
extern float _Complex clogf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern float _Complex __clogf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__));


/* The base 10 logarithm is not defined by the standard but to implement
   the standard C++ library it is handy.  */
extern float _Complex clog10f (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern float _Complex __clog10f (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__));


/* Power functions.  */

/* Return X to the Y power.  */
extern float _Complex cpowf (float _Complex __x, float _Complex __y) __attribute__ ((__nothrow__ , __leaf__)); extern float _Complex __cpowf (float _Complex __x, float _Complex __y) __attribute__ ((__nothrow__ , __leaf__));

/* Return the square root of Z.  */
extern float _Complex csqrtf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern float _Complex __csqrtf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__));


/* Absolute value, conjugates, and projection.  */

/* Absolute value of Z.  */
extern float cabsf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern float __cabsf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__));

/* Argument value of Z.  */
extern float cargf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern float __cargf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__));

/* Complex conjugate of Z.  */
extern float _Complex conjf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern float _Complex __conjf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__));

/* Projection of Z onto the Riemann sphere.  */
extern float _Complex cprojf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern float _Complex __cprojf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__));


/* Decomposing complex values.  */

/* Imaginary part of Z.  */
extern float cimagf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern float __cimagf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__));

/* Real part of Z.  */
extern float crealf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern float __crealf (float _Complex __z) __attribute__ ((__nothrow__ , __leaf__));


/* Now some optimized versions.  GCC has handy notations for these
   functions.  Recent GCC handles these as builtin functions so does
   not need inlines.  */
# 84 "/usr/include/complex.h" 2 3 4
#undef _Mdouble_
#undef __MATH_PRECNAME

/* And the long double versions.  It is non-critical to define them
   here unconditionally since `long double' is required in ISO C99.  */
# 100 "/usr/include/complex.h" 3 4
#define _Mdouble_ _Mlong_double_
#define __MATH_PRECNAME(name) name ##l
# 1 "/usr/include/arm-linux-gnueabihf/bits/cmathcalls.h" 1 3 4
/* Prototype declarations for complex math functions;
   helper file for <complex.h>.
   Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* NOTE: Because of the special way this file is used by <complex.h>, this
   file must NOT be protected from multiple inclusion as header files
   usually are.

   This file provides prototype declarations for the math functions.
   Most functions are declared using the macro:

   __MATHCALL (NAME, (ARGS...));

   This means there is a function `NAME' returning `double' and a function
   `NAMEf' returning `float'.  Each place `_Mdouble_' appears in the
   prototype, that is actually `double' in the prototype for `NAME' and
   `float' in the prototype for `NAMEf'.  Reentrant variant functions are
   called `NAME_r' and `NAMEf_r'.

   Functions returning other types like `int' are declared using the macro:

   __MATHDECL (TYPE, NAME, (ARGS...));

   This is just like __MATHCALL but for a function returning `TYPE'
   instead of `_Mdouble_'.  In all of these cases, there is still
   both a `NAME' and a `NAMEf' that takes `float' arguments.  */





#define _Mdouble_complex_ _Mdouble_ _Complex


/* Trigonometric functions.  */

/* Arc cosine of Z.  */
extern long double _Complex cacosl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double _Complex __cacosl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));
/* Arc sine of Z.  */
extern long double _Complex casinl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double _Complex __casinl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));
/* Arc tangent of Z.  */
extern long double _Complex catanl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double _Complex __catanl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));

/* Cosine of Z.  */
extern long double _Complex ccosl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double _Complex __ccosl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));
/* Sine of Z.  */
extern long double _Complex csinl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double _Complex __csinl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));
/* Tangent of Z.  */
extern long double _Complex ctanl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double _Complex __ctanl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));


/* Hyperbolic functions.  */

/* Hyperbolic arc cosine of Z.  */
extern long double _Complex cacoshl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double _Complex __cacoshl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic arc sine of Z.  */
extern long double _Complex casinhl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double _Complex __casinhl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic arc tangent of Z.  */
extern long double _Complex catanhl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double _Complex __catanhl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));

/* Hyperbolic cosine of Z.  */
extern long double _Complex ccoshl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double _Complex __ccoshl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic sine of Z.  */
extern long double _Complex csinhl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double _Complex __csinhl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));
/* Hyperbolic tangent of Z.  */
extern long double _Complex ctanhl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double _Complex __ctanhl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));


/* Exponential and logarithmic functions.  */

/* Exponential function of Z.  */
extern long double _Complex cexpl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double _Complex __cexpl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));

/* Natural logarithm of Z.  */
extern long double _Complex clogl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double _Complex __clogl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));


/* The base 10 logarithm is not defined by the standard but to implement
   the standard C++ library it is handy.  */
extern long double _Complex clog10l (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double _Complex __clog10l (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));


/* Power functions.  */

/* Return X to the Y power.  */
extern long double _Complex cpowl (long double _Complex __x, long double _Complex __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double _Complex __cpowl (long double _Complex __x, long double _Complex __y) __attribute__ ((__nothrow__ , __leaf__));

/* Return the square root of Z.  */
extern long double _Complex csqrtl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double _Complex __csqrtl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));


/* Absolute value, conjugates, and projection.  */

/* Absolute value of Z.  */
extern long double cabsl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cabsl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));

/* Argument value of Z.  */
extern long double cargl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cargl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));

/* Complex conjugate of Z.  */
extern long double _Complex conjl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double _Complex __conjl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));

/* Projection of Z onto the Riemann sphere.  */
extern long double _Complex cprojl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double _Complex __cprojl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));


/* Decomposing complex values.  */

/* Imaginary part of Z.  */
extern long double cimagl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cimagl (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));

/* Real part of Z.  */
extern long double creall (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double __creall (long double _Complex __z) __attribute__ ((__nothrow__ , __leaf__));


/* Now some optimized versions.  GCC has handy notations for these
   functions.  Recent GCC handles these as builtin functions so does
   not need inlines.  */
# 103 "/usr/include/complex.h" 2 3 4

#undef _Mdouble_
#undef __MATH_PRECNAME
#undef __MATHDECL_1
#undef __MATHDECL
#undef __MATHCALL


# 28 "/usr/include/tgmath.h" 2 3 4


/* Since `complex' is currently not really implemented in most C compilers
   and if it is implemented, the implementations differ.  This makes it
   quite difficult to write a generic implementation of this header.  We
   do not try this for now and instead concentrate only on GNU CC.  Once
   we have more information support for other compilers might follow.  */




#define __tgml(fct) fct




/* This is ugly but unless gcc gets appropriate builtins we have to do
   something like this.  Don't ask how it works.  */

/* 1 if 'type' is a floating type, 0 if 'type' is an integer type.
   Allows for _Bool.  Expands to an integer constant expression.  */

#define __floating_type(type) (__builtin_classify_type ((type) 0) == 8 || (__builtin_classify_type ((type) 0) == 9 && __builtin_classify_type (__real__ ((type) 0)) == 8))







/* The tgmath real type for T, where E is 0 if T is an integer type and
   1 for a floating type.  */
#define __tgmath_real_type_sub(T,E) __typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) (E))) 0 : (__typeof__ (0 ? (T *) 0 : (void *) (!(E)))) 0))



/* The tgmath real type of EXPR.  */
#define __tgmath_real_type(expr) __tgmath_real_type_sub (__typeof__ ((__typeof__ (expr)) 0), __floating_type (__typeof__ (expr)))




/* We have two kinds of generic macros: to support functions which are
   only defined on real valued parameters and those which are defined
   for complex functions as well.  */
#define __TGMATH_UNARY_REAL_ONLY(Val,Fct) (__extension__ ((sizeof (Val) == sizeof (double) || __builtin_classify_type (Val) != 8) ? (__tgmath_real_type (Val)) Fct (Val) : (sizeof (Val) == sizeof (float)) ? (__tgmath_real_type (Val)) Fct ##f (Val) : (__tgmath_real_type (Val)) __tgml(Fct) (Val)))







#define __TGMATH_UNARY_REAL_RET_ONLY(Val,RetType,Fct) (__extension__ ((sizeof (Val) == sizeof (double) || __builtin_classify_type (Val) != 8) ? (RetType) Fct (Val) : (sizeof (Val) == sizeof (float)) ? (RetType) Fct ##f (Val) : (RetType) __tgml(Fct) (Val)))







#define __TGMATH_BINARY_FIRST_REAL_ONLY(Val1,Val2,Fct) (__extension__ ((sizeof (Val1) == sizeof (double) || __builtin_classify_type (Val1) != 8) ? (__tgmath_real_type (Val1)) Fct (Val1, Val2) : (sizeof (Val1) == sizeof (float)) ? (__tgmath_real_type (Val1)) Fct ##f (Val1, Val2) : (__tgmath_real_type (Val1)) __tgml(Fct) (Val1, Val2)))







#define __TGMATH_BINARY_REAL_ONLY(Val1,Val2,Fct) (__extension__ (((sizeof (Val1) > sizeof (double) || sizeof (Val2) > sizeof (double)) && __builtin_classify_type ((Val1) + (Val2)) == 8) ? (__typeof ((__tgmath_real_type (Val1)) 0 + (__tgmath_real_type (Val2)) 0)) __tgml(Fct) (Val1, Val2) : (sizeof (Val1) == sizeof (double) || sizeof (Val2) == sizeof (double) || __builtin_classify_type (Val1) != 8 || __builtin_classify_type (Val2) != 8) ? (__typeof ((__tgmath_real_type (Val1)) 0 + (__tgmath_real_type (Val2)) 0)) Fct (Val1, Val2) : (__typeof ((__tgmath_real_type (Val1)) 0 + (__tgmath_real_type (Val2)) 0)) Fct ##f (Val1, Val2)))
# 115 "/usr/include/tgmath.h" 3 4
#define __TGMATH_TERNARY_FIRST_SECOND_REAL_ONLY(Val1,Val2,Val3,Fct) (__extension__ (((sizeof (Val1) > sizeof (double) || sizeof (Val2) > sizeof (double)) && __builtin_classify_type ((Val1) + (Val2)) == 8) ? (__typeof ((__tgmath_real_type (Val1)) 0 + (__tgmath_real_type (Val2)) 0)) __tgml(Fct) (Val1, Val2, Val3) : (sizeof (Val1) == sizeof (double) || sizeof (Val2) == sizeof (double) || __builtin_classify_type (Val1) != 8 || __builtin_classify_type (Val2) != 8) ? (__typeof ((__tgmath_real_type (Val1)) 0 + (__tgmath_real_type (Val2)) 0)) Fct (Val1, Val2, Val3) : (__typeof ((__tgmath_real_type (Val1)) 0 + (__tgmath_real_type (Val2)) 0)) Fct ##f (Val1, Val2, Val3)))
# 133 "/usr/include/tgmath.h" 3 4
#define __TGMATH_TERNARY_REAL_ONLY(Val1,Val2,Val3,Fct) (__extension__ (((sizeof (Val1) > sizeof (double) || sizeof (Val2) > sizeof (double) || sizeof (Val3) > sizeof (double)) && __builtin_classify_type ((Val1) + (Val2) + (Val3)) == 8) ? (__typeof ((__tgmath_real_type (Val1)) 0 + (__tgmath_real_type (Val2)) 0 + (__tgmath_real_type (Val3)) 0)) __tgml(Fct) (Val1, Val2, Val3) : (sizeof (Val1) == sizeof (double) || sizeof (Val2) == sizeof (double) || sizeof (Val3) == sizeof (double) || __builtin_classify_type (Val1) != 8 || __builtin_classify_type (Val2) != 8 || __builtin_classify_type (Val3) != 8) ? (__typeof ((__tgmath_real_type (Val1)) 0 + (__tgmath_real_type (Val2)) 0 + (__tgmath_real_type (Val3)) 0)) Fct (Val1, Val2, Val3) : (__typeof ((__tgmath_real_type (Val1)) 0 + (__tgmath_real_type (Val2)) 0 + (__tgmath_real_type (Val3)) 0)) Fct ##f (Val1, Val2, Val3)))
# 158 "/usr/include/tgmath.h" 3 4
/* XXX This definition has to be changed as soon as the compiler understands
   the imaginary keyword.  */
#define __TGMATH_UNARY_REAL_IMAG(Val,Fct,Cfct) (__extension__ ((sizeof (__real__ (Val)) == sizeof (double) || __builtin_classify_type (__real__ (Val)) != 8) ? ((sizeof (__real__ (Val)) == sizeof (Val)) ? (__tgmath_real_type (Val)) Fct (Val) : (__tgmath_real_type (Val)) Cfct (Val)) : (sizeof (__real__ (Val)) == sizeof (float)) ? ((sizeof (__real__ (Val)) == sizeof (Val)) ? (__tgmath_real_type (Val)) Fct ##f (Val) : (__tgmath_real_type (Val)) Cfct ##f (Val)) : ((sizeof (__real__ (Val)) == sizeof (Val)) ? (__tgmath_real_type (Val)) __tgml(Fct) (Val) : (__tgmath_real_type (Val)) __tgml(Cfct) (Val))))
# 174 "/usr/include/tgmath.h" 3 4
#define __TGMATH_UNARY_IMAG(Val,Cfct) (__extension__ ((sizeof (__real__ (Val)) == sizeof (double) || __builtin_classify_type (__real__ (Val)) != 8) ? (__typeof__ ((__tgmath_real_type (Val)) 0 + _Complex_I)) Cfct (Val) : (sizeof (__real__ (Val)) == sizeof (float)) ? (__typeof__ ((__tgmath_real_type (Val)) 0 + _Complex_I)) Cfct ##f (Val) : (__typeof__ ((__tgmath_real_type (Val)) 0 + _Complex_I)) __tgml(Cfct) (Val)))
# 185 "/usr/include/tgmath.h" 3 4
/* XXX This definition has to be changed as soon as the compiler understands
   the imaginary keyword.  */
#define __TGMATH_UNARY_REAL_IMAG_RET_REAL(Val,Fct,Cfct) (__extension__ ((sizeof (__real__ (Val)) == sizeof (double) || __builtin_classify_type (__real__ (Val)) != 8) ? ((sizeof (__real__ (Val)) == sizeof (Val)) ? (__typeof__ (__real__ (__tgmath_real_type (Val)) 0)) Fct (Val) : (__typeof__ (__real__ (__tgmath_real_type (Val)) 0)) Cfct (Val)) : (sizeof (__real__ (Val)) == sizeof (float)) ? ((sizeof (__real__ (Val)) == sizeof (Val)) ? (__typeof__ (__real__ (__tgmath_real_type (Val)) 0)) Fct ##f (Val) : (__typeof__ (__real__ (__tgmath_real_type (Val)) 0)) Cfct ##f (Val)) : ((sizeof (__real__ (Val)) == sizeof (Val)) ? (__typeof__ (__real__ (__tgmath_real_type (Val)) 0)) __tgml(Fct) (Val) : (__typeof__ (__real__ (__tgmath_real_type (Val)) 0)) __tgml(Cfct) (Val))))
# 207 "/usr/include/tgmath.h" 3 4
/* XXX This definition has to be changed as soon as the compiler understands
   the imaginary keyword.  */
#define __TGMATH_BINARY_REAL_IMAG(Val1,Val2,Fct,Cfct) (__extension__ (((sizeof (__real__ (Val1)) > sizeof (double) || sizeof (__real__ (Val2)) > sizeof (double)) && __builtin_classify_type (__real__ (Val1) + __real__ (Val2)) == 8) ? ((sizeof (__real__ (Val1)) == sizeof (Val1) && sizeof (__real__ (Val2)) == sizeof (Val2)) ? (__typeof ((__tgmath_real_type (Val1)) 0 + (__tgmath_real_type (Val2)) 0)) __tgml(Fct) (Val1, Val2) : (__typeof ((__tgmath_real_type (Val1)) 0 + (__tgmath_real_type (Val2)) 0)) __tgml(Cfct) (Val1, Val2)) : (sizeof (__real__ (Val1)) == sizeof (double) || sizeof (__real__ (Val2)) == sizeof (double) || __builtin_classify_type (__real__ (Val1)) != 8 || __builtin_classify_type (__real__ (Val2)) != 8) ? ((sizeof (__real__ (Val1)) == sizeof (Val1) && sizeof (__real__ (Val2)) == sizeof (Val2)) ? (__typeof ((__tgmath_real_type (Val1)) 0 + (__tgmath_real_type (Val2)) 0)) Fct (Val1, Val2) : (__typeof ((__tgmath_real_type (Val1)) 0 + (__tgmath_real_type (Val2)) 0)) Cfct (Val1, Val2)) : ((sizeof (__real__ (Val1)) == sizeof (Val1) && sizeof (__real__ (Val2)) == sizeof (Val2)) ? (__typeof ((__tgmath_real_type (Val1)) 0 + (__tgmath_real_type (Val2)) 0)) Fct ##f (Val1, Val2) : (__typeof ((__tgmath_real_type (Val1)) 0 + (__tgmath_real_type (Val2)) 0)) Cfct ##f (Val1, Val2))))
# 247 "/usr/include/tgmath.h" 3 4
/* Unary functions defined for real and complex values.  */


/* Trigonometric functions.  */

/* Arc cosine of X.  */
#define acos(Val) __TGMATH_UNARY_REAL_IMAG (Val, acos, cacos)
/* Arc sine of X.  */
#define asin(Val) __TGMATH_UNARY_REAL_IMAG (Val, asin, casin)
/* Arc tangent of X.  */
#define atan(Val) __TGMATH_UNARY_REAL_IMAG (Val, atan, catan)
/* Arc tangent of Y/X.  */
#define atan2(Val1,Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, atan2)

/* Cosine of X.  */
#define cos(Val) __TGMATH_UNARY_REAL_IMAG (Val, cos, ccos)
/* Sine of X.  */
#define sin(Val) __TGMATH_UNARY_REAL_IMAG (Val, sin, csin)
/* Tangent of X.  */
#define tan(Val) __TGMATH_UNARY_REAL_IMAG (Val, tan, ctan)


/* Hyperbolic functions.  */

/* Hyperbolic arc cosine of X.  */
#define acosh(Val) __TGMATH_UNARY_REAL_IMAG (Val, acosh, cacosh)
/* Hyperbolic arc sine of X.  */
#define asinh(Val) __TGMATH_UNARY_REAL_IMAG (Val, asinh, casinh)
/* Hyperbolic arc tangent of X.  */
#define atanh(Val) __TGMATH_UNARY_REAL_IMAG (Val, atanh, catanh)

/* Hyperbolic cosine of X.  */
#define cosh(Val) __TGMATH_UNARY_REAL_IMAG (Val, cosh, ccosh)
/* Hyperbolic sine of X.  */
#define sinh(Val) __TGMATH_UNARY_REAL_IMAG (Val, sinh, csinh)
/* Hyperbolic tangent of X.  */
#define tanh(Val) __TGMATH_UNARY_REAL_IMAG (Val, tanh, ctanh)


/* Exponential and logarithmic functions.  */

/* Exponential function of X.  */
#define exp(Val) __TGMATH_UNARY_REAL_IMAG (Val, exp, cexp)

/* Break VALUE into a normalized fraction and an integral power of 2.  */
#define frexp(Val1,Val2) __TGMATH_BINARY_FIRST_REAL_ONLY (Val1, Val2, frexp)

/* X times (two to the EXP power).  */
#define ldexp(Val1,Val2) __TGMATH_BINARY_FIRST_REAL_ONLY (Val1, Val2, ldexp)

/* Natural logarithm of X.  */
#define log(Val) __TGMATH_UNARY_REAL_IMAG (Val, log, clog)

/* Base-ten logarithm of X.  */

#define log10(Val) __TGMATH_UNARY_REAL_IMAG (Val, log10, __clog10)




/* Return exp(X) - 1.  */
#define expm1(Val) __TGMATH_UNARY_REAL_ONLY (Val, expm1)

/* Return log(1 + X).  */
#define log1p(Val) __TGMATH_UNARY_REAL_ONLY (Val, log1p)

/* Return the base 2 signed integral exponent of X.  */
#define logb(Val) __TGMATH_UNARY_REAL_ONLY (Val, logb)

/* Compute base-2 exponential of X.  */
#define exp2(Val) __TGMATH_UNARY_REAL_ONLY (Val, exp2)

/* Compute base-2 logarithm of X.  */
#define log2(Val) __TGMATH_UNARY_REAL_ONLY (Val, log2)


/* Power functions.  */

/* Return X to the Y power.  */
#define pow(Val1,Val2) __TGMATH_BINARY_REAL_IMAG (Val1, Val2, pow, cpow)

/* Return the square root of X.  */
#define sqrt(Val) __TGMATH_UNARY_REAL_IMAG (Val, sqrt, csqrt)

/* Return `sqrt(X*X + Y*Y)'.  */
#define hypot(Val1,Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, hypot)

/* Return the cube root of X.  */
#define cbrt(Val) __TGMATH_UNARY_REAL_ONLY (Val, cbrt)


/* Nearest integer, absolute value, and remainder functions.  */

/* Smallest integral value not less than X.  */
#define ceil(Val) __TGMATH_UNARY_REAL_ONLY (Val, ceil)

/* Absolute value of X.  */
#define fabs(Val) __TGMATH_UNARY_REAL_IMAG_RET_REAL (Val, fabs, cabs)

/* Largest integer not greater than X.  */
#define floor(Val) __TGMATH_UNARY_REAL_ONLY (Val, floor)

/* Floating-point modulo remainder of X/Y.  */
#define fmod(Val1,Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, fmod)

/* Round X to integral valuein floating-point format using current
   rounding direction, but do not raise inexact exception.  */
#define nearbyint(Val) __TGMATH_UNARY_REAL_ONLY (Val, nearbyint)

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
#define round(Val) __TGMATH_UNARY_REAL_ONLY (Val, round)

/* Round X to the integral value in floating-point format nearest but
   not larger in magnitude.  */
#define trunc(Val) __TGMATH_UNARY_REAL_ONLY (Val, trunc)

/* Compute remainder of X and Y and put in *QUO a value with sign of x/y
   and magnitude congruent `mod 2^n' to the magnitude of the integral
   quotient x/y, with n >= 3.  */
#define remquo(Val1,Val2,Val3) __TGMATH_TERNARY_FIRST_SECOND_REAL_ONLY (Val1, Val2, Val3, remquo)


/* Round X to nearest integral value according to current rounding
   direction.  */
#define lrint(Val) __TGMATH_UNARY_REAL_RET_ONLY (Val, long int, lrint)
#define llrint(Val) __TGMATH_UNARY_REAL_RET_ONLY (Val, long long int, llrint)

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
#define lround(Val) __TGMATH_UNARY_REAL_RET_ONLY (Val, long int, lround)
#define llround(Val) __TGMATH_UNARY_REAL_RET_ONLY (Val, long long int, llround)


/* Return X with its signed changed to Y's.  */
#define copysign(Val1,Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, copysign)

/* Error and gamma functions.  */
#define erf(Val) __TGMATH_UNARY_REAL_ONLY (Val, erf)
#define erfc(Val) __TGMATH_UNARY_REAL_ONLY (Val, erfc)
#define tgamma(Val) __TGMATH_UNARY_REAL_ONLY (Val, tgamma)
#define lgamma(Val) __TGMATH_UNARY_REAL_ONLY (Val, lgamma)


/* Return the integer nearest X in the direction of the
   prevailing rounding mode.  */
#define rint(Val) __TGMATH_UNARY_REAL_ONLY (Val, rint)


/* Return X - epsilon.  */
#define nextdown(Val) __TGMATH_UNARY_REAL_ONLY (Val, nextdown)
/* Return X + epsilon.  */
#define nextup(Val) __TGMATH_UNARY_REAL_ONLY (Val, nextup)


/* Return X + epsilon if X < Y, X - epsilon if X > Y.  */
#define nextafter(Val1,Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, nextafter)
#define nexttoward(Val1,Val2) __TGMATH_BINARY_FIRST_REAL_ONLY (Val1, Val2, nexttoward)


/* Return the remainder of integer divison X / Y with infinite precision.  */
#define remainder(Val1,Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, remainder)

/* Return X times (2 to the Nth power).  */

#define scalb(Val1,Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, scalb)


/* Return X times (2 to the Nth power).  */
#define scalbn(Val1,Val2) __TGMATH_BINARY_FIRST_REAL_ONLY (Val1, Val2, scalbn)

/* Return X times (2 to the Nth power).  */
#define scalbln(Val1,Val2) __TGMATH_BINARY_FIRST_REAL_ONLY (Val1, Val2, scalbln)


/* Return the binary exponent of X, which must be nonzero.  */
#define ilogb(Val) __TGMATH_UNARY_REAL_RET_ONLY (Val, int, ilogb)


/* Return positive difference between X and Y.  */
#define fdim(Val1,Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, fdim)

/* Return maximum numeric value from X and Y.  */
#define fmax(Val1,Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, fmax)

/* Return minimum numeric value from X and Y.  */
#define fmin(Val1,Val2) __TGMATH_BINARY_REAL_ONLY (Val1, Val2, fmin)


/* Multiply-add function computed as a ternary operation.  */
#define fma(Val1,Val2,Val3) __TGMATH_TERNARY_REAL_ONLY (Val1, Val2, Val3, fma)



/* Absolute value, conjugates, and projection.  */

/* Argument value of Z.  */
#define carg(Val) __TGMATH_UNARY_REAL_IMAG_RET_REAL (Val, carg, carg)

/* Complex conjugate of Z.  */
#define conj(Val) __TGMATH_UNARY_IMAG (Val, conj)

/* Projection of Z onto the Riemann sphere.  */
#define cproj(Val) __TGMATH_UNARY_IMAG (Val, cproj)


/* Decomposing complex values.  */

/* Imaginary part of Z.  */
#define cimag(Val) __TGMATH_UNARY_REAL_IMAG_RET_REAL (Val, cimag, cimag)

/* Real part of Z.  */
#define creal(Val) __TGMATH_UNARY_REAL_IMAG_RET_REAL (Val, creal, creal)
# 98 "pifunk.c" 2
# 1 "/usr/include/complex.h" 1 3 4
/* Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99:  7.3 Complex arithmetic	<complex.h>
 */
# 99 "pifunk.c" 2
# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 100 "pifunk.c" 2
# 1 "/usr/include/fenv.h" 1 3 4
/* Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * ISO C99 7.6: Floating-point environment	<fenv.h>
 */


#define _FENV_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/fenv.h" 2 3 4

/* Get the architecture dependend definitions.  The following definitions
   are expected to be done:

   fenv_t	type for object representing an entire floating-point
		environment

   FE_DFL_ENV	macro of type pointer to fenv_t to be used as the argument
		to functions taking an argument of type fenv_t; in this
		case the default environment will be used

   fexcept_t	type for object representing the floating-point exception
		flags including status associated with the flags

   The following macros are defined iff the implementation supports this
   kind of exception.
   FE_INEXACT		inexact result
   FE_DIVBYZERO		division by zero
   FE_UNDERFLOW		result not representable due to underflow
   FE_OVERFLOW		result not representable due to overflow
   FE_INVALID		invalid operation

   FE_ALL_EXCEPT	bitwise OR of all supported exceptions

   The next macros are defined iff the appropriate rounding mode is
   supported by the implementation.
   FE_TONEAREST		round to nearest
   FE_UPWARD		round toward +Inf
   FE_DOWNWARD		round toward -Inf
   FE_TOWARDZERO	round toward 0
*/
# 1 "/usr/include/arm-linux-gnueabihf/bits/fenv.h" 1 3 4
/* Copyright (C) 2004-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */





/* Define bits representing exceptions in the FPU status word.  */
enum
  {
    FE_INVALID =
#define FE_INVALID 1
      1,
    FE_DIVBYZERO =
#define FE_DIVBYZERO 2
      2,
    FE_OVERFLOW =
#define FE_OVERFLOW 4
      4,
    FE_UNDERFLOW =
#define FE_UNDERFLOW 8
      8,
    FE_INEXACT =
#define FE_INEXACT 16
      16,
  };

/* Amount to shift by to convert an exception to a mask bit.  */
#define FE_EXCEPT_SHIFT 8

/* All supported exceptions.  */
#define FE_ALL_EXCEPT (FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW | FE_INEXACT)


/* VFP supports all of the four defined rounding modes.  */
enum
  {
    FE_TONEAREST =
#define FE_TONEAREST 0
      0,
    FE_UPWARD =
#define FE_UPWARD 0x400000
      0x400000,
    FE_DOWNWARD =
#define FE_DOWNWARD 0x800000
      0x800000,
    FE_TOWARDZERO =
#define FE_TOWARDZERO 0xc00000
      0xc00000
  };

/* Type representing exception flags. */
typedef unsigned int fexcept_t;

/* Type representing floating-point environment.  */
typedef struct
  {
    unsigned int __cw;
  }
fenv_t;

/* If the default argument is used we use this value.  */
#define FE_DFL_ENV ((const fenv_t *) -1l)


/* Floating-point environment where none of the exceptions are masked.  */
#define FE_NOMASK_ENV ((const fenv_t *) -2)
# 58 "/usr/include/fenv.h" 2 3 4



/* Floating-point exception handling.  */

/* Clear the supported exceptions represented by EXCEPTS.  */
extern int feclearexcept (int __excepts) __attribute__ ((__nothrow__ , __leaf__));

/* Store implementation-defined representation of the exception flags
   indicated by EXCEPTS in the object pointed to by FLAGP.  */
extern int fegetexceptflag (fexcept_t *__flagp, int __excepts) __attribute__ ((__nothrow__ , __leaf__));

/* Raise the supported exceptions represented by EXCEPTS.  */
extern int feraiseexcept (int __excepts) __attribute__ ((__nothrow__ , __leaf__));

/* Set complete status for exceptions indicated by EXCEPTS according to
   the representation in the object pointed to by FLAGP.  */
extern int fesetexceptflag (const fexcept_t *__flagp, int __excepts) __attribute__ ((__nothrow__ , __leaf__));

/* Determine which of subset of the exceptions specified by EXCEPTS are
   currently set.  */
extern int fetestexcept (int __excepts) __attribute__ ((__nothrow__ , __leaf__));


/* Rounding control.  */

/* Get current rounding direction.  */
extern int fegetround (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));

/* Establish the rounding direction represented by ROUND.  */
extern int fesetround (int __rounding_direction) __attribute__ ((__nothrow__ , __leaf__));


/* Floating-point environment.  */

/* Store the current floating-point environment in the object pointed
   to by ENVP.  */
extern int fegetenv (fenv_t *__envp) __attribute__ ((__nothrow__ , __leaf__));

/* Save the current environment in the object pointed to by ENVP, clear
   exception flags and install a non-stop mode (if available) for all
   exceptions.  */
extern int feholdexcept (fenv_t *__envp) __attribute__ ((__nothrow__ , __leaf__));

/* Establish the floating-point environment represented by the object
   pointed to by ENVP.  */
extern int fesetenv (const fenv_t *__envp) __attribute__ ((__nothrow__ , __leaf__));

/* Save current exceptions in temporary storage, install environment
   represented by object pointed to by ENVP and raise exceptions
   according to saved exceptions.  */
extern int feupdateenv (const fenv_t *__envp) __attribute__ ((__nothrow__ , __leaf__));


/* Include optimization.  */

# 1 "/usr/include/arm-linux-gnueabihf/bits/fenvinline.h" 1 3 4
/* This file provides inline versions of floating-pint environment
   handling functions.  If there were any.  */
# 115 "/usr/include/fenv.h" 2 3 4




/* Enable individual exceptions.  Will not enable more exceptions than
   EXCEPTS specifies.  Returns the previous enabled exceptions if all
   exceptions are successfully set, otherwise returns -1.  */
extern int feenableexcept (int __excepts) __attribute__ ((__nothrow__ , __leaf__));

/* Disable individual exceptions.  Will not disable more exceptions than
   EXCEPTS specifies.  Returns the previous enabled exceptions if all
   exceptions are successfully disabled, otherwise returns -1.  */
extern int fedisableexcept (int __excepts) __attribute__ ((__nothrow__ , __leaf__));

/* Return enabled exceptions.  */
extern int fegetexcept (void) __attribute__ ((__nothrow__ , __leaf__));



# 101 "pifunk.c" 2
# 1 "/usr/include/grp.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 9.2.1 Group Database Access	<grp.h>
 */


#define _GRP_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/grp.h" 2 3 4



# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 30 "/usr/include/grp.h" 2 3 4

#define __need_size_t 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 160 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 347 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_wchar_t
# 362 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 33 "/usr/include/grp.h" 2 3 4


/* For the Single Unix specification we must define this type here.  */





/* The group structure.	 */
struct group
  {
    char *gr_name; /* Group name.	*/
    char *gr_passwd; /* Password.	*/
    __gid_t gr_gid; /* Group ID.	*/
    char **gr_mem; /* Member list.	*/
  };



#define __need_FILE 
# 1 "/usr/include/stdio.h" 1 3 4
/* Define ISO C stdio on top of C++ iostreams.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.19 Input/output	<stdio.h>
 */
# 54 "/usr/include/grp.h" 2 3 4




/* Rewind the group-file stream.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void setgrent (void);

/* Close the group-file stream.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void endgrent (void);

/* Read an entry from the group-file stream, opening it if necessary.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct group *getgrent (void);



/* Read a group entry from STREAM.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern struct group *fgetgrent (FILE *__stream);



/* Write the given entry onto the given stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int putgrent (const struct group *__restrict __p,
       FILE *__restrict __f);


/* Search for an entry with a matching group ID.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct group *getgrgid (__gid_t __gid);

/* Search for an entry with a matching group name.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct group *getgrnam (const char *__name);




/* Reasonable value for the buffer sized used in the reentrant
   functions below.  But better use `sysconf'.  */
#define NSS_BUFLEN_GROUP 1024


/* Reentrant versions of some of the functions above.

   PLEASE NOTE: the `getgrent_r' function is not (yet) standardized.
   The interface may change in later versions of this library.  But
   the interface is designed following the principals used for the
   other reentrant functions so the chances are good this is what the
   POSIX people would choose.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */


extern int getgrent_r (struct group *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct group **__restrict __result);


/* Search for an entry with a matching group ID.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int getgrgid_r (__gid_t __gid, struct group *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct group **__restrict __result);

/* Search for an entry with a matching group name.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int getgrnam_r (const char *__restrict __name,
         struct group *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct group **__restrict __result);


/* Read a group entry from STREAM.  This function is not standardized
   an probably never will.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fgetgrent_r (FILE *__restrict __stream,
   struct group *__restrict __resultbuf,
   char *__restrict __buffer, size_t __buflen,
   struct group **__restrict __result);







#define __need_size_t 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 160 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 347 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_wchar_t
# 362 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 175 "/usr/include/grp.h" 2 3 4

/* Set the group set for the current user to GROUPS (N of them).  */
extern int setgroups (size_t __n, const __gid_t *__groups) __attribute__ ((__nothrow__ , __leaf__));

/* Store at most *NGROUPS members of the group set for USER into
   *GROUPS.  Also include GROUP.  The actual number of groups found is
   returned in *NGROUPS.  Return -1 if the if *NGROUPS is too small.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int getgrouplist (const char *__user, __gid_t __group,
    __gid_t *__groups, int *__ngroups);

/* Initialize the group set for the current user
   by reading the group database and using all groups
   of which USER is a member.  Also include GROUP.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int initgroups (const char *__user, __gid_t __group);




# 102 "pifunk.c" 2
# 1 "/usr/include/pwd.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 9.2.2 User Database Access	<pwd.h>
 */


#define _PWD_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/pwd.h" 2 3 4



# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 30 "/usr/include/pwd.h" 2 3 4

#define __need_size_t 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 160 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 347 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_wchar_t
# 362 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 33 "/usr/include/pwd.h" 2 3 4


/* The Single Unix specification says that some more types are
   available here.  */
# 48 "/usr/include/pwd.h" 3 4
/* The passwd structure.  */
struct passwd
{
  char *pw_name; /* Username.  */
  char *pw_passwd; /* Password.  */
  __uid_t pw_uid; /* User ID.  */
  __gid_t pw_gid; /* Group ID.  */
  char *pw_gecos; /* Real name.  */
  char *pw_dir; /* Home directory.  */
  char *pw_shell; /* Shell program.  */
};



#define __need_FILE 
# 1 "/usr/include/stdio.h" 1 3 4
/* Define ISO C stdio on top of C++ iostreams.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.19 Input/output	<stdio.h>
 */
# 64 "/usr/include/pwd.h" 2 3 4




/* Rewind the password-file stream.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void setpwent (void);

/* Close the password-file stream.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void endpwent (void);

/* Read an entry from the password-file stream, opening it if necessary.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct passwd *getpwent (void);



/* Read an entry from STREAM.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern struct passwd *fgetpwent (FILE *__stream) __attribute__ ((__nonnull__ (1)));

/* Write the given entry onto the given stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int putpwent (const struct passwd *__restrict __p,
       FILE *__restrict __f);


/* Search for an entry with a matching user ID.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct passwd *getpwuid (__uid_t __uid);

/* Search for an entry with a matching username.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct passwd *getpwnam (const char *__name) __attribute__ ((__nonnull__ (1)));




/* Reasonable value for the buffer sized used in the reentrant
   functions below.  But better use `sysconf'.  */
#define NSS_BUFLEN_PASSWD 1024


/* Reentrant versions of some of the functions above.

   PLEASE NOTE: the `getpwent_r' function is not (yet) standardized.
   The interface may change in later versions of this library.  But
   the interface is designed following the principals used for the
   other reentrant functions so the chances are good this is what the
   POSIX people would choose.  */


/* This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int getpwent_r (struct passwd *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct passwd **__restrict __result)
         __attribute__ ((__nonnull__ (1, 2, 4)));


extern int getpwuid_r (__uid_t __uid,
         struct passwd *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct passwd **__restrict __result)
         __attribute__ ((__nonnull__ (2, 3, 5)));

extern int getpwnam_r (const char *__restrict __name,
         struct passwd *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct passwd **__restrict __result)
         __attribute__ ((__nonnull__ (1, 2, 3, 5)));



/* Read an entry from STREAM.  This function is not standardized and
   probably never will.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fgetpwent_r (FILE *__restrict __stream,
   struct passwd *__restrict __resultbuf,
   char *__restrict __buffer, size_t __buflen,
   struct passwd **__restrict __result)
   __attribute__ ((__nonnull__ (1, 2, 3, 5)));





/* Re-construct the password-file line for the given uid
   in the given buffer.  This knows the format that the caller
   will expect, but this need not be the format of the password file.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int getpw (__uid_t __uid, char *__buffer);



# 103 "pifunk.c" 2
# 1 "/usr/include/poll.h" 1 3 4
# 1 "/usr/include/arm-linux-gnueabihf/sys/poll.h" 1 3 4
/* Compatibility definitions for System V `poll' interface.
   Copyright (C) 1994-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _SYS_POLL_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 23 "/usr/include/arm-linux-gnueabihf/sys/poll.h" 2 3 4

/* Get the platform dependent bits of `poll'.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/poll.h" 1 3 4
/* Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* Event types that can be polled for.  These bits may be set in `events'
   to indicate the interesting event types; they will appear in `revents'
   to indicate the status of the file descriptor.  */
#define POLLIN 0x001
#define POLLPRI 0x002
#define POLLOUT 0x004


/* These values are defined in XPG4.2.  */
#define POLLRDNORM 0x040
#define POLLRDBAND 0x080
#define POLLWRNORM 0x100
#define POLLWRBAND 0x200



/* These are extensions for Linux.  */
#define POLLMSG 0x400
#define POLLREMOVE 0x1000
#define POLLRDHUP 0x2000


/* Event types always implicitly polled for.  These bits need not be set in
   `events', but they will appear in `revents' to indicate the status of
   the file descriptor.  */
#define POLLERR 0x008
#define POLLHUP 0x010
#define POLLNVAL 0x020
# 26 "/usr/include/arm-linux-gnueabihf/sys/poll.h" 2 3 4

/* Get the __sigset_t definition.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/sigset.h" 1 3 4
/* __sig_atomic_t, __sigset_t, and related definitions.  Linux version.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 35 "/usr/include/arm-linux-gnueabihf/bits/sigset.h" 3 4
/* We only want to define these functions if <signal.h> was actually
   included; otherwise we were included just to define the types.  Since we
   are namespace-clean, it wouldn't hurt to define extra macros.  But
   trouble can be caused by functions being defined (e.g., any global
   register vars declared later will cause compilation errors).  */
# 29 "/usr/include/arm-linux-gnueabihf/sys/poll.h" 2 3 4
/* Get the timespec definition.  */
#define __need_timespec 
# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 32 "/usr/include/arm-linux-gnueabihf/sys/poll.h" 2 3 4



/* Type used for the number of file descriptors.  */
typedef unsigned long int nfds_t;

/* Data structure describing a polling request.  */
struct pollfd
  {
    int fd; /* File descriptor to poll.  */
    short int events; /* Types of events poller cares about.  */
    short int revents; /* Types of events that actually occurred.  */
  };




/* Poll the file descriptors described by the NFDS structures starting at
   FDS.  If TIMEOUT is nonzero and not -1, allow TIMEOUT milliseconds for
   an event to occur; if TIMEOUT is -1, block until an event occurs.
   Returns the number of file descriptors with events, zero if timed out,
   or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int poll (struct pollfd *__fds, nfds_t __nfds, int __timeout);


/* Like poll, but before waiting the threads signal mask is replaced
   with that specified in the fourth parameter.  For better usability,
   the timeout value is specified using a TIMESPEC object.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int ppoll (struct pollfd *__fds, nfds_t __nfds,
    const struct timespec *__timeout,
    const __sigset_t *__ss);





/* Define some inlines helping to catch common problems.  */
# 1 "/usr/include/poll.h" 2 3 4
# 104 "pifunk.c" 2
# 1 "/usr/include/argp.h" 1 3 4
/* Hierarchial argument parsing, layered over getopt.
   Copyright (C) 1995-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Written by Miles Bader <miles@gnu.ai.mit.edu>.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 105 "pifunk.c" 2
# 1 "/usr/include/uchar.h" 1 3 4
/* Copyright (C) 2011-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *      ISO C11 Standard: 7.28
 *	Unicode utilities	<uchar.h>
 */


#define _UCHAR_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 27 "/usr/include/uchar.h" 2 3 4

#define __need_size_t 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 160 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 347 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_wchar_t
# 362 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 30 "/usr/include/uchar.h" 2 3 4
#define __need_mbstate_t 
# 1 "/usr/include/wchar.h" 1 3 4
/* Copyright (C) 1995-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *      ISO C99 Standard: 7.24
 *	Extended multibyte and wide character utilities	<wchar.h>
 */
# 900 "/usr/include/wchar.h" 3 4
/* Undefine all __need_* constants in case we are included to get those
   constants but the whole file was already read.  */
#undef __need_mbstate_t
#undef __need_wint_t
# 32 "/usr/include/uchar.h" 2 3 4
# 43 "/usr/include/uchar.h" 3 4
/* Define the 16-bit and 32-bit character types.  Use the information
   provided by the compiler.  */







typedef short unsigned int char16_t;
typedef unsigned int char32_t;





/* Write char16_t representation of multibyte character pointed
   to by S to PC16.  */
extern size_t mbrtoc16 (char16_t *__restrict __pc16,
   const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __p) __attribute__ ((__nothrow__ , __leaf__));

/* Write multibyte representation of char16_t C16 to S.  */
extern size_t c16rtomb (char *__restrict __s, char16_t __c16,
   mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));



/* Write char32_t representation of multibyte character pointed
   to by S to PC32.  */
extern size_t mbrtoc32 (char32_t *__restrict __pc32,
   const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __p) __attribute__ ((__nothrow__ , __leaf__));

/* Write multibyte representation of char32_t C32 to S.  */
extern size_t c32rtomb (char *__restrict __s, char32_t __c32,
   mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));


# 106 "pifunk.c" 2
# 1 "opt/vc/include/bcm_host.h" 1

# 1 "opt/vc/include/bcm_host.h"
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Header file with useful bits from other headers


#define BCM_HOST_H 







void bcm_host_init(void);
void bcm_host_deinit(void);

int32_t graphics_get_display_size( const uint16_t display_number,
                                                    uint32_t *width,
                                                    uint32_t *height);

unsigned bcm_host_get_peripheral_address(void);
unsigned bcm_host_get_peripheral_size(void);
unsigned bcm_host_get_sdram_address(void);

# 1 "opt/vc/include/interface/vmcs_host/vc_dispmanx.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Display manager service API


#define _VC_DISPMANX_H_ 

# 1 "/opt/vc/include/interface/vcos/vcos.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */


#define VCOS_H 

# 1 "/opt/vc/include/interface/vcos/vcos_assert.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - Assertion and error-handling macros.
=============================================================================*/



#define VCOS_ASSERT_H 

/*
 * Macro:
 *    vcos_assert(cond)
 *    vcos_assert_msg(cond, fmt, ...)
 * Use:
 *    Detecting programming errors by ensuring that assumptions are correct.
 * On failure:
 *    Performs a platform-dependent "breakpoint", usually with an assert-style
 *    message. The '_msg' variant expects a printf-style format string and
 *    parameters.
 *    If a failure is detected, the code should be fixed and rebuilt.
 * In release builds:
 *    Generates no code, i.e. does not evaluate 'cond'.
 * Returns:
 *    Nothing.
 *
 * Macro:
 *    vcos_demand(cond)
 *    vcos_demand_msg(cond, fmt, ...)
 * Use:
 *    Detecting fatal system errors that require a reboot.
 * On failure:
 *    Performs a platform-dependent "breakpoint", usually with an assert-style
 *    message, then calls vcos_abort (see below).
 * In release builds:
 *    Calls vcos_abort() if 'cond' is false.
 * Returns:
 *    Nothing (never, on failure).
 *
 * Macro:
 *    vcos_verify(cond)
 *    vcos_verify_msg(cond, fmt, ...)
 * Use:
 *    Detecting run-time errors and interesting conditions, normally within an
 *    'if' statement to catch the failures, i.e.
 *       if (!vcos_verify(cond)) handle_error();
 * On failure:
 *    Generates a message and optionally stops at a platform-dependent
 *    "breakpoint" (usually disabled). See vcos_verify_bkpts_enable below.
 * In release builds:
 *    Just evaluates and returns 'cond'.
 * Returns:
 *    Non-zero if 'cond' is true, otherwise zero.
 *
 * Macro:
 *    vcos_static_assert(cond)
 * Use:
 *    Detecting compile-time errors.
 * On failure:
 *    Generates a compiler error.
 * In release builds:
 *    Generates a compiler error.
 *
 * Function:
 *    void vcos_abort(void)
 * Use:
 *    Invokes the fatal error handling mechanism, alerting the host where
 *    applicable.
 * Returns:
 *    Never.
 *
 * Macro:
 *    VCOS_VERIFY_BKPTS
 * Use:
 *    Define in a module (before including vcos.h) to specify an alternative
 *    flag to control breakpoints on vcos_verify() failures.
 * Returns:
 *    Non-zero values enable breakpoints.
 *
 * Function:
 *    int vcos_verify_bkpts_enable(int enable);
 * Use:
 *    Sets the global flag controlling breakpoints on vcos_verify failures,
 *    enabling the breakpoints iff 'enable' is non-zero.
 * Returns:
 *    The previous state of the flag.
 *
 * Function:
 *    int vcos_verify_bkpts_enabled(void);
 * Use:
 *    Queries the state of the global flag enabling breakpoints on vcos_verify
 *    failures.
 * Returns:
 *    The current state of the flag.
 *
 * Examples:
 *
 * int my_breakpoint_enable_flag = 1;
 *
 * #define VCOS_VERIFY_BKPTS my_breakpoint_enable_flag
 *
 * #include "interface/vcos/vcos.h"
 *
 * vcos_static_assert((sizeof(object) % 32) == 0);
 *
 * // ...
 *
 *    vcos_assert_msg(postcondition_is_true, "Coding error");
 *
 *    if (!vcos_verify_msg(buf, "Buffer allocation failed (%d bytes)", size))
 *    {
 *       // Tidy up
 *       // ...
 *       return OUT_OF_MEMORY;
 *    }
 *
 *    vcos_demand(*p++==GUARDWORDHEAP);
 */





# 1 "/opt/vc/include/interface/vcos/vcos_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/


#define VCOS_TYPES_H 

#define VCOS_VERSION 1

# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4

# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
# 38 "/opt/vc/include/interface/vcos/vcos_types.h" 2

# 1 "/opt/vc/include/interface/vcos/pthreads/vcos_platform_types.h" 1

# 1 "/opt/vc/include/interface/vcos/pthreads/vcos_platform_types.h"
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - platform-specific types and defines
=============================================================================*/


#define VCOS_PLATFORM_TYPES_H 

# 1 "/opt/vc/include/interface/vcos/vcos_inttypes.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#define VCOS_INTTYPES_H 

/** \file
 * Attempt to provide the support for fixed width integer types as per
 * inttypes.h. This simply includes inttypes.h, which should find the
 * system/toolchain version if present, otherwise falling back to the version
 * in interface/vcos/<platform>. The vcos versions initially only provide the
 * most common printf() macros.
 */





# 1 "/usr/include/inttypes.h" 1 3 4

# 1 "/usr/include/inttypes.h" 3 4
/* Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99: 7.8 Format conversion of integer types	<inttypes.h>
 */
# 44 "/opt/vc/include/interface/vcos/vcos_inttypes.h" 2
# 36 "/opt/vc/include/interface/vcos/pthreads/vcos_platform_types.h" 2





#define VCOSPRE_ extern
#define VCOSPOST_ 


#define VCOS_FORMAT_ATTR_(ARCHETYPE,STRING_INDEX,FIRST_TO_CHECK) __attribute__ ((format (ARCHETYPE, STRING_INDEX, FIRST_TO_CHECK)))








# 53 "/opt/vc/include/interface/vcos/pthreads/vcos_platform_types.h"
/*#define VCOS_BKPT vcos_abort() */

#define VCOS_ASSERT_LOGGING 1
#define VCOS_ASSERT_LOGGING_DISABLE 0

extern void
vcos_pthreads_logging_assert(const char *file, const char *func, unsigned int line, const char *fmt, ...);

#define VCOS_ASSERT_MSG(...) ((VCOS_ASSERT_LOGGING && !VCOS_ASSERT_LOGGING_DISABLE) ? vcos_pthreads_logging_assert(__FILE__, __func__, __LINE__, __VA_ARGS__) : (void)0)

#define VCOS_INLINE_BODIES 
#define VCOS_INLINE_DECL extern __inline__
#define VCOS_INLINE_IMPL static __inline__
# 40 "/opt/vc/include/interface/vcos/vcos_types.h" 2



# 1 "/opt/vc/include/interface/vcos/vcos_attr.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - compiler-specific attributes
=============================================================================*/


#define VCOS_ATTR_H 

/**
 * Type attribute indicating the enum should be stored in as few bytes as
 * possible. MetaWare does this by default, so the attribute is useful when
 * structs need to be portable to GCC too.
 *
 * MSVC doesn't support VCOS_ENUM_PACKED, so code that needs to be portable
 * across all platforms but wants the type-safety and debug-info benefits
 * of enum types when possible, should do:
 *
 *    typedef enum VCOS_ENUM_PACKED { a = 0, b = 0xffff } EXAMPLE_T;
 *    struct foo {
 *       int bar;
 *       #if VCOS_HAS_ENUM_PACKED
 *       EXAMPLE_T baz;
 *       #else
 *       uint16_t baz;
 *       #endif
 *    };
 */





#define VCOS_ENUM_PACKED __attribute__ ((packed))
#define VCOS_HAS_ENUM_PACKED 1
# 69 "/opt/vc/include/interface/vcos/vcos_attr.h"
/** Variable attribute indicating the variable must be emitted even if it appears unused. */

#define VCOS_ATTR_USED __attribute__ ((used))




/** Variable attribute indicating the compiler should not warn if the variable is unused. */

#define VCOS_ATTR_POSSIBLY_UNUSED __attribute__ ((unused))




/** Variable attribute requiring specific alignment.
 *
 * Use as:
 *   int VCOS_ATTR_ALIGNED(256) n;
 * or:
 *   VCOS_ATTR_ALIGNED(256) int n;
 * or if you don't want to support MSVC:
 *   int n VCOS_ATTR_ALIGNED(256);
 */

#define VCOS_ATTR_ALIGNED(n) __attribute__ ((aligned(n)))
# 102 "/opt/vc/include/interface/vcos/vcos_attr.h"
/** Variable attribute requiring specific ELF section.
 *
 * Use as:
 *   int n VCOS_ATTR_SECTION(".foo") = 1;
 *
 * A pointer like &n will have type "VCOS_ATTR_SECTION_QUALIFIER int *".
 */





#define VCOS_ATTR_SECTION(s) __attribute__ ((section(s)))
#define VCOS_ATTR_SECTION_QUALIFIER 






/** Define a function as a weak alias to another function.
 * @param ret_type     Function return type.
 * @param alias_name   Name of the alias.
 * @param param_list   Function parameter list, including the parentheses.
 * @param target_name  Target function (bare function name, not a string).
 */

  /* N.B. gcc allows __attribute__ after parameter list, but hcvc seems to silently ignore it. */
#define VCOS_WEAK_ALIAS(ret_type,alias_name,param_list,target_name) __attribute__ ((weak, alias(#target_name))) ret_type alias_name param_list





/** Define a function as a weak alias to another function, specified as a string.
 * @param ret_type     Function return type.
 * @param alias_name   Name of the alias.
 * @param param_list   Function parameter list, including the parentheses.
 * @param target_name  Target function name as a string.
 * @note Prefer the use of VCOS_WEAK_ALIAS - it is likely to be more portable.
 *       Only use VCOS_WEAK_ALIAS_STR if you need to do pre-processor mangling of the target
 *       symbol.
 */

  /* N.B. gcc allows __attribute__ after parameter list, but hcvc seems to silently ignore it. */
#define VCOS_WEAK_ALIAS_STR(ret_type,alias_name,param_list,target_name) __attribute__ ((weak, alias(target_name))) ret_type alias_name param_list
# 44 "/opt/vc/include/interface/vcos/vcos_types.h" 2





/* Redefine these here; this means that existing header files can carry on
 * using the VCHPOST/VCHPRE macros rather than having huge changes, which
 * could cause nasty merge problems.
 */

#define VCHPOST_ VCOSPOST_


#define VCHPRE_ VCOSPRE_


/** Entry function for a lowlevel thread.
  *
  * Returns void for consistency with Nucleus/ThreadX.
  */
typedef void (*VCOS_LLTHREAD_ENTRY_FN_T)(void *);

/** Thread entry point. Returns a void* for consistency
  * with pthreads.
  */
typedef void *(*VCOS_THREAD_ENTRY_FN_T)(void*);


/* Error return codes - chosen to be similar to errno values */
typedef enum
{
   VCOS_SUCCESS,
   VCOS_EAGAIN,
   VCOS_ENOENT,
   VCOS_ENOSPC,
   VCOS_EINVAL,
   VCOS_EACCESS,
   VCOS_ENOMEM,
   VCOS_ENOSYS,
   VCOS_EEXIST,
   VCOS_ENXIO,
   VCOS_EINTR
} VCOS_STATUS_T;

/* Some compilers (MetaWare) won't inline with -g turned on, which then results
 * in a lot of code bloat. To overcome this, inline functions are forward declared
 * with the prefix VCOS_INLINE_DECL, and implemented with the prefix VCOS_INLINE_IMPL.
 *
 * That then means that in a release build, "static inline" can be used in the obvious
 * way, but in a debug build the implementations can be skipped in all but one file,
 * by using VCOS_INLINE_BODIES.
 *
 * VCOS_INLINE_DECL - put this at the start of an inline forward declaration of a VCOS
 * function.
 *
 * VCOS_INLINE_IMPL - put this at the start of an inlined implementation of a VCOS
 * function.
 *
 */

/* VCOS_EXPORT - it turns out that in some circumstances we need the implementation of
 * a function even if it is usually inlined.
 *
 * In particular, if we have a codec that is usually provided in object form, if it
 * was built for a debug build it will be full of calls to vcos_XXX(). If this is used
 * in a *release* build, then there won't be any of these calls around in the main image
 * as they will all have been inlined. The problem also exists for vcos functions called
 * from assembler.
 *
 * VCOS_EXPORT ensures that the named function will be emitted as a regular (not static-inline)
 * function inside vcos_<platform>.c so that it can be linked against. Doing this for every
 * VCOS function would be a bit code-bloat-tastic, so it is only done for those that need it.
 *
 */




#define _VCOS_INLINE __inline
# 151 "/opt/vc/include/interface/vcos/vcos_types.h"
#define VCOS_EXPORT VCOS_INLINE_IMPL


#define VCOS_STATIC_INLINE static _VCOS_INLINE





/** It seems that __FUNCTION__ isn't standard!
  */







#define VCOS_FUNCTION __func__


#define _VCOS_MS_PER_TICK (1000/VCOS_TICKS_PER_SECOND)

/* Convert a number of milliseconds to a tick count. Internal use only - fails to
 * convert VCOS_SUSPEND correctly.
 */
#define _VCOS_MS_TO_TICKS(ms) (((ms)+_VCOS_MS_PER_TICK-1)/_VCOS_MS_PER_TICK)

#define VCOS_TICKS_TO_MS(ticks) ((ticks) * _VCOS_MS_PER_TICK)

/** VCOS version of DATESTR, from pcdisk.h. Used by the hostreq service.
 */
typedef struct vcos_datestr
{
   uint8_t cmsec; /**< Centesimal mili second */
   uint16_t date; /**< Date */
   uint16_t time; /**< Time */

} VCOS_DATESTR;

/* Compile-time assert - declares invalid array length if condition
 * not met, or array of length one if OK.
 */
#define VCOS_CASSERT(e) extern char vcos_compile_time_check[1/(e)]

#define vcos_min(x,y) ((x) < (y) ? (x) : (y))
#define vcos_max(x,y) ((x) > (y) ? (x) : (y))

/** Return the count of an array. FIXME: under gcc we could make
 * this report an error for pointers using __builtin_types_compatible().
 */
#define vcos_countof(x) (sizeof((x)) / sizeof((x)[0]))

/* for backward compatibility */
#define countof(x) (sizeof((x)) / sizeof((x)[0]))

#define VCOS_ALIGN_DOWN(p,n) (((ptrdiff_t)(p)) & ~((n)-1))
#define VCOS_ALIGN_UP(p,n) VCOS_ALIGN_DOWN((ptrdiff_t)(p)+(n)-1,(n))




#define vcos_alignof(T) __alignof__(T)




/** bool_t is not a POSIX type so cannot rely on it. Define it here.
  * It's not even defined in stdbool.h.
  */
typedef int32_t vcos_bool_t;
typedef int32_t vcos_fourcc_t;

#define VCOS_FALSE 0
#define VCOS_TRUE (!VCOS_FALSE)

/** Mark unused arguments to keep compilers quiet */
#define vcos_unused(x) (void)(x)

/** For backward compatibility */
typedef vcos_fourcc_t fourcc_t;
typedef vcos_fourcc_t FOURCC_T;





#define VCOS_EXTERN_C_BEGIN 
#define VCOS_EXTERN_C_END 


/** Define a function as a weak alias to another function.
 * @param ret_type     Function return type.
 * @param alias_name   Name of the alias.
 * @param param_list   Function parameter list, including the parentheses.
 * @param target_name  Target function (bare function name, not a string).
 */

  /* N.B. gcc allows __attribute__ after parameter list, but hcvc seems to silently ignore it. */
#define VCOS_WEAK_ALIAS(ret_type,alias_name,param_list,target_name) __attribute__ ((weak, alias(#target_name))) ret_type alias_name param_list





/** Define a function as a weak alias to another function, specified as a string.
 * @param ret_type     Function return type.
 * @param alias_name   Name of the alias.
 * @param param_list   Function parameter list, including the parentheses.
 * @param target_name  Target function name as a string.
 * @note Prefer the use of VCOS_WEAK_ALIAS - it is likely to be more portable.
 *       Only use VCOS_WEAK_ALIAS_STR if you need to do pre-processor mangling of the target
 *       symbol.
 */

  /* N.B. gcc allows __attribute__ after parameter list, but hcvc seems to silently ignore it. */
#define VCOS_WEAK_ALIAS_STR(ret_type,alias_name,param_list,target_name) __attribute__ ((weak, alias(target_name))) ret_type alias_name param_list






#define VCOS_DEPRECATED(msg) __attribute__((deprecated(msg)))
# 150 "/opt/vc/include/interface/vcos/vcos_assert.h" 2
# 159 "/opt/vc/include/interface/vcos/vcos_assert.h"
/*
 * ANDROID should NOT be defined for files built for Videocore, but currently it
 * is. FIXME When that's fixed, remove the __VIDEOCORE__ band-aid.
 */






#define VCOS_VERIFY_BKPTS vcos_verify_bkpts_enabled()






#define VCOS_BKPT (void )0




#define VCOS_ASSERT_BKPT VCOS_BKPT



#define VCOS_VERIFY_BKPT (VCOS_VERIFY_BKPTS ? VCOS_BKPT : (void)0)


extern int vcos_verify_bkpts_enabled(void);
extern int vcos_verify_bkpts_enable(int enable);
extern void vcos_abort(void);
# 203 "/opt/vc/include/interface/vcos/vcos_assert.h"
#define VCOS_VERIFY_MSG(...) VCOS_ASSERT_MSG(__VA_ARGS__)
# 215 "/opt/vc/include/interface/vcos/vcos_assert.h"
#define VCOS_ASSERT_ENABLED 1
#define VCOS_VERIFY_ENABLED 1





#define VCOS_DEMAND_ENABLED 1




#define vcos_assert(cond) ( (cond) ? (void)0 : (VCOS_ASSERT_BKPT, VCOS_ASSERT_MSG("%s", #cond)) )




#define vcos_assert_msg(cond,...) ( (cond) ? (void)0 : (VCOS_ASSERT_BKPT, VCOS_ASSERT_MSG(__VA_ARGS__)) )
# 252 "/opt/vc/include/interface/vcos/vcos_assert.h"
#define vcos_demand(cond) ( (cond) ? (void)0 : (VCOS_ASSERT_BKPT, VCOS_ASSERT_MSG("%s", #cond), vcos_abort()) )




#define vcos_demand_msg(cond,...) ( (cond) ? (void)0 : (VCOS_ASSERT_BKPT, VCOS_ASSERT_MSG(__VA_ARGS__), vcos_abort()) )
# 279 "/opt/vc/include/interface/vcos/vcos_assert.h"
#define vcos_verify(cond) ( (cond) ? 1 : (VCOS_VERIFY_MSG("%s", #cond), VCOS_VERIFY_BKPT, 0) )




#define vcos_verify_msg(cond,...) ( (cond) ? 1 : (VCOS_VERIFY_MSG(__VA_ARGS__), VCOS_VERIFY_BKPT, 0) )
# 303 "/opt/vc/include/interface/vcos/vcos_assert.h"
#define vcos_static_assert(cond) __attribute__((unused)) extern int vcos_static_assert[(cond)?1:-1]






#define vc_assert(cond) vcos_assert(cond)


#define vcos_unreachable() vcos_assert(0)
#define vcos_not_impl() vcos_assert(0)

/** Print out a backtrace, on supported platforms.
  */
extern void vcos_backtrace_self(void);
# 115 "/opt/vc/include/interface/vcos/vcos.h" 2
# 1 "/opt/vc/include/interface/vcos/vcos_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/
# 116 "/opt/vc/include/interface/vcos/vcos.h" 2


# 1 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - pthreads types
=============================================================================*/

/* DO NOT include this file directly - instead include it via vcos.h */

/** @file
  *
  * Pthreads implementation of VCOS.
  *
  */


#define VCOS_PLATFORM_H 





# 1 "/usr/include/pthread.h" 1 3 4

# 1 "/usr/include/pthread.h" 3 4
/* Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 48 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 2
# 1 "/usr/include/semaphore.h" 1 3 4
/* Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _SEMAPHORE_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 22 "/usr/include/semaphore.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/sys/types.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */
# 23 "/usr/include/semaphore.h" 2 3 4

#define __need_timespec 
# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 26 "/usr/include/semaphore.h" 2 3 4


/* Get the definition for sem_t.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/semaphore.h" 1 3 4
/* Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */






#define __SIZEOF_SEM_T 16


/* Value returned if `sem_open' failed.  */
#define SEM_FAILED ((sem_t *) 0)


typedef union
{
  char __size[16];
  long int __align;
} sem_t;
# 30 "/usr/include/semaphore.h" 2 3 4




/* Initialize semaphore object SEM to VALUE.  If PSHARED then share it
   with other processes.  */
extern int sem_init (sem_t *__sem, int __pshared, unsigned int __value)
     __attribute__ ((__nothrow__ , __leaf__));
/* Free resources associated with semaphore object SEM.  */
extern int sem_destroy (sem_t *__sem) __attribute__ ((__nothrow__ , __leaf__));

/* Open a named semaphore NAME with open flags OFLAG.  */
extern sem_t *sem_open (const char *__name, int __oflag, ...) __attribute__ ((__nothrow__ , __leaf__));

/* Close descriptor for named semaphore SEM.  */
extern int sem_close (sem_t *__sem) __attribute__ ((__nothrow__ , __leaf__));

/* Remove named semaphore NAME.  */
extern int sem_unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__));

/* Wait for SEM being posted.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int sem_wait (sem_t *__sem);


/* Similar to `sem_wait' but wait only until ABSTIME.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int sem_timedwait (sem_t *__restrict __sem,
     const struct timespec *__restrict __abstime);


/* Test whether SEM is posted.  */
extern int sem_trywait (sem_t *__sem) __attribute__ ((__nothrow__));

/* Post SEM.  */
extern int sem_post (sem_t *__sem) __attribute__ ((__nothrow__));

/* Get current value of SEM and store it in *SVAL.  */
extern int sem_getvalue (sem_t *__restrict __sem, int *__restrict __sval)
     __attribute__ ((__nothrow__ , __leaf__));



# 49 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 2
# 1 "/usr/include/unistd.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.10 Symbolic Constants		<unistd.h>
 */
# 50 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 2
# 1 "/usr/include/arm-linux-gnueabihf/sys/types.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */
# 51 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 2
# 1 "/usr/include/sched.h" 1 3 4
/* Definitions for POSIX 1003.1b-1993 (aka POSIX.4) scheduling interface.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 52 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 2
# 1 "/usr/include/errno.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.5 Errors	<errno.h>
 */
# 62 "/usr/include/errno.h" 3 4
/* The Hurd <bits/errno.h> defines `error_t' as an enumerated type so
   that printing `error_t' values in the debugger shows the names.  We
   might need this definition sometimes even if this file was included
   before.  */





#undef __need_error_t
# 53 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 2
# 1 "/usr/include/unistd.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.10 Symbolic Constants		<unistd.h>
 */
# 54 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 2
# 1 "/usr/include/string.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.21 String handling	<string.h>
 */
# 55 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 2
# 1 "/usr/include/strings.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _STRINGS_H 1

/* We don't need and should not read this file if <string.h> was already
   read. The one exception being that if __USE_MISC isn't defined, then
   these aren't defined in string.h, so we need to define them here.  */
# 56 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 2
# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 57 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 2
# 1 "/usr/include/signal.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.14 Signal handling <signal.h>
 */
# 58 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 2
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
# 59 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 2
# 1 "/usr/include/stdlib.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.20 General utilities	<stdlib.h>
 */
# 60 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 2
# 1 "/usr/include/dlfcn.h" 1 3 4
/* User functions for run-time dynamic loading.
   Copyright (C) 1995-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _DLFCN_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 23 "/usr/include/dlfcn.h" 2 3 4
#define __need_size_t 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 160 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 347 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_wchar_t
# 362 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 25 "/usr/include/dlfcn.h" 2 3 4

/* Collect various system dependent definitions and declarations.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/dlfcn.h" 1 3 4
/* System dependent definitions for run-time dynamic loading.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* The MODE argument to `dlopen' contains one of the following: */
#define RTLD_LAZY 0x00001
#define RTLD_NOW 0x00002
#define RTLD_BINDING_MASK 0x3
#define RTLD_NOLOAD 0x00004
#define RTLD_DEEPBIND 0x00008

/* If the following bit is set in the MODE argument to `dlopen',
   the symbols of the loaded object and its dependencies are made
   visible as if the object were linked directly into the program.  */
#define RTLD_GLOBAL 0x00100

/* Unix98 demands the following flag which is the inverse to RTLD_GLOBAL.
   The implementation does this by default and so we can define the
   value to zero.  */
#define RTLD_LOCAL 0

/* Do not delete object when closed.  */
#define RTLD_NODELETE 0x01000


/* To support profiling of shared objects it is a good idea to call
   the function found using `dlsym' using the following macro since
   these calls do not use the PLT.  But this would mean the dynamic
   loader has no chance to find out when the function is called.  The
   macro applies the necessary magic so that profiling is possible.
   Rewrite
	foo = (*fctp) (arg1, arg2);
   into
        foo = DL_CALL_FCT (fctp, (arg1, arg2));
*/
#define DL_CALL_FCT(fctp,args) (_dl_mcount_wrapper_check ((void *) (fctp)), (*(fctp)) args)




/* This function calls the profiling functions.  */
extern void _dl_mcount_wrapper_check (void *__selfpc) __attribute__ ((__nothrow__ , __leaf__));


# 28 "/usr/include/dlfcn.h" 2 3 4



/* If the first argument of `dlsym' or `dlvsym' is set to RTLD_NEXT
   the run-time address of the symbol called NAME in the next shared
   object is returned.  The "next" relation is defined by the order
   the shared objects were loaded.  */
#define RTLD_NEXT ((void *) -1l)

/* If the first argument to `dlsym' or `dlvsym' is set to RTLD_DEFAULT
   the run-time address of the symbol called NAME in the global scope
   is returned.  */
#define RTLD_DEFAULT ((void *) 0)


/* Type for namespace indeces.  */
typedef long int Lmid_t;

/* Special namespace ID values.  */
#define LM_ID_BASE 0
#define LM_ID_NEWLM -1





/* Open the shared object FILE and map it in; return a handle that can be
   passed to `dlsym' to get symbol values from it.  */
extern void *dlopen (const char *__file, int __mode) __attribute__ ((__nothrow__));

/* Unmap and close a shared object opened by `dlopen'.
   The handle cannot be used again after calling `dlclose'.  */
extern int dlclose (void *__handle) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));

/* Find the run-time address in the shared object HANDLE refers to
   of the symbol called NAME.  */
extern void *dlsym (void *__restrict __handle,
      const char *__restrict __name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


/* Like `dlopen', but request object to be allocated in a new namespace.  */
extern void *dlmopen (Lmid_t __nsid, const char *__file, int __mode) __attribute__ ((__nothrow__));

/* Find the run-time address in the shared object HANDLE refers to
   of the symbol called NAME with VERSION.  */
extern void *dlvsym (void *__restrict __handle,
       const char *__restrict __name,
       const char *__restrict __version)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));


/* When any of the above functions fails, call this function
   to return a string describing the error.  Each call resets
   the error string so that a following call returns null.  */
extern char *dlerror (void) __attribute__ ((__nothrow__ , __leaf__));



/* Structure containing information about object searched using
   `dladdr'.  */
typedef struct
{
  const char *dli_fname; /* File name of defining object.  */
  void *dli_fbase; /* Load address of that object.  */
  const char *dli_sname; /* Name of nearest symbol.  */
  void *dli_saddr; /* Exact value of nearest symbol.  */
} Dl_info;

/* Fill in *INFO with the following information about ADDRESS.
   Returns 0 iff no shared object's segments contain that address.  */
extern int dladdr (const void *__address, Dl_info *__info)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

/* Same as `dladdr', but additionally sets *EXTRA_INFO according to FLAGS.  */
extern int dladdr1 (const void *__address, Dl_info *__info,
      void **__extra_info, int __flags) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

/* These are the possible values for the FLAGS argument to `dladdr1'.
   This indicates what extra information is stored at *EXTRA_INFO.
   It may also be zero, in which case the EXTRA_INFO argument is not used.  */
enum
  {
    /* Matching symbol table entry (const ElfNN_Sym *).  */
    RTLD_DL_SYMENT = 1,

    /* The object containing the address (struct link_map *).  */
    RTLD_DL_LINKMAP = 2
  };


/* Get information about the shared object HANDLE refers to.
   REQUEST is from among the values below, and determines the use of ARG.

   On success, returns zero.  On failure, returns -1 and records an error
   message to be fetched with `dlerror'.  */
extern int dlinfo (void *__restrict __handle,
     int __request, void *__restrict __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

/* These are the possible values for the REQUEST argument to `dlinfo'.  */
enum
  {
    /* Treat ARG as `lmid_t *'; store namespace ID for HANDLE there.  */
    RTLD_DI_LMID = 1,

    /* Treat ARG as `struct link_map **';
       store the `struct link_map *' for HANDLE there.  */
    RTLD_DI_LINKMAP = 2,

    RTLD_DI_CONFIGADDR = 3, /* Unsupported, defined by Solaris.  */

    /* Treat ARG as `Dl_serinfo *' (see below), and fill in to describe the
       directories that will be searched for dependencies of this object.
       RTLD_DI_SERINFOSIZE fills in just the `dls_cnt' and `dls_size'
       entries to indicate the size of the buffer that must be passed to
       RTLD_DI_SERINFO to fill in the full information.  */
    RTLD_DI_SERINFO = 4,
    RTLD_DI_SERINFOSIZE = 5,

    /* Treat ARG as `char *', and store there the directory name used to
       expand $ORIGIN in this shared object's dependency file names.  */
    RTLD_DI_ORIGIN = 6,

    RTLD_DI_PROFILENAME = 7, /* Unsupported, defined by Solaris.  */
    RTLD_DI_PROFILEOUT = 8, /* Unsupported, defined by Solaris.  */

    /* Treat ARG as `size_t *', and store there the TLS module ID
       of this object's PT_TLS segment, as used in TLS relocations;
       store zero if this object does not define a PT_TLS segment.  */
    RTLD_DI_TLS_MODID = 9,

    /* Treat ARG as `void **', and store there a pointer to the calling
       thread's TLS block corresponding to this object's PT_TLS segment.
       Store a null pointer if this object does not define a PT_TLS
       segment, or if the calling thread has not allocated a block for it.  */
    RTLD_DI_TLS_DATA = 10,

    RTLD_DI_MAX = 10
  };


/* This is the type of elements in `Dl_serinfo', below.
   The `dls_name' member points to space in the buffer passed to `dlinfo'.  */
typedef struct
{
  char *dls_name; /* Name of library search path directory.  */
  unsigned int dls_flags; /* Indicates where this directory came from. */
} Dl_serpath;

/* This is the structure that must be passed (by reference) to `dlinfo' for
   the RTLD_DI_SERINFO and RTLD_DI_SERINFOSIZE requests.  */
typedef struct
{
  size_t dls_size; /* Size in bytes of the whole buffer.  */
  unsigned int dls_cnt; /* Number of elements in `dls_serpath'.  */
  Dl_serpath dls_serpath[1]; /* Actually longer, dls_cnt elements.  */
} Dl_serinfo;




# 61 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 2


#define VCOS_HAVE_RTOS 1
#define VCOS_HAVE_SEMAPHORE 1
#define VCOS_HAVE_EVENT 1
#define VCOS_HAVE_QUEUE 0
#define VCOS_HAVE_LEGACY_ISR 0
#define VCOS_HAVE_TIMER 1
#define VCOS_HAVE_CANCELLATION_SAFE_TIMER 1
#define VCOS_HAVE_MEMPOOL 0
#define VCOS_HAVE_ISR 0
#define VCOS_HAVE_ATOMIC_FLAGS 1
#define VCOS_HAVE_THREAD_AT_EXIT 1
#define VCOS_HAVE_ONCE 1
#define VCOS_HAVE_BLOCK_POOL 1
#define VCOS_HAVE_FILE 0
#define VCOS_HAVE_PROC 0
#define VCOS_HAVE_CFG 0
#define VCOS_HAVE_ALIEN_THREADS 1
#define VCOS_HAVE_CMD 1
#define VCOS_HAVE_EVENT_FLAGS 1
#define VCOS_WANT_LOG_CMD 0

#define VCOS_ALWAYS_WANT_LOGGING 


#define VCOS_HAVE_BACKTRACE 1


#define VCOS_SO_EXT ".so"


# 92 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
/* Linux/pthreads seems to have different timer characteristics */
#define VCOS_TIMER_MARGIN_EARLY 0
#define VCOS_TIMER_MARGIN_LATE 15

typedef sem_t VCOS_SEMAPHORE_T;
typedef uint32_t VCOS_UNSIGNED;
typedef uint32_t VCOS_OPTION;
typedef pthread_key_t VCOS_TLS_KEY_T;
typedef pthread_once_t VCOS_ONCE_T;

typedef struct VCOS_LLTHREAD_T
{
   pthread_t thread; // Must be first field.
} VCOS_LLTHREAD_T;

/* VCOS_CASSERT(offsetof(VCOS_LLTHREAD_T, thread) == 0); */


typedef pthread_mutex_t VCOS_MUTEX_T;




typedef struct
{
   VCOS_MUTEX_T mutex;
   sem_t sem;
} VCOS_EVENT_T;

#define VCOS_ONCE_INIT PTHREAD_ONCE_INIT

typedef struct VCOS_TIMER_T
{
   pthread_t thread; /**< id of the timer thread */

   pthread_mutex_t lock; /**< lock protecting all other members of the struct */
   pthread_cond_t settings_changed; /**< cond. var. for informing the timer thread about changes*/
   int quit; /**< non-zero if the timer thread is requested to quit*/

   struct timespec expires; /**< absolute time of next expiration, or 0 if disarmed*/

   void (*orig_expiration_routine)(void*);/**< the expiration routine provided by the user of the timer*/
   void *orig_context; /**< the context for exp. routine provided by the user*/

} VCOS_TIMER_T;

/** Thread attribute structure. Don't use pthread_attr directly, as
  * the calls can fail, and inits must match deletes.
  */
typedef struct VCOS_THREAD_ATTR_T
{
   void *ta_stackaddr;
   VCOS_UNSIGNED ta_stacksz;
   VCOS_UNSIGNED ta_priority;
   VCOS_UNSIGNED ta_affinity;
   VCOS_UNSIGNED ta_timeslice;
   VCOS_UNSIGNED legacy;
} VCOS_THREAD_ATTR_T;

/** Called at thread exit.
  */
typedef struct VCOS_THREAD_EXIT_T
{
   void (*pfn)(void *);
   void *cxt;
} VCOS_THREAD_EXIT_T;
#define VCOS_MAX_EXIT_HANDLERS 4

typedef struct VCOS_THREAD_T
{
   pthread_t thread; /**< The thread itself */
   VCOS_THREAD_ENTRY_FN_T entry; /**< The thread entry point */
   void *arg; /**< The argument to be passed to entry */
   VCOS_SEMAPHORE_T suspend; /**< For support event groups and similar - a per thread semaphore */

   VCOS_TIMER_T task_timer;
   int task_timer_created; /**< non-zero if the task timer has already been created*/
   void (*orig_task_timer_expiration_routine)(void*);
   void *orig_task_timer_context;

   VCOS_UNSIGNED legacy;
   char name[16]; /**< Record the name of this thread, for diagnostics */
   VCOS_UNSIGNED dummy; /**< Dummy thread created for non-vcos created threads */

   /** Callback invoked at thread exit time */
   VCOS_THREAD_EXIT_T at_exit[4];
} VCOS_THREAD_T;
# 191 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
#define VCOS_SUSPEND -1
#define VCOS_NO_SUSPEND 0

#define VCOS_START 1
#define VCOS_NO_START 0

#define VCOS_THREAD_PRI_MIN (sched_get_priority_min(SCHED_OTHER))
#define VCOS_THREAD_PRI_MAX (sched_get_priority_max(SCHED_OTHER))

#define VCOS_THREAD_PRI_INCREASE (1)
#define VCOS_THREAD_PRI_HIGHEST VCOS_THREAD_PRI_MAX
#define VCOS_THREAD_PRI_LOWEST VCOS_THREAD_PRI_MIN
#define VCOS_THREAD_PRI_NORMAL ((VCOS_THREAD_PRI_MAX+VCOS_THREAD_PRI_MIN)/2)
#define VCOS_THREAD_PRI_BELOW_NORMAL (VCOS_THREAD_PRI_NORMAL-VCOS_THREAD_PRI_INCREASE)
#define VCOS_THREAD_PRI_ABOVE_NORMAL (VCOS_THREAD_PRI_NORMAL+VCOS_THREAD_PRI_INCREASE)
#define VCOS_THREAD_PRI_REALTIME VCOS_THREAD_PRI_MAX

#define _VCOS_AFFINITY_DEFAULT 0
#define _VCOS_AFFINITY_CPU0 0x100
#define _VCOS_AFFINITY_CPU1 0x200
#define _VCOS_AFFINITY_MASK 0x300
#define VCOS_CAN_SET_STACK_ADDR 0

#define VCOS_TICKS_PER_SECOND _vcos_get_ticks_per_second()

# 1 "/opt/vc/include/interface/vcos/generic/vcos_generic_event_flags.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - event flags implemented via a semaphore
=============================================================================*/


#define VCOS_GENERIC_EVENT_FLAGS_H 





# 1 "/opt/vc/include/interface/vcos/vcos_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/
# 40 "/opt/vc/include/interface/vcos/generic/vcos_generic_event_flags.h" 2

/**
  * \file
  *
  * This provides event flags (as per Nucleus Event Groups) based on a
  * mutex, a semaphore (per waiting thread) and a timer (per waiting
  * thread).
  * 
  * The data structure is a 32 bit unsigned int (the current set of
  * flags) and a linked list of clients waiting to be 'satisfied'.
  *
  * The mutex merely locks access to the data structure. If a client
  * calls vcos_event_flags_get() and the requested bits are not already
  * present, it then sleeps on its per-thread semaphore after adding
  * this semaphore to the queue waiting. It also sets up a timer.
  *
  * The per-thread semaphore and timer are actually stored in the
  * thread context (joinable thread). In future it may become necessary
  * to support non-VCOS threads by using thread local storage to
  * create these objects and associate them with the thread.
  */

struct VCOS_EVENT_WAITER_T;

typedef struct VCOS_EVENT_FLAGS_T
{
   VCOS_UNSIGNED events; /**< Events currently set */
   VCOS_MUTEX_T lock; /**< Serialize access */
   struct
   {
      struct VCOS_EVENT_WAITER_T *head; /**< List of threads waiting */
      struct VCOS_EVENT_WAITER_T *tail; /**< List of threads waiting */
   } waiters;
} VCOS_EVENT_FLAGS_T;

#define VCOS_OR 1
#define VCOS_AND 2
#define VCOS_CONSUME 4
#define VCOS_OR_CONSUME (VCOS_OR | VCOS_CONSUME)
#define VCOS_AND_CONSUME (VCOS_AND | VCOS_CONSUME)
#define VCOS_EVENT_FLAG_OP_MASK (VCOS_OR|VCOS_AND)

extern VCOS_STATUS_T vcos_generic_event_flags_create(VCOS_EVENT_FLAGS_T *flags, const char *name);
extern void vcos_generic_event_flags_set(VCOS_EVENT_FLAGS_T *flags,
                                                      VCOS_UNSIGNED events,
                                                      VCOS_OPTION op);
extern void vcos_generic_event_flags_delete(VCOS_EVENT_FLAGS_T *);
extern VCOS_STATUS_T vcos_generic_event_flags_get(VCOS_EVENT_FLAGS_T *flags,
                                                               VCOS_UNSIGNED requested_events,
                                                               VCOS_OPTION op,
                                                               VCOS_UNSIGNED suspend,
                                                               VCOS_UNSIGNED *retrieved_events);



static __inline__
VCOS_STATUS_T vcos_event_flags_create(VCOS_EVENT_FLAGS_T *flags, const char *name) {
   return vcos_generic_event_flags_create(flags, name);
}

static __inline__
void vcos_event_flags_set(VCOS_EVENT_FLAGS_T *flags,
                          VCOS_UNSIGNED events,
                          VCOS_OPTION op) {
   vcos_generic_event_flags_set(flags, events, op);
}

static __inline__
void vcos_event_flags_delete(VCOS_EVENT_FLAGS_T *f) {
   vcos_generic_event_flags_delete(f);
}

static __inline__
VCOS_STATUS_T vcos_event_flags_get(VCOS_EVENT_FLAGS_T *flags,
                                   VCOS_UNSIGNED requested_events,
                                   VCOS_OPTION op,
                                   VCOS_UNSIGNED suspend,
                                   VCOS_UNSIGNED *retrieved_events) {
   return vcos_generic_event_flags_get(flags, requested_events, op, suspend, retrieved_events);
}
# 217 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 2
# 1 "/opt/vc/include/interface/vcos/generic/vcos_generic_blockpool.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - event flags implemented via a semaphore
=============================================================================*/


#define VCOS_GENERIC_BLOCKPOOL_H 

/**
  * \file
  *
  * This provides a generic, thread safe implementation of a VCOS block pool
  * fixed size memory allocator.
  */





# 1 "/opt/vc/include/interface/vcos/vcos_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/
# 47 "/opt/vc/include/interface/vcos/generic/vcos_generic_blockpool.h" 2

/** Bits 0 to (VCOS_BLOCKPOOL_SUBPOOL_BITS - 1) are used to store the
 * subpool id. */
#define VCOS_BLOCKPOOL_SUBPOOL_BITS 3
#define VCOS_BLOCKPOOL_MAX_SUBPOOLS (1 << VCOS_BLOCKPOOL_SUBPOOL_BITS)

/* Make zero an invalid handle at the cost of decreasing the maximum
 * number of blocks (2^28) by 1. Alternatively, a spare bit could be
 * used to indicated valid blocks but there are likely to be better
 * uses for spare bits. e.g. allowing more subpools
 */
#define INDEX_OFFSET 1

#define VCOS_BLOCKPOOL_HANDLE_GET_INDEX(h) (((h) >> VCOS_BLOCKPOOL_SUBPOOL_BITS) - INDEX_OFFSET)


#define VCOS_BLOCKPOOL_HANDLE_GET_SUBPOOL(h) ((h) & ((1 << VCOS_BLOCKPOOL_SUBPOOL_BITS) - 1))


#define VCOS_BLOCKPOOL_HANDLE_CREATE(i,s) ((((i) + INDEX_OFFSET) << VCOS_BLOCKPOOL_SUBPOOL_BITS) | (s))


#define VCOS_BLOCKPOOL_INVALID_HANDLE 0
#define VCOS_BLOCKPOOL_ALIGN_DEFAULT sizeof(unsigned long)
#define VCOS_BLOCKPOOL_FLAG_NONE 0

typedef struct VCOS_BLOCKPOOL_HEADER_TAG
{
   /* Blocks either refer to to the pool if they are allocated
    * or the free list if they are available.
    */
   union {
   struct VCOS_BLOCKPOOL_HEADER_TAG *next;
   struct VCOS_BLOCKPOOL_SUBPOOL_TAG* subpool;
   } owner;
} VCOS_BLOCKPOOL_HEADER_T;

typedef struct VCOS_BLOCKPOOL_SUBPOOL_TAG
{
   /** VCOS_BLOCKPOOL_SUBPOOL_MAGIC */
   uint32_t magic;
   VCOS_BLOCKPOOL_HEADER_T* free_list;
   /* The start of the pool memory */
   void *mem;
   /* Address of the first block header */
   void *start;
   /* The end of the subpool */
   void *end;
   /** The number of blocks in this sub-pool */
   VCOS_UNSIGNED num_blocks;
   /** Current number of available blocks in this sub-pool */
   VCOS_UNSIGNED available_blocks;
   /** Pointers to the pool that owns this sub-pool */
   struct VCOS_BLOCKPOOL_TAG* owner;
   /** Define properties such as memory ownership */
   uint32_t flags;
} VCOS_BLOCKPOOL_SUBPOOL_T;

typedef struct VCOS_BLOCKPOOL_TAG
{
   /** VCOS_BLOCKPOOL_MAGIC */
   uint32_t magic;
   /** Thread safety for Alloc, Free, Delete, Stats */
   VCOS_MUTEX_T mutex;
   /** Alignment of block data pointers */
   VCOS_UNSIGNED align;
   /** Flags for future use e.g. cache options */
   VCOS_UNSIGNED flags;
   /** The size of the block data */
   size_t block_data_size;
   /** Block size inc overheads */
   size_t block_size;
   /** Name for debugging */
   const char *name;
   /* The number of subpools that may be used */
   VCOS_UNSIGNED num_subpools;
   /** Number of blocks in each dynamically allocated subpool */
   VCOS_UNSIGNED num_extension_blocks;
   /** Array of subpools. Subpool zero is is not deleted until the pool is
    * destroed. If the index of the pool is < num_subpools and
    * subpool[index.mem] is null then the subpool entry is valid but
    * "not currently allocated" */
   VCOS_BLOCKPOOL_SUBPOOL_T subpools[(1 << 3)];
} VCOS_BLOCKPOOL_T;

#define VCOS_BLOCKPOOL_ROUND_UP(x,s) (((x) + ((s) - 1)) & ~((s) - 1))
/**
 * Calculates the size in bytes required for a block pool containing
 * num_blocks of size block_size plus any overheads.
 *
 * The block pool header (VCOS_BLOCKPOOL_T) is allocated separately
 *
 * Overheads:
 * block_size + header must be rounded up to meet the required alignment
 * The start of the first block may need to be up to align bytes
 * into the given buffer because statically allocated buffers within structures
 * are not guaranteed to be aligned as required.
 */
#define VCOS_BLOCKPOOL_SIZE(num_blocks,block_size,align) ((VCOS_BLOCKPOOL_ROUND_UP((block_size) + (align >= 4096 ? 32 : 0) + sizeof(VCOS_BLOCKPOOL_HEADER_T), (align)) * (num_blocks)) + (align))



/**
 * Sanity check to verify whether a handle is potentially a blockpool handle
 * when the pool pointer is not available.
 *
 * If the pool pointer is available use vcos_blockpool_elem_to_handle instead.
 *
 * @param handle       the handle to verify
 * @param max_blocks   the expected maximum number of block in the pool
 *                     that the handle belongs to.
 */
#define VCOS_BLOCKPOOL_IS_VALID_HANDLE_FORMAT(handle,max_blocks) ((handle) != VCOS_BLOCKPOOL_INVALID_HANDLE && VCOS_BLOCKPOOL_HANDLE_GET_INDEX((handle)) < (max_blocks))



extern
   VCOS_STATUS_T vcos_generic_blockpool_init(VCOS_BLOCKPOOL_T *pool,
      VCOS_UNSIGNED num_blocks, VCOS_UNSIGNED block_size,
      void *start, VCOS_UNSIGNED pool_size,
      VCOS_UNSIGNED align, VCOS_UNSIGNED flags,
      const char *name);

extern
   VCOS_STATUS_T vcos_generic_blockpool_create_on_heap(
         VCOS_BLOCKPOOL_T *pool, VCOS_UNSIGNED num_blocks,
         VCOS_UNSIGNED block_size,
         VCOS_UNSIGNED align, VCOS_UNSIGNED flags,
         const char *name);

extern
   VCOS_STATUS_T vcos_generic_blockpool_extend(VCOS_BLOCKPOOL_T *pool,
         VCOS_UNSIGNED num_extensions, VCOS_UNSIGNED num_blocks);

extern void *vcos_generic_blockpool_alloc(VCOS_BLOCKPOOL_T *pool);

extern void *vcos_generic_blockpool_calloc(VCOS_BLOCKPOOL_T *pool);

extern void vcos_generic_blockpool_free(void *block);

extern
   VCOS_UNSIGNED vcos_generic_blockpool_available_count(
         VCOS_BLOCKPOOL_T *pool);

extern
   VCOS_UNSIGNED vcos_generic_blockpool_used_count(
         VCOS_BLOCKPOOL_T *pool);

extern void vcos_generic_blockpool_delete(VCOS_BLOCKPOOL_T *pool);

extern uint32_t vcos_generic_blockpool_elem_to_handle(void *block);

extern void
   *vcos_generic_blockpool_elem_from_handle(
         VCOS_BLOCKPOOL_T *pool, uint32_t handle);

extern uint32_t
   vcos_generic_blockpool_is_valid_elem(
         VCOS_BLOCKPOOL_T *pool, const void *block);


static __inline__
VCOS_STATUS_T vcos_blockpool_init(VCOS_BLOCKPOOL_T *pool,
      VCOS_UNSIGNED num_blocks, VCOS_UNSIGNED block_size,
      void *start, VCOS_UNSIGNED pool_size,
      VCOS_UNSIGNED align, VCOS_UNSIGNED flags, const char *name)
{
   return vcos_generic_blockpool_init(pool, num_blocks, block_size,
         start, pool_size, align, flags, name);
}

static __inline__
VCOS_STATUS_T vcos_blockpool_create_on_heap(VCOS_BLOCKPOOL_T *pool,
      VCOS_UNSIGNED num_blocks, VCOS_UNSIGNED block_size,
      VCOS_UNSIGNED align, VCOS_UNSIGNED flags, const char *name)
{
   return vcos_generic_blockpool_create_on_heap(
         pool, num_blocks, block_size, align, flags, name);
}

static __inline__
   VCOS_STATUS_T vcos_blockpool_extend(VCOS_BLOCKPOOL_T *pool,
         VCOS_UNSIGNED num_extensions, VCOS_UNSIGNED num_blocks)
{
    return vcos_generic_blockpool_extend(pool, num_extensions, num_blocks);
}

static __inline__
void *vcos_blockpool_alloc(VCOS_BLOCKPOOL_T *pool)
{
   return vcos_generic_blockpool_alloc(pool);
}

static __inline__
void *vcos_blockpool_calloc(VCOS_BLOCKPOOL_T *pool)
{
   return vcos_generic_blockpool_calloc(pool);
}

static __inline__
void vcos_blockpool_free(void *block)
{
   vcos_generic_blockpool_free(block);
}

static __inline__
VCOS_UNSIGNED vcos_blockpool_available_count(VCOS_BLOCKPOOL_T *pool)
{
   return vcos_generic_blockpool_available_count(pool);
}

static __inline__
VCOS_UNSIGNED vcos_blockpool_used_count(VCOS_BLOCKPOOL_T *pool)
{
   return vcos_generic_blockpool_used_count(pool);
}

static __inline__
void vcos_blockpool_delete(VCOS_BLOCKPOOL_T *pool)
{
   vcos_generic_blockpool_delete(pool);
}

static __inline__
uint32_t vcos_blockpool_elem_to_handle(void *block)
{
   return vcos_generic_blockpool_elem_to_handle(block);
}

static __inline__
void *vcos_blockpool_elem_from_handle(VCOS_BLOCKPOOL_T *pool, uint32_t handle)
{
   return vcos_generic_blockpool_elem_from_handle(pool, handle);
}

static __inline__
uint32_t vcos_blockpool_is_valid_elem(VCOS_BLOCKPOOL_T *pool, const void *block)
{
   return vcos_generic_blockpool_is_valid_elem(pool, block);
}
# 218 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 2
# 1 "/opt/vc/include/interface/vcos/generic/vcos_mem_from_malloc.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
Create the vcos_malloc API from the regular system malloc/free
=============================================================================*/

/**
  * \file
  *
  * Create the vcos malloc API from a regular system malloc/free library.
  *
  * The API lets callers specify an alignment.
  *
  * Under VideoCore this is not needed, as we can simply use the rtos_malloc routines.
  * But on host platforms that won't be the case.
  *
  */

extern void * vcos_generic_mem_alloc(VCOS_UNSIGNED sz, const char *desc);
extern void * vcos_generic_mem_calloc(VCOS_UNSIGNED count, VCOS_UNSIGNED sz, const char *descr);
extern void vcos_generic_mem_free(void *ptr);
extern void * vcos_generic_mem_alloc_aligned(VCOS_UNSIGNED sz, VCOS_UNSIGNED align, const char *desc);



static __inline__
void *vcos_malloc(VCOS_UNSIGNED size, const char *description) {
   return vcos_generic_mem_alloc(size, description);
}

static __inline__
void *vcos_calloc(VCOS_UNSIGNED num, VCOS_UNSIGNED size, const char *description) {
   return vcos_generic_mem_calloc(num, size, description);
}

static __inline__
void vcos_free(void *ptr) {
   vcos_generic_mem_free(ptr);
}

static __inline__
void * vcos_malloc_aligned(VCOS_UNSIGNED size, VCOS_UNSIGNED align, const char *description) {
   return vcos_generic_mem_alloc_aligned(size, align, description);
}

/* Returns invalid result, do not use */

static __inline__
unsigned long __attribute__((deprecated("returns invalid result"))) vcos_get_free_mem(void) {
   return 0;
}
# 219 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 2

/** Convert errno values into the values recognized by vcos */
extern VCOS_STATUS_T vcos_pthreads_map_error(int error);
extern VCOS_STATUS_T vcos_pthreads_map_errno(void);

/** Register a function to be called when the current thread exits.
  */
extern VCOS_STATUS_T vcos_thread_at_exit(void (*pfn)(void*), void *cxt);

extern uint32_t _vcos_get_ticks_per_second(void);

/**
 * Set to 1 by default when ANDROID is defined. Allows runtime
 * switching for console apps.
 */
extern int vcos_use_android_log;

typedef struct {
   VCOS_MUTEX_T mutex;
   uint32_t flags;
} VCOS_ATOMIC_FLAGS_T;



#undef VCOS_ASSERT_LOGGING_DISABLE
#define VCOS_ASSERT_LOGGING_DISABLE 1


/*
 * Counted Semaphores
 */
static __inline__
VCOS_STATUS_T vcos_semaphore_wait(VCOS_SEMAPHORE_T *sem) {
   int ret;
   /* gdb causes sem_wait() to EINTR when a breakpoint is hit, retry here */
   while ((ret = sem_wait(sem)) == -1 && 
# 254 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 3 4
                                        (*__errno_location ()) 
# 254 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
                                              == 
# 254 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 3 4
                                                 4
# 254 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
                                                      )
      continue;
   ( (ret==0) ? (void)0 : ((void )0, ((1 && !1) ? vcos_pthreads_logging_assert("/opt/vc/include/interface/vcos/pthreads/vcos_platform.h", __func__, 256, "%s", "ret==0") : (void)0)) );
   return VCOS_SUCCESS;
}

static __inline__
VCOS_STATUS_T vcos_semaphore_trywait(VCOS_SEMAPHORE_T *sem) {
   int ret;
   while ((ret = sem_trywait(sem)) == -1 && 
# 263 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 3 4
                                           (*__errno_location ()) 
# 263 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
                                                 == 
# 263 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 3 4
                                                    4
# 263 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
                                                         )
      continue;
   if (ret == 0)
      return VCOS_SUCCESS;
   else if (
# 267 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 3 4
           (*__errno_location ()) 
# 267 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
                 == 
# 267 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 3 4
                    11
# 267 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
                          )
      return VCOS_EAGAIN;
   else {
      ( (0) ? (void)0 : ((void )0, ((1 && !1) ? vcos_pthreads_logging_assert("/opt/vc/include/interface/vcos/pthreads/vcos_platform.h", __func__, 270, "%s", "0") : (void)0)) );
      return VCOS_EINVAL;
   }
}

/**
  * \brief Wait on a semaphore with a timeout.
  *
  * Note that this function may not be implemented on all
  * platforms, and may not be efficient on all platforms
  * (see comment in vcos_semaphore_wait)
  *
  * Try to obtain the semaphore. If it is already taken, return
  * VCOS_EAGAIN.
  * @param sem Semaphore to wait on
  * @param timeout Number of milliseconds to wait before
  *                returning if the semaphore can't be acquired.
  * @return VCOS_SUCCESS - semaphore was taken.
  *         VCOS_EAGAIN - could not take semaphore (i.e. timeout
  *         expired)
  *         VCOS_EINVAL - Some other error (most likely bad
  *         parameters).
  */
static __inline__
VCOS_STATUS_T vcos_semaphore_wait_timeout(VCOS_SEMAPHORE_T *sem, VCOS_UNSIGNED timeout) {
   struct timespec ts;
   int ret;
   if (clock_gettime(
# 297 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 3 4
                    0
# 297 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
                                  , &ts) == -1)
      return VCOS_EINVAL;
   ts.tv_sec += timeout/1000;
   ts.tv_nsec += (timeout%1000)*1000*1000;
   if (ts.tv_nsec > 1000000000) {
      ts.tv_sec++;
      ts.tv_nsec -= 1000000000;
   }

   while (1) {
      ret = sem_timedwait( sem, &ts );
      if (ret == 0) {
         return VCOS_SUCCESS;
      } else {
         if (
# 311 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 3 4
            (*__errno_location ()) 
# 311 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
                  == 
# 311 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 3 4
                     4
# 311 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
                          ) {
            continue;
         } else if (
# 313 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 3 4
                   (*__errno_location ()) 
# 313 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
                         == 
# 313 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 3 4
                            110
# 313 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
                                     ) {
            return VCOS_EAGAIN;
         } else {
            ( (0) ? (void)0 : ((void )0, ((1 && !1) ? vcos_pthreads_logging_assert("/opt/vc/include/interface/vcos/pthreads/vcos_platform.h", __func__, 316, "%s", "0") : (void)0)) );
            return VCOS_EINVAL;
         }
      }
   }
}

static __inline__
VCOS_STATUS_T vcos_semaphore_create(VCOS_SEMAPHORE_T *sem,
                                    const char *name,
                                    VCOS_UNSIGNED initial_count) {
   int rc = sem_init(sem, 0, initial_count);
   (void)name;
   if (rc != -1) return VCOS_SUCCESS;
   else return vcos_pthreads_map_errno();
}

static __inline__
void vcos_semaphore_delete(VCOS_SEMAPHORE_T *sem) {
   int rc = sem_destroy(sem);
   ( (rc != -1) ? (void)0 : ((void )0, ((1 && !1) ? vcos_pthreads_logging_assert("/opt/vc/include/interface/vcos/pthreads/vcos_platform.h", __func__, 336, "%s", "rc != -1") : (void)0)) );
   (void)rc;
}

static __inline__
VCOS_STATUS_T vcos_semaphore_post(VCOS_SEMAPHORE_T *sem) {
   int rc = sem_post(sem);
   ( (rc == 0) ? (void)0 : ((void )0, ((1 && !1) ? vcos_pthreads_logging_assert("/opt/vc/include/interface/vcos/pthreads/vcos_platform.h", __func__, 343, "%s", "rc == 0") : (void)0)) );
   (void)rc;
   return VCOS_SUCCESS;
}

/***********************************************************
 *
 * Threads
 *
 ***********************************************************/


extern VCOS_THREAD_T *vcos_dummy_thread_create(void);
extern pthread_key_t _vcos_thread_current_key;
extern uint64_t vcos_getmicrosecs64_internal(void);

static __inline__
uint32_t vcos_getmicrosecs(void) { return (uint32_t)vcos_getmicrosecs64_internal(); }

static __inline__
uint64_t vcos_getmicrosecs64(void) { return vcos_getmicrosecs64_internal(); }

static __inline__
VCOS_THREAD_T *vcos_thread_current(void) {
   void *ret = pthread_getspecific(_vcos_thread_current_key);
   if (ret == 
# 368 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 3 4
             ((void *)0)
# 368 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
                 )
   {
      ret = vcos_dummy_thread_create();
   }




   return (VCOS_THREAD_T *)ret;

}

static __inline__
void vcos_sleep(uint32_t ms) {
   struct timespec ts;
   ts.tv_sec = ms/1000;
   ts.tv_nsec = ms % 1000 * (1000000);
   nanosleep(&ts, 
# 385 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 3 4
                 ((void *)0)
# 385 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
                     );
}

static __inline__
void vcos_thread_attr_setstack(VCOS_THREAD_ATTR_T *attr, void *addr, VCOS_UNSIGNED sz) {
   attr->ta_stackaddr = addr;
   attr->ta_stacksz = sz;
}

static __inline__
void vcos_thread_attr_setstacksize(VCOS_THREAD_ATTR_T *attr, VCOS_UNSIGNED sz) {
   attr->ta_stacksz = sz;
}

static __inline__
void vcos_thread_attr_setpriority(VCOS_THREAD_ATTR_T *attr, VCOS_UNSIGNED pri) {
   (void)attr;
   (void)pri;
}

static __inline__
void vcos_thread_set_priority(VCOS_THREAD_T *thread, VCOS_UNSIGNED p) {
   /* not implemented */
   (void)thread;
   (void)p;
}

static __inline__
VCOS_UNSIGNED vcos_thread_get_priority(VCOS_THREAD_T *thread) {
   /* not implemented */
   (void)thread;
   return 0;
}

static __inline__
void vcos_thread_set_affinity(VCOS_THREAD_T *thread, VCOS_UNSIGNED affinity) {
   /* not implemented */
   (void)(thread);
   (void)(affinity);
}


static __inline__
void vcos_thread_attr_setaffinity(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED affinity) {
   attrs->ta_affinity = affinity;
}

static __inline__
void vcos_thread_attr_settimeslice(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED ts) {
   attrs->ta_timeslice = ts;
}

static __inline__
void _vcos_thread_attr_setlegacyapi(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED legacy) {
   attrs->legacy = legacy;
}

static __inline__
void vcos_thread_attr_setautostart(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED autostart) {
   (void)attrs;
   (void)autostart;
}

static __inline__
VCOS_LLTHREAD_T *vcos_llthread_current(void) {
   return (VCOS_LLTHREAD_T *)pthread_self();
}

static __inline__
VCOS_UNSIGNED vcos_thread_get_affinity(VCOS_THREAD_T *thread) {
   (void)(thread);
   return 0x100;
}

static __inline__
int vcos_thread_running(VCOS_THREAD_T *thread) {
   (void)(thread);
   /* Not applicable to pthreads */
   return 0;
}

static __inline__
VCOS_UNSIGNED vcos_change_preemption(VCOS_UNSIGNED pe) {
   (void)(pe);
   /* Nothing to do */
   return 0;
}

static __inline__
void vcos_thread_relinquish(void) {
   /* Nothing to do */
}

static __inline__
void vcos_thread_resume(VCOS_THREAD_T *thread) {
   (void)(thread);
   /* Nothing to do */
}


/*
 * Mutexes
 */



static __inline__
VCOS_STATUS_T vcos_mutex_create(VCOS_MUTEX_T *latch, const char *name) {
   int rc = pthread_mutex_init(latch, 
# 493 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 3 4
                                     ((void *)0)
# 493 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
                                         );
   (void)name;
   if (rc == 0) return VCOS_SUCCESS;
   else return vcos_pthreads_map_errno();
}

static __inline__
void vcos_mutex_delete(VCOS_MUTEX_T *latch) {
   int rc = pthread_mutex_destroy(latch);
   (void)rc;
   ( (rc==0) ? (void)0 : ((void )0, ((1 && !1) ? vcos_pthreads_logging_assert("/opt/vc/include/interface/vcos/pthreads/vcos_platform.h", __func__, 503, "%s", "rc==0") : (void)0)) );
}

static __inline__
VCOS_STATUS_T vcos_mutex_lock(VCOS_MUTEX_T *latch) {
   int rc = pthread_mutex_lock(latch);
   ( (rc==0) ? (void)0 : ((void )0, ((1 && !1) ? vcos_pthreads_logging_assert("/opt/vc/include/interface/vcos/pthreads/vcos_platform.h", __func__, 509, "%s", "rc==0") : (void)0)) );
   (void)rc;
   return VCOS_SUCCESS;
}

static __inline__
void vcos_mutex_unlock(VCOS_MUTEX_T *latch) {
   int rc = pthread_mutex_unlock(latch);
   (void)rc;
   ( (rc==0) ? (void)0 : ((void )0, ((1 && !1) ? vcos_pthreads_logging_assert("/opt/vc/include/interface/vcos/pthreads/vcos_platform.h", __func__, 518, "%s", "rc==0") : (void)0)) );
}

static __inline__
int vcos_mutex_is_locked(VCOS_MUTEX_T *m) {
   int rc = pthread_mutex_trylock(m);
   if (rc == 0) {
      pthread_mutex_unlock(m);
      /* it wasn't locked */
      return 0;
   }
   else {
      return 1; /* it was locked */
   }
}

static __inline__
VCOS_STATUS_T vcos_mutex_trylock(VCOS_MUTEX_T *m) {
   int rc = pthread_mutex_trylock(m);
   (void)rc;
   return (rc == 0) ? VCOS_SUCCESS : VCOS_EAGAIN;
}



/*
 * Events
 */

static __inline__
VCOS_STATUS_T vcos_event_create(VCOS_EVENT_T *event, const char *debug_name)
{
   VCOS_STATUS_T status;

   int rc = sem_init(&event->sem, 0, 0);
   if (rc != 0) return vcos_pthreads_map_errno();

   status = vcos_mutex_create(&event->mutex, debug_name);
   if (status != VCOS_SUCCESS) {
      sem_destroy(&event->sem);
      return status;
   }

   return VCOS_SUCCESS;
}

static __inline__
void vcos_event_signal(VCOS_EVENT_T *event)
{
   int ok = 0;
   int value;

   if (vcos_mutex_lock(&event->mutex) != VCOS_SUCCESS)
      goto fail_mtx;

   if (sem_getvalue(&event->sem, &value) != 0)
      goto fail_sem;

   if (value == 0)
      if (sem_post(&event->sem) != 0)
         goto fail_sem;

   ok = 1;
fail_sem:
   vcos_mutex_unlock(&event->mutex);
fail_mtx:
   if (!ok)
      ( (ok) ? (void)0 : ((void )0, ((1 && !1) ? vcos_pthreads_logging_assert("/opt/vc/include/interface/vcos/pthreads/vcos_platform.h", __func__, 585, "%s", "ok") : (void)0)) );
}

static __inline__
VCOS_STATUS_T vcos_event_wait(VCOS_EVENT_T *event)
{
   int ret;
   /* gdb causes sem_wait() to EINTR when a breakpoint is hit, retry here */
   while ((ret = sem_wait(&event->sem)) == -1 && 
# 593 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 3 4
                                                (*__errno_location ()) 
# 593 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
                                                      == 
# 593 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 3 4
                                                         4
# 593 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
                                                              )
      continue;
   ( (ret==0) ? (void)0 : ((void )0, ((1 && !1) ? vcos_pthreads_logging_assert("/opt/vc/include/interface/vcos/pthreads/vcos_platform.h", __func__, 595, "%s", "ret==0") : (void)0)) );
   return ret == 0 ? VCOS_SUCCESS : (VCOS_STATUS_T)
# 596 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 3 4
                                                  (*__errno_location ())
# 596 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
                                                       ;
}

static __inline__
VCOS_STATUS_T vcos_event_try(VCOS_EVENT_T *event)
{
   int ret;
   while ((ret = sem_trywait(&event->sem)) == -1 && 
# 603 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 3 4
                                                   (*__errno_location ()) 
# 603 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
                                                         == 
# 603 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 3 4
                                                            4
# 603 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
                                                                 )
      continue;

   if (ret == -1 && 
# 606 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 3 4
                   (*__errno_location ()) 
# 606 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
                         == 
# 606 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 3 4
                            11
# 606 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
                                  )
      return VCOS_EAGAIN;
   else
      return VCOS_SUCCESS;
}

static __inline__
void vcos_event_delete(VCOS_EVENT_T *event)
{
   int rc = sem_destroy(&event->sem);
   ( (rc != -1) ? (void)0 : ((void )0, ((1 && !1) ? vcos_pthreads_logging_assert("/opt/vc/include/interface/vcos/pthreads/vcos_platform.h", __func__, 616, "%s", "rc != -1") : (void)0)) );
   (void)rc;

   vcos_mutex_delete(&event->mutex);
}

static __inline__
VCOS_UNSIGNED vcos_process_id_current(void) {
   return (VCOS_UNSIGNED) getpid();
}

static __inline__
int vcos_strcasecmp(const char *s1, const char *s2) {
   return strcasecmp(s1,s2);
}

static __inline__
int vcos_strncasecmp(const char *s1, const char *s2, size_t n) {
   return strncasecmp(s1,s2,n);
}

static __inline__
int vcos_in_interrupt(void) {
   return 0;
}

/* For support event groups - per thread semaphore */
static __inline__
void _vcos_thread_sem_wait(void) {
   VCOS_THREAD_T *t = vcos_thread_current();
   vcos_semaphore_wait(&t->suspend);
}

static __inline__
void _vcos_thread_sem_post(VCOS_THREAD_T *target) {
   vcos_semaphore_post(&target->suspend);
}

static __inline__
VCOS_STATUS_T vcos_tls_create(VCOS_TLS_KEY_T *key) {
   int st = pthread_key_create(key, 
# 656 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 3 4
                                   ((void *)0)
# 656 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
                                       );
   return st == 0 ? VCOS_SUCCESS: VCOS_ENOMEM;
}

static __inline__
void vcos_tls_delete(VCOS_TLS_KEY_T tls) {
   pthread_key_delete(tls);
}

static __inline__
VCOS_STATUS_T vcos_tls_set(VCOS_TLS_KEY_T tls, void *v) {
   pthread_setspecific(tls, v);
   return VCOS_SUCCESS;
}

static __inline__
void *vcos_tls_get(VCOS_TLS_KEY_T tls) {
   return pthread_getspecific(tls);
}

/***********************************************************
 *
 * Timers
 *
 ***********************************************************/

//Other platforms can call compatible OS implementations directly
//from inline functions with minimal overhead.
//Pthreads needs a little bit more, so call functions
//in vcos_pthreads.c from the inline functions.
VCOS_STATUS_T vcos_pthreads_timer_create(VCOS_TIMER_T *timer,
                                const char *name,
                                void (*expiration_routine)(void *context),
                                void *context);
void vcos_pthreads_timer_set(VCOS_TIMER_T *timer, VCOS_UNSIGNED delay_ms);
void vcos_pthreads_timer_cancel(VCOS_TIMER_T *timer);
void vcos_pthreads_timer_reset(VCOS_TIMER_T *timer, VCOS_UNSIGNED delay_ms);
void vcos_pthreads_timer_delete(VCOS_TIMER_T *timer);

/** Create a timer.
  *
  * Note that we just cast the expiry function - this assumes that UNSIGNED
  * and VOID* are the same size.
  */


static __inline__
VCOS_STATUS_T vcos_timer_create(VCOS_TIMER_T *timer,
                                const char *name,
                                void (*expiration_routine)(void *context),
                                void *context) {
   return vcos_pthreads_timer_create(timer, name, expiration_routine, context);
}

static __inline__
void vcos_timer_set(VCOS_TIMER_T *timer, VCOS_UNSIGNED delay_ms) {
   return vcos_pthreads_timer_set(timer, delay_ms);
}

static __inline__
void vcos_timer_cancel(VCOS_TIMER_T *timer) {
   return vcos_pthreads_timer_cancel(timer);
}

static __inline__
void vcos_timer_reset(VCOS_TIMER_T *timer, VCOS_UNSIGNED delay) {
   vcos_timer_set(timer, delay);
}

static __inline__
void vcos_timer_delete(VCOS_TIMER_T *timer) {
   vcos_pthreads_timer_delete(timer);
}



/*
 * Atomic flags
 */

/* TODO implement properly... */

static __inline__
VCOS_STATUS_T vcos_atomic_flags_create(VCOS_ATOMIC_FLAGS_T *atomic_flags)
{
   atomic_flags->flags = 0;
   return vcos_mutex_create(&atomic_flags->mutex, "VCOS_ATOMIC_FLAGS_T");
}

static __inline__
void vcos_atomic_flags_or(VCOS_ATOMIC_FLAGS_T *atomic_flags, uint32_t flags)
{
   vcos_mutex_lock(&atomic_flags->mutex);
   atomic_flags->flags |= flags;
   vcos_mutex_unlock(&atomic_flags->mutex);
}

static __inline__
uint32_t vcos_atomic_flags_get_and_clear(VCOS_ATOMIC_FLAGS_T *atomic_flags)
{
   uint32_t flags;
   vcos_mutex_lock(&atomic_flags->mutex);
   flags = atomic_flags->flags;
   atomic_flags->flags = 0;
   vcos_mutex_unlock(&atomic_flags->mutex);
   return flags;
}

static __inline__
void vcos_atomic_flags_delete(VCOS_ATOMIC_FLAGS_T *atomic_flags)
{
   vcos_mutex_delete(&atomic_flags->mutex);
}
# 784 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
#undef VCOS_ASSERT_LOGGING_DISABLE
#define VCOS_ASSERT_LOGGING_DISABLE 0



#define vcos_log_platform_init() _vcos_log_platform_init()
extern void _vcos_log_platform_init(void);

extern __inline__ void _vcos_thread_sem_wait(void);
extern __inline__ void _vcos_thread_sem_post(VCOS_THREAD_T *);

#define VCOS_APPLICATION_ARGC vcos_get_argc()
#define VCOS_APPLICATION_ARGV vcos_get_argv()

# 1 "/opt/vc/include/interface/vcos/generic/vcos_generic_reentrant_mtx.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - reentrant mutexes created from regular ones.
=============================================================================*/


#define VCOS_GENERIC_REENTRANT_MUTEX_H 





# 1 "/opt/vc/include/interface/vcos/vcos_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/
# 40 "/opt/vc/include/interface/vcos/generic/vcos_generic_reentrant_mtx.h" 2

/**
 * \file
 *
 * Reentrant Mutexes from regular ones.
 *
 */

typedef struct VCOS_REENTRANT_MUTEX_T
{
   VCOS_MUTEX_T mutex;
   VCOS_THREAD_T *owner;
   unsigned count;
} VCOS_REENTRANT_MUTEX_T;

/* Extern definitions of functions that do the actual work */

extern VCOS_STATUS_T vcos_generic_reentrant_mutex_create(VCOS_REENTRANT_MUTEX_T *m, const char *name);

extern void vcos_generic_reentrant_mutex_delete(VCOS_REENTRANT_MUTEX_T *m);

extern void vcos_generic_reentrant_mutex_lock(VCOS_REENTRANT_MUTEX_T *m);

extern void vcos_generic_reentrant_mutex_unlock(VCOS_REENTRANT_MUTEX_T *m);

/* Inline forwarding functions */



static __inline__
VCOS_STATUS_T vcos_reentrant_mutex_create(VCOS_REENTRANT_MUTEX_T *m, const char *name) {
   return vcos_generic_reentrant_mutex_create(m,name);
}

static __inline__
void vcos_reentrant_mutex_delete(VCOS_REENTRANT_MUTEX_T *m) {
   vcos_generic_reentrant_mutex_delete(m);
}

static __inline__
void vcos_reentrant_mutex_lock(VCOS_REENTRANT_MUTEX_T *m) {
   vcos_generic_reentrant_mutex_lock(m);
}

static __inline__
void vcos_reentrant_mutex_unlock(VCOS_REENTRANT_MUTEX_T *m) {
   vcos_generic_reentrant_mutex_unlock(m);
}
# 799 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 2
# 1 "/opt/vc/include/interface/vcos/generic/vcos_generic_named_sem.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - named semaphores
=============================================================================*/


#define VCOS_GENERIC_NAMED_SEM_H 





# 1 "/opt/vc/include/interface/vcos/vcos_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/
# 40 "/opt/vc/include/interface/vcos/generic/vcos_generic_named_sem.h" 2

/**
 * \file
 *
 * Generic support for named semaphores, using regular ones. This is only
 * suitable for emulating them on an embedded MMUless system, since there is
 * no support for opening semaphores across process boundaries.
 *
 */

#define VCOS_NAMED_SEMAPHORE_NAMELEN 64

/* In theory we could use the name facility provided within Nucleus. However, this
 * is hard to do as semaphores are constantly being created and destroyed; we
 * would need to stop everything while allocating the memory for the semaphore
 * list and then walking it. So keep our own list.
 */
typedef struct VCOS_NAMED_SEMAPHORE_T
{
   struct VCOS_NAMED_SEMAPHORE_IMPL_T *actual; /**< There are 'n' named semaphores per 1 actual semaphore  */
   VCOS_SEMAPHORE_T *sem; /**< Pointer to actual underlying semaphore */
} VCOS_NAMED_SEMAPHORE_T;

extern VCOS_STATUS_T
vcos_generic_named_semaphore_create(VCOS_NAMED_SEMAPHORE_T *sem, const char *name, VCOS_UNSIGNED count);

extern void vcos_named_semaphore_delete(VCOS_NAMED_SEMAPHORE_T *sem);

extern VCOS_STATUS_T _vcos_named_semaphore_init(void);
extern void _vcos_named_semaphore_deinit(void);



static __inline__
VCOS_STATUS_T vcos_named_semaphore_create(VCOS_NAMED_SEMAPHORE_T *sem, const char *name, VCOS_UNSIGNED count) {
   return vcos_generic_named_semaphore_create(sem, name, count);
}

static __inline__
void vcos_named_semaphore_wait(VCOS_NAMED_SEMAPHORE_T *sem) {
   vcos_semaphore_wait(sem->sem);
}

static __inline__
VCOS_STATUS_T vcos_named_semaphore_trywait(VCOS_NAMED_SEMAPHORE_T *sem) {
   return vcos_semaphore_trywait(sem->sem);
}

static __inline__
void vcos_named_semaphore_post(VCOS_NAMED_SEMAPHORE_T *sem) {
   vcos_semaphore_post(sem->sem);
}
# 800 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 2
# 1 "/opt/vc/include/interface/vcos/generic/vcos_generic_quickslow_mutex.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - reentrant mutexes created from regular ones.
=============================================================================*/


#define VCOS_GENERIC_QUICKSLOW_MUTEX_H 





# 1 "/opt/vc/include/interface/vcos/vcos_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/
# 40 "/opt/vc/include/interface/vcos/generic/vcos_generic_quickslow_mutex.h" 2

/**
 * \file
 *
 * Quickslow Mutexes implemented as regular ones (i.e. quick and slow modes are the same).
 *
 */

typedef VCOS_MUTEX_T VCOS_QUICKSLOW_MUTEX_T;


static __inline__
VCOS_STATUS_T vcos_quickslow_mutex_create(VCOS_QUICKSLOW_MUTEX_T *m, const char *name)
{
   return vcos_mutex_create(m, name);
}

static __inline__
void vcos_quickslow_mutex_delete(VCOS_QUICKSLOW_MUTEX_T *m)
{
   vcos_mutex_delete(m);
}

static __inline__
void vcos_quickslow_mutex_lock(VCOS_QUICKSLOW_MUTEX_T *m)
{
   while (vcos_mutex_lock(m) == VCOS_EAGAIN);
}

static __inline__
void vcos_quickslow_mutex_unlock(VCOS_QUICKSLOW_MUTEX_T *m)
{
   vcos_mutex_unlock(m);
}

static __inline__
void vcos_quickslow_mutex_lock_quick(VCOS_QUICKSLOW_MUTEX_T *m)
{
   while (vcos_mutex_lock(m) == VCOS_EAGAIN);
}

static __inline__
void vcos_quickslow_mutex_unlock_quick(VCOS_QUICKSLOW_MUTEX_T *m)
{
   vcos_mutex_unlock(m);
}
# 801 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 2
# 1 "/opt/vc/include/interface/vcos/generic/vcos_common.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - common postamble code
=============================================================================*/

/** \file
  *
  * Postamble code included by the platform-specific header files
  */

#define VCOS_THREAD_PRI_DEFAULT VCOS_THREAD_PRI_NORMAL
# 48 "/opt/vc/include/interface/vcos/generic/vcos_common.h"
/* bigger numbers are lower priority */
#define VCOS_THREAD_PRI_MORE(x) ((x)<VCOS_THREAD_PRI_MAX?(x)+1:VCOS_THREAD_PRI_MAX)
#define VCOS_THREAD_PRI_LESS(x) ((x)>VCOS_THREAD_PRI_MIN?(x)-1:VCOS_THREAD_PRI_MIN)


/* Convenience for Brits: */
#define VCOS_APPLICATION_INITIALISE VCOS_APPLICATION_INITIALIZE

/*
 * Check for constant definitions
 */
# 79 "/opt/vc/include/interface/vcos/generic/vcos_common.h"
/** Append to the end of a singly-linked queue, O(1). Works with
  * any structure where list has members 'head' and 'tail' and
  * item has a 'next' pointer.
  */
#define VCOS_QUEUE_APPEND_TAIL(list,item) { (item)->next = NULL; if (!(list)->head) { (list)->head = (list)->tail = (item); } else { (list)->tail->next = (item); (list)->tail = (item); } }
# 802 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 2

#define _VCOS_LOG_LEVEL() getenv("VC_LOGLEVEL")

static __inline
char *vcos_strdup(const char *str)
{
   size_t len = strlen(str) + 1;
   void *p = malloc(len);

   if (p == 
# 811 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 3 4
           ((void *)0)
# 811 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
               )
      return 
# 812 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h" 3 4
            ((void *)0)
# 812 "/opt/vc/include/interface/vcos/pthreads/vcos_platform.h"
                ;

   return (char *)memcpy(p, str, len);
}

typedef void (*VCOS_ISR_HANDLER_T)(VCOS_UNSIGNED vecnum);

#define VCOS_DL_LAZY RTLD_LAZY
#define VCOS_DL_NOW RTLD_NOW
#define VCOS_DL_LOCAL RTLD_LOCAL
#define VCOS_DL_GLOBAL RTLD_GLOBAL
# 119 "/opt/vc/include/interface/vcos/vcos.h" 2





# 1 "/opt/vc/include/interface/vcos/vcos_init.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - initialization routines
=============================================================================*/


# 1 "/opt/vc/include/interface/vcos/vcos_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/
# 34 "/opt/vc/include/interface/vcos/vcos_init.h" 2
# 1 "/opt/vc/include/interface/vcos/vcos.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */
# 35 "/opt/vc/include/interface/vcos/vcos_init.h" 2





/** \file
  *
  * Some OS support libraries need some initialization. To support this, call
  * vcos_init() function at the start of day; vcos_deinit() at the end.
  */

/**
 * vcos initialization. Call this function before using other vcos functions.
 * Calls can be nested within the same process; they are reference counted so
 * that only a call from uninitialized state has any effect.
 * @note On platforms/toolchains that support it, gcc's constructor attribute or
 *       similar is used to invoke this function before main() or equivalent.
 * @return Status of initialisation.
 */
extern VCOS_STATUS_T vcos_init(void);

/**
 * vcos deinitialization. Call this function when vcos is no longer required,
 * in order to free resources.
 * Calls can be nested within the same process; they are reference counted so
 * that only a call that decrements the reference count to 0 has any effect.
 * @note On platforms/toolchains that support it, gcc's destructor attribute or
 *       similar is used to invoke this function after exit() or equivalent.
 * @return Status of initialisation.
 */
extern void vcos_deinit(void);

/**
 * Acquire global lock. This must be available independent of vcos_init()/vcos_deinit().
 */
extern void vcos_global_lock(void);

/**
 * Release global lock. This must be available independent of vcos_init()/vcos_deinit().
 */
extern void vcos_global_unlock(void);

/** Pass in the argv/argc arguments passed to main() */
extern void vcos_set_args(int argc, const char **argv);

/** Return argc. */
extern int vcos_get_argc(void);

/** Return argv. */
extern const char ** vcos_get_argv(void);

/**
 * Platform-specific initialisation.
 * VCOS internal function, not part of public API, do not call from outside
 * vcos. vcos_init()/vcos_deinit() reference count calls, so this function is
 * only called from an uninitialized state, i.e. there will not be two
 * consecutive calls to vcos_platform_init() without an intervening call to
 * vcos_platform_deinit().
 * This function is called with vcos_global_lock held.
 * @return Status of initialisation.
 */
extern VCOS_STATUS_T vcos_platform_init(void);

/**
 * Platform-specific de-initialisation.
 * VCOS internal function, not part of public API, do not call from outside
 * vcos.
 * See vcos_platform_init() re reference counting.
 * This function is called with vcos_global_lock held.
 */
extern void vcos_platform_deinit(void);
# 125 "/opt/vc/include/interface/vcos/vcos.h" 2



# 1 "/opt/vc/include/interface/vcos/vcos_semaphore.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/


#define VCOS_SEMAPHORE_H 





# 1 "/opt/vc/include/interface/vcos/vcos_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/
# 40 "/opt/vc/include/interface/vcos/vcos_semaphore.h" 2




/**
 * \file vcos_semaphore.h
 *
 * \section sem Semaphores
 *
 * This provides counting semaphores. Semaphores are not re-entrant. On sensible
 * operating systems a semaphore can always be posted but can only be taken in 
 * thread (not interrupt) context. Under Nucleus, a LISR cannot post a semaphore,
 * although it would not be hard to lift this restriction.
 *
 * \subsection timeout Timeout
 *
 * On both Nucleus and ThreadX a semaphore can be taken with a timeout. This is
 * not supported by VCOS because it makes the non-timeout code considerably more
 * complicated (and hence slower). In the unlikely event that you need a timeout
 * with a semaphore, and you cannot simply redesign your code to avoid it, use
 * an event flag (vcos_event_flags.h).
 *
 * \subsection sem_nucleus Changes from Nucleus:
 *
 *  Semaphores are always "FIFO" - i.e. sleeping threads are woken in FIFO order. That's
 *  because:
 *  \arg there's no support for NU_PRIORITY in threadx (though it can be emulated, slowly)
 *  \arg we don't appear to actually consciously use it - for example, Dispmanx uses
 *  it, but all threads waiting are the same priority.
 *         
 */

/** 
  * \brief Create a semaphore.
  *
  * Create a semaphore.
  *
  * @param sem   Pointer to memory to be initialized
  * @param name  A name for this semaphore. The name may be truncated internally.
  * @param count The initial count for the semaphore.
  *
  * @return VCOS_SUCCESS if the semaphore was created.
  * 
  */
extern __inline__
VCOS_STATUS_T vcos_semaphore_create(VCOS_SEMAPHORE_T *sem, const char *name, VCOS_UNSIGNED count);

/**
  * \brief Wait on a semaphore.
  *
  * There is no timeout option on a semaphore, as adding this will slow down
  * implementations on some platforms. If you need that kind of behaviour, use
  * an event group.
  *
  * On most platforms this always returns VCOS_SUCCESS, and so would ideally be
  * a void function, however some platforms allow a wait to be interrupted so
  * it remains non-void.
  *
  * @param sem Semaphore to wait on
  * @return VCOS_SUCCESS - semaphore was taken.
  *         VCOS_EAGAIN  - could not take semaphore
  *
  */
extern __inline__
VCOS_STATUS_T vcos_semaphore_wait(VCOS_SEMAPHORE_T *sem);

/**
  * \brief Wait on a semaphore with a timeout.
  *
  * Note that this function may not be implemented on all
  * platforms, and may not be efficient on all platforms
  * (see comment in vcos_semaphore_wait)
  *
  * Try to obtain the semaphore. If it is already taken, return
  * VCOS_EAGAIN.
  * @param sem Semaphore to wait on
  * @param timeout Number of milliseconds to wait before
  *                returning if the semaphore can't be acquired.
  * @return VCOS_SUCCESS - semaphore was taken.
  *         VCOS_EAGAIN - could not take semaphore (i.e. timeout
  *         expired)
  *         VCOS_EINVAL - Some other error (most likely bad
  *         parameters).
  */
extern __inline__
VCOS_STATUS_T vcos_semaphore_wait_timeout(VCOS_SEMAPHORE_T *sem, VCOS_UNSIGNED timeout);

/**
  * \brief Try to wait for a semaphore.
  *
  * Try to obtain the semaphore. If it is already taken, return VCOS_TIMEOUT.
  * @param sem Semaphore to wait on
  * @return VCOS_SUCCESS - semaphore was taken.
  *         VCOS_EAGAIN - could not take semaphore
  */
extern __inline__
VCOS_STATUS_T vcos_semaphore_trywait(VCOS_SEMAPHORE_T *sem);

/**
  * \brief Post a semaphore.
  *
  * @param sem Semaphore to wait on
  */
extern __inline__
VCOS_STATUS_T vcos_semaphore_post(VCOS_SEMAPHORE_T *sem);

/**
  * \brief Delete a semaphore, releasing any resources consumed by it.
  *
  * @param sem Semaphore to wait on
  */
extern __inline__
void vcos_semaphore_delete(VCOS_SEMAPHORE_T *sem);
# 129 "/opt/vc/include/interface/vcos/vcos.h" 2



# 1 "/opt/vc/include/interface/vcos/vcos_thread.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/


#define VCOS_THREAD_H 





# 1 "/opt/vc/include/interface/vcos/vcos_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/
# 40 "/opt/vc/include/interface/vcos/vcos_thread.h" 2
# 1 "/opt/vc/include/interface/vcos/vcos.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */
# 41 "/opt/vc/include/interface/vcos/vcos_thread.h" 2

/**
 * \file vcos_thread.h
 *
 * \section thread Threads
 *
 * Under Nucleus, a thread is created by NU_Create_Task, passing in the stack
 * and various other parameters. To stop the thread, NU_Terminate_Thread() and
 * NU_Delete_Thread() are called.
 *
 * Unfortunately it's not possible to emulate this API under some fairly common
 * operating systems. Under Windows you can't pass in the stack, and you can't
 * safely terminate a thread.
 *
 * Therefore, an API which is similar to the pthreads API is used instead. This
 * API can (mostly) be emulated under all interesting operating systems.
 *
 * Obviously this makes the code somewhat more complicated on VideoCore than it
 * would otherwise be - we end up with an extra mutex per thread, and some code
 * that waits for it. The benefit is that we have a single way of creating
 * threads that works consistently on all platforms (apart from stack supplying).
 *
 * \subsection stack Stack
 *
 * It's still not possible to pass in the stack address, but this can be made
 * much more obvious in the API: the relevant function is missing and the
 * CPP symbol VCOS_CAN_SET_STACK_ADDR is zero rather than one.
 *
 * \subsection thr_create Creating a thread
 *
 * The simplest way to create a thread is with vcos_thread_create() passing in a
 * NULL thread parameter argument. To wait for the thread to exit, call
 * vcos_thread_join().
 *
 * \subsection back Backward compatibility
 *
 * To ease migration, a "classic" thread creation API is provided for code
 * that used to make use of Nucleus, vcos_thread_create_classic(). The
 * arguments are not exactly the same, as the PREEMPT parameter is dropped.
 *
 */

#define VCOS_AFFINITY_CPU0 _VCOS_AFFINITY_CPU0
#define VCOS_AFFINITY_CPU1 _VCOS_AFFINITY_CPU1
#define VCOS_AFFINITY_MASK _VCOS_AFFINITY_MASK
#define VCOS_AFFINITY_DEFAULT _VCOS_AFFINITY_DEFAULT
#define VCOS_AFFINITY_THISCPU _VCOS_AFFINITY_THISCPU

/** Report whether or not we have an RTOS at all, and hence the ability to
  * create threads.
  */
extern int vcos_have_rtos(void);

/** Create a thread. It must be cleaned up by calling vcos_thread_join().
  *
  * @param thread   Filled in on return with thread
  * @param name     A name for the thread. May be the empty string.
  * @param attrs    Attributes; default attributes will be used if this is NULL.
  * @param entry    Entry point.
  * @param arg      Argument passed to the entry point.
  */
extern VCOS_STATUS_T vcos_thread_create(VCOS_THREAD_T *thread,
                                                    const char *name,
                                                    VCOS_THREAD_ATTR_T *attrs,
                                                    VCOS_THREAD_ENTRY_FN_T entry,
                                                    void *arg);

/** Exit the thread from within the thread function itself.
  * Resources must still be cleaned up via a call to thread_join().
  *
  * The thread can also be terminated by simply exiting the thread function.
  *
  * @param data Data passed to thread_join. May be NULL.
  */
extern void vcos_thread_exit(void *data);

/** Wait for a thread to terminate and then clean up its resources.
  *
  * @param thread Thread to wait for
  * @param pData  Updated to point at data provided in vcos_thread_exit or exit
  * code of thread function.
  */
extern void vcos_thread_join(VCOS_THREAD_T *thread,
                             void **pData);


/**
  * \brief Create a thread using an API similar to the one "traditionally"
  * used under Nucleus.
  *
  * This creates a thread which must be cleaned up by calling vcos_thread_join().
  * The thread cannot be simply terminated (as in Nucleus and ThreadX) as thread
  * termination is not universally supported.
  *
  * @param thread       Filled in with thread instance
  * @param name         An optional name for the thread. NULL or "" may be used (but
  *                     a name will aid in debugging).
  * @param entry        Entry point
  * @param arg          A single argument passed to the entry point function
  * @param stack        Pointer to stack address
  * @param stacksz      Size of stack in bytes
  * @param priaff       Priority of task, between VCOS_PRI_LOW and VCOS_PRI_HIGH, ORed with the CPU affinity
  * @param autostart    If non-zero the thread will start immediately.
  * @param timeslice    Timeslice (system ticks) for this thread.
  *
  * @sa vcos_thread_terminate vcos_thread_delete
  */
extern VCOS_STATUS_T vcos_thread_create_classic(VCOS_THREAD_T *thread,
                                                            const char *name,
                                                            void *(*entry)(void *arg),
                                                            void *arg,
                                                            void *stack,
                                                            VCOS_UNSIGNED stacksz,
                                                            VCOS_UNSIGNED priaff,
                                                            VCOS_UNSIGNED timeslice,
                                                            VCOS_UNSIGNED autostart);

/**
  * \brief Set a thread's priority
  *
  * Set the priority for a thread.
  *
  * @param thread  The thread
  * @param pri     Thread priority in VCOS_PRI_MASK bits; affinity in VCOS_AFFINITY_MASK bits.
  */
extern __inline__
void vcos_thread_set_priority(VCOS_THREAD_T *thread, VCOS_UNSIGNED pri);

/**
  * \brief Return the currently executing thread.
  *
  */
extern __inline__
VCOS_THREAD_T *vcos_thread_current(void);

/**
  * \brief Return the thread's priority.
  */
extern __inline__
VCOS_UNSIGNED vcos_thread_get_priority(VCOS_THREAD_T *thread);

/**
  * \brief Return the thread's cpu affinity.
  */
extern __inline__
VCOS_UNSIGNED vcos_thread_get_affinity(VCOS_THREAD_T *thread);

/**
  * \brief Set the thread's cpu affinity.
  */

extern __inline__
void vcos_thread_set_affinity(VCOS_THREAD_T *thread, VCOS_UNSIGNED affinity);

/**
  * \brief Query whether we are in an interrupt.
  *
  * @return 1 if in interrupt context.
  */
extern __inline__
int vcos_in_interrupt(void);

/**
  * \brief Sleep a while.
  *
  * @param ms Number of milliseconds to sleep for
  *
  * This may actually sleep a whole number of ticks.
  */
extern __inline__
void vcos_sleep(uint32_t ms);

/**
  * \brief Return the value of the hardware microsecond counter.
  *
  */
extern __inline__
uint32_t vcos_getmicrosecs(void);

extern __inline__
uint64_t vcos_getmicrosecs64(void);

#define vcos_get_ms() (vcos_getmicrosecs()/1000)

/**
  * \brief Return a unique identifier for the current process
  *
  */
extern __inline__
VCOS_UNSIGNED vcos_process_id_current(void);

/** Relinquish this time slice. */
extern __inline__
void vcos_thread_relinquish(void);

/** Return the name of the given thread.
  */
extern const char * vcos_thread_get_name(const VCOS_THREAD_T *thread);

/** Change preemption. This is almost certainly not what you want, as it won't
  * work reliably in a multicore system: although you can affect the preemption
  * on *this* core, you won't affect what's happening on the other core(s).
  *
  * It's mainly here to ease migration. If you're using it in new code, you
  * probably need to think again.
  *
  * @param pe New preemption, VCOS_PREEMPT or VCOS_NO_PREEMPT
  * @return Old value of preemption.
  */
extern __inline__
VCOS_UNSIGNED vcos_change_preemption(VCOS_UNSIGNED pe);

/** Is a thread still running, or has it exited?
  *
  * Note: this exists for some fairly scary code in the video codec tests. Don't
  * try to use it for anything else, as it may well not do what you expect.
  *
  * @param thread   thread to query
  * @return non-zero if thread is running, or zero if it has exited.
  */
extern __inline__
int vcos_thread_running(VCOS_THREAD_T *thread);

/** Resume a thread.
  *
  * @param thread thread to resume
  */
extern __inline__
void vcos_thread_resume(VCOS_THREAD_T *thread);

/*
 * Internal APIs - may not always be present and should not be used in
 * client code.
 */

extern void _vcos_task_timer_set(void (*pfn)(void*), void *, VCOS_UNSIGNED ms);
extern void _vcos_task_timer_cancel(void);
# 133 "/opt/vc/include/interface/vcos/vcos.h" 2



# 1 "/opt/vc/include/interface/vcos/vcos_mutex.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - mutex public header file
=============================================================================*/


#define VCOS_MUTEX_H 





# 1 "/opt/vc/include/interface/vcos/vcos_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/
# 40 "/opt/vc/include/interface/vcos/vcos_mutex.h" 2
# 1 "/opt/vc/include/interface/vcos/vcos.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */
# 41 "/opt/vc/include/interface/vcos/vcos_mutex.h" 2

/**
 * \file vcos_mutex.h
 *
 * Mutex API. Mutexes are not re-entrant, as supporting this adds extra code
 * that slows down clients which have been written sensibly.
 *
 * \sa vcos_reentrant_mutex.h
 *
 */

/** Create a mutex.
  *
  * @param m      Filled in with mutex on return
  * @param name   A non-null name for the mutex, used for diagnostics.
  *
  * @return VCOS_SUCCESS if mutex was created, or error code.
  */
extern __inline__
VCOS_STATUS_T vcos_mutex_create(VCOS_MUTEX_T *m, const char *name);

/** Delete the mutex.
  */
extern __inline__
void vcos_mutex_delete(VCOS_MUTEX_T *m);

/**
  * \brief Wait to claim the mutex.
  *
  * On most platforms this always returns VCOS_SUCCESS, and so would ideally be
  * a void function, however some platforms allow a wait to be interrupted so
  * it remains non-void.
  *
  * Try to obtain the mutex.
  * @param m   Mutex to wait on
  * @return VCOS_SUCCESS - mutex was taken.
  *         VCOS_EAGAIN  - could not take mutex.
  */

extern __inline__
VCOS_STATUS_T vcos_mutex_lock(VCOS_MUTEX_T *m);

/** Release the mutex.
  */
extern __inline__
void vcos_mutex_unlock(VCOS_MUTEX_T *m);


/** Test if the mutex is already locked.
  *
  * @return 1 if mutex is locked, 0 if it is unlocked.
  */
extern __inline__
int vcos_mutex_is_locked(VCOS_MUTEX_T *m);

/** Obtain the mutex if possible.
  *
  * @param m  the mutex to try to obtain
  *
  * @return VCOS_SUCCESS if mutex is successfully obtained, or VCOS_EAGAIN
  * if it is already in use by another thread.
  */

extern __inline__
VCOS_STATUS_T vcos_mutex_trylock(VCOS_MUTEX_T *m);
# 137 "/opt/vc/include/interface/vcos/vcos.h" 2



# 1 "/opt/vc/include/interface/vcos/vcos_mem.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - memory support
=============================================================================*/


#define VCOS_MEM_H 





# 1 "/opt/vc/include/interface/vcos/vcos_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/
# 40 "/opt/vc/include/interface/vcos/vcos_mem.h" 2
# 1 "/opt/vc/include/interface/vcos/vcos.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */
# 41 "/opt/vc/include/interface/vcos/vcos_mem.h" 2

/** \file
  *
  * Memory allocation api (malloc/free equivalents) is for benefit of host
  * applications. VideoCore code should use rtos_XXX functions.
  *
  */


/** Allocate memory
  *
  * @param size Size of memory to allocate
  * @param description Description, to aid in debugging. May be ignored internally on some platforms.
  */
extern __inline__
void *vcos_malloc(VCOS_UNSIGNED size, const char *description);

void *vcos_kmalloc(VCOS_UNSIGNED size, const char *description);
void *vcos_kcalloc(VCOS_UNSIGNED num, VCOS_UNSIGNED size, const char *description);

/** Allocate cleared memory
  *
  * @param num Number of items to allocate.
  * @param size Size of each item in bytes.
  * @param description Description, to aid in debugging. May be ignored internally on some platforms.
  */
extern __inline__
void *vcos_calloc(VCOS_UNSIGNED num, VCOS_UNSIGNED size, const char *description);

/** Free memory
  *
  * Free memory that has been allocated.
  */
extern __inline__
void vcos_free(void *ptr);

void vcos_kfree(void *ptr);

/** Allocate aligned memory
  *
  * Allocate memory aligned on the specified boundary.
  *
  * @param size Size of memory to allocate
  * @param description Description, to aid in debugging. May be ignored internally on some platforms.
  */
extern __inline__
void *vcos_malloc_aligned(VCOS_UNSIGNED size, VCOS_UNSIGNED align, const char *description);

/** Return the amount of free heap memory
  *
  */
extern __inline__
unsigned long vcos_get_free_mem(void);
# 141 "/opt/vc/include/interface/vcos/vcos.h" 2



# 1 "/opt/vc/include/interface/vcos/vcos_logging.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - logging support
=============================================================================*/


#define VCOS_LOGGING_H 





# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stdarg.h" 1 3 4

# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stdarg.h" 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */
# 40 "/opt/vc/include/interface/vcos/vcos_logging.h" 2

# 1 "/opt/vc/include/interface/vcos/vcos_types.h" 1

# 1 "/opt/vc/include/interface/vcos/vcos_types.h"
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/
# 42 "/opt/vc/include/interface/vcos/vcos_logging.h" 2
# 1 "/opt/vc/include/interface/vcos/vcos.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */
# 43 "/opt/vc/include/interface/vcos/vcos_logging.h" 2
# 1 "/opt/vc/include/interface/vcos/vcos_logging_control.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
# 44 "/opt/vc/include/interface/vcos/vcos_logging.h" 2

/**
 * \file
 *
 * Logging support
 *
 * This provides categorised logging. Clients register
 * a category, and then get a number of logging levels for
 * that category.
 *
 * The logging level flag is tested using a flag *before* the
 * function call, which makes logging very fast when disabled - there
 * is no function call overhead just to find out that this log
 * message is disabled.
 *
 * \section VCOS_LOG_CATEGORY
 *
 * As a convenience, clients define VCOS_LOG_CATEGORY to point to
 * their category; the various vcos_log_xxx() macros then expand to
 * use this.
 *
 * e.g.
 *
 *     #define VCOS_LOG_CATEGORY (&my_category)
 *
 *     #include <interface/vcos/vcos.h>
 *
 *     VCOS_LOG_CAT_T my_category;
 *
 *     ....
 *
 *     vcos_log_trace("Stuff happened: %d", n_stuff);
 *
 */

/** Logging levels */
typedef enum VCOS_LOG_LEVEL_T
{
   VCOS_LOG_UNINITIALIZED = 0,
   VCOS_LOG_NEVER,
   VCOS_LOG_ERROR,
   VCOS_LOG_WARN,
   VCOS_LOG_INFO,
   VCOS_LOG_TRACE,
} VCOS_LOG_LEVEL_T;


/** Initialize a logging category without going through vcos_log_register().
 *
 * This is useful for the case where there is no obvious point to do the
 * registration (no initialization function for the module). However, it
 * means that your logging category is not registered, so cannot be easily
 * changed at run-time.
 */
#define VCOS_LOG_INIT(n,l) { l, n, 0, {0}, 0, 0 }

/** A registered logging category.
  */
typedef struct VCOS_LOG_CAT_T
{
   VCOS_LOG_LEVEL_T level; /**< Which levels are enabled for this category */
   const char *name; /**< Name for this category. */
   struct VCOS_LOG_CAT_T *next;
   struct {
      unsigned int want_prefix:1;
   } flags;
   unsigned int refcount;
   void *platform_data; /**< platform specific data */
} VCOS_LOG_CAT_T;

typedef void (*VCOS_VLOG_IMPL_FUNC_T)(const VCOS_LOG_CAT_T *cat, VCOS_LOG_LEVEL_T _level, const char *fmt, va_list args);

/** Convert a VCOS_LOG_LEVEL_T into a printable string.
  * The platform needs to implement this function.
  */
extern const char * vcos_log_level_to_string( VCOS_LOG_LEVEL_T level );

/** Convert a string into a VCOS_LOG_LEVEL_T
  * The platform needs to implement this function.
  */
extern VCOS_STATUS_T vcos_string_to_log_level( const char *str, VCOS_LOG_LEVEL_T *level );

/** Log a message. Basic API. Normal code should not use this.
  * The platform needs to implement this function.
  */
extern void vcos_log_impl(const VCOS_LOG_CAT_T *cat, VCOS_LOG_LEVEL_T _level, const char *fmt, ...) __attribute__ ((format (printf, 3, 4)));

/** Log a message using a varargs parameter list. Normal code should
  * not use this.
  */
extern void vcos_vlog_impl(const VCOS_LOG_CAT_T *cat, VCOS_LOG_LEVEL_T _level, const char *fmt, va_list args) __attribute__ ((format (printf, 3, 0)));

/** Set the function which does the actual logging output.
 *  Passing in NULL causes the default logging function to be
 *  used.
  */
extern void vcos_set_vlog_impl( VCOS_VLOG_IMPL_FUNC_T vlog_impl_func );

/** The default logging function, which is provided by each
  * platform.
  */

extern void vcos_vlog_default_impl(const VCOS_LOG_CAT_T *cat, VCOS_LOG_LEVEL_T _level, const char *fmt, va_list args) __attribute__ ((format (printf, 3, 0)));

/*
 * Initialise the logging subsystem. This is called from
 * vcos_init() so you don't normally need to call it.
 */
extern void vcos_logging_init(void);

/** Register a logging category.
  *
  * @param name the name of this category.
  * @param category the category to register.
  */
extern void vcos_log_register(const char *name, VCOS_LOG_CAT_T *category);

/** Unregister a logging category.
  */
extern void vcos_log_unregister(VCOS_LOG_CAT_T *category);

/** Return a default logging category, for people too lazy to create their own.
  *
  * Using the default category will be slow (there's an extra function
  * call overhead). Don't do this in normal code.
  */
extern const VCOS_LOG_CAT_T * vcos_log_get_default_category(void);

extern void vcos_set_log_options(const char *opt);

/** Set the logging level for a category at run time. Without this, the level
  * will be that set by vcos_log_register from a platform-specific source.
  *
  * @param category the category to modify.
  * @param level the new logging level for this category.
  */
static __inline void vcos_log_set_level(VCOS_LOG_CAT_T *category, VCOS_LOG_LEVEL_T level)
{
   category->level = level;
}


/** Set the logging levels for many categories at once.
  *
  * Set lots of categorys from a string cat:lev,cat:lev This can 
  * be used at startup time to set a bunch of category levels from
  * a single string.  Used with C(vcos_logging_level)
  */
extern void vcos_log_set_level_all(char *levels);

#define vcos_log_dump_mem(cat,label,addr,voidMem,numBytes) do { if (vcos_is_log_enabled(cat,VCOS_LOG_TRACE)) vcos_log_dump_mem_impl(cat,label,addr,voidMem,numBytes); } while (0)

void vcos_log_dump_mem_impl( const VCOS_LOG_CAT_T *cat,
                             const char *label,
                             uint32_t addr,
                             const void *voidMem,
                             size_t numBytes );

/*
 * Platform specific hooks (optional).
 */





#define vcos_log_platform_register(category) (void)0



#define vcos_log_platform_unregister(category) (void)0


/* VCOS_TRACE() - deprecated macro which just outputs in a debug build and
 * is a no-op in a release build.
 *
 * _VCOS_LOG_X() - internal macro which outputs if the current level for the
 * particular category is higher than the supplied message level.
 */

#define VCOS_LOG_DFLT_CATEGORY vcos_log_get_default_category()

#define _VCOS_LEVEL(x) (x)

#define vcos_is_log_enabled(cat,_level) (_VCOS_LEVEL((cat)->level) >= _VCOS_LEVEL(_level))




#define VCOS_LOGGING_ENABLED 
#define _VCOS_LOG_X(cat,_level,fmt...) do { if (vcos_is_log_enabled(cat,_level)) vcos_log_impl(cat,_level,fmt); } while (0)
#define _VCOS_VLOG_X(cat,_level,fmt,ap) do { if (vcos_is_log_enabled(cat,_level)) vcos_vlog_impl(cat,_level,fmt,ap); } while (0)







#define vcos_log_error(...) _VCOS_LOG_X(VCOS_LOG_CATEGORY, VCOS_LOG_ERROR, __VA_ARGS__)
#define vcos_log_warn(...) _VCOS_LOG_X(VCOS_LOG_CATEGORY, VCOS_LOG_WARN, __VA_ARGS__)
#define vcos_log_info(...) _VCOS_LOG_X(VCOS_LOG_CATEGORY, VCOS_LOG_INFO, __VA_ARGS__)
#define vcos_log_trace(...) _VCOS_LOG_X(VCOS_LOG_CATEGORY, VCOS_LOG_TRACE, __VA_ARGS__)

#define vcos_vlog_error(fmt,ap) _VCOS_VLOG_X(VCOS_LOG_CATEGORY, VCOS_LOG_ERROR, fmt, ap)
#define vcos_vlog_warn(fmt,ap) _VCOS_VLOG_X(VCOS_LOG_CATEGORY, VCOS_LOG_WARN, fmt, ap)
#define vcos_vlog_info(fmt,ap) _VCOS_VLOG_X(VCOS_LOG_CATEGORY, VCOS_LOG_INFO, fmt, ap)
#define vcos_vlog_trace(fmt,ap) _VCOS_VLOG_X(VCOS_LOG_CATEGORY, VCOS_LOG_TRACE, fmt, ap)

#define vcos_logc_error(cat,...) _VCOS_LOG_X(cat, VCOS_LOG_ERROR, __VA_ARGS__)
#define vcos_logc_warn(cat,...) _VCOS_LOG_X(cat, VCOS_LOG_WARN, __VA_ARGS__)
#define vcos_logc_info(cat,...) _VCOS_LOG_X(cat, VCOS_LOG_INFO, __VA_ARGS__)
#define vcos_logc_trace(cat,...) _VCOS_LOG_X(cat, VCOS_LOG_TRACE, __VA_ARGS__)

#define vcos_vlogc_error(cat,fmt,ap) _VCOS_VLOG_X(cat, VCOS_LOG_ERROR, fmt, ap)
#define vcos_vlogc_warn(cat,fmt,ap) _VCOS_VLOG_X(cat, VCOS_LOG_WARN, fmt, ap)
#define vcos_vlogc_info(cat,fmt,ap) _VCOS_VLOG_X(cat, VCOS_LOG_INFO, fmt, ap)
#define vcos_vlogc_trace(cat,fmt,ap) _VCOS_VLOG_X(cat, VCOS_LOG_TRACE, fmt, ap)

#define vcos_log(...) _VCOS_LOG_X(VCOS_LOG_DFLT_CATEGORY, VCOS_LOG_INFO, __VA_ARGS__)
#define vcos_vlog(fmt,ap) _VCOS_VLOG_X(VCOS_LOG_DFLT_CATEGORY, VCOS_LOG_INFO, fmt, ap)
#define VCOS_ALERT(...) _VCOS_LOG_X(VCOS_LOG_DFLT_CATEGORY, VCOS_LOG_ERROR, __VA_ARGS__)
#define VCOS_TRACE(...) _VCOS_LOG_X(VCOS_LOG_DFLT_CATEGORY, VCOS_LOG_INFO, __VA_ARGS__)

/*
 * MS Visual Studio - pre 2005 does not grok variadic macros
 */
# 306 "/opt/vc/include/interface/vcos/vcos_logging.h"
# 1 "/opt/vc/include/interface/vcos/vcos_cmd.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#define VCOS_CMD_H 

/* ---- Include Files ----------------------------------------------------- */




# 1 "/opt/vc/include/interface/vcos/vcos_stdint.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#define VCOS_STDINT_H 

/** \file
 * Attempt to provide the types defined in stdint.h.
 *
 * Except for use with lcc, this simply includes stdint.h, which should find
 * the system/toolchain version if present, otherwise falling back to the
 * version in interface/vcos/<platform>.
 */
# 37 "/opt/vc/include/interface/vcos/vcos_cmd.h" 2


/* ---- Constants and Types ---------------------------------------------- */

struct VCOS_CMD_S;
typedef struct VCOS_CMD_S VCOS_CMD_T;

typedef struct
{
    int argc; /* Number of arguments (includes the command/sub-command) */
    char **argv; /* Array of arguments */
    char **argv_orig; /* Original array of arguments */

    VCOS_CMD_T *cmd_entry;
    VCOS_CMD_T *cmd_parent_entry;

    int use_log; /* Output being logged? */
    size_t result_size; /* Size of result buffer. */
    char *result_ptr; /* Next place to put output. */
    char *result_buf; /* Start of the buffer. */

} VCOS_CMD_PARAM_T;

typedef VCOS_STATUS_T (*VCOS_CMD_FUNC_T)( VCOS_CMD_PARAM_T *param );

struct VCOS_CMD_S
{
    const char *name;
    const char *args;
    VCOS_CMD_FUNC_T cmd_fn;
    VCOS_CMD_T *sub_cmd_entry;
    const char *descr;

};

/* ---- Variable Externs ------------------------------------------------- */

/* ---- Function Prototypes ---------------------------------------------- */

/*
 * Common printing routine for generating command output.
 */
extern void vcos_cmd_error( VCOS_CMD_PARAM_T *param, const char *fmt, ... ) __attribute__ ((format (printf, 2, 3)));
extern void vcos_cmd_printf( VCOS_CMD_PARAM_T *param, const char *fmt, ... ) __attribute__ ((format (printf, 2, 3)));
extern void vcos_cmd_vprintf( VCOS_CMD_PARAM_T *param, const char *fmt, va_list args ) __attribute__ ((format (printf, 2, 0)));

/*
 * Cause vcos_cmd_error, printf and vprintf to always log to the provided
 * category. When this call is made, the results buffer passed into
 * vcos_cmd_execute is used as a line buffer and does not need to be
 * output by the caller.
 */
struct VCOS_LOG_CAT_T;
extern void vcos_cmd_always_log_output( struct VCOS_LOG_CAT_T *log_category );

/*
 * Prints command usage for the current command.
 */
extern void vcos_cmd_usage( VCOS_CMD_PARAM_T *param );

/*
 * Register commands to be processed
 */
extern VCOS_STATUS_T vcos_cmd_register( VCOS_CMD_T *cmd_entry );

/*
 * Registers multiple commands to be processed. The array should
 * be terminated by an entry with all zeros.
 */
extern VCOS_STATUS_T vcos_cmd_register_multiple( VCOS_CMD_T *cmd_entry );

/*
 * Executes a command based on a command line.
 */
extern VCOS_STATUS_T vcos_cmd_execute( int argc, char **argv, size_t result_size, char *result_buf );

/*
 * Shut down the command system and free all allocated data.
 * Do not call any other command functions after this.
 */
extern void vcos_cmd_shutdown( void );
# 307 "/opt/vc/include/interface/vcos/vcos_logging.h" 2

/*
 * These are the log sub-commands. They're exported here for user-mode apps which 
 * may want to call these, since the "log" command isn't registered for user-mode 
 * apps (vcdbg for example, has its own log command). 
 */
extern VCOS_STATUS_T vcos_log_assert_cmd( VCOS_CMD_PARAM_T *param );
extern VCOS_STATUS_T vcos_log_set_cmd( VCOS_CMD_PARAM_T *param );
extern VCOS_STATUS_T vcos_log_status_cmd( VCOS_CMD_PARAM_T *param );
extern VCOS_STATUS_T vcos_log_test_cmd( VCOS_CMD_PARAM_T *param );
# 145 "/opt/vc/include/interface/vcos/vcos.h" 2



# 1 "/opt/vc/include/interface/vcos/vcos_string.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/


#define VCOS_STRING_H 

/**
  * \file
  *
  * String functions.
  *
  */





# 1 "/opt/vc/include/interface/vcos/vcos_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/
# 47 "/opt/vc/include/interface/vcos/vcos_string.h" 2
# 1 "/opt/vc/include/interface/vcos/vcos.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */
# 48 "/opt/vc/include/interface/vcos/vcos_string.h" 2




# 1 "/usr/include/string.h" 1 3 4

# 1 "/usr/include/string.h" 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.21 String handling	<string.h>
 */
# 53 "/opt/vc/include/interface/vcos/vcos_string.h" 2



# 55 "/opt/vc/include/interface/vcos/vcos_string.h"
/** Case insensitive string comparison.
  *
  */

extern __inline__
int vcos_strcasecmp(const char *s1, const char *s2);

extern __inline__
int vcos_strncasecmp(const char *s1, const char *s2, size_t n);

extern int vcos_vsnprintf(char *buf, size_t buflen, const char *fmt, va_list ap);

extern int vcos_snprintf(char *buf, size_t buflen, const char *fmt, ...);

/** Like vsnprintf, except it places the output at the specified offset.
  * Output is truncated to fit in buflen bytes, and is guaranteed to be NUL-terminated.
  * Returns the string length before/without truncation.
  */
extern size_t vcos_safe_vsprintf(char *buf, size_t buflen, size_t offset, const char *fmt, va_list ap);

#define VCOS_SAFE_VSPRINTF(buf,offset,fmt,ap) vcos_safe_vsprintf(buf, sizeof(buf) + ((char (*)[sizeof(buf)])buf - &(buf)), offset, fmt, ap)


/** Like snprintf, except it places the output at the specified offset.
  * Output is truncated to fit in buflen bytes, and is guaranteed to be NUL-terminated.
  * Returns the string length before/without truncation.
  */
extern size_t vcos_safe_sprintf(char *buf, size_t buflen, size_t offset, const char *fmt, ...);

/* The Metaware compiler currently has a bug in its variadic macro handling which
   causes it to append a spurious command to the end of its __VA_ARGS__ data.
   Do not use until this has been fixed (and this comment has been deleted). */

#define VCOS_SAFE_SPRINTF(buf,offset,...) vcos_safe_sprintf(buf, sizeof(buf) + ((char (*)[sizeof(buf)])buf - &(buf)), offset, __VA_ARGS__)


/** Copies string src to dst at the specified offset.
  * Output is truncated to fit in dstlen bytes, i.e. the string is at most
  * (buflen - 1) characters long. Unlike strncpy, exactly one NUL is written
  * to dst, which is always NUL-terminated.
  * Returns the string length before/without truncation.
  */
extern size_t vcos_safe_strcpy(char *dst, const char *src, size_t dstlen, size_t offset);

#define VCOS_SAFE_STRCPY(dst,src,offset) vcos_safe_strcpy(dst, src, sizeof(dst) + ((char (*)[sizeof(dst)])dst - &(dst)), offset)


static __inline
int vcos_strlen(const char *s) { return (int)strlen(s); }

static __inline
int vcos_strcmp(const char *s1, const char *s2) { return 
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s1
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ) && __builtin_constant_p (
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s2
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ) && (__s1_len = __builtin_strlen (
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s1
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ), __s2_len = __builtin_strlen (
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s2
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ), (!((size_t)(const void *)((
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s1
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ) + 1) - (size_t)(const void *)(
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s1
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s2
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ) + 1) - (size_t)(const void *)(
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s2
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ) == 1) || __s2_len >= 4)) ? __builtin_strcmp (
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s1
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        , 
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s2
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ) : (__builtin_constant_p (
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s1
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ) && ((size_t)(const void *)((
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s1
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ) + 1) - (size_t)(const void *)(
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s1
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ) == 1) && (__s1_len = __builtin_strlen (
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s1
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ), __s1_len < 4) ? (__builtin_constant_p (
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s2
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ) && ((size_t)(const void *)((
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s2
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ) + 1) - (size_t)(const void *)(
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s2
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ) == 1) ? __builtin_strcmp (
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s1
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        , 
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s2
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s2
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ); int __result = (((const unsigned char *) (const char *) (
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s1
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s1
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s1
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s1
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s2
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ) && ((size_t)(const void *)((
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s2
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ) + 1) - (size_t)(const void *)(
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s2
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ) == 1) && (__s2_len = __builtin_strlen (
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s2
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ), __s2_len < 4) ? (__builtin_constant_p (
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s1
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ) && ((size_t)(const void *)((
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s1
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ) + 1) - (size_t)(const void *)(
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s1
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ) == 1) ? __builtin_strcmp (
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s1
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        , 
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s2
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ) : -(__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s1
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ); int __result = (((const unsigned char *) (const char *) (
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s2
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s2
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s2
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s2
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        ))[3] - __s2[3]); } } __result; }))) : __builtin_strcmp (
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s1
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        , 
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                        s2
# 106 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                        )))); })
# 106 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                     ; }

static __inline
int vcos_strncmp(const char *cs, const char *ct, size_t count) { return 
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       (__extension__ (__builtin_constant_p (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       count
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) && ((__builtin_constant_p (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       cs
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) && strlen (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       cs
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) < ((size_t) (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       count
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ))) || (__builtin_constant_p (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       ct
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) && strlen (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       ct
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) < ((size_t) (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       count
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       )))) ? __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       cs
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) && __builtin_constant_p (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       ct
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) && (__s1_len = __builtin_strlen (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       cs
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ), __s2_len = __builtin_strlen (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       ct
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ), (!((size_t)(const void *)((
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       cs
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) + 1) - (size_t)(const void *)(
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       cs
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       ct
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) + 1) - (size_t)(const void *)(
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       ct
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) == 1) || __s2_len >= 4)) ? __builtin_strcmp (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       cs
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       , 
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       ct
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) : (__builtin_constant_p (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       cs
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) && ((size_t)(const void *)((
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       cs
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) + 1) - (size_t)(const void *)(
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       cs
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) == 1) && (__s1_len = __builtin_strlen (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       cs
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ), __s1_len < 4) ? (__builtin_constant_p (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       ct
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) && ((size_t)(const void *)((
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       ct
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) + 1) - (size_t)(const void *)(
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       ct
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) == 1) ? __builtin_strcmp (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       cs
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       , 
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       ct
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       ct
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ); int __result = (((const unsigned char *) (const char *) (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       cs
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       cs
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       cs
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       cs
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       ct
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) && ((size_t)(const void *)((
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       ct
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) + 1) - (size_t)(const void *)(
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       ct
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) == 1) && (__s2_len = __builtin_strlen (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       ct
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ), __s2_len < 4) ? (__builtin_constant_p (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       cs
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) && ((size_t)(const void *)((
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       cs
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) + 1) - (size_t)(const void *)(
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       cs
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) == 1) ? __builtin_strcmp (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       cs
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       , 
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       ct
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ) : -(__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       cs
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ); int __result = (((const unsigned char *) (const char *) (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       ct
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       ct
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       ct
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       ct
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       ))[3] - __s2[3]); } } __result; }))) : __builtin_strcmp (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       cs
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       , 
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       ct
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       )))); }) : strncmp (
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       cs
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       , 
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       ct
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       , 
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                       count
# 109 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                       )))
# 109 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                                             ; }

static __inline
char *vcos_strcpy(char *dst, const char *src) { return strcpy(dst, src); }

static __inline
char *vcos_strncpy(char *dst, const char *src, size_t count) { return 
# 115 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                     __builtin_strncpy (
# 115 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                     dst
# 115 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                     , 
# 115 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                     src
# 115 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                     , 
# 115 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                     count
# 115 "/opt/vc/include/interface/vcos/vcos_string.h" 3 4
                                                                     )
# 115 "/opt/vc/include/interface/vcos/vcos_string.h"
                                                                                             ; }

static __inline
void *vcos_memcpy(void *dst, const void *src, size_t n) { memcpy(dst, src, n); return dst; }

static __inline
void *vcos_memset(void *p, int c, size_t n) { return memset(p, c, n); }

static __inline
int vcos_memcmp(const void *ptr1, const void *ptr2, size_t count) { return memcmp(ptr1, ptr2, count); }
# 149 "/opt/vc/include/interface/vcos/vcos.h" 2



# 1 "/opt/vc/include/interface/vcos/vcos_event.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file for events
=============================================================================*/


#define VCOS_EVENT_H 





# 1 "/opt/vc/include/interface/vcos/vcos_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/
# 40 "/opt/vc/include/interface/vcos/vcos_event.h" 2
# 1 "/opt/vc/include/interface/vcos/vcos.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */
# 41 "/opt/vc/include/interface/vcos/vcos_event.h" 2

/** 
  * \file
  *
  * An event is akin to the Win32 auto-reset event.
  *
  *
  * Signalling an event will wake up one waiting thread only. Once one
  * thread has been woken the event atomically returns to the unsignalled
  * state.
  * 
  * If no threads are waiting on the event when it is signalled it remains
  * signalled.
  *
  * This is almost, but not quite, completely unlike the "event flags"
  * object based on Nucleus event groups and ThreadX event flags.
  *
  * In particular, it should be similar in speed to a semaphore, unlike
  * the event flags.
  */

/**
  * Create an event instance.
  *
  * @param event  Filled in with constructed event.
  * @param name   Name of the event (for debugging)
  *
  * @return VCOS_SUCCESS on success, or error code.
  */
extern __inline__
VCOS_STATUS_T vcos_event_create(VCOS_EVENT_T *event, const char *name);



/**
  * Signal the event. The event will return to being unsignalled
  * after exactly one waiting thread has been woken up. If no
  * threads are waiting it remains signalled.
  *
  * @param event The event to signal
  */
extern __inline__
void vcos_event_signal(VCOS_EVENT_T *event);

/**
  * Wait for the event.
  *
  * @param event The event to wait for
  * @return VCOS_SUCCESS on success, VCOS_EAGAIN if the wait was interrupted.
  */
extern __inline__
VCOS_STATUS_T vcos_event_wait(VCOS_EVENT_T *event);

/**
  * Try event, but don't block.
  *
  * @param event The event to try
  * @return VCOS_SUCCESS on success, VCOS_EAGAIN if the event is not currently signalled
  */
extern __inline__
VCOS_STATUS_T vcos_event_try(VCOS_EVENT_T *event);



/*
 * Destroy an event.
 */
extern __inline__
void vcos_event_delete(VCOS_EVENT_T *event);
# 153 "/opt/vc/include/interface/vcos/vcos.h" 2



# 1 "/opt/vc/include/interface/vcos/vcos_thread_attr.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - thread attributes
=============================================================================*/


#define VCOS_THREAD_ATTR_H 





/**
 * \file
 *
 * Attributes for thread creation.
 *
 */

/** Initialize thread attribute struct. This call does not allocate memory,
  * and so cannot fail.
  *
  */
extern void vcos_thread_attr_init(VCOS_THREAD_ATTR_T *attrs);

/** Set the stack address and size. If not set, a stack will be allocated automatically.
  *
  * This can only be set on some platforms. It will always be possible to set the stack
  * address on VideoCore, but on host platforms, support may well not be available.
  */





/** Set the stack size. If not set, a default size will be used. Attempting to call this after having
  * set the stack location with vcos_thread_attr_setstack() will result in undefined behaviour.
  */
extern __inline__
void vcos_thread_attr_setstacksize(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED sz);

/** Set the task priority. If not set, a default value will be used.
  */
extern __inline__
void vcos_thread_attr_setpriority(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED pri);

/** Set the task cpu affinity. If not set, the default will be used.
  */
extern __inline__
void vcos_thread_attr_setaffinity(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED aff);

/** Set the timeslice. If not set the default will be used.
  */
extern __inline__
void vcos_thread_attr_settimeslice(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED ts);

/** The thread entry function takes (argc,argv), as per Nucleus, with
  * argc being 0. This may be withdrawn in a future release and should not
  * be used in new code.
  */
extern __inline__
void _vcos_thread_attr_setlegacyapi(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED legacy);

extern __inline__
void vcos_thread_attr_setautostart(VCOS_THREAD_ATTR_T *attrs, VCOS_UNSIGNED autostart);
# 157 "/opt/vc/include/interface/vcos/vcos.h" 2



# 1 "/opt/vc/include/interface/vcos/vcos_tls.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - thread local storage
=============================================================================*/


#define VCOS_TLS_H 





# 1 "/opt/vc/include/interface/vcos/vcos_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/
# 40 "/opt/vc/include/interface/vcos/vcos_tls.h" 2
# 1 "/opt/vc/include/interface/vcos/vcos.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */
# 41 "/opt/vc/include/interface/vcos/vcos_tls.h" 2


/** Create a new thread local storage data key visible to all threads in
  * the current process.
  *
  * @param key    The key to create
  */
extern __inline__
VCOS_STATUS_T vcos_tls_create(VCOS_TLS_KEY_T *key);

/** Delete an existing TLS data key.
  */
extern __inline__
void vcos_tls_delete(VCOS_TLS_KEY_T tls);

/** Set the value seen by the current thread.
  *
  * @param key    The key to update
  * @param v      The value to set for the current thread.
  *
  * @return VCOS_SUCCESS, or VCOS_ENOMEM if memory for this slot
  * could not be allocated.
  *
  * If TLS is being emulated via VCOS then the memory required
  * can be preallocated at thread creation time
  */
extern __inline__
VCOS_STATUS_T vcos_tls_set(VCOS_TLS_KEY_T tls, void *v);

/** Get the value for the current thread.
  *
  * @param key    The key to update
  *
  * @return The current value for this thread.
  */
extern __inline__
void *vcos_tls_get(VCOS_TLS_KEY_T tls);
# 161 "/opt/vc/include/interface/vcos/vcos.h" 2



# 1 "/opt/vc/include/interface/vcos/vcos_reentrant_mutex.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - reentrant mutex public header file
=============================================================================*/


#define VCOS_REENTRANT_MUTEX_H 





# 1 "/opt/vc/include/interface/vcos/vcos_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/
# 40 "/opt/vc/include/interface/vcos/vcos_reentrant_mutex.h" 2
# 1 "/opt/vc/include/interface/vcos/vcos.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */
# 41 "/opt/vc/include/interface/vcos/vcos_reentrant_mutex.h" 2

/**
 * \file
 *
 * Reentrant Mutex API. You can take one of these mutexes even if you've already
 * taken it. Just to make sure.
 *
 * A re-entrant mutex may be slower on some platforms than a regular one.
 *
 * \sa vcos_mutex.h
 *
 */

/** Create a mutex.
  *
  * @param m      Filled in with mutex on return
  * @param name   A non-null name for the mutex, used for diagnostics.
  *
  * @return VCOS_SUCCESS if mutex was created, or error code.
  */
extern __inline__
VCOS_STATUS_T vcos_reentrant_mutex_create(VCOS_REENTRANT_MUTEX_T *m, const char *name);

/** Delete the mutex.
  */
extern __inline__
void vcos_reentrant_mutex_delete(VCOS_REENTRANT_MUTEX_T *m);

/** Wait to claim the mutex. Must not have already been claimed by the current thread.
  */

extern __inline__
void vcos_reentrant_mutex_lock(VCOS_REENTRANT_MUTEX_T *m);

/** Release the mutex.
  */
extern __inline__
void vcos_reentrant_mutex_unlock(VCOS_REENTRANT_MUTEX_T *m);
# 165 "/opt/vc/include/interface/vcos/vcos.h" 2



# 1 "/opt/vc/include/interface/vcos/vcos_named_semaphore.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - named semaphores
=============================================================================*/


#define VCOS_NAMED_SEMAPHORE_H 





# 1 "/opt/vc/include/interface/vcos/vcos_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/
# 40 "/opt/vc/include/interface/vcos/vcos_named_semaphore.h" 2
# 1 "/opt/vc/include/interface/vcos/vcos.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */
# 41 "/opt/vc/include/interface/vcos/vcos_named_semaphore.h" 2

/**
 * \file
 *
 * Create a named semaphore, or open an existing one by name.
 *
 */

/** 
  * \brief Create a named semaphore.
  *
  * Semaphores are not re-entrant.
  *
  * @param sem   Pointer to memory to be initialized
  * @param name  A name for this semaphore.
  * @param count The initial count for the semaphore.
  *
  * @return VCOS_SUCCESS if the semaphore was created.
  * 
  */
extern __inline__
VCOS_STATUS_T vcos_named_semaphore_create(VCOS_NAMED_SEMAPHORE_T *sem, const char *name, VCOS_UNSIGNED count);

/**
  * \brief Wait on a named semaphore.
  *
  * There is no timeout option on a semaphore, as adding this will slow down
  * implementations on some platforms. If you need that kind of behaviour, use
  * an event group.
  *
  * This always returns VCOS_SUCCESS and so should really be a void function. However
  * too many lines of code would need to be changed in non-trivial ways, so for now
  * it is non-void.
  *
  * @param sem Semaphore to wait on
  * @return VCOS_SUCCESS - semaphore was taken.
  *
  */
extern __inline__
void vcos_named_semaphore_wait(VCOS_NAMED_SEMAPHORE_T *sem);

/**
  * \brief Try to wait for a semaphore.
  *
  * Try to obtain the semaphore. If it is already taken, return VCOS_TIMEOUT.
  * @param sem Semaphore to wait on
  * @return VCOS_SUCCESS - semaphore was taken.
  *         VCOS_EAGAIN - could not take semaphore
  */
extern __inline__
VCOS_STATUS_T vcos_named_semaphore_trywait(VCOS_NAMED_SEMAPHORE_T *sem);

/**
  * \brief Post a semaphore.
  *
  * @param sem Semaphore to wait on
  */
extern __inline__
void vcos_named_semaphore_post(VCOS_NAMED_SEMAPHORE_T *sem);

/**
  * \brief Delete a semaphore, releasing any resources consumed by it.
  *
  * @param sem Semaphore to wait on
  */
void vcos_named_semaphore_delete(VCOS_NAMED_SEMAPHORE_T *sem);
# 169 "/opt/vc/include/interface/vcos/vcos.h" 2



# 1 "/opt/vc/include/interface/vcos/vcos_quickslow_mutex.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - mutex public header file
=============================================================================*/


#define VCOS_QUICKSLOW_MUTEX_H 





# 1 "/opt/vc/include/interface/vcos/vcos_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/
# 40 "/opt/vc/include/interface/vcos/vcos_quickslow_mutex.h" 2
# 1 "/opt/vc/include/interface/vcos/vcos.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */
# 41 "/opt/vc/include/interface/vcos/vcos_quickslow_mutex.h" 2

/**
 * \file vcos_quickslow_mutex.h
 *
 * "Quick/Slow" Mutex API. This is a mutex which supports an additional "quick"
 * (spinlock-based) locking mechanism. While in this quick locked state, other
 * operating system commands will be unavailable and the caller should complete
 * whatever it has to do in a short, bounded length of time (as the spinlock
 * completely locks out other system activity).
 *
 * \sa vcos_mutex.h
 *
 */

/** Create a mutex.
  *
  * @param m      Filled in with mutex on return
  * @param name   A non-null name for the mutex, used for diagnostics.
  *
  * @return VCOS_SUCCESS if mutex was created, or error code.
  */
extern __inline__
VCOS_STATUS_T vcos_quickslow_mutex_create(VCOS_QUICKSLOW_MUTEX_T *m, const char *name);

/** Delete the mutex.
  */
extern __inline__
void vcos_quickslow_mutex_delete(VCOS_QUICKSLOW_MUTEX_T *m);

/**
  * \brief Wait to claim the mutex ("slow" mode).
  *
  * Obtain the mutex.
  */
extern __inline__
void vcos_quickslow_mutex_lock(VCOS_QUICKSLOW_MUTEX_T *m);

/** Release the mutex ("slow" mode).
  */
extern __inline__
void vcos_quickslow_mutex_unlock(VCOS_QUICKSLOW_MUTEX_T *m);

/**
  * \brief Wait to claim the mutex ("quick" mode).
  *
  * Obtain the mutex. The caller must not call any OS functions or do anything
  * "slow" before the corresponding call to vcos_mutex_quickslow_unlock_quick.
  */
extern __inline__
void vcos_quickslow_mutex_lock_quick(VCOS_QUICKSLOW_MUTEX_T *m);

/** Release the mutex ("quick" mode).
  */
extern __inline__
void vcos_quickslow_mutex_unlock_quick(VCOS_QUICKSLOW_MUTEX_T *m);
# 173 "/opt/vc/include/interface/vcos/vcos.h" 2


/* Headers with predicates */


# 1 "/opt/vc/include/interface/vcos/vcos_event_flags.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/


#define VCOS_EVENT_FLAGS_H 






# 1 "/opt/vc/include/interface/vcos/vcos_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/
# 41 "/opt/vc/include/interface/vcos/vcos_event_flags.h" 2
# 1 "/opt/vc/include/interface/vcos/vcos.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */
# 42 "/opt/vc/include/interface/vcos/vcos_event_flags.h" 2

#define VCOS_EVENT_FLAGS_SUSPEND VCOS_SUSPEND
#define VCOS_EVENT_FLAGS_NO_SUSPEND VCOS_NO_SUSPEND
typedef VCOS_OPTION VCOS_EVENTGROUP_OPERATION_T;

/**
 * \file vcos_event_flags.h
 *
 * Defines event flags API.
 *
 * Similar to Nucleus event groups.
 *
 * These have the same semantics as Nucleus event groups and ThreadX event
 * flags. As such, they are quite complex internally; if speed is important
 * they might not be your best choice.
 *
 */

/**
 * Create an event flags instance.
 *
 * @param flags   Pointer to event flags instance, filled in on return.
 * @param name    Name for the event flags, used for debug.
 *
 * @return VCOS_SUCCESS if succeeded.
 */

extern __inline__
VCOS_STATUS_T vcos_event_flags_create(VCOS_EVENT_FLAGS_T *flags, const char *name);

/**
  * Set some events.
  *
  * @param flags   Instance to set flags on
  * @param events  Bitmask of the flags to actually set
  * @param op      How the flags should be set. VCOS_OR will OR in the flags; VCOS_AND
  *                will AND them in, possibly clearing existing flags.
  */
extern __inline__
void vcos_event_flags_set(VCOS_EVENT_FLAGS_T *flags,
                          VCOS_UNSIGNED events,
                          VCOS_OPTION op);

/**
 * Retrieve some events.
 *
 * Waits until the specified events have been set.
 *
 * @param flags            Instance to wait on
 * @param requested_events The bitmask to wait for
 * @param op               VCOS_OR - get any; VCOS_AND - get all.
 * @param ms_suspend       How long to wait, in milliseconds
 * @param retrieved_events the events actually retrieved.
 *
 * @return VCOS_SUCCESS if events were retrieved. VCOS_EAGAIN if the
 * timeout expired.
 */
extern __inline__
VCOS_STATUS_T vcos_event_flags_get(VCOS_EVENT_FLAGS_T *flags,
                                                     VCOS_UNSIGNED requested_events,
                                                     VCOS_OPTION op,
                                                     VCOS_UNSIGNED ms_suspend,
                                                     VCOS_UNSIGNED *retrieved_events);


/**
 * Delete an event flags instance.
 */
extern __inline__
void vcos_event_flags_delete(VCOS_EVENT_FLAGS_T *);
# 179 "/opt/vc/include/interface/vcos/vcos.h" 2
# 190 "/opt/vc/include/interface/vcos/vcos.h"
# 1 "/opt/vc/include/interface/vcos/vcos_timer.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - timer support
=============================================================================*/


#define VCOS_TIMER_H 





# 1 "/opt/vc/include/interface/vcos/vcos_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/
# 40 "/opt/vc/include/interface/vcos/vcos_timer.h" 2




/** \file vcos_timer.h
  *
  * Timers are single shot.
  *
  * Timer times are in milliseconds.
  *
  * \note that timer callback functions are called from an arbitrary thread
  * context. The expiration function should do its work as quickly as possible;
  * blocking should be avoided.
  *
  * \note On Windows, the separate function vcos_timer_init() must be called
  * as timer initialization from DllMain is not possible.
  */

/** Perform timer subsystem initialization. This function is not needed
  * on non-Windows platforms but is still present so that it can be
  * called. On Windows it is needed because vcos_init() gets called
  * from DLL initialization where it is not possible to create a
  * time queue (deadlock occurs if you try).
  *
  * @return VCOS_SUCCESS on success. VCOS_EEXIST if this has already been called
  * once. VCOS_ENOMEM if resource allocation failed.
  */
extern VCOS_STATUS_T vcos_timer_init(void);

/** Create a timer in a disabled state.
  *
  * The timer is initially disabled.
  *
  * @param timer     timer handle
  * @param name      name for timer
  * @param expiration_routine function to call when timer expires
  * @param context   context passed to expiration routine
  *
  */
extern __inline__
VCOS_STATUS_T vcos_timer_create(VCOS_TIMER_T *timer,
                                const char *name,
                                void (*expiration_routine)(void *context),
                                void *context);



/** Start a timer running.
  *
  * Timer must be stopped.
  *
  * @param timer     timer handle
  * @param delay     Delay to wait for, in ms
  */
extern __inline__
void vcos_timer_set(VCOS_TIMER_T *timer, VCOS_UNSIGNED delay);

/** Stop an already running timer.
  *
  * @param timer     timer handle
  */
extern __inline__
void vcos_timer_cancel(VCOS_TIMER_T *timer);

/** Stop a timer and restart it.
  * @param timer     timer handle
  * @param delay     delay in ms
  */
extern __inline__
void vcos_timer_reset(VCOS_TIMER_T *timer, VCOS_UNSIGNED delay);

extern __inline__
void vcos_timer_delete(VCOS_TIMER_T *timer);
# 191 "/opt/vc/include/interface/vcos/vcos.h" 2
# 202 "/opt/vc/include/interface/vcos/vcos.h"
# 1 "/opt/vc/include/interface/vcos/vcos_atomic_flags.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/


#define VCOS_ATOMIC_FLAGS_H 





# 1 "/opt/vc/include/interface/vcos/vcos_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/
# 40 "/opt/vc/include/interface/vcos/vcos_atomic_flags.h" 2
# 1 "/opt/vc/include/interface/vcos/vcos.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */
# 41 "/opt/vc/include/interface/vcos/vcos_atomic_flags.h" 2

/**
 * \file vcos_atomic_flags.h
 *
 * Defines atomic flags API.
 *
 * 32 flags. Atomic "or" and "get and clear" operations
 */

/**
 * Create an atomic flags instance.
 *
 * @param atomic_flags Pointer to atomic flags instance, filled in on return
 *
 * @return VCOS_SUCCESS if succeeded.
 */
extern __inline__
VCOS_STATUS_T vcos_atomic_flags_create(VCOS_ATOMIC_FLAGS_T *atomic_flags);

/**
 * Atomically set the specified flags.
 *
 * @param atomic_flags Instance to set flags on
 * @param flags        Mask of flags to set
 */
extern __inline__
void vcos_atomic_flags_or(VCOS_ATOMIC_FLAGS_T *atomic_flags, uint32_t flags);

/**
 * Retrieve the current flags and then clear them. The entire operation is
 * atomic.
 *
 * @param atomic_flags Instance to get/clear flags from/on
 *
 * @return Mask of flags which were set (and we cleared)
 */
extern __inline__
uint32_t vcos_atomic_flags_get_and_clear(VCOS_ATOMIC_FLAGS_T *atomic_flags);

/**
 * Delete an atomic flags instance.
 *
 * @param atomic_flags Instance to delete
 */
extern __inline__
void vcos_atomic_flags_delete(VCOS_ATOMIC_FLAGS_T *atomic_flags);
# 203 "/opt/vc/include/interface/vcos/vcos.h" 2



# 1 "/opt/vc/include/interface/vcos/vcos_once.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - 'once'
=============================================================================*/


#define VCOS_ONCE_H 





# 1 "/opt/vc/include/interface/vcos/vcos_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/
# 40 "/opt/vc/include/interface/vcos/vcos_once.h" 2
# 1 "/opt/vc/include/interface/vcos/vcos.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */
# 41 "/opt/vc/include/interface/vcos/vcos_once.h" 2

/**
 * \file vcos_once.h
 *
 * Ensure something is called only once.
 *
 * Initialize once_control to VCOS_ONCE_INIT. The first
 * time this is called, the init_routine will be called. Thereafter
 * it won't.
 *
 * \sa pthread_once()
 *
 */

VCOS_STATUS_T vcos_once(VCOS_ONCE_T *once_control,
                        void (*init_routine)(void));
# 207 "/opt/vc/include/interface/vcos/vcos.h" 2



# 1 "/opt/vc/include/interface/vcos/vcos_blockpool.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - fixed size allocator support
=============================================================================*/


#define VCOS_BLOCKPOOL_H 





# 1 "/opt/vc/include/interface/vcos/vcos_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - basic types
=============================================================================*/
# 40 "/opt/vc/include/interface/vcos/vcos_blockpool.h" 2
# 1 "/opt/vc/include/interface/vcos/vcos.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */
# 41 "/opt/vc/include/interface/vcos/vcos_blockpool.h" 2

/** \file
  *
  * Thread safe, fixed size allocator API.
  *
  */

/** Initialises a block pool to use already allocated (e.g. statically)
 * allocated memory.
 *
 * Different implementations will incur different overheads. Use
 * VCOS_BLOCKPOOL_SIZE(num_blocks, block_size) to calculate the number
 * of bytes required including overheads for the desired pools.
 *
 * @param pool        Pointer to pool object
 * @param num_blocks  The number of blocks required.
 * @param block_size  The size of an individual block.
 * @param start       The address of the start of the pool.
 * @param pool_size   The size of the pool in bytes.
 * @param align       Alignment for block data. Use VCOS_BLOCKPOOL_ALIGN_DEFAULT
 *                    for default word alignment.
 * @param flags       Reserved for future use.
 * @param name        Name of the pool. Used for diagnostics.
 *
 * @return VCOS_SUCCESS if the pool was created.
 */

extern __inline__
VCOS_STATUS_T vcos_blockpool_init(VCOS_BLOCKPOOL_T *pool,
      VCOS_UNSIGNED num_blocks, VCOS_UNSIGNED block_size,
      void *start, VCOS_UNSIGNED pool_size, VCOS_UNSIGNED align,
      VCOS_UNSIGNED flags, const char *name);

/** Creates a pool of blocks of a given size within a buffer allocated on
 * the heap.
 *
 * The heap memory is freed when the block pool is destroyed by
 * calling vcos_blockpool_delete.
 *
 * @param pool        Pointer to pool object
 * @param num_blocks  The number of blocks required.
 * @param block_size  The size of an individual block.
 * @param align       Alignment for block data. Use VCOS_BLOCKPOOL_ALIGN_DEFAULT
 *                    for default word alignment.
 * @param flags       Reserved for future use.
 * @param name        Name of the pool. Used for diagnostics.
 *
 * @return VCOS_SUCCESS if the pool was created.
 */
extern __inline__
VCOS_STATUS_T vcos_blockpool_create_on_heap(VCOS_BLOCKPOOL_T *pool,
      VCOS_UNSIGNED num_blocks, VCOS_UNSIGNED block_size,
      VCOS_UNSIGNED align, VCOS_UNSIGNED flags,
      const char *name);

/** Allocate a block from the pool
 *
 * @param pool Pointer to the pool to allocate from.
 * @return a pointer to the newly allocated block or NULL if no blocks were
 * available.
 */
extern __inline__
void *vcos_blockpool_alloc(VCOS_BLOCKPOOL_T *pool);

/** Allocate a block from the pool and zero it.
 *
 * @param pool Pointer to the pool to allocate from.
 * @return a pointer to the newly allocated block or NULL if no blocks were
 * available.
 */
extern __inline__
void *vcos_blockpool_calloc(VCOS_BLOCKPOOL_T *pool);

/** Returns a block to the pool.
 *
 * @param block The block to free.
 */
extern __inline__
void vcos_blockpool_free(void *block);

/** Queries the number of available blocks in the pool.
 * @param pool The pool to query.
 */
static __inline__
   VCOS_UNSIGNED vcos_blockpool_available_count(VCOS_BLOCKPOOL_T *pool);

/** Queries the number of used blocks in the pool.
 * @param pool The pool to query.
 */
static __inline__
   VCOS_UNSIGNED vcos_blockpool_used_count(VCOS_BLOCKPOOL_T *pool);

/** Deinitialize a memory pool.
 *
 * @param pool The pool to de-initialize.
 */
extern __inline__
void vcos_blockpool_delete(VCOS_BLOCKPOOL_T *pool);

/** Return an integer handle for a given allocated block. */
extern __inline__
uint32_t vcos_blockpool_elem_to_handle(void *block);

/** Convert an integer handle back into a pointer.
  * Returns NULL if invalid. */
extern __inline__
void *vcos_blockpool_elem_from_handle(VCOS_BLOCKPOOL_T *pool, uint32_t handle);

/** Checks whether a pointer is an allocated block within the specified pool.
  * Returns true if the block is valid, otherwise, false is returned. */
extern __inline__
uint32_t vcos_blockpool_is_valid_elem(
      VCOS_BLOCKPOOL_T *pool, const void *block);

/** May be called once to allow the block pool to be extended by dynamically
 * adding subpools. The block size cannot be altered.
 *
 * @param num_extensions The number of extensions that may be created.
 *                       The maximum is (VCOS_BLOCKPOOL_MAX_SUBPOOLS - 1)
 * @param num_blocks     The number of blocks to allocate in each in each
 *                       dynamically allocated subpool.
 * @return VCOS_SUCCESS if successful.
 */
extern __inline__
   VCOS_STATUS_T vcos_blockpool_extend(VCOS_BLOCKPOOL_T *pool,
         VCOS_UNSIGNED num_extensions, VCOS_UNSIGNED num_blocks);
# 211 "/opt/vc/include/interface/vcos/vcos.h" 2
# 222 "/opt/vc/include/interface/vcos/vcos.h"
# 1 "/opt/vc/include/interface/vcos/vcos_cmd.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
# 223 "/opt/vc/include/interface/vcos/vcos.h" 2
# 34 "opt/vc/include/interface/vmcs_host/vc_dispmanx.h" 2
# 1 "/opt/vc/include/interface/vctypes/vc_image_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Common image types used by the vc_image library


#define INTERFACE_VC_IMAGE_TYPES_H 

/* This file gets included by the VCE compiler, which gets confused
 * easily by the VCOS headers. So cannot include vcos.h here.
 */
# 1 "/opt/vc/include/interface/vcos/vcos_stdint.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
# 37 "/opt/vc/include/interface/vctypes/vc_image_types.h" 2

/* We have so many rectangle types; let's try to introduce a common one. */
typedef struct tag_VC_RECT_T {
   int32_t x;
   int32_t y;
   int32_t width;
   int32_t height;
} VC_RECT_T;

struct VC_IMAGE_T;
typedef struct VC_IMAGE_T VC_IMAGE_T;

/* Types of image supported. */
/* Please add any new types to the *end* of this list.  Also update
 * case_VC_IMAGE_ANY_xxx macros (below), and the vc_image_type_info table in
 * vc_image/vc_image_helper.c.
 */
typedef enum
{
   VC_IMAGE_MIN = 0, //bounds for error checking

   VC_IMAGE_RGB565 = 1,
   VC_IMAGE_1BPP,
   VC_IMAGE_YUV420,
   VC_IMAGE_48BPP,
   VC_IMAGE_RGB888,
   VC_IMAGE_8BPP,
   VC_IMAGE_4BPP, // 4bpp palettised image
   VC_IMAGE_3D32, /* A separated format of 16 colour/light shorts followed by 16 z values */
   VC_IMAGE_3D32B, /* 16 colours followed by 16 z values */
   VC_IMAGE_3D32MAT, /* A separated format of 16 material/colour/light shorts followed by 16 z values */
   VC_IMAGE_RGB2X9, /* 32 bit format containing 18 bits of 6.6.6 RGB, 9 bits per short */
   VC_IMAGE_RGB666, /* 32-bit format holding 18 bits of 6.6.6 RGB */
   VC_IMAGE_PAL4_OBSOLETE, // 4bpp palettised image with embedded palette
   VC_IMAGE_PAL8_OBSOLETE, // 8bpp palettised image with embedded palette
   VC_IMAGE_RGBA32, /* RGB888 with an alpha byte after each pixel */ /* xxx: isn't it BEFORE each pixel? */
   VC_IMAGE_YUV422, /* a line of Y (32-byte padded), a line of U (16-byte padded), and a line of V (16-byte padded) */
   VC_IMAGE_RGBA565, /* RGB565 with a transparent patch */
   VC_IMAGE_RGBA16, /* Compressed (4444) version of RGBA32 */
   VC_IMAGE_YUV_UV, /* VCIII codec format */
   VC_IMAGE_TF_RGBA32, /* VCIII T-format RGBA8888 */
   VC_IMAGE_TF_RGBX32, /* VCIII T-format RGBx8888 */
   VC_IMAGE_TF_FLOAT, /* VCIII T-format float */
   VC_IMAGE_TF_RGBA16, /* VCIII T-format RGBA4444 */
   VC_IMAGE_TF_RGBA5551, /* VCIII T-format RGB5551 */
   VC_IMAGE_TF_RGB565, /* VCIII T-format RGB565 */
   VC_IMAGE_TF_YA88, /* VCIII T-format 8-bit luma and 8-bit alpha */
   VC_IMAGE_TF_BYTE, /* VCIII T-format 8 bit generic sample */
   VC_IMAGE_TF_PAL8, /* VCIII T-format 8-bit palette */
   VC_IMAGE_TF_PAL4, /* VCIII T-format 4-bit palette */
   VC_IMAGE_TF_ETC1, /* VCIII T-format Ericsson Texture Compressed */
   VC_IMAGE_BGR888, /* RGB888 with R & B swapped */
   VC_IMAGE_BGR888_NP, /* RGB888 with R & B swapped, but with no pitch, i.e. no padding after each row of pixels */
   VC_IMAGE_BAYER, /* Bayer image, extra defines which variant is being used */
   VC_IMAGE_CODEC, /* General wrapper for codec images e.g. JPEG from camera */
   VC_IMAGE_YUV_UV32, /* VCIII codec format */
   VC_IMAGE_TF_Y8, /* VCIII T-format 8-bit luma */
   VC_IMAGE_TF_A8, /* VCIII T-format 8-bit alpha */
   VC_IMAGE_TF_SHORT,/* VCIII T-format 16-bit generic sample */
   VC_IMAGE_TF_1BPP, /* VCIII T-format 1bpp black/white */
   VC_IMAGE_OPENGL,
   VC_IMAGE_YUV444I, /* VCIII-B0 HVS YUV 4:4:4 interleaved samples */
   VC_IMAGE_YUV422PLANAR, /* Y, U, & V planes separately (VC_IMAGE_YUV422 has them interleaved on a per line basis) */
   VC_IMAGE_ARGB8888, /* 32bpp with 8bit alpha at MS byte, with R, G, B (LS byte) */
   VC_IMAGE_XRGB8888, /* 32bpp with 8bit unused at MS byte, with R, G, B (LS byte) */

   VC_IMAGE_YUV422YUYV, /* interleaved 8 bit samples of Y, U, Y, V */
   VC_IMAGE_YUV422YVYU, /* interleaved 8 bit samples of Y, V, Y, U */
   VC_IMAGE_YUV422UYVY, /* interleaved 8 bit samples of U, Y, V, Y */
   VC_IMAGE_YUV422VYUY, /* interleaved 8 bit samples of V, Y, U, Y */

   VC_IMAGE_RGBX32, /* 32bpp like RGBA32 but with unused alpha */
   VC_IMAGE_RGBX8888, /* 32bpp, corresponding to RGBA with unused alpha */
   VC_IMAGE_BGRX8888, /* 32bpp, corresponding to BGRA with unused alpha */

   VC_IMAGE_YUV420SP, /* Y as a plane, then UV byte interleaved in plane with with same pitch, half height */

   VC_IMAGE_YUV444PLANAR, /* Y, U, & V planes separately 4:4:4 */

   VC_IMAGE_TF_U8, /* T-format 8-bit U - same as TF_Y8 buf from U plane */
   VC_IMAGE_TF_V8, /* T-format 8-bit U - same as TF_Y8 buf from V plane */

   VC_IMAGE_YUV420_16, /* YUV4:2:0 planar, 16bit values */
   VC_IMAGE_YUV_UV_16, /* YUV4:2:0 codec format, 16bit values */
   VC_IMAGE_YUV420_S, /* YUV4:2:0 with U,V in side-by-side format */
   VC_IMAGE_YUV10COL, /* 10-bit YUV 420 column image format */

   VC_IMAGE_RGBA1010102, /* 32-bpp, 10-bit R/G/B, 2-bit Alpha */

   VC_IMAGE_MAX, //bounds for error checking
   VC_IMAGE_FORCE_ENUM_16BIT = 0xffff,
} VC_IMAGE_TYPE_T;

/* Image transformations (flips and 90 degree rotations).
   These are made out of 3 primitives (transpose is done first).
   These must match the DISPMAN and Media Player definitions. */

#define TRANSFORM_HFLIP (1<<0)
#define TRANSFORM_VFLIP (1<<1)
#define TRANSFORM_TRANSPOSE (1<<2)

typedef enum {
   VC_IMAGE_ROT0 = 0,
   VC_IMAGE_MIRROR_ROT0 = (1<<0),
   VC_IMAGE_MIRROR_ROT180 = (1<<1),
   VC_IMAGE_ROT180 = (1<<0)|(1<<1),
   VC_IMAGE_MIRROR_ROT90 = (1<<2),
   VC_IMAGE_ROT270 = (1<<2)|(1<<0),
   VC_IMAGE_ROT90 = (1<<2)|(1<<1),
   VC_IMAGE_MIRROR_ROT270 = (1<<2)|(1<<0)|(1<<1),
} VC_IMAGE_TRANSFORM_T;

typedef enum
{ //defined to be identical to register bits
   VC_IMAGE_BAYER_RGGB = 0,
   VC_IMAGE_BAYER_GBRG = 1,
   VC_IMAGE_BAYER_BGGR = 2,
   VC_IMAGE_BAYER_GRBG = 3
} VC_IMAGE_BAYER_ORDER_T;

typedef enum
{ //defined to be identical to register bits
   VC_IMAGE_BAYER_RAW6 = 0,
   VC_IMAGE_BAYER_RAW7 = 1,
   VC_IMAGE_BAYER_RAW8 = 2,
   VC_IMAGE_BAYER_RAW10 = 3,
   VC_IMAGE_BAYER_RAW12 = 4,
   VC_IMAGE_BAYER_RAW14 = 5,
   VC_IMAGE_BAYER_RAW16 = 6,
   VC_IMAGE_BAYER_RAW10_8 = 7,
   VC_IMAGE_BAYER_RAW12_8 = 8,
   VC_IMAGE_BAYER_RAW14_8 = 9,
   VC_IMAGE_BAYER_RAW10L = 11,
   VC_IMAGE_BAYER_RAW12L = 12,
   VC_IMAGE_BAYER_RAW14L = 13,
   VC_IMAGE_BAYER_RAW16_BIG_ENDIAN = 14,
   VC_IMAGE_BAYER_RAW4 = 15,
} VC_IMAGE_BAYER_FORMAT_T;
# 35 "opt/vc/include/interface/vmcs_host/vc_dispmanx.h" 2
# 1 "opt/vc/include/interface/vmcs_host/vc_dispservice_x_defs.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Display service command enumeration.


#define VC_DISPSERVICEX_DEFS_H 

# 1 "/opt/vc/include/interface/vctypes/vc_image_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Common image types used by the vc_image library
# 34 "opt/vc/include/interface/vmcs_host/vc_dispservice_x_defs.h" 2

#define HOST_PITCH_ALIGNMENT 4

//Round up to the nearest multiple of 16
#define PAD16(x) (((x) + (VC_INTERFACE_BLOCK_SIZE-1)) & ~(VC_INTERFACE_BLOCK_SIZE-1))

//The max length for an effect name
#define DISPMANX_MAX_EFFECT_NAME (28)

// Should really use the VC_IMAGE_TYPE_T, but this one has been extended
// to force it up to 32-bits...
typedef enum {
   // Values initially chosen to match VC_IMAGE_TYPE_T to aid debugging
   // This is now a mandatory constraint
   VC_FORMAT_RGB565 = VC_IMAGE_RGB565,
   VC_FORMAT_YUV420 = VC_IMAGE_YUV420,
   VC_FORMAT_RGB888 = VC_IMAGE_RGB888,
   VC_FORMAT_RGBA32 = VC_IMAGE_RGBA32,
   VC_FORMAT_RGBA565 = VC_IMAGE_RGBA565,
   VC_FORMAT_RGBA16 = VC_IMAGE_RGBA16,
   VC_FORMAT_TF_RGBA32 = VC_IMAGE_TF_RGBA32,
   VC_FORMAT_TF_RGBA16 = VC_IMAGE_TF_RGBA16,
   VC_FORMAT_TF_RGB565 = VC_IMAGE_TF_RGB565,
   VC_FORMAT_BGR888 = VC_IMAGE_BGR888,
   VC_FORMAT_BGR888_NP = VC_IMAGE_BGR888_NP,

   VC_FORMAT_ARGB8888 = VC_IMAGE_ARGB8888,
   VC_FORMAT_XRGB8888 = VC_IMAGE_XRGB8888,

   /* To force 32-bit storage, enabling use in structures over-the-wire */
   VC_FORMAT_RANGE_MAX = 0x7FFFFFFF
} VC_IMAGE_FORMAT_T;

// Transforms.
/* Image transformations. These must match the DISPMAN and Media Player versions */
#define TRANSFORM_HFLIP (1<<0)
#define TRANSFORM_VFLIP (1<<1)
#define TRANSFORM_TRANSPOSE (1<<2)

#define VC_DISPMAN_ROT0 VC_IMAGE_ROT0
#define VC_DISPMAN_ROT90 VC_IMAGE_ROT90
#define VC_DISPMAN_ROT180 VC_IMAGE_ROT180
#define VC_DISPMAN_ROT270 VC_IMAGE_ROT270
#define VC_DISPMAN_MIRROR_ROT0 VC_IMAGE_MIRROR_ROT0
#define VC_DISPMAN_MIRROR_ROT90 VC_IMAGE_MIRROR_ROT90
#define VC_DISPMAN_MIRROR_ROT180 VC_IMAGE_MIRROR_ROT180
#define VC_DISPMAN_MIRROR_ROT270 VC_IMAGE_MIRROR_ROT270
#define VC_DISPMAN_TRANSFORM_T VC_IMAGE_TRANSFORM_T

typedef enum {
   VC_RESOURCE_TYPE_HOST,
   VC_RESOURCE_TYPE_VIDEOCORE,
   VC_RESOURCE_TYPE_VIDEOCORE_UNCACHED,
} VC_RESOURCE_TYPE_T;

typedef struct {
   uint8_t type; // VC_IMAGE_FORMAT_T
   uint32_t width; // width in pixels
   uint32_t height; // height in pixels
   uint32_t pitch; // pitch of image_data array in *bytes*
   uint32_t size; // number of *bytes* available in the image_data arry
   uint32_t pointer; // pointer for image_data - this allows the object to be cast to a VC_IMAGE_T on the VIDEOCORE side
} VC_IMAGE_PARAM_T;

typedef enum {
   VC_DISPMANX_GET_DEVICES = 0,
   VC_DISPMANX_GET_DEVICE_NAME,
   VC_DISPMANX_GET_MODES,
   VC_DISPMANX_GET_MODE_INFO,
   VC_DISPMANX_DISPLAY_QUERY_IMAGE_FORMATS,
   // Resources
   VC_DISPMANX_RESOURCE_CREATE,
   VC_DISPMANX_RESOURCE_WRITE_DATA,
   VC_DISPMANX_RESOURCE_DELETE,
   // Displays
   VC_DISPMANX_DISPLAY_OPEN,
   VC_DISPMANX_DISPLAY_OPEN_MODE,
   VC_DISPMANX_DISPLAY_OPEN_OFFSCREEN,
   VC_DISPMANX_DISPLAY_RECONFIGURE,
   VC_DISPMANX_DISPLAY_SET_DESTINATION,
   VC_DISPMANX_DISPLAY_SET_BACKGROUND,
   VC_DISPMANX_DISPLAY_GET_INFO,
   VC_DISPMANX_DISPLAY_CLOSE,
   // Updates
   VC_DISPMANX_UPDATE_START,
   VC_DISPMANX_ELEMENT_ADD,
   VC_DISPMANX_ELEMENT_CHANGE_SOURCE,
   VC_DISPMANX_ELEMENT_MODIFIED,
   VC_DISPMANX_ELEMENT_REMOVE,
   VC_DISPMANX_UPDATE_SUBMIT,
   VC_DISPMANX_UPDATE_SUBMIT_SYNC,
   // Miscellaneous
   VC_DISPMANX_SNAPSHOT,
   // new features - add to end of list
   VC_CMD_END_OF_LIST
} VC_CMD_CODE_T;

/* The table of functions executed for each command. */

typedef void (*INTERFACE_EXECUTE_FN_T)(int, int);

extern INTERFACE_EXECUTE_FN_T interface_execute_fn[];

#define DISPMANX_MAX_HOST_DEVICES 8
#define DISPMANX_MAX_DEVICE_NAME_LEN 16

//Parameter sets for dispservice commands

typedef struct {
   int32_t response;
   uint32_t ndevices;
   uint32_t dummy[2];
   uint8_t names[8][16];
} DISPMANX_GET_DEVICES_RESP_T;
typedef struct {
   uint32_t device;
   uint32_t dummy[3]; //Pad to multiple of 16 bytes
} DISPMANX_GET_MODES_PARAM_T;
typedef struct {
   uint32_t display;
   uint32_t mode;
   uint32_t dummy[2]; //Pad to multiple of 16 bytes
} DISPMANX_GET_MODE_INFO_PARAM_T;
typedef struct {
   uint32_t type;
   uint32_t width;
   uint32_t height;
   uint32_t dummy[1]; // Pad to multiple of 16 bytes
} DISPMANX_RESOURCE_CREATE_PARAM_T;
typedef struct {
   // This will be needed when we change to vchi.
   int junk; // empty structure not allowed
} DISPMANX_RESOURCE_WRITE_DATA_PARAM_T;
typedef struct {
   uint32_t handle;
   uint32_t dummy[3]; //Pad to multiple of 16 bytes
} DISPMANX_RESOURCE_DELETE_PARAM_T;
typedef struct {
   uint32_t device;
   uint32_t dummy[3];
} DISPMANX_DISPLAY_OPEN_PARAM_T;
typedef struct {
   uint32_t device;
   uint32_t mode;
   uint32_t dummy[2];
} DISPMANX_DISPLAY_OPEN_MODE_PARAM_T;
typedef struct {
   uint32_t dest;
   uint32_t orientation;
   uint32_t dummy[2];
} DISPMANX_DISPLAY_OPEN_OFFSCREEN_PARAM_T;
typedef struct {
   uint32_t display;
   uint32_t dest;
   uint32_t dummy[2];
} DISPMANX_DISPLAY_SET_DESTINATION_PARAM_T;
typedef struct {
   uint32_t display;
   uint32_t update;
   uint32_t colour;
   uint32_t dummy;
} DISPMANX_DISPLAY_SET_BACKGROUND_PARAM_T;
typedef struct {
   uint32_t display;
   uint32_t dummy[3];
} DISPMANX_DISPLAY_GET_INFO_PARAM_T;
typedef struct {
   uint32_t read_response;
   int32_t width;
   int32_t height;
   int32_t aspect_pixwidth;
   int32_t aspect_pixheight;
   int32_t fieldrate_num;
   int32_t fieldrate_denom;
   int32_t fields_per_frame;
   uint32_t transform;
   uint32_t dummy[3];
} DISPMANX_DISPLAY_GET_INFO_RESP_T;
typedef struct {
   int32_t priority;
   uint32_t dummy[3];
} DISPMANX_UPDATE_START_PARAM_T;
typedef struct {
   uint32_t update;
   uint32_t display;
   int32_t layer;
   uint32_t transform;
   uint32_t src_resource;
   uint16_t dest_x;
   uint16_t dest_y;
   uint16_t dest_width;
   uint16_t dest_height;
   uint16_t src_x;
   uint16_t src_y;
   uint16_t src_width;
   uint16_t src_height;
   uint32_t flags;
   uint32_t opacity;
   uint32_t mask_resource;
   // already 16 byte aligned
} DISPMANX_ELEMENT_ADD_PARAM_T;
typedef struct {
   uint32_t update;
   uint32_t element;
   uint32_t src_resource;
   uint32_t dummy; // pad to 16 bytes
} DISPMANX_ELEMENT_CHANGE_SOURCE_PARAM_T;
typedef struct {
   uint32_t update;
   uint32_t element;
   uint16_t x;
   uint16_t y;
   uint16_t width;
   uint16_t height;
} DISPMANX_ELEMENT_MODIFIED_PARAM_T;
typedef struct {
   uint32_t update;
   uint32_t element;
   uint32_t dummy[2];
} DISPMANX_ELEMENT_REMOVE_PARAM_T;
typedef struct {
   uint32_t update;
   uint32_t dummy[3];
} DISPMANX_UPDATE_SUBMIT_PARAM_T;
typedef struct {
   uint32_t update;
   uint32_t dummy[3];
} DISPMANX_UPDATE_SUBMIT_SYNC_PARAM_T;
typedef struct {
   uint32_t display;
   uint32_t snapshot_resource;
   uint32_t transform;
   uint32_t dummy[1];
} DISPMANX_DISPLAY_SNAPSHOT_PARAM_T;

// for dispmanx

#define TRANSFORM_HFLIP (1<<0)
#define TRANSFORM_VFLIP (1<<1)
#define TRANSFORM_TRANSPOSE (1<<2)
# 36 "opt/vc/include/interface/vmcs_host/vc_dispmanx.h" 2
# 1 "/opt/vc/include/interface/vmcs_host/vc_dispmanx_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Typedefs and enums for the VideoCore III Display Manager


#define _DISPMANX_TYPES_H 

# 1 "/opt/vc/include/interface/vctypes/vc_image_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Common image types used by the vc_image library
# 34 "/opt/vc/include/interface/vmcs_host/vc_dispmanx_types.h" 2
# 1 "/opt/vc/include/interface/vctypes/vc_display_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
Common image types used by the vc_image library.
=============================================================================*/


#define INTERFACE_VC_DISPLAY_TYPES_H 

//enums of display input format
typedef enum
{
   VCOS_DISPLAY_INPUT_FORMAT_INVALID = 0,
   VCOS_DISPLAY_INPUT_FORMAT_RGB888,
   VCOS_DISPLAY_INPUT_FORMAT_RGB565
}
VCOS_DISPLAY_INPUT_FORMAT_T;

/** For backward compatibility */
#define DISPLAY_INPUT_FORMAT_INVALID VCOS_DISPLAY_INPUT_FORMAT_INVALID
#define DISPLAY_INPUT_FORMAT_RGB888 VCOS_DISPLAY_INPUT_FORMAT_RGB888
#define DISPLAY_INPUT_FORMAT_RGB565 VCOS_DISPLAY_INPUT_FORMAT_RGB565
typedef VCOS_DISPLAY_INPUT_FORMAT_T DISPLAY_INPUT_FORMAT_T;

// Enum determining how image data for 3D displays has to be supplied
typedef enum
{
   DISPLAY_3D_UNSUPPORTED = 0, // default
   DISPLAY_3D_INTERLEAVED, // For autosteroscopic displays
   DISPLAY_3D_SBS_FULL_AUTO, // Side-By-Side, Full Width (also used by some autostereoscopic displays)
   DISPLAY_3D_SBS_HALF_HORIZ, // Side-By-Side, Half Width, Horizontal Subsampling (see HDMI spec)
   DISPLAY_3D_TB_HALF, // Top-bottom 3D
   DISPLAY_3D_FRAME_PACKING, // Frame Packed 3D
   DISPLAY_3D_FRAME_SEQUENTIAL, // Output left on even frames and right on odd frames (typically 120Hz)
   DISPLAY_3D_FORMAT_MAX
} DISPLAY_3D_FORMAT_T;

//enums of display types
typedef enum
{
   DISPLAY_INTERFACE_MIN,
   DISPLAY_INTERFACE_SMI,
   DISPLAY_INTERFACE_DPI,
   DISPLAY_INTERFACE_DSI,
   DISPLAY_INTERFACE_LVDS,
   DISPLAY_INTERFACE_MAX

} DISPLAY_INTERFACE_T;

/* display dither setting, used on B0 */
typedef enum {
   DISPLAY_DITHER_NONE = 0, /* default if not set */
   DISPLAY_DITHER_RGB666 = 1,
   DISPLAY_DITHER_RGB565 = 2,
   DISPLAY_DITHER_RGB555 = 3,
   DISPLAY_DITHER_MAX
} DISPLAY_DITHER_T;

struct PIXELVALVE_PERIPH_SETUP_S;
typedef struct PIXELVALVE_PERIPH_SETUP_S PIXELVALVE_PERIPH_SETUP_T;

//info struct
typedef struct
{
   //type
   DISPLAY_INTERFACE_T type;
   //width / height
   uint32_t width;
   uint32_t height;
   //output format
   DISPLAY_INPUT_FORMAT_T input_format;
   //interlaced?
   uint32_t interlaced;
   /* output dither setting (if required) */
   DISPLAY_DITHER_T output_dither;
   /* Pixel frequency */
   uint32_t pixel_freq;
   /* Line rate in lines per second */
   uint32_t line_rate;
   // Format required for image data for 3D displays
   DISPLAY_3D_FORMAT_T format_3d;
   // If display requires PV1 (e.g. DSI1), special config is required in HVS
   uint32_t use_pixelvalve;
   // Set for DSI displays which use video mode.
   uint32_t dsi_video_mode;
   // Select HVS channel (usually 0).
   uint32_t hvs_channel;
   // transform required to get the display correctly oriented landscape
   uint32_t transform;
   // pixel valve setup for detailed timings
   PIXELVALVE_PERIPH_SETUP_T *pv_setup;
} DISPLAY_INFO_T;
# 35 "/opt/vc/include/interface/vmcs_host/vc_dispmanx_types.h" 2

#define VC_DISPMANX_VERSION 1

/* Opaque handles */
typedef uint32_t DISPMANX_DISPLAY_HANDLE_T;
typedef uint32_t DISPMANX_UPDATE_HANDLE_T;
typedef uint32_t DISPMANX_ELEMENT_HANDLE_T;
typedef uint32_t DISPMANX_RESOURCE_HANDLE_T;

typedef uint32_t DISPMANX_PROTECTION_T;

#define DISPMANX_NO_HANDLE 0

#define DISPMANX_PROTECTION_MAX 0x0f
#define DISPMANX_PROTECTION_NONE 0
#define DISPMANX_PROTECTION_HDCP 11



/* Default display IDs.
   Note: if you overwrite with your own dispmanx_platform_init function, you
   should use IDs you provided during dispmanx_display_attach.
*/
#define DISPMANX_ID_MAIN_LCD 0
#define DISPMANX_ID_AUX_LCD 1
#define DISPMANX_ID_HDMI0 2
// deprecated, but support for backwards compatibility
#define DISPMANX_ID_HDMI DISPMANX_ID_HDMI0
#define DISPMANX_ID_SDTV 3
#define DISPMANX_ID_FORCE_LCD 4
#define DISPMANX_ID_FORCE_TV 5
#define DISPMANX_ID_FORCE_OTHER 6
#define DISPMANX_ID_HDMI1 7
#define DISPMANX_ID_FORCE_TV2 8

#define DISPMANX_ID_MAX DISPMANX_ID_FORCE_TV2

/* Return codes. Nonzero ones indicate failure. */
typedef enum {
  DISPMANX_SUCCESS = 0,
  DISPMANX_INVALID = -1
  /* XXX others TBA */
} DISPMANX_STATUS_T;

typedef enum {
  /* Bottom 2 bits sets the orientation */
  DISPMANX_NO_ROTATE = 0,
  DISPMANX_ROTATE_90 = 1,
  DISPMANX_ROTATE_180 = 2,
  DISPMANX_ROTATE_270 = 3,

  DISPMANX_FLIP_HRIZ = 1 << 16,
  DISPMANX_FLIP_VERT = 1 << 17,

  /* invert left/right images */
  DISPMANX_STEREOSCOPIC_INVERT = 1 << 19,
  /* extra flags for controlling 3d duplication behaviour */
  DISPMANX_STEREOSCOPIC_NONE = 0 << 20,
  DISPMANX_STEREOSCOPIC_MONO = 1 << 20,
  DISPMANX_STEREOSCOPIC_SBS = 2 << 20,
  DISPMANX_STEREOSCOPIC_TB = 3 << 20,
  DISPMANX_STEREOSCOPIC_MASK = 15 << 20,

  /* extra flags for controlling snapshot behaviour */
  DISPMANX_SNAPSHOT_NO_YUV = 1 << 24,
  DISPMANX_SNAPSHOT_NO_RGB = 1 << 25,
  DISPMANX_SNAPSHOT_FILL = 1 << 26,
  DISPMANX_SNAPSHOT_SWAP_RED_BLUE = 1 << 27,
  DISPMANX_SNAPSHOT_PACK = 1 << 28
} DISPMANX_TRANSFORM_T;

typedef enum {
  /* Bottom 2 bits sets the alpha mode */
  DISPMANX_FLAGS_ALPHA_FROM_SOURCE = 0,
  DISPMANX_FLAGS_ALPHA_FIXED_ALL_PIXELS = 1,
  DISPMANX_FLAGS_ALPHA_FIXED_NON_ZERO = 2,
  DISPMANX_FLAGS_ALPHA_FIXED_EXCEED_0X07 = 3,

  DISPMANX_FLAGS_ALPHA_PREMULT = 1 << 16,
  DISPMANX_FLAGS_ALPHA_MIX = 1 << 17,
  DISPMANX_FLAGS_ALPHA_DISCARD_LOWER_LAYERS = 1 << 18,
} DISPMANX_FLAGS_ALPHA_T;

typedef struct {
  DISPMANX_FLAGS_ALPHA_T flags;
  uint32_t opacity;
  VC_IMAGE_T *mask;
} DISPMANX_ALPHA_T;

typedef struct {
  DISPMANX_FLAGS_ALPHA_T flags;
  uint32_t opacity;
  DISPMANX_RESOURCE_HANDLE_T mask;
} VC_DISPMANX_ALPHA_T; /* for use with vmcs_host */

typedef enum {
  DISPMANX_FLAGS_CLAMP_NONE = 0,
  DISPMANX_FLAGS_CLAMP_LUMA_TRANSPARENT = 1,




  DISPMANX_FLAGS_CLAMP_CHROMA_TRANSPARENT = 2,
  DISPMANX_FLAGS_CLAMP_TRANSPARENT = 3

} DISPMANX_FLAGS_CLAMP_T;

typedef enum {
  DISPMANX_FLAGS_KEYMASK_OVERRIDE = 1,
  DISPMANX_FLAGS_KEYMASK_SMOOTH = 1 << 1,
  DISPMANX_FLAGS_KEYMASK_CR_INV = 1 << 2,
  DISPMANX_FLAGS_KEYMASK_CB_INV = 1 << 3,
  DISPMANX_FLAGS_KEYMASK_YY_INV = 1 << 4
} DISPMANX_FLAGS_KEYMASK_T;

typedef union {
  struct {
    uint8_t yy_upper;
    uint8_t yy_lower;
    uint8_t cr_upper;
    uint8_t cr_lower;
    uint8_t cb_upper;
    uint8_t cb_lower;
  } yuv;
  struct {
    uint8_t red_upper;
    uint8_t red_lower;
    uint8_t blue_upper;
    uint8_t blue_lower;
    uint8_t green_upper;
    uint8_t green_lower;
  } rgb;
} DISPMANX_CLAMP_KEYS_T;

typedef struct {
  DISPMANX_FLAGS_CLAMP_T mode;
  DISPMANX_FLAGS_KEYMASK_T key_mask;
  DISPMANX_CLAMP_KEYS_T key_value;
  uint32_t replace_value;
} DISPMANX_CLAMP_T;

typedef struct {
  int32_t width;
  int32_t height;
  DISPMANX_TRANSFORM_T transform;
  DISPLAY_INPUT_FORMAT_T input_format;
  uint32_t display_num;
} DISPMANX_MODEINFO_T;

/* Update callback. */
typedef void (*DISPMANX_CALLBACK_FUNC_T)(DISPMANX_UPDATE_HANDLE_T u, void * arg);

/* Progress callback */
typedef void (*DISPMANX_PROGRESS_CALLBACK_FUNC_T)(DISPMANX_UPDATE_HANDLE_T u,
                                                  uint32_t line,
                                                  void * arg);

/* Pluggable display interface */

typedef struct tag_DISPMANX_DISPLAY_FUNCS_T {
   // Get essential HVS configuration to be passed to the HVS driver. Options
   // is any combination of the following flags: HVS_ONESHOT, HVS_FIFOREG,
   // HVS_FIFO32, HVS_AUTOHSTART, HVS_INTLACE; and if HVS_FIFOREG, one of;
   // { HVS_FMT_RGB888, HVS_FMT_RGB565, HVS_FMT_RGB666, HVS_FMT_YUV }.
   int32_t (*get_hvs_config)(void *instance, uint32_t *pchan,
                             uint32_t *poptions, DISPLAY_INFO_T *info,
                             uint32_t *bg_colour, uint32_t *test_mode);

   // Get optional HVS configuration for gamma tables, OLED matrix and dither controls.
   // Set these function pointers to NULL if the relevant features are not required.
   int32_t (*get_gamma_params)(void * instance,
                               int32_t gain[3], int32_t offset[3], int32_t gamma[3]);
   int32_t (*get_oled_params)(void * instance, uint32_t * poffsets,
                              uint32_t coeffs[3]);
   int32_t (*get_dither)(void * instance, uint32_t * dither_depth, uint32_t * dither_type);

   // Get mode information, which may be returned to the applications as a courtesy.
   // Transform should be set to 0, and {width,height} should be final dimensions.
   int32_t (*get_info)(void * instance, DISPMANX_MODEINFO_T * info);

   // Inform driver that the application refcount has become nonzero / zero
   // These callbacks might perhaps be used for backlight and power management.
   int32_t (*open)(void * instance);
   int32_t (*close)(void * instance);

   // Display list updated callback. Primarily of use to a "one-shot" display.
   // For convenience of the driver, we pass the register address of the HVS FIFO.
   void (*dlist_updated)(void * instance, volatile uint32_t * fifo_reg);

   // End-of-field callback. This may occur in an interrupt context.
   void (*eof_callback)(void * instance);

   // Return screen resolution format
   DISPLAY_INPUT_FORMAT_T (*get_input_format)(void * instance);

   int32_t (*suspend_resume)(void *instance, int up);

   DISPLAY_3D_FORMAT_T (*get_3d_format)(void * instance);
} DISPMANX_DISPLAY_FUNCS_T;
# 37 "opt/vc/include/interface/vmcs_host/vc_dispmanx.h" 2
# 1 "/opt/vc/include/interface/vchi/vchi.h" 1
/*
Copyright (c) 2012-2014, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Contains the protypes for the vchi functions.


#define VCHI_H_ 

# 1 "/opt/vc/include/interface/vcos/vcos.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */
# 34 "/opt/vc/include/interface/vchi/vchi.h" 2
# 1 "/opt/vc/include/interface/vchi/vchi_cfg.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Contains the #defines for the number of servers / clients etc, these can be
// over-ridden from the platform makefile if needed



#define VCHI_CFG_H_ 

/****************************************************************************************
 * Defines in this first section are part of the VCHI API and may be examined by VCHI
 * services.
 ***************************************************************************************/

/* Required alignment of base addresses for bulk transfer, if unaligned transfers are not enabled */
/* Really determined by the message driver, and should be available from a run-time call. */




#define VCHI_BULK_ALIGN 16



/* Required length multiple for bulk transfers, if unaligned transfers are not enabled */
/* May be less than or greater than VCHI_BULK_ALIGN */
/* Really determined by the message driver, and should be available from a run-time call. */




#define VCHI_BULK_GRANULARITY 16



/* The largest possible message to be queued with vchi_msg_queue. */




#define VCHI_MAX_MSG_SIZE 4096



/******************************************************************************************
 * Defines below are system configuration options, and should not be used by VCHI services.
 *****************************************************************************************/

/* How many connections can we support? A localhost implementation uses 2 connections,
 * 1 for host-app, 1 for VMCS, and these are hooked together by a loopback MPHI VCFW
 * driver. */

#define VCHI_MAX_NUM_CONNECTIONS 3


/* How many services can we open per connection? Extending this doesn't cost processing time, just a small
 * amount of static memory. */

#define VCHI_MAX_SERVICES_PER_CONNECTION 36


/* Adjust if using a message driver that supports more logical TX channels */

#define VCHI_MAX_BULK_TX_CHANNELS_PER_CONNECTION 9


/* Adjust if using a message driver that supports more logical RX channels */

#define VCHI_MAX_BULK_RX_CHANNELS_PER_CONNECTION 1


/* How many receive slots do we use. This times VCHI_MAX_MSG_SIZE gives the effective
 * receive queue space, less message headers. */




#define VCHI_NUM_READ_SLOTS 48



/* Do we utilise overrun facility for receive message slots? Can aid peer transmit
 * performance. Only define on VideoCore end, talking to host.
 */
//#define VCHI_MSG_RX_OVERRUN

/* How many transmit slots do we use. Generally don't need many, as the hardware driver
 * underneath VCHI will usually have its own buffering. */

#define VCHI_NUM_WRITE_SLOTS 4


/* If a service has held or queued received messages in VCHI_XOFF_THRESHOLD or more slots,
 * then it's taking up too much buffer space, and the peer service will be told to stop
 * transmitting with an XOFF message. For this to be effective, the VCHI_NUM_READ_SLOTS
 * needs to be considerably bigger than VCHI_NUM_WRITE_SLOTS, or the transmit latency
 * is too high. */

#define VCHI_XOFF_THRESHOLD (VCHI_NUM_READ_SLOTS / 2)


/* After we've sent an XOFF, the peer will be told to resume transmission once the local
 * service has dequeued/released enough messages that it's now occupying
 * VCHI_XON_THRESHOLD slots or fewer. */

#define VCHI_XON_THRESHOLD (VCHI_NUM_READ_SLOTS / 4)


/* A size below which a bulk transfer omits the handshake completely and always goes
 * via the message channel, if bulk auxiliary is being sent on that service. (The user
 * can guarantee this by enabling unaligned transmits).
 * Not API. */

#define VCHI_MIN_BULK_SIZE ( VCHI_MAX_MSG_SIZE / 2 < 4096 ? VCHI_MAX_MSG_SIZE / 2 : 4096 )


/* Maximum size of bulk transmission chunks, for each interface type. A trade-off between
 * speed and latency; the smaller the chunk size the better change of messages and other
 * bulk transmissions getting in when big bulk transfers are happening. Set to 0 to not
 * break transmissions into chunks.
 */

#define VCHI_MAX_BULK_CHUNK_SIZE_MPHI (16 * 1024)


/* NB Chunked CCP2 transmissions violate the letter of the CCP2 spec by using "JPEG8" mode
 * with multiple-line frames. Only use if the receiver can cope. */

#define VCHI_MAX_BULK_CHUNK_SIZE_CCP2 0


/* How many TX messages can we have pending in our transmit slots. Once exhausted,
 * vchi_msg_queue will be blocked. */

#define VCHI_TX_MSG_QUEUE_SIZE 256


/* How many RX messages can we have parsed in the receive slots. Once exhausted, parsing
 * will be suspended until older messages are dequeued/released. */

#define VCHI_RX_MSG_QUEUE_SIZE 256


/* Really should be able to cope if we run out of received message descriptors, by
 * suspending parsing as the comment above says, but we don't. This sweeps the issue
 * under the carpet. */

#undef VCHI_RX_MSG_QUEUE_SIZE
#define VCHI_RX_MSG_QUEUE_SIZE (VCHI_MAX_MSG_SIZE/16 + 1) * VCHI_NUM_READ_SLOTS


/* How many bulk transmits can we have pending. Once exhausted, vchi_bulk_queue_transmit
 * will be blocked. */

#define VCHI_TX_BULK_QUEUE_SIZE 64


/* How many bulk receives can we have pending. Once exhausted, vchi_bulk_queue_receive
 * will be blocked. */

#define VCHI_RX_BULK_QUEUE_SIZE 64


/* A limit on how many outstanding bulk requests we expect the peer to give us. If
 * the peer asks for more than this, VCHI will fail and assert. The number is determined
 * by the peer's hardware - it's the number of outstanding requests that can be queued
 * on all bulk channels. VC3's MPHI peripheral allows 16. */

#define VCHI_MAX_PEER_BULK_REQUESTS 32


/* Define VCHI_CCP2TX_MANUAL_POWER if the host tells us when to turn the CCP2
 * transmitter on and off.
 */
/*#define VCHI_CCP2TX_MANUAL_POWER*/



/* Timeout (in milliseconds) for putting the CCP2TX interface into IDLE state. Set
 * negative for no IDLE.
 */

#define VCHI_CCP2TX_IDLE_TIMEOUT 5


/* Timeout (in milliseconds) for putting the CCP2TX interface into OFF state. Set
 * negative for no OFF.
 */

#define VCHI_CCP2TX_OFF_TIMEOUT 1000






/****************************** End of file **********************************/
# 35 "/opt/vc/include/interface/vchi/vchi.h" 2
# 1 "/opt/vc/include/interface/vchi/vchi_common.h" 1
/*
Copyright (c) 2012-2014, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Contains global defs used by submodules within vchi


#define VCHI_COMMON_H_ 


//flags used when sending messages (must be bitmapped)
typedef enum
{
   VCHI_FLAGS_NONE = 0x0,
   VCHI_FLAGS_BLOCK_UNTIL_OP_COMPLETE = 0x1, // waits for message to be received, or sent (NB. not the same as being seen on other side)
   VCHI_FLAGS_CALLBACK_WHEN_OP_COMPLETE = 0x2, // run a callback when message sent
   VCHI_FLAGS_BLOCK_UNTIL_QUEUED = 0x4, // return once the transfer is in a queue ready to go
   VCHI_FLAGS_ALLOW_PARTIAL = 0x8,
   VCHI_FLAGS_BLOCK_UNTIL_DATA_READ = 0x10,
   VCHI_FLAGS_CALLBACK_WHEN_DATA_READ = 0x20,

   VCHI_FLAGS_ALIGN_SLOT = 0x000080, // internal use only
   VCHI_FLAGS_BULK_AUX_QUEUED = 0x010000, // internal use only
   VCHI_FLAGS_BULK_AUX_COMPLETE = 0x020000, // internal use only
   VCHI_FLAGS_BULK_DATA_QUEUED = 0x040000, // internal use only
   VCHI_FLAGS_BULK_DATA_COMPLETE = 0x080000, // internal use only
   VCHI_FLAGS_INTERNAL = 0xFF0000
} VCHI_FLAGS_T;

// constants for vchi_crc_control()
typedef enum {
   VCHI_CRC_NOTHING = -1,
   VCHI_CRC_PER_SERVICE = 0,
   VCHI_CRC_EVERYTHING = 1,
} VCHI_CRC_CONTROL_T;

//callback reasons when an event occurs on a service
typedef enum
{
   VCHI_CALLBACK_REASON_MIN,

   //This indicates that there is data available
   //handle is the msg id that was transmitted with the data
   //    When a message is received and there was no FULL message available previously, send callback
   //    Tasks get kicked by the callback, reset their event and try and read from the fifo until it fails
   VCHI_CALLBACK_MSG_AVAILABLE,
   VCHI_CALLBACK_MSG_SENT,
   VCHI_CALLBACK_MSG_SPACE_AVAILABLE, // XXX not yet implemented

   // This indicates that a transfer from the other side has completed
   VCHI_CALLBACK_BULK_RECEIVED,
   //This indicates that data queued up to be sent has now gone
   //handle is the msg id that was used when sending the data
   VCHI_CALLBACK_BULK_SENT,
   VCHI_CALLBACK_BULK_RX_SPACE_AVAILABLE, // XXX not yet implemented
   VCHI_CALLBACK_BULK_TX_SPACE_AVAILABLE, // XXX not yet implemented

   VCHI_CALLBACK_SERVICE_CLOSED,

   // this side has sent XOFF to peer due to lack of data consumption by service
   // (suggests the service may need to take some recovery action if it has
   // been deliberately holding off consuming data)
   VCHI_CALLBACK_SENT_XOFF,
   VCHI_CALLBACK_SENT_XON,

   // indicates that a bulk transfer has finished reading the source buffer
   VCHI_CALLBACK_BULK_DATA_READ,

   // power notification events (currently host side only)
   VCHI_CALLBACK_PEER_OFF,
   VCHI_CALLBACK_PEER_SUSPENDED,
   VCHI_CALLBACK_PEER_ON,
   VCHI_CALLBACK_PEER_RESUMED,
   VCHI_CALLBACK_FORCED_POWER_OFF,
# 106 "/opt/vc/include/interface/vchi/vchi_common.h"
   VCHI_CALLBACK_REASON_MAX
} VCHI_CALLBACK_REASON_T;

// service control options
typedef enum
{
   VCHI_SERVICE_OPTION_MIN,

   VCHI_SERVICE_OPTION_TRACE,
   VCHI_SERVICE_OPTION_SYNCHRONOUS,

   VCHI_SERVICE_OPTION_MAX
} VCHI_SERVICE_OPTION_T;

//Callback used by all services / bulk transfers
typedef void (*VCHI_CALLBACK_T)( void *callback_param, //my service local param
                                 VCHI_CALLBACK_REASON_T reason,
                                 void *handle ); //for transmitting msg's only



/*
 * Define vector struct for scatter-gather (vector) operations
 * Vectors can be nested - if a vector element has negative length, then
 * the data pointer is treated as pointing to another vector array, with
 * '-vec_len' elements. Thus to append a header onto an existing vector,
 * you can do this:
 *
 * void foo(const VCHI_MSG_VECTOR_T *v, int n)
 * {
 *    VCHI_MSG_VECTOR_T nv[2];
 *    nv[0].vec_base = my_header;
 *    nv[0].vec_len = sizeof my_header;
 *    nv[1].vec_base = v;
 *    nv[1].vec_len = -n;
 *    ...
 *
 */
typedef struct vchi_msg_vector {
   const void *vec_base;
   int32_t vec_len;
} VCHI_MSG_VECTOR_T;

// Opaque type for a connection API
typedef struct opaque_vchi_connection_api_t VCHI_CONNECTION_API_T;

// Opaque type for a message driver
typedef struct opaque_vchi_message_driver_t VCHI_MESSAGE_DRIVER_T;


// Iterator structure for reading ahead through received message queue. Allocated by client,
// initialised by vchi_msg_look_ahead. Fields are for internal VCHI use only.
// Iterates over messages in queue at the instant of the call to vchi_msg_lookahead -
// will not proceed to messages received since. Behaviour is undefined if an iterator
// is used again after messages for that service are removed/dequeued by any
// means other than vchi_msg_iter_... calls on the iterator itself.
typedef struct {
   struct opaque_vchi_service_t *service;
   void *last;
   void *next;
   void *remove;
} VCHI_MSG_ITER_T;
# 36 "/opt/vc/include/interface/vchi/vchi.h" 2
# 1 "/opt/vc/include/interface/vchi/connections/connection.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * \file
 *
 * \brief Contains the protypes for the interface functions.
*/


#define CONNECTION_H_ 

# 1 "/opt/vc/include/interface/vchi/vchi_cfg_internal.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#define VCHI_CFG_INTERNAL_H_ 

/****************************************************************************************
 * Control optimisation attempts.
 ***************************************************************************************/

// Don't use lots of short-term locks - use great long ones, reducing the overall locks-per-second
#define VCHI_COARSE_LOCKING 

// Avoid lock then unlock on exit from blocking queue operations (msg tx, bulk rx/tx)
// (only relevant if VCHI_COARSE_LOCKING)
#define VCHI_ELIDE_BLOCK_EXIT_LOCK 

// Avoid lock on non-blocking peek
// (only relevant if VCHI_COARSE_LOCKING)
#define VCHI_AVOID_PEEK_LOCK 

// Use one slot-handler thread per connection, rather than 1 thread dealing with all connections in rotation.
#define VCHI_MULTIPLE_HANDLER_THREADS 

// Put free descriptors onto the head of the free queue, rather than the tail, so that we don't thrash
// our way through the pool of descriptors.
#define VCHI_PUSH_FREE_DESCRIPTORS_ONTO_HEAD 

// Don't issue a MSG_AVAILABLE callback for every single message. Possibly only safe if VCHI_COARSE_LOCKING.
#define VCHI_FEWER_MSG_AVAILABLE_CALLBACKS 

// Don't use message descriptors for TX messages that don't need them
#define VCHI_MINIMISE_TX_MSG_DESCRIPTORS 

// Nano-locks for multiqueue
//#define VCHI_MQUEUE_NANOLOCKS

// Lock-free(er) dequeuing
//#define VCHI_RX_NANOLOCKS
# 38 "/opt/vc/include/interface/vchi/connections/connection.h" 2
# 1 "/opt/vc/include/interface/vchi/vchi_common.h" 1
/*
Copyright (c) 2012-2014, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Contains global defs used by submodules within vchi
# 39 "/opt/vc/include/interface/vchi/connections/connection.h" 2
# 1 "/opt/vc/include/interface/vchi/message_drivers/message.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// MPHI videocore message driver


#define _VCHI_MESSAGE_H_ 

# 1 "/opt/vc/include/interface/vchi/vchi_cfg_internal.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
# 34 "/opt/vc/include/interface/vchi/message_drivers/message.h" 2
# 1 "/opt/vc/include/interface/vcos/vcos.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */
# 35 "/opt/vc/include/interface/vchi/message_drivers/message.h" 2
# 1 "/opt/vc/include/interface/vchi/vchi_common.h" 1
/*
Copyright (c) 2012-2014, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Contains global defs used by submodules within vchi
# 36 "/opt/vc/include/interface/vchi/message_drivers/message.h" 2


typedef enum message_event_type {
   MESSAGE_EVENT_NONE,
   MESSAGE_EVENT_NOP,
   MESSAGE_EVENT_MESSAGE,
   MESSAGE_EVENT_SLOT_COMPLETE,
   MESSAGE_EVENT_RX_BULK_PAUSED,
   MESSAGE_EVENT_RX_BULK_COMPLETE,
   MESSAGE_EVENT_TX_COMPLETE,
   MESSAGE_EVENT_MSG_DISCARDED
} MESSAGE_EVENT_TYPE_T;

typedef enum vchi_msg_flags
{
   VCHI_MSG_FLAGS_NONE = 0x0,
   VCHI_MSG_FLAGS_TERMINATE_DMA = 0x1
} VCHI_MSG_FLAGS_T;

typedef enum message_tx_channel
{
   MESSAGE_TX_CHANNEL_MESSAGE = 0,
   MESSAGE_TX_CHANNEL_BULK = 1 // drivers may provide multiple bulk channels, from 1 upwards
} MESSAGE_TX_CHANNEL_T;

// Macros used for cycling through bulk channels
#define MESSAGE_TX_CHANNEL_BULK_PREV(c) (MESSAGE_TX_CHANNEL_BULK+((c)-MESSAGE_TX_CHANNEL_BULK+VCHI_MAX_BULK_TX_CHANNELS_PER_CONNECTION-1)%VCHI_MAX_BULK_TX_CHANNELS_PER_CONNECTION)
#define MESSAGE_TX_CHANNEL_BULK_NEXT(c) (MESSAGE_TX_CHANNEL_BULK+((c)-MESSAGE_TX_CHANNEL_BULK+1)%VCHI_MAX_BULK_TX_CHANNELS_PER_CONNECTION)

typedef enum message_rx_channel
{
   MESSAGE_RX_CHANNEL_MESSAGE = 0,
   MESSAGE_RX_CHANNEL_BULK = 1 // drivers may provide multiple bulk channels, from 1 upwards
} MESSAGE_RX_CHANNEL_T;

// Message receive slot information
typedef struct rx_msg_slot_info {

   struct rx_msg_slot_info *next;
   //struct slot_info *prev;




   uint8_t *addr; // base address of slot
   uint32_t len; // length of slot in bytes

   uint32_t write_ptr; // hardware causes this to advance
   uint32_t read_ptr; // this module does the reading
   int active; // is this slot in the hardware dma fifo?
   uint32_t msgs_parsed; // count how many messages are in this slot
   uint32_t msgs_released; // how many messages have been released
   void *state; // connection state information
   uint8_t ref_count[36]; // reference count for slots held by services
} RX_MSG_SLOTINFO_T;

// The message driver no longer needs to know about the fields of RX_BULK_SLOTINFO_T - sort this out.
// In particular, it mustn't use addr and len - they're the client buffer, but the message
// driver will be tasked with sending the aligned core section.
typedef struct rx_bulk_slotinfo_t {
   struct rx_bulk_slotinfo_t *next;

   VCOS_SEMAPHORE_T *blocking;

   // needed by DMA
   void *addr;
   uint32_t len;

   // needed for the callback
   void *service;
   void *handle;
   VCHI_FLAGS_T flags;
} RX_BULK_SLOTINFO_T;


/* ----------------------------------------------------------------------
 * each connection driver will have a pool of the following struct.
 *
 * the pool will be managed by vchi_qman_*
 * this means there will be multiple queues (single linked lists)
 * a given struct message_info will be on exactly one of these queues
 * at any one time
 * -------------------------------------------------------------------- */
typedef struct rx_message_info {

   struct message_info *next;
   //struct message_info *prev;

   uint8_t *addr;
   uint32_t len;
   RX_MSG_SLOTINFO_T *slot; // points to whichever slot contains this message
   uint32_t tx_timestamp;
   uint32_t rx_timestamp;

} RX_MESSAGE_INFO_T;

typedef struct {
   MESSAGE_EVENT_TYPE_T type;

   struct {
      // for messages
      void *addr; // address of message
      uint16_t slot_delta; // whether this message indicated slot delta
      uint32_t len; // length of message
      RX_MSG_SLOTINFO_T *slot; // slot this message is in
      vcos_fourcc_t service; // service id this message is destined for
      uint32_t tx_timestamp; // timestamp from the header
      uint32_t rx_timestamp; // timestamp when we parsed it
   } message;

   // FIXME: cleanup slot reporting...
   RX_MSG_SLOTINFO_T *rx_msg;
   RX_BULK_SLOTINFO_T *rx_bulk;
   void *tx_handle;
   MESSAGE_TX_CHANNEL_T tx_channel;

} MESSAGE_EVENT_T;


// callbacks
typedef void VCHI_MESSAGE_DRIVER_EVENT_CALLBACK_T( void *state );

typedef struct {
   VCHI_MESSAGE_DRIVER_EVENT_CALLBACK_T *event_callback;
} VCHI_MESSAGE_DRIVER_OPEN_T;


// handle to this instance of message driver (as returned by ->open)
typedef struct opaque_mhandle_t *VCHI_MDRIVER_HANDLE_T;

struct opaque_vchi_message_driver_t {
   VCHI_MDRIVER_HANDLE_T *(*open)( VCHI_MESSAGE_DRIVER_OPEN_T *params, void *state );
   int32_t (*suspending)( VCHI_MDRIVER_HANDLE_T *handle );
   int32_t (*resumed)( VCHI_MDRIVER_HANDLE_T *handle );
   int32_t (*power_control)( VCHI_MDRIVER_HANDLE_T *handle, MESSAGE_TX_CHANNEL_T, vcos_bool_t enable );
   int32_t (*add_msg_rx_slot)( VCHI_MDRIVER_HANDLE_T *handle, RX_MSG_SLOTINFO_T *slot ); // rx message
   int32_t (*add_bulk_rx)( VCHI_MDRIVER_HANDLE_T *handle, void *data, uint32_t len, RX_BULK_SLOTINFO_T *slot ); // rx data (bulk)
   int32_t (*send)( VCHI_MDRIVER_HANDLE_T *handle, MESSAGE_TX_CHANNEL_T channel, const void *data, uint32_t len, VCHI_MSG_FLAGS_T flags, void *send_handle ); // tx (message & bulk)
   void (*next_event)( VCHI_MDRIVER_HANDLE_T *handle, MESSAGE_EVENT_T *event ); // get the next event from message_driver
   int32_t (*enable)( VCHI_MDRIVER_HANDLE_T *handle );
   int32_t (*form_message)( VCHI_MDRIVER_HANDLE_T *handle, vcos_fourcc_t service_id, VCHI_MSG_VECTOR_T *vector, uint32_t count, void
                            *address, uint32_t length_avail, uint32_t max_total_length, vcos_bool_t pad_to_fill, vcos_bool_t allow_partial );

   int32_t (*update_message)( VCHI_MDRIVER_HANDLE_T *handle, void *dest, int16_t *slot_count );
   int32_t (*buffer_aligned)( VCHI_MDRIVER_HANDLE_T *handle, int tx, int uncached, const void *address, const uint32_t length );
   void * (*allocate_buffer)( VCHI_MDRIVER_HANDLE_T *handle, uint32_t *length );
   void (*free_buffer)( VCHI_MDRIVER_HANDLE_T *handle, void *address );
   int (*rx_slot_size)( VCHI_MDRIVER_HANDLE_T *handle, int msg_size );
   int (*tx_slot_size)( VCHI_MDRIVER_HANDLE_T *handle, int msg_size );

   vcos_bool_t (*tx_supports_terminate)( const VCHI_MDRIVER_HANDLE_T *handle, MESSAGE_TX_CHANNEL_T channel );
   uint32_t (*tx_bulk_chunk_size)( const VCHI_MDRIVER_HANDLE_T *handle, MESSAGE_TX_CHANNEL_T channel );
   int (*tx_alignment)( const VCHI_MDRIVER_HANDLE_T *handle, MESSAGE_TX_CHANNEL_T channel );
   int (*rx_alignment)( const VCHI_MDRIVER_HANDLE_T *handle, MESSAGE_RX_CHANNEL_T channel );
   void (*form_bulk_aux)( VCHI_MDRIVER_HANDLE_T *handle, MESSAGE_TX_CHANNEL_T channel, const void *data, uint32_t len, uint32_t chunk_size, const void **aux_data, int32_t *aux_len );
   void (*debug)( VCHI_MDRIVER_HANDLE_T *handle );
};




/****************************** End of file ***********************************/
# 40 "/opt/vc/include/interface/vchi/connections/connection.h" 2

/******************************************************************************
 Global defs
 *****************************************************************************/

// Opaque handle for a connection / service pair
typedef struct opaque_vchi_connection_connected_service_handle_t *VCHI_CONNECTION_SERVICE_HANDLE_T;

// opaque handle to the connection state information
typedef struct opaque_vchi_connection_info_t VCHI_CONNECTION_STATE_T;

typedef struct vchi_connection_t VCHI_CONNECTION_T;


/******************************************************************************
 API
 *****************************************************************************/

// Routine to init a connection with a particular low level driver
typedef VCHI_CONNECTION_STATE_T * (*VCHI_CONNECTION_INIT_T)( struct vchi_connection_t * connection,
                                                             const VCHI_MESSAGE_DRIVER_T * driver );

// Routine to control CRC enabling at a connection level
typedef int32_t (*VCHI_CONNECTION_CRC_CONTROL_T)( VCHI_CONNECTION_STATE_T *state_handle,
                                                  VCHI_CRC_CONTROL_T control );

// Routine to create a service
typedef int32_t (*VCHI_CONNECTION_SERVICE_CONNECT_T)( VCHI_CONNECTION_STATE_T *state_handle,
                                                      vcos_fourcc_t service_id,
                                                      uint32_t rx_fifo_size,
                                                      uint32_t tx_fifo_size,
                                                      int server,
                                                      VCHI_CALLBACK_T callback,
                                                      void *callback_param,
                                                      vcos_bool_t want_crc,
                                                      vcos_bool_t want_unaligned_bulk_rx,
                                                      vcos_bool_t want_unaligned_bulk_tx,
                                                      VCHI_CONNECTION_SERVICE_HANDLE_T *service_handle );

// Routine to close a service
typedef int32_t (*VCHI_CONNECTION_SERVICE_DISCONNECT_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle );

// Routine to queue a message
typedef int32_t (*VCHI_CONNECTION_SERVICE_QUEUE_MESSAGE_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
                                                            const void *data,
                                                            uint32_t data_size,
                                                            VCHI_FLAGS_T flags,
                                                            void *msg_handle );

// scatter-gather (vector) message queueing
typedef int32_t (*VCHI_CONNECTION_SERVICE_QUEUE_MESSAGEV_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
                                                             VCHI_MSG_VECTOR_T *vector,
                                                             uint32_t count,
                                                             VCHI_FLAGS_T flags,
                                                             void *msg_handle );

// Routine to dequeue a message
typedef int32_t (*VCHI_CONNECTION_SERVICE_DEQUEUE_MESSAGE_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
                                                              void *data,
                                                              uint32_t max_data_size_to_read,
                                                              uint32_t *actual_msg_size,
                                                              VCHI_FLAGS_T flags );

// Routine to peek at a message
typedef int32_t (*VCHI_CONNECTION_SERVICE_PEEK_MESSAGE_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
                                                           void **data,
                                                           uint32_t *msg_size,
                                                           VCHI_FLAGS_T flags );

// Routine to hold a message
typedef int32_t (*VCHI_CONNECTION_SERVICE_HOLD_MESSAGE_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
                                                           void **data,
                                                           uint32_t *msg_size,
                                                           VCHI_FLAGS_T flags,
                                                           void **message_handle );

// Routine to initialise a received message iterator
typedef int32_t (*VCHI_CONNECTION_SERVICE_LOOKAHEAD_MESSAGE_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
                                                                VCHI_MSG_ITER_T *iter,
                                                                VCHI_FLAGS_T flags );

// Routine to release a held message
typedef int32_t (*VCHI_CONNECTION_HELD_MSG_RELEASE_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
                                                       void *message_handle );

// Routine to get info on a held message
typedef int32_t (*VCHI_CONNECTION_HELD_MSG_INFO_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
                                                    void *message_handle,
                                                    void **data,
                                                    int32_t *msg_size,
                                                    uint32_t *tx_timestamp,
                                                    uint32_t *rx_timestamp );

// Routine to check whether the iterator has a next message
typedef vcos_bool_t (*VCHI_CONNECTION_MSG_ITER_HAS_NEXT_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service,
                                                       const VCHI_MSG_ITER_T *iter );

// Routine to advance the iterator
typedef int32_t (*VCHI_CONNECTION_MSG_ITER_NEXT_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service,
                                                    VCHI_MSG_ITER_T *iter,
                                                    void **data,
                                                    uint32_t *msg_size );

// Routine to remove the last message returned by the iterator
typedef int32_t (*VCHI_CONNECTION_MSG_ITER_REMOVE_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service,
                                                      VCHI_MSG_ITER_T *iter );

// Routine to hold the last message returned by the iterator
typedef int32_t (*VCHI_CONNECTION_MSG_ITER_HOLD_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service,
                                                    VCHI_MSG_ITER_T *iter,
                                                    void **msg_handle );

// Routine to transmit bulk data
typedef int32_t (*VCHI_CONNECTION_BULK_QUEUE_TRANSMIT_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
                                                          const void *data_src,
                                                          uint32_t data_size,
                                                          VCHI_FLAGS_T flags,
                                                          void *bulk_handle );

// Routine to receive data
typedef int32_t (*VCHI_CONNECTION_BULK_QUEUE_RECEIVE_T)( VCHI_CONNECTION_SERVICE_HANDLE_T service_handle,
                                                         void *data_dst,
                                                         uint32_t data_size,
                                                         VCHI_FLAGS_T flags,
                                                         void *bulk_handle );

// Routine to report if a server is available
typedef int32_t (*VCHI_CONNECTION_SERVER_PRESENT)( VCHI_CONNECTION_STATE_T *state, vcos_fourcc_t service_id, int32_t peer_flags );

// Routine to report the number of RX slots available
typedef int (*VCHI_CONNECTION_RX_SLOTS_AVAILABLE)( const VCHI_CONNECTION_STATE_T *state );

// Routine to report the RX slot size
typedef uint32_t (*VCHI_CONNECTION_RX_SLOT_SIZE)( const VCHI_CONNECTION_STATE_T *state );

// Callback to indicate that the other side has added a buffer to the rx bulk DMA FIFO
typedef void (*VCHI_CONNECTION_RX_BULK_BUFFER_ADDED)(VCHI_CONNECTION_STATE_T *state,
                                                     vcos_fourcc_t service,
                                                     uint32_t length,
                                                     MESSAGE_TX_CHANNEL_T channel,
                                                     uint32_t channel_params,
                                                     uint32_t data_length,
                                                     uint32_t data_offset);

// Callback to inform a service that a Xon or Xoff message has been received
typedef void (*VCHI_CONNECTION_FLOW_CONTROL)(VCHI_CONNECTION_STATE_T *state, vcos_fourcc_t service_id, int32_t xoff);

// Callback to inform a service that a server available reply message has been received
typedef void (*VCHI_CONNECTION_SERVER_AVAILABLE_REPLY)(VCHI_CONNECTION_STATE_T *state, vcos_fourcc_t service_id, uint32_t flags);

// Callback to indicate that bulk auxiliary messages have arrived
typedef void (*VCHI_CONNECTION_BULK_AUX_RECEIVED)(VCHI_CONNECTION_STATE_T *state);

// Callback to indicate that bulk auxiliary messages have arrived
typedef void (*VCHI_CONNECTION_BULK_AUX_TRANSMITTED)(VCHI_CONNECTION_STATE_T *state, void *handle);

// Callback with all the connection info you require
typedef void (*VCHI_CONNECTION_INFO)(VCHI_CONNECTION_STATE_T *state, uint32_t protocol_version, uint32_t slot_size, uint32_t num_slots, uint32_t min_bulk_size);

// Callback to inform of a disconnect
typedef void (*VCHI_CONNECTION_DISCONNECT)(VCHI_CONNECTION_STATE_T *state, uint32_t flags);

// Callback to inform of a power control request
typedef void (*VCHI_CONNECTION_POWER_CONTROL)(VCHI_CONNECTION_STATE_T *state, MESSAGE_TX_CHANNEL_T channel, vcos_bool_t enable);

// allocate memory suitably aligned for this connection
typedef void * (*VCHI_BUFFER_ALLOCATE)(VCHI_CONNECTION_SERVICE_HANDLE_T service_handle, uint32_t * length);

// free memory allocated by buffer_allocate
typedef void (*VCHI_BUFFER_FREE)(VCHI_CONNECTION_SERVICE_HANDLE_T service_handle, void * address);


/******************************************************************************
 System driver struct
 *****************************************************************************/

struct opaque_vchi_connection_api_t
{
   // Routine to init the connection
   VCHI_CONNECTION_INIT_T init;

   // Connection-level CRC control
   VCHI_CONNECTION_CRC_CONTROL_T crc_control;

   // Routine to connect to or create service
   VCHI_CONNECTION_SERVICE_CONNECT_T service_connect;

   // Routine to disconnect from a service
   VCHI_CONNECTION_SERVICE_DISCONNECT_T service_disconnect;

   // Routine to queue a message
   VCHI_CONNECTION_SERVICE_QUEUE_MESSAGE_T service_queue_msg;

   // scatter-gather (vector) message queue
   VCHI_CONNECTION_SERVICE_QUEUE_MESSAGEV_T service_queue_msgv;

   // Routine to dequeue a message
   VCHI_CONNECTION_SERVICE_DEQUEUE_MESSAGE_T service_dequeue_msg;

   // Routine to peek at a message
   VCHI_CONNECTION_SERVICE_PEEK_MESSAGE_T service_peek_msg;

   // Routine to hold a message
   VCHI_CONNECTION_SERVICE_HOLD_MESSAGE_T service_hold_msg;

   // Routine to initialise a received message iterator
   VCHI_CONNECTION_SERVICE_LOOKAHEAD_MESSAGE_T service_look_ahead_msg;

   // Routine to release a message
   VCHI_CONNECTION_HELD_MSG_RELEASE_T held_msg_release;

   // Routine to get information on a held message
   VCHI_CONNECTION_HELD_MSG_INFO_T held_msg_info;

   // Routine to check for next message on iterator
   VCHI_CONNECTION_MSG_ITER_HAS_NEXT_T msg_iter_has_next;

   // Routine to get next message on iterator
   VCHI_CONNECTION_MSG_ITER_NEXT_T msg_iter_next;

   // Routine to remove the last message returned by iterator
   VCHI_CONNECTION_MSG_ITER_REMOVE_T msg_iter_remove;

   // Routine to hold the last message returned by iterator
   VCHI_CONNECTION_MSG_ITER_HOLD_T msg_iter_hold;

   // Routine to transmit bulk data
   VCHI_CONNECTION_BULK_QUEUE_TRANSMIT_T bulk_queue_transmit;

   // Routine to receive data
   VCHI_CONNECTION_BULK_QUEUE_RECEIVE_T bulk_queue_receive;

   // Routine to report the available servers
   VCHI_CONNECTION_SERVER_PRESENT server_present;

   // Routine to report the number of RX slots available
   VCHI_CONNECTION_RX_SLOTS_AVAILABLE connection_rx_slots_available;

   // Routine to report the RX slot size
   VCHI_CONNECTION_RX_SLOT_SIZE connection_rx_slot_size;

   // Callback to indicate that the other side has added a buffer to the rx bulk DMA FIFO
   VCHI_CONNECTION_RX_BULK_BUFFER_ADDED rx_bulk_buffer_added;

   // Callback to inform a service that a Xon or Xoff message has been received
   VCHI_CONNECTION_FLOW_CONTROL flow_control;

   // Callback to inform a service that a server available reply message has been received
   VCHI_CONNECTION_SERVER_AVAILABLE_REPLY server_available_reply;

   // Callback to indicate that bulk auxiliary messages have arrived
   VCHI_CONNECTION_BULK_AUX_RECEIVED bulk_aux_received;

   // Callback to indicate that a bulk auxiliary message has been transmitted
   VCHI_CONNECTION_BULK_AUX_TRANSMITTED bulk_aux_transmitted;

   // Callback to provide information about the connection
   VCHI_CONNECTION_INFO connection_info;

   // Callback to notify that peer has requested disconnect
   VCHI_CONNECTION_DISCONNECT disconnect;

   // Callback to notify that peer has requested power change
   VCHI_CONNECTION_POWER_CONTROL power_control;

   // allocate memory suitably aligned for this connection
   VCHI_BUFFER_ALLOCATE buffer_allocate;

   // free memory allocated by buffer_allocate
   VCHI_BUFFER_FREE buffer_free;

};

struct vchi_connection_t {
   const VCHI_CONNECTION_API_T *api;
   VCHI_CONNECTION_STATE_T *state;

   VCOS_SEMAPHORE_T sem;

};




/****************************** End of file **********************************/
# 37 "/opt/vc/include/interface/vchi/vchi.h" 2
# 1 "/opt/vc/include/interface/vchi/vchi_mh.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#define VCHI_MH_H_ 

# 1 "/opt/vc/include/interface/vcos/vcos.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */
# 32 "/opt/vc/include/interface/vchi/vchi_mh.h" 2

typedef int32_t VCHI_MEM_HANDLE_T;
#define VCHI_MEM_HANDLE_INVALID 0
# 38 "/opt/vc/include/interface/vchi/vchi.h" 2


/******************************************************************************
 Global defs
 *****************************************************************************/

#define VCHI_SERVICE_HANDLE_INVALID 0

#define VCHI_BULK_ROUND_UP(x) ((((unsigned long)(x))+VCHI_BULK_ALIGN-1) & ~(VCHI_BULK_ALIGN-1))
#define VCHI_BULK_ROUND_DOWN(x) (((unsigned long)(x)) & ~(VCHI_BULK_ALIGN-1))
#define VCHI_BULK_ALIGN_NBYTES(x) (VCHI_BULK_ALIGNED(x) ? 0 : (VCHI_BULK_ALIGN - ((unsigned long)(x) & (VCHI_BULK_ALIGN-1))))




#define VCHI_BULK_ALIGNED(x) (((unsigned long)(x) & (VCHI_BULK_ALIGN-1)) == 0)


typedef struct
{
   uint32_t version;
   uint32_t version_min;
} VCHI_VERSION_T;
#define VCHI_VERSION(v_) { v_, v_ }
#define VCHI_VERSION_EX(v_,m_) { v_, m_ }

typedef enum
{
   VCHI_VEC_POINTER,
   VCHI_VEC_HANDLE,
   VCHI_VEC_LIST
} VCHI_MSG_VECTOR_TYPE_T;

typedef struct vchi_msg_vector_ex {

   VCHI_MSG_VECTOR_TYPE_T type;
   union
   {
      // a memory handle
      struct
      {
         VCHI_MEM_HANDLE_T handle;
         uint32_t offset;
         int32_t vec_len;
      } handle;

      // an ordinary data pointer
      struct
      {
         const void *vec_base;
         int32_t vec_len;
      } ptr;

      // a nested vector list
      struct
      {
         struct vchi_msg_vector_ex *vec;
         uint32_t vec_len;
      } list;
   } u;
} VCHI_MSG_VECTOR_EX_T;


// Construct an entry in a msg vector for a pointer (p) of length (l)
#define VCHI_VEC_POINTER(p,l) VCHI_VEC_POINTER, { { (VCHI_MEM_HANDLE_T)(p), (l) } }

// Construct an entry in a msg vector for a message handle (h), starting at offset (o) of length (l)
#define VCHI_VEC_HANDLE(h,o,l) VCHI_VEC_HANDLE, { { (h), (o), (l) } }

// Macros to manipulate fourcc_t values
#define MAKE_FOURCC(x) ((fourcc_t)( (x[0] << 24) | (x[1] << 16) | (x[2] << 8) | x[3] ))
#define FOURCC_TO_CHAR(x) (x >> 24) & 0xFF,(x >> 16) & 0xFF,(x >> 8) & 0xFF, x & 0xFF


// Opaque service information
struct opaque_vchi_service_t;

// Descriptor for a held message. Allocated by client, initialised by vchi_msg_hold,
// vchi_msg_iter_hold or vchi_msg_iter_hold_next. Fields are for internal VCHI use only.
typedef struct
{
   struct opaque_vchi_service_t *service;
   void *message;
} VCHI_HELD_MSG_T;



// structure used to provide the information needed to open a server or a client
typedef struct {
   VCHI_VERSION_T version;
   vcos_fourcc_t service_id;
   VCHI_CONNECTION_T *connection;
   uint32_t rx_fifo_size;
   uint32_t tx_fifo_size;
   VCHI_CALLBACK_T callback;
   void *callback_param;
   vcos_bool_t want_unaligned_bulk_rx; // client intends to receive bulk transfers of odd lengths or into unaligned buffers
   vcos_bool_t want_unaligned_bulk_tx; // client intends to transmit bulk transfers of odd lengths or out of unaligned buffers
   vcos_bool_t want_crc; // client wants to check CRCs on (bulk) transfers. Only needs to be set at 1 end - will do both directions.
} SERVICE_CREATION_T;

// Opaque handle for a VCHI instance
typedef struct opaque_vchi_instance_handle_t *VCHI_INSTANCE_T;

// Opaque handle for a server or client
typedef unsigned int VCHI_SERVICE_HANDLE_T;

// Service registration & startup
typedef void (*VCHI_SERVICE_INIT)(VCHI_INSTANCE_T initialise_instance, VCHI_CONNECTION_T **connections, uint32_t num_connections);

typedef struct service_info_tag {
   const char * const vll_filename; /* VLL to load to start this service. This is an empty string if VLL is "static" */
   VCHI_SERVICE_INIT init; /* Service initialisation function */
   void *vll_handle; /* VLL handle; NULL when unloaded or a "static VLL" in build */
} SERVICE_INFO_T;

// Pagelist structure for copy callback
struct pagelist_struct;

/******************************************************************************
 Global funcs - implementation is specific to which side you are on (local / remote)
 *****************************************************************************/





extern /*@observer@*/ VCHI_CONNECTION_T * vchi_create_connection( const VCHI_CONNECTION_API_T * function_table,
                                                   const VCHI_MESSAGE_DRIVER_T * low_level);


// Routine used to initialise the vchi on both local + remote connections
extern int32_t vchi_initialise( VCHI_INSTANCE_T *instance_handle );

extern int32_t vchi_connect( VCHI_CONNECTION_T **connections,
                             const uint32_t num_connections,
                             VCHI_INSTANCE_T instance_handle );

//When this is called, ensure that all services have no data pending.
//Bulk transfers can remain 'queued'
extern int32_t vchi_disconnect( VCHI_INSTANCE_T instance_handle );

// Global control over bulk CRC checking
extern int32_t vchi_crc_control( VCHI_CONNECTION_T *connection,
                                 VCHI_CRC_CONTROL_T control );

// helper functions
extern void * vchi_allocate_buffer(VCHI_SERVICE_HANDLE_T handle, uint32_t *length);
extern void vchi_free_buffer(VCHI_SERVICE_HANDLE_T handle, void *address);
extern uint32_t vchi_current_time(VCHI_INSTANCE_T instance_handle);


/******************************************************************************
 Global service API
 *****************************************************************************/
// Routine to create a named service
extern int32_t vchi_service_create( VCHI_INSTANCE_T instance_handle,
                                    SERVICE_CREATION_T *setup,
                                    VCHI_SERVICE_HANDLE_T *handle );

// Routine to destroy a service
extern int32_t vchi_service_destroy( const VCHI_SERVICE_HANDLE_T handle );

// Routine to open a named service
extern int32_t vchi_service_open( VCHI_INSTANCE_T instance_handle,
                                  SERVICE_CREATION_T *setup,
                                  VCHI_SERVICE_HANDLE_T *handle);

extern int32_t vchi_get_peer_version( const VCHI_SERVICE_HANDLE_T handle,
                                      short *peer_version );

// Routine to close a named service
extern int32_t vchi_service_close( const VCHI_SERVICE_HANDLE_T handle );

// Routine to increment ref count on a named service
extern int32_t vchi_service_use( const VCHI_SERVICE_HANDLE_T handle );

// Routine to decrement ref count on a named service
extern int32_t vchi_service_release( const VCHI_SERVICE_HANDLE_T handle );

// Routine to set a control option for a named service
extern int32_t vchi_service_set_option( const VCHI_SERVICE_HANDLE_T handle,
                                        VCHI_SERVICE_OPTION_T option,
                                        int value);

// Routine to send a message across a service
extern int32_t vchi_msg_queue( VCHI_SERVICE_HANDLE_T handle,
                               const void *data,
                               uint32_t data_size,
                               VCHI_FLAGS_T flags,
                               void *msg_handle );

// scatter-gather (vector) and send message
int32_t vchi_msg_queuev_ex( VCHI_SERVICE_HANDLE_T handle,
                            VCHI_MSG_VECTOR_EX_T *vector,
                            uint32_t count,
                            VCHI_FLAGS_T flags,
                            void *msg_handle );

// legacy scatter-gather (vector) and send message, only handles pointers
int32_t vchi_msg_queuev( VCHI_SERVICE_HANDLE_T handle,
                         VCHI_MSG_VECTOR_T *vector,
                         uint32_t count,
                         VCHI_FLAGS_T flags,
                         void *msg_handle );

// Routine to receive a msg from a service
// Dequeue is equivalent to hold, copy into client buffer, release
extern int32_t vchi_msg_dequeue( VCHI_SERVICE_HANDLE_T handle,
                                 void *data,
                                 uint32_t max_data_size_to_read,
                                 uint32_t *actual_msg_size,
                                 VCHI_FLAGS_T flags );

// Routine to look at a message in place.
// The message is not dequeued, so a subsequent call to peek or dequeue
// will return the same message.
extern int32_t vchi_msg_peek( VCHI_SERVICE_HANDLE_T handle,
                              void **data,
                              uint32_t *msg_size,
                              VCHI_FLAGS_T flags );

// Routine to remove a message after it has been read in place with peek
// The first message on the queue is dequeued.
extern int32_t vchi_msg_remove( VCHI_SERVICE_HANDLE_T handle );

// Routine to look at a message in place.
// The message is dequeued, so the caller is left holding it; the descriptor is
// filled in and must be released when the user has finished with the message.
extern int32_t vchi_msg_hold( VCHI_SERVICE_HANDLE_T handle,
                              void **data, // } may be NULL, as info can be
                              uint32_t *msg_size, // } obtained from HELD_MSG_T
                              VCHI_FLAGS_T flags,
                              VCHI_HELD_MSG_T *message_descriptor );

// Initialise an iterator to look through messages in place
extern int32_t vchi_msg_look_ahead( VCHI_SERVICE_HANDLE_T handle,
                                    VCHI_MSG_ITER_T *iter,
                                    VCHI_FLAGS_T flags );

/******************************************************************************
 Global service support API - operations on held messages and message iterators
 *****************************************************************************/

// Routine to get the address of a held message
extern void *vchi_held_msg_ptr( const VCHI_HELD_MSG_T *message );

// Routine to get the size of a held message
extern int32_t vchi_held_msg_size( const VCHI_HELD_MSG_T *message );

// Routine to get the transmit timestamp as written into the header by the peer
extern uint32_t vchi_held_msg_tx_timestamp( const VCHI_HELD_MSG_T *message );

// Routine to get the reception timestamp, written as we parsed the header
extern uint32_t vchi_held_msg_rx_timestamp( const VCHI_HELD_MSG_T *message );

// Routine to release a held message after it has been processed
extern int32_t vchi_held_msg_release( VCHI_HELD_MSG_T *message );

// Indicates whether the iterator has a next message.
extern vcos_bool_t vchi_msg_iter_has_next( const VCHI_MSG_ITER_T *iter );

// Return the pointer and length for the next message and advance the iterator.
extern int32_t vchi_msg_iter_next( VCHI_MSG_ITER_T *iter,
                                   void **data,
                                   uint32_t *msg_size );

// Remove the last message returned by vchi_msg_iter_next.
// Can only be called once after each call to vchi_msg_iter_next.
extern int32_t vchi_msg_iter_remove( VCHI_MSG_ITER_T *iter );

// Hold the last message returned by vchi_msg_iter_next.
// Can only be called once after each call to vchi_msg_iter_next.
extern int32_t vchi_msg_iter_hold( VCHI_MSG_ITER_T *iter,
                                   VCHI_HELD_MSG_T *message );

// Return information for the next message, and hold it, advancing the iterator.
extern int32_t vchi_msg_iter_hold_next( VCHI_MSG_ITER_T *iter,
                                        void **data, // } may be NULL
                                        uint32_t *msg_size, // }
                                        VCHI_HELD_MSG_T *message );


/******************************************************************************
 Global bulk API
 *****************************************************************************/

// Routine to prepare interface for a transfer from the other side
extern int32_t vchi_bulk_queue_receive( VCHI_SERVICE_HANDLE_T handle,
                                        void *data_dst,
                                        uint32_t data_size,
                                        VCHI_FLAGS_T flags,
                                        void *transfer_handle );


// Prepare interface for a transfer from the other side into relocatable memory.
int32_t vchi_bulk_queue_receive_reloc( const VCHI_SERVICE_HANDLE_T handle,
                                       VCHI_MEM_HANDLE_T h_dst,
                                       uint32_t offset,
                                       uint32_t data_size,
                                       const VCHI_FLAGS_T flags,
                                       void * const bulk_handle );

// Prepare interface for a transfer from the other side into relocatable memory.
int32_t vchi_bulk_queue_receive_reloc_func( const VCHI_SERVICE_HANDLE_T handle,
                                       VCHI_MEM_HANDLE_T h_dst,
                                       uint32_t offset,
                                       uint32_t data_size,
                                       const VCHI_FLAGS_T flags,
                                       void * const bulk_handle,
                                       int copy_pagelist(char *vcptr, const struct pagelist_struct *pagelist));

// Routine to queue up data ready for transfer to the other (once they have signalled they are ready)
extern int32_t vchi_bulk_queue_transmit( VCHI_SERVICE_HANDLE_T handle,
                                         const void *data_src,
                                         uint32_t data_size,
                                         VCHI_FLAGS_T flags,
                                         void *transfer_handle );


/******************************************************************************
 Configuration plumbing
 *****************************************************************************/

// function prototypes for the different mid layers (the state info gives the different physical connections)
extern const VCHI_CONNECTION_API_T *single_get_func_table( void );
//extern const VCHI_CONNECTION_API_T *local_server_get_func_table( void );
//extern const VCHI_CONNECTION_API_T *local_client_get_func_table( void );

// declare all message drivers here
const VCHI_MESSAGE_DRIVER_T *vchi_mphi_message_driver_func_table( void );





extern int32_t vchi_bulk_queue_transmit_reloc( VCHI_SERVICE_HANDLE_T handle,
                                               VCHI_MEM_HANDLE_T h_src,
                                               uint32_t offset,
                                               uint32_t data_size,
                                               VCHI_FLAGS_T flags,
                                               void *transfer_handle );


/****************************** End of file **********************************/
# 38 "opt/vc/include/interface/vmcs_host/vc_dispmanx.h" 2




// Same function as above, to aid migration of code.
extern int vc_dispman_init( void );
// Stop the service from being used
extern void vc_dispmanx_stop( void );
// Set the entries in the rect structure
extern int vc_dispmanx_rect_set( VC_RECT_T *rect, uint32_t x_offset, uint32_t y_offset, uint32_t width, uint32_t height );
// Resources
// Create a new resource
extern DISPMANX_RESOURCE_HANDLE_T vc_dispmanx_resource_create( VC_IMAGE_TYPE_T type, uint32_t width, uint32_t height, uint32_t *native_image_handle );
// Write the bitmap data to VideoCore memory
extern int vc_dispmanx_resource_write_data( DISPMANX_RESOURCE_HANDLE_T res, VC_IMAGE_TYPE_T src_type, int src_pitch, void * src_address, const VC_RECT_T * rect );
extern int vc_dispmanx_resource_write_data_handle( DISPMANX_RESOURCE_HANDLE_T res, VC_IMAGE_TYPE_T src_type, int src_pitch, VCHI_MEM_HANDLE_T handle, uint32_t offset, const VC_RECT_T * rect );
extern int vc_dispmanx_resource_read_data(
                              DISPMANX_RESOURCE_HANDLE_T handle,
                              const VC_RECT_T* p_rect,
                              void * dst_address,
                              uint32_t dst_pitch );
// Delete a resource
extern int vc_dispmanx_resource_delete( DISPMANX_RESOURCE_HANDLE_T res );

// Displays
// Opens a display on the given device
extern DISPMANX_DISPLAY_HANDLE_T vc_dispmanx_display_open( uint32_t device );
// Opens a display on the given device in the request mode
extern DISPMANX_DISPLAY_HANDLE_T vc_dispmanx_display_open_mode( uint32_t device, uint32_t mode );
// Open an offscreen display
extern DISPMANX_DISPLAY_HANDLE_T vc_dispmanx_display_open_offscreen( DISPMANX_RESOURCE_HANDLE_T dest, DISPMANX_TRANSFORM_T orientation );
// Change the mode of a display
extern int vc_dispmanx_display_reconfigure( DISPMANX_DISPLAY_HANDLE_T display, uint32_t mode );
// Sets the desstination of the display to be the given resource
extern int vc_dispmanx_display_set_destination( DISPMANX_DISPLAY_HANDLE_T display, DISPMANX_RESOURCE_HANDLE_T dest );
// Set the background colour of the display
extern int vc_dispmanx_display_set_background( DISPMANX_UPDATE_HANDLE_T update, DISPMANX_DISPLAY_HANDLE_T display,
                                                                       uint8_t red, uint8_t green, uint8_t blue );
// get the width, height, frame rate and aspect ratio of the display
extern int vc_dispmanx_display_get_info( DISPMANX_DISPLAY_HANDLE_T display, DISPMANX_MODEINFO_T * pinfo );
// Closes a display
extern int vc_dispmanx_display_close( DISPMANX_DISPLAY_HANDLE_T display );

// Updates
// Start a new update, DISPMANX_NO_HANDLE on error
extern DISPMANX_UPDATE_HANDLE_T vc_dispmanx_update_start( int32_t priority );
// Add an elment to a display as part of an update
extern DISPMANX_ELEMENT_HANDLE_T vc_dispmanx_element_add ( DISPMANX_UPDATE_HANDLE_T update, DISPMANX_DISPLAY_HANDLE_T display,
                                                                     int32_t layer, const VC_RECT_T *dest_rect, DISPMANX_RESOURCE_HANDLE_T src,
                                                                     const VC_RECT_T *src_rect, DISPMANX_PROTECTION_T protection,
                                                                     VC_DISPMANX_ALPHA_T *alpha,
                                                                     DISPMANX_CLAMP_T *clamp, DISPMANX_TRANSFORM_T transform );
// Change the source image of a display element
extern int vc_dispmanx_element_change_source( DISPMANX_UPDATE_HANDLE_T update, DISPMANX_ELEMENT_HANDLE_T element,
                                                        DISPMANX_RESOURCE_HANDLE_T src );
// Change the layer number of a display element
extern int vc_dispmanx_element_change_layer ( DISPMANX_UPDATE_HANDLE_T update, DISPMANX_ELEMENT_HANDLE_T element,
                                                        int32_t layer );
// Signal that a region of the bitmap has been modified
extern int vc_dispmanx_element_modified( DISPMANX_UPDATE_HANDLE_T update, DISPMANX_ELEMENT_HANDLE_T element, const VC_RECT_T * rect );
// Remove a display element from its display
extern int vc_dispmanx_element_remove( DISPMANX_UPDATE_HANDLE_T update, DISPMANX_ELEMENT_HANDLE_T element );
// Ends an update
extern int vc_dispmanx_update_submit( DISPMANX_UPDATE_HANDLE_T update, DISPMANX_CALLBACK_FUNC_T cb_func, void *cb_arg );
// End an update and wait for it to complete
extern int vc_dispmanx_update_submit_sync( DISPMANX_UPDATE_HANDLE_T update );
// Query the image formats supported in the VMCS build
extern int vc_dispmanx_query_image_formats( uint32_t *supported_formats );

//New function added to VCHI to change attributes, set_opacity does not work there.
extern int vc_dispmanx_element_change_attributes( DISPMANX_UPDATE_HANDLE_T update,
                                                            DISPMANX_ELEMENT_HANDLE_T element,
                                                            uint32_t change_flags,
                                                            int32_t layer,
                                                            uint8_t opacity,
                                                            const VC_RECT_T *dest_rect,
                                                            const VC_RECT_T *src_rect,
                                                            DISPMANX_RESOURCE_HANDLE_T mask,
                                                            DISPMANX_TRANSFORM_T transform );

//xxx hack to get the image pointer from a resource handle, will be obsolete real soon
extern uint32_t vc_dispmanx_resource_get_image_handle( DISPMANX_RESOURCE_HANDLE_T res);

//Call this instead of vc_dispman_init
extern void vc_vchi_dispmanx_init (VCHI_INSTANCE_T initialise_instance, VCHI_CONNECTION_T **connections, uint32_t num_connections );

// Take a snapshot of a display in its current state.
// This call may block for a time; when it completes, the snapshot is ready.
// only transform=0 is supported
extern int vc_dispmanx_snapshot( DISPMANX_DISPLAY_HANDLE_T display,
                                           DISPMANX_RESOURCE_HANDLE_T snapshot_resource,
                                           DISPMANX_TRANSFORM_T transform );

// Set the resource palette (for VC_IMAGE_4BPP and VC_IMAGE_8BPP)
extern int vc_dispmanx_resource_set_palette( DISPMANX_RESOURCE_HANDLE_T handle,
                                                      void * src_address, int offset, int size);

// Start triggering callbacks synced to vsync
extern int vc_dispmanx_vsync_callback( DISPMANX_DISPLAY_HANDLE_T display, DISPMANX_CALLBACK_FUNC_T cb_func, void *cb_arg );
# 51 "opt/vc/include/bcm_host.h" 2
# 1 "opt/vc/include/interface/vmcs_host/vc_tvservice.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * TV service host API,
 * See vc_hdmi.h for HDMI related constants
 * See vc_sdtv.h for SDTV related constants
 */


#define _VC_TVSERVICE_H_ 

# 1 "/opt/vc/include/vcinclude/common.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#define __VC_INCLUDE_COMMON_H__ 

# 1 "/opt/vc/include/interface/vcos/vcos_stdint.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
# 32 "/opt/vc/include/vcinclude/common.h" 2
# 1 "/opt/vc/include/interface/vctypes/vc_image_types.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Common image types used by the vc_image library
# 33 "/opt/vc/include/vcinclude/common.h" 2
# 67 "/opt/vc/include/vcinclude/common.h"
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include-fixed/limits.h" 1 3 4

# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include-fixed/limits.h" 3 4
/* Copyright (C) 1992-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */
# 68 "/opt/vc/include/vcinclude/common.h" 2





# 72 "/opt/vc/include/vcinclude/common.h"
/*}}}*/

/* Fixed-point types */
typedef unsigned short uint8p8_t;
typedef signed short sint8p8_t;
typedef unsigned short uint4p12_t;
typedef signed short sint4p12_t;
typedef signed short sint0p16_t;
typedef signed char sint8p0_t;
typedef unsigned char uint0p8_t;
typedef signed long int24p8_t;

/*{{{ Common typedefs */

typedef enum bool_e
{
   VC_FALSE = 0,
   VC_TRUE = 1,
} VC_BOOL_T;


#define bool_t VC_BOOL_T


/*}}}*/

/*{{{ Common macros */


/* Align a pointer/integer by rounding up/down */
#define ALIGN_DOWN(p,n) ((uintptr_t)(p) - ( (uintptr_t)(p) % (uintptr_t)(n) ))
#define ALIGN_UP(p,n) ALIGN_DOWN((uintptr_t)(p) + (uintptr_t)(n) - 1, (n))

#define CLIP(lower,n,upper) _min((upper), _max((lower), (n)))

/*}}}*/

/*{{{ Debugging and profiling macros */
# 132 "/opt/vc/include/vcinclude/common.h"
#define profile_rename(name) (void)0


/*}}}*/
# 38 "opt/vc/include/interface/vmcs_host/vc_tvservice.h" 2
# 1 "/opt/vc/include/interface/vcos/vcos.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */
# 39 "opt/vc/include/interface/vmcs_host/vc_tvservice.h" 2
# 1 "/opt/vc/include/interface/vchi/vchi.h" 1
/*
Copyright (c) 2012-2014, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Contains the protypes for the vchi functions.
# 382 "/opt/vc/include/interface/vchi/vchi.h"
/****************************** End of file **********************************/
# 40 "opt/vc/include/interface/vmcs_host/vc_tvservice.h" 2
# 1 "/opt/vc/include/interface/vmcs_host/vc_tvservice_defs.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * TV service command enumeration and parameter types.
 */


#define _VC_TVSERVICE_DEFS_H_ 
# 1 "/opt/vc/include/vcinclude/common.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
# 35 "/opt/vc/include/interface/vmcs_host/vc_tvservice_defs.h" 2
# 1 "/opt/vc/include/interface/vchi/message_drivers/message.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// MPHI videocore message driver
# 197 "/opt/vc/include/interface/vchi/message_drivers/message.h"
/****************************** End of file ***********************************/
# 36 "/opt/vc/include/interface/vmcs_host/vc_tvservice_defs.h" 2
# 1 "/opt/vc/include/interface/vmcs_host/vc_hdmi.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * HDMI common host header for TV service, defines resolution code which host applications should
 * use for power up command for HDMI
 */


#define _VC_HDMI_H_ 

# 1 "/opt/vc/include/interface/vmcs_host/vc_hdmi_property.h" 1
/*
Copyright (c) 2012 Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
      ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
      WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
      DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
      SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * This file contains all the properties one can set in HDMI
 * Each property has up to two parameters corresponding to list of enums one can set via
 * the set/get property function from TV service (HOST) or HDMI middleware API (Videocore)
 * Each property also has a default value for these parameters. Please refer to 
 * individual properties for details.
 */


#define _VC_HDMI_PROPERTY_H_ 
# 1 "/opt/vc/include/vcinclude/common.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
# 39 "/opt/vc/include/interface/vmcs_host/vc_hdmi_property.h" 2

/**
 * Property type
 */
typedef enum {
   HDMI_PROPERTY_PIXEL_ENCODING = 0, /**< Set pixel encoding, value of property is HDMI_PIXEL_ENCODING_T, default is RGB full range (unless it is not supported) */
   HDMI_PROPERTY_PIXEL_CLOCK_TYPE = 1, /**< See HDMI_PIXEL_CLOCK_TYPE_T, default is HDMI_PIXEL_CLOCK_TYPE_PAL */
   HDMI_PROPERTY_CONTENT_TYPE = 2, /**< Set content type flag EDID_ContentType_T */
   HDMI_PROPERTY_FUZZY_MATCH = 3, /**< disable (0 - default) or enable (1) fuzzy format match */
   HDMI_PROPERTY_3D_STRUCTURE = 4, /**< Set the 3D structure of the next HDMI power on (only for CEA mode) */

   //More properties to be added here
   HDMI_PROPERTY_MAX /**< place holder */
} HDMI_PROPERTY_T;

/**
 * Setting/getting a property
 */
typedef struct {
   HDMI_PROPERTY_T property;
   uint32_t param1;
   uint32_t param2;
   //More fields may be added here if required in future
} HDMI_PROPERTY_PARAM_T;

/**
 * PIXEL_ENCODING: param1: encoding type, param2: n/a
 * Setting encoding type is subjected to support in EDID
 */
typedef enum {
   HDMI_PIXEL_ENCODING_DEFAULT = 0, /**<Default, note that CEA modes (except VGA) default to RGB limited but DMT modes default to RGB full */
   HDMI_PIXEL_ENCODING_RGB_LIMITED,
   HDMI_PIXEL_ENCODING_RGB_FULL,
   HDMI_PIXEL_ENCODING_YCbCr444_LIMITED,
   HDMI_PIXEL_ENCODING_YCbCr444_FULL,
   /** YCbCr 422 are not used at the moment */
   HDMI_PIXEL_ENCODING_YCbCr422_LIMITED,
   HDMI_PIXEL_ENCODING_YCbCr422_FULL,
   HDMI_PIXEL_ENCODING_MAX /**<place holder */
} HDMI_PIXEL_ENCODING_T;

/**
 * PIXEL_CLOCK_TYPE: param1: pixel clock type, param2: n/a
 * Pixel clock nudge factor (set pixel clock type)
 */
typedef enum {
   HDMI_PIXEL_CLOCK_TYPE_PAL = 0, /**< Use norminal pixel clock (default) */
   HDMI_PIXEL_CLOCK_TYPE_NTSC = 1, /**< Multiply norminal pixel clock by 1000/1001 to get the alternative frame rate e.g. 59.94Hz rather than 60, not applicable to all formats */
   HDMI_PIXEL_CLOCK_TYPE_MAX /**< place holder */
} HDMI_PIXEL_CLOCK_TYPE_T;

/**
 * Content type: param1: EDID content type, param2: n/a
 */
/**
 * Content type: the enum is the actual value in AVI infoframe + 1
 * because NODATA and Graphics both have value zero
 */
typedef enum {
   EDID_ContentType_NODATA = 0x0, /**<Content type none */
   EDID_ContentType_Graphics = 0x1, /**<Graphics, ITC must be set to 1 */
   EDID_ContentType_Photo = 0x2, /**<Photo */
   EDID_ContentType_Cinema = 0x3, /**<Cinema */
   EDID_ContentType_Game = 0x4, /**<Game */
   EDID_ContentType_MAX /**<place holder */
} EDID_ContentType_T;

/**
 * Fuzzy match: param1 zero (disabled) or non-zero (enabled), param2: n/a
 * If enabled, match format in EDID based on resolutions and formats only
 * Default is zero (disabled, so match on blanking periods and pixel clock)
 * Set to non-zero to enable fuzzy match
 */
typedef enum {
   EDID_FUZZY_MATCH_DISABLED = 0x0,
   EDID_FUZZY_MATCH_ENABLED = 0x1,
   EDID_FUZZY_MATCH_MAX
} EDID_FuzzyMatch_T;

/**
 * 3D structure: param1 - 3D structure (e.g. top/bottom side by side) (default value is none, i.e. 2D)
 *               param2 - n/a at the moment, may be used in the future
 *
 * 3D structure is auto reset to "2D" every time HDMI is power on. Only affect CEA formats.
 */
/*
 * Matched to the 3d struct bit fields stored internally to represent 3D support in EDID
 */
typedef enum {
   HDMI_3D_FORMAT_NONE = 0, /**<plain and simple 2D! */
   HDMI_3D_FORMAT_SBS_HALF = (1<<7), /**<side by side half horizontal */
   HDMI_3D_FORMAT_TB_HALF = (1<<6), /**<top and bottom half vertical */
   HDMI_3D_FORMAT_FRAME_PACKING = (1<<8), /**<frame packed */
   HDMI_3D_FORMAT_FRAME_SEQUENTIAL = (1<<9), /**<Output left on even frames and right on odd frames (typically 120Hz)*/
   /* More 3D structs, e.g. full frame packing, may be added here */
   HDMI_3D_FORMAT_INVALID = 0xFFFF
} HDMI_3D_FORMAT_T;
# 37 "/opt/vc/include/interface/vmcs_host/vc_hdmi.h" 2

typedef int VC_HDMI_BOOL_T;

/**
 * HDMI resolution groups. There are two main groups: 
 * CEA - the conventional HDMI ones like 720p
 * DMT - computer monitor resolutions like XGA
 */
typedef enum {
   HDMI_RES_GROUP_INVALID = 0, /**< Initialised value */
   HDMI_RES_GROUP_CEA = 1, /**< CEA - HDMI device */
   HDMI_RES_GROUP_DMT = 2, /**< DMT - computer monitors */
   HDMI_RES_GROUP_CEA_3D = 3, /* deprecated */
   HDMI_RES_GROUP_CUSTOM = 4, /**< Custom timings from the client */

} HDMI_RES_GROUP_T;

#define HDMI_RES_GROUP_NAME(g) (((g) == HDMI_RES_GROUP_INVALID) ? "Invalid" : (((g) == HDMI_RES_GROUP_CEA) ? "CEA" : (((g) == HDMI_RES_GROUP_DMT) ? "DMT" : (((g) == HDMI_RES_GROUP_CUSTOM) ? "Custom" : "Unknown"))))






/**
 *  CEA 861 defined video code and aspect ratios for various HDMI modes
 *  Not all values are valid for AVI infoframe
 */
typedef enum {
   HDMI_ASPECT_UNKNOWN = 0, /**< Unknown aspect ratio, or not one of the values below */
   HDMI_ASPECT_4_3 = 1, /**< 4:3  */
   HDMI_ASPECT_14_9 = 2, /**< 14:9 */
   HDMI_ASPECT_16_9 = 3, /**< 16:9 */
   HDMI_ASPECT_5_4 = 4, /**< 5:4  */
   HDMI_ASPECT_16_10 = 5, /**< 16:10*/
   HDMI_ASPECT_15_9 = 6, /**< 15:9 */
   HDMI_ASPECT_64_27 = 7, /**< 64:27 */
   HDMI_ASPECT_21_9 = HDMI_ASPECT_64_27, /**< 21:9 is jargon, 64:27 is the actual aspect ratio */
   HDMI_ASPECT_256_135 = 8, /**< 256:135 */
   /* More aspect ratio values may be added here if defined by CEA in future */
} HDMI_ASPECT_T;

/**
 * Display options set the bounding box (only used in CEA mode)
 */
typedef struct {
   uint16_t aspect; /**<HDMI_ASPECT_T */
   /** Active area information - meanings as in CEA-861. */
   uint16_t vertical_bar_present; /**<VC_HDMI_BOOL_T */
   uint16_t left_bar_width;
   uint16_t right_bar_width;
   uint16_t horizontal_bar_present; /**<VC_HDMI_BOOL_T */
   uint16_t top_bar_height;
   uint16_t bottom_bar_height;
   /** S0/S1 flags as defined in CEA-861. */
   uint8_t overscan_flags;
} HDMI_DISPLAY_OPTIONS_T;

/**
 * HDMI internal state (with some of the properties related to current display signal)
 * Also see SDTV_DISPLAY_STATE_T in vc_sdtv.h, members up to scan_mode will be in the
 * same position as the equivalent state in SDTV_DISPLAY_STATE_T;
 */
typedef struct {
   uint32_t state;
   uint32_t width;
   uint32_t height;
   uint16_t frame_rate;
   uint16_t scan_mode;
   uint32_t group; /**<HDMI_RES_GROUP_T */
   uint32_t mode; /* This is the mode number of the format */
   uint16_t pixel_rep; /* Pixel repetition factor, only relevant for CEA formats */
   uint16_t aspect_ratio; /* This is the format's native aspect ratio */
   HDMI_DISPLAY_OPTIONS_T display_options; /* This has the aspect ratio sent in AVI infoframe */
   uint16_t pixel_encoding;
   uint16_t format_3d; /* 3D format, only relevant for CEA formats */
} HDMI_DISPLAY_STATE_T;

/**
 * Copy protection for HDMI, only HDCP is available
 * This enum is to make it consistent with the enums
 * SDTV_CP_MODE_T in vc_sdtv.h
 */
typedef enum {
   HDMI_CP_NONE = 0, /**< No copyprotection */
   HDMI_CP_HDCP = 1 /**< HDCP 1.x */
} HDMI_CP_MODE_T;

/**
 *  HDMI operation modes
 */
typedef enum {
   HDMI_MODE_OFF, /**< Off! */
   HDMI_MODE_DVI, /**< DVI */
   HDMI_MODE_HDMI, /**< HDMI */
   HDMI_MODE_3D /**< HDMI 1.4a 3D */
} HDMI_MODE_T;

/**
 * Possible values for the Source Product Description type code (in SPD infoframe).
 * Taken from the CEA-861 spec.
 */
typedef enum {
   HDMI_SPD_TYPE_UNKNOWN,
   HDMI_SPD_TYPE_STB, /**<Digital STB */
   HDMI_SPD_TYPE_DVD, /**<DVD player */
   HDMI_SPD_TYPE_DVHS, /**<D-VHS */
   HDMI_SPD_TYPE_HDD_RECORDER, /**<HDD video recoder */
   HDMI_SPD_TYPE_DVC, /**<DVC */
   HDMI_SPD_TYPE_DSC, /**<DSC */
   HDMI_SPD_TYPE_VCD, /**<Video CD */
   HDMI_SPD_TYPE_GAME, /**<Game */
   HDMI_SPD_TYPE_PC, /**<PC general */
   HDMI_SPD_TYPE_BD, /**<Blu-Ray Disc */
   HDMI_SPD_TYPE_SACD, /**<Super Audio CD */
   HDMI_SPD_TYPE_HDDVD, /**<HD DVD */
   HDMI_SPD_TYPE_PMP /**<Personal media player */
} HDMI_SPD_TYPE_CODE_T;

/**
 * Structure for SPD infoframe
 */
typedef struct {
   char *manufacturer; /**< Manufacture name (up to 8 characters) */
   char *description; /**< Product name (up to 16 characters) */
   HDMI_SPD_TYPE_CODE_T type; /**< Product type */
} HDMI_SPD_DATA_T;

/**
 * These are CEA mode numbers (sent in AVI infoframe) for different resolutions as define in CEA-861
 * 1080i at 100/120Hz (40,46) are supported by HDMI H/W but note we cannot
 * display the debug overlay under these modes.
 * Some modes have two codes, the first one has aspect ratio 4:3 and
 * the second one (with "H" suffix") 16:9.
 * The modes with "4x", etc. are the same the corresponding "non-multiplied" modes
 * but clocked at a higher pixel clock.
 */
typedef enum {
   HDMI_CEA_VGA = 1,
   HDMI_CEA_480p60 = 2,
   HDMI_CEA_480p60H = 3,
   HDMI_CEA_720p60 = 4,
   HDMI_CEA_1080i60 = 5,
   HDMI_CEA_480i60 = 6,
   HDMI_CEA_480i60H = 7,
   HDMI_CEA_240p60 = 8,
   HDMI_CEA_240p60H = 9,
   HDMI_CEA_480i60_4x = 10,
   HDMI_CEA_480i60_4xH = 11,
   HDMI_CEA_240p60_4x = 12,
   HDMI_CEA_240p60_4xH = 13,
   HDMI_CEA_480p60_2x = 14,
   HDMI_CEA_480p60_2xH = 15,
   HDMI_CEA_1080p60 = 16,
   HDMI_CEA_576p50 = 17,
   HDMI_CEA_576p50H = 18,
   HDMI_CEA_720p50 = 19,
   HDMI_CEA_1080i50 = 20,
   HDMI_CEA_576i50 = 21,
   HDMI_CEA_576i50H = 22,
   HDMI_CEA_288p50 = 23,
   HDMI_CEA_288p50H = 24,
   HDMI_CEA_576i50_4x = 25,
   HDMI_CEA_576i50_4xH = 26,
   HDMI_CEA_288p50_4x = 27,
   HDMI_CEA_288p50_4xH = 28,
   HDMI_CEA_576p50_2x = 29,
   HDMI_CEA_576p50_2xH = 30,
   HDMI_CEA_1080p50 = 31,
   HDMI_CEA_1080p24 = 32,
   HDMI_CEA_1080p25 = 33,
   HDMI_CEA_1080p30 = 34,
   HDMI_CEA_480p60_4x = 35,
   HDMI_CEA_480p60_4xH = 36,
   HDMI_CEA_576p50_4x = 37,
   HDMI_CEA_576p50_4xH = 38,
   HDMI_CEA_1080i50_rb = 39,
   HDMI_CEA_1080i100 = 40,
   HDMI_CEA_720p100 = 41,
   HDMI_CEA_576p100 = 42,
   HDMI_CEA_576p100H = 43,
   HDMI_CEA_576i100 = 44,
   HDMI_CEA_576i100H = 45,
   HDMI_CEA_1080i120 = 46,
   HDMI_CEA_720p120 = 47,
   HDMI_CEA_480p120 = 48,
   HDMI_CEA_480p120H = 49,
   HDMI_CEA_480i120 = 50,
   HDMI_CEA_480i120H = 51,
   HDMI_CEA_576p200 = 52,
   HDMI_CEA_576p200H = 53,
   HDMI_CEA_576i200 = 54,
   HDMI_CEA_576i200H = 55,
   HDMI_CEA_480p240 = 56,
   HDMI_CEA_480p240H = 57,
   HDMI_CEA_480i240 = 58,
   HDMI_CEA_480i240H = 59,
   HDMI_CEA_720p24 = 60,
   HDMI_CEA_720p25 = 61,
   HDMI_CEA_720p30 = 62,
   HDMI_CEA_1080p120 = 63,
   HDMI_CEA_1080p100 = 64,

   /* Up-to-date as of CEA 861-E */

   HDMI_CEA_OFF = 0xff /**<Special code to shutdown HDMI */

} HDMI_CEA_RES_CODE_T;

/**
 * These are the DMT modes from VESA. They are used for powering up
 * HDMI in DMT resolutions and are not sent in AVI infoframes.
 * Enum is ordered as ascending order of DMT id.
 * All reduced blanking formats are 60Hz unless stated otherwise.
 */
typedef enum {
   HDMI_DMT_640x350_85 = 0x1, /**<640x350 */
   HDMI_DMT_640x400_85 = 0x2, /**<640x400 */
   HDMI_DMT_IBM_VGA_85 = 0x3, /**<720x400 */
   HDMI_DMT_VGA_60 = 0x4, /**<640x480 (60Hz is same as VGA above) */
   HDMI_DMT_VGA_72 = 0x5,
   HDMI_DMT_VGA_75 = 0x6,
   HDMI_DMT_VGA_85 = 0x7,
   HDMI_DMT_SVGA_56 = 0x8, /**<800x600 */
   HDMI_DMT_SVGA_60 = 0x9,
   HDMI_DMT_SVGA_72 = 0xA,
   HDMI_DMT_SVGA_75 = 0xB,
   HDMI_DMT_SVGA_85 = 0xC,
   HDMI_DMT_SVGA_120 = 0xD,
   HDMI_DMT_848x480_60 = 0xE, /**<848x480 */
   HDMI_DMT_XGA_43 = 0xF, /**<1024x768 - interlaced, DO NOT USE */
   HDMI_DMT_XGA_60 = 0x10, /**<1024x768 */
   HDMI_DMT_XGA_70 = 0x11,
   HDMI_DMT_XGA_75 = 0x12,
   HDMI_DMT_XGA_85 = 0x13,
   HDMI_DMT_XGA_120 = 0x14,
   HDMI_DMT_XGAP_75 = 0x15, /**<1152x864 */
   HDMI_DMT_WXGA_RB = 0x16, /**<1280x768 reduced blanking */
   HDMI_DMT_WXGA_60 = 0x17,
   HDMI_DMT_WXGA_75 = 0x18,
   HDMI_DMT_WXGA_85 = 0x19,
   HDMI_DMT_WXGA_120 = 0x1A, /**<120Hz with reduced blanking */
   HDMI_DMT_1280x800_RB = 0x1B, /**<1280x800 reduced blanking */
   HDMI_DMT_1280x800_60 = 0x1C,
   HDMI_DMT_1280x800_75 = 0x1D,
   HDMI_DMT_1280x800_85 = 0x1E,
   HDMI_DMT_1280x800_120 = 0x1F, /** reduced blanking */
   HDMI_DMT_1280x960_60 = 0x20, /**<1280x960 */
   HDMI_DMT_1280x960_85 = 0x21,
   HDMI_DMT_1280x960_120 = 0x22, /** reduced blanking */
   HDMI_DMT_SXGA_60 = 0x23, /**<1280x1024 */
   HDMI_DMT_SXGA_75 = 0x24,
   HDMI_DMT_SXGA_85 = 0x25,
   HDMI_DMT_SXGA_120 = 0x26, /** reduced blanking */
   HDMI_DMT_1360x768_60 = 0x27, /**<1360x768 */
   HDMI_DMT_1360x768_120 = 0x28, /**<120 Hz with reduced blanking */
   HDMI_DMT_SXGAP_RB = 0x29, /**<1400x1050 reduced blanking */
   HDMI_DMT_SXGAP_60 = 0x2A,
   HDMI_DMT_SXGAP_75 = 0x2B,
   HDMI_DMT_SXGAP_85 = 0x2C,
   HDMI_DMT_SXGAP_120 = 0x2D, /** reduced blanking */
   HDMI_DMT_1440x900_RB = 0x2E, /**<1440x900 reduced blanking */
   HDMI_DMT_1440x900_60 = 0x2F,
   HDMI_DMT_1440x900_75 = 0x30,
   HDMI_DMT_1440x900_85 = 0x31,
   HDMI_DMT_1440x900_120 = 0x32, /** reduced blanking */
   HDMI_DMT_UXGA_60 = 0x33, /**<1600x1200 60Hz */
   HDMI_DMT_UXGA_65 = 0x34,
   HDMI_DMT_UXGA_70 = 0x35,
   HDMI_DMT_UXGA_75 = 0x36,
   HDMI_DMT_UXGA_85 = 0x37,
   HDMI_DMT_UXGA_120 = 0x38, /** reduced blanking */
   HDMI_DMT_SWXGAP_RB = 0x39, /**<1680x1050 reduced blanking */
   HDMI_DMT_SWXGAP_60 = 0x3A, /**<1680x1050 60Hz */
   HDMI_DMT_SWXGAP_75 = 0x3B,
   HDMI_DMT_SWXGAP_85 = 0x3C,
   HDMI_DMT_SWXGAP_120 = 0x3D, /** reduced blanking */
   HDMI_DMT_1792x1344_60 = 0x3E, /**<1792x1344 60Hz */
   HDMI_DMT_1792x1344_75 = 0x3F, /**<1792x1344 75Hz */
   HDMI_DMT_1792x1344_120 = 0x40, /** reduced blanking */
   HDMI_DMT_1856x1392_60 = 0x41, /**<1856x1392 60Hz */
   HDMI_DMT_1856x1392_75 = 0x42, /**<1856x1392 75Hz */
   HDMI_DMT_1856x1392_120 = 0x43, /** reduced blanking */
   HDMI_DMT_WUXGA_RB = 0x44, /**<1920x1200 reduced blanking */
   HDMI_DMT_WUXGA_60 = 0x45, /**<1920x1200 60Hz */
   HDMI_DMT_WUXGA_75 = 0x46, /**<1920x1200 75Hz */
   HDMI_DMT_WUXGA_85 = 0x47, /**<1920x1200 85Hz */
   HDMI_DMT_WUXGA_120 = 0x48, /** reduced blanking */
   HDMI_DMT_1920x1440_60 = 0x49, /**<1920x1440 60Hz */
   HDMI_DMT_1920x1440_75 = 0x4A, /**<1920x1440 75Hz */
   HDMI_DMT_1920x1440_120 = 0x4B, /** reduced blanking */
   HDMI_DMT_2560x1600_RB = 0x4C, /**<2560x1600 reduced blanking */
   HDMI_DMT_2560x1600_60 = 0x4D, /**<2560x1600 60 Hz */
   HDMI_DMT_2560x1600_75 = 0x4E, /**<2560x1600 75 Hz */
   HDMI_DMT_2560x1600_85 = 0x4E, /**<2560x1600 85 Hz */
   HDMI_DMT_2560x1600_120 = 0x50, /** reduced blanking */
   HDMI_DMT_1366x768_60 = 0x51, /**<1366x768 60Hz */
   HDMI_DMT_1080p_60 = 0x52, /**<Same as 1080p60 above */
   HDMI_DMT_1600x900_RB = 0x53, /**<1600x900 reduced blanking */
   HDMI_DMT_2048x1152_RB = 0x54, /**<2048x1152 reduced blanking */
   HDMI_DMT_720p_60 = 0x55, /**<Same as 720p60 above */
   HDMI_DMT_1366x768_RB = 0x56, /**<1366x768 reduced blanking */
   /* Up-to-date as of VESA DMT v1 r12 */

   HDMI_DMT_OFF = 0xff
} HDMI_DMT_RES_CODE_T;

/**
 * HDMI scanmode
 */
typedef enum {
   HDMI_NONINTERLACED,
   HDMI_INTERLACED
} HDMI_INTERLACED_T;

/**
 * Preference for powering up HDMI using best mode
 * Note we will only use CEA modes for matching
 */
typedef enum {
   HDMI_MODE_MATCH_NONE = 0x0, /**<No mode*/
   HDMI_MODE_MATCH_FRAMERATE = 0x1, /**<Match based on frame rate */
   HDMI_MODE_MATCH_RESOLUTION = 0x2, /**<Match based on resolution */
   HDMI_MODE_MATCH_SCANMODE = 0x4 /**<Match based on scan mode */
} EDID_MODE_MATCH_FLAG_T;

/**
 * Audio support flags
 */
typedef enum {
   EDID_AUDIO_NO_SUPPORT = (1 << 0), /**<No support for that format */
   EDID_AUDIO_CHAN_UNSUPPORTED = (1 << 1), /**<max. no. of channels exceeded */
   EDID_AUDIO_FS_UNSUPPORTED = (1 << 2), /**<no support for that sampling frequency */
   EDID_AUDIO_BR_UNSUPPORTED = (1 << 3), /**<max. bitrate exceeded */
   EDID_AUDIO_SAMP_UNSUPPORTED = (1 << 4), /**sample size unsupported (pcm only) */
} EDID_AUDIO_SUPPORT_FLAG_T;

/**
 * Enums for audio support in audio descriptor block (CEA only)
 * audio formats as specified in CEA Short Audio Descriptors
 */
typedef enum {
   EDID_AudioFormat_eReserved, /**<Refer to header when set in audio info frame */
   EDID_AudioFormat_ePCM, /**<Plain old PCM, mandatory for any audio support */
   EDID_AudioFormat_eAC3, /**<AC3 */
   EDID_AudioFormat_eMPEG1, /**<Mpeg layer 1 and 2 */
   EDID_AudioFormat_eMP3, /**<Mpeg layer 3 */
   EDID_AudioFormat_eMPEG2, /**<Mpeg 2 audio */
   EDID_AudioFormat_eAAC, /**<AAC */
   EDID_AudioFormat_eDTS, /**<DTS */
   EDID_AudioFormat_eATRAC, /**<Sony proprietary */
   EDID_AudioFormat_eDSD, /**<Super Audio CD 1-bit audio */
   EDID_AudioFormat_eEAC3, /**<Dolby Digital + */
   EDID_AudioFormat_eDTS_HD, /**<DTS-HD */
   EDID_AudioFormat_eMLP, /**<Meridian Lossless Packing - for DVD audio */
   EDID_AudioFormat_eDST, /**<Direct stream transfer - compressed super audio CD */
   EDID_AudioFormat_eWMAPRO, /**<WMA Pro */
   EDID_AudioFormat_eExtended, /**<Refer to byte 3 of audio db for coding extension type */

   EDID_AudioFormat_eMaxCount
} EDID_AudioFormat;

/**
 * If audio format is set to EDID_AudioFormat_eExtended,
 * this gives the extended audio type (see CEA-861E section 6.6.1)
 */
typedef enum {
   EDID_AudioCodingExtension_NONE = 0x0, /** no extension, for audio format != Extended */
   EDID_AudioCodingExtension_HEAAC = 0x1, /**<HE-AAC */
   EDID_AudioCodingExtension_HEAAC2 = 0x2, /**<HE-AAC v2 */
   EDID_AudioCodingExtension_MPEGSUR = 0x3, /**<MPEG Surround */

   EDID_AudioCodingExtension_max
} EDID_AudioCodingExtension;

/**
 * Audio sample rates as specified in CEA Short Audio Descriptors
 */
typedef enum {
   EDID_AudioSampleRate_eReferToHeader = 0x0, /**<Only used in audio infoframe */
   EDID_AudioSampleRate_e32KHz = (1 << 0), /**<32 kHz (mandatory) */
   EDID_AudioSampleRate_e44KHz = (1 << 1), /**<44.1 kHz (mandatory) */
   EDID_AudioSampleRate_e48KHz = (1 << 2), /**<48kHz (mandatory) */
   EDID_AudioSampleRate_e88KHz = (1 << 3), /**<88.2 kHz */
   EDID_AudioSampleRate_e96KHz = (1 << 4), /**<96kHz */
   EDID_AudioSampleRate_e176KHz = (1 << 5), /**<176.4 kHz */
   EDID_AudioSampleRate_e192KHz = (1 << 6) /**<192 kHz */
} EDID_AudioSampleRate;

/**
 * Audio sample sizes (L-PCM) as specified in CEA Short Audio Descriptors
 */
typedef enum {
   EDID_AudioSampleSize_refertoheader = 0x0, /**<Only used in audio infoframe */
   EDID_AudioSampleSize_16bit = 0x1, /**<16-bit samples (mandatory) */
   EDID_AudioSampleSize_20bit = 0x2, /**<20-bit samples */
   EDID_AudioSampleSize_24bit = 0x4 /**<24-bit samples */
} EDID_AudioSampleSize;

/**
 *  LFE feedback level as described in audio db
 */
typedef enum {
   EDID_AudioLFEFB_UNKNOWN = 0x0, /**<Refer to other information */
   EDID_AudioLFEFB_0dB = 0x1, /**<0dB - same level as other channels */
   EDID_AudioLFEFB_10dB = 0x2 /**<+10dB relative to other channels */
} EDID_AudioLFEFB;

/**
 * All possible 3D structures
 * to be used in decoded 3D modes (e.g. HDMI_3D_SUPPORTED_MODE)
 */
typedef enum {
   HDMI_3D_STRUCT_NONE = 0,
   HDMI_3D_STRUCT_FRAME_PACKING = (1<<0),
   HDMI_3D_STRUCT_FIELD_ALTERNATIVE = (1<<1),
   HDMI_3D_STRUCT_LINE_ALTERNATIVE = (1<<2),
   HDMI_3D_STRUCT_SIDE_BY_SIDE_FULL = (1<<3),
   HDMI_3D_STRUCT_L_DEPTH = (1<<4),
   HDMI_3D_STRUCT_L_DEPTH_GRAPHICS_GRAPHICS_DEPTH = (1<<5),
   HDMI_3D_STRUCT_TOP_AND_BOTTOM = (1<<6),
   HDMI_3D_STRUCT_SIDE_BY_SIDE_HALF_HORIZONTAL = (1<<7),
   HDMI_3D_STRUCT_SIDE_BY_SIDE_HALF_ODD_LEFT_ODD_RIGHT = (1<<8),
   HDMI_3D_STRUCT_SIDE_BY_SIDE_HALF_ODD_LEFT_EVEN_RIGHT = (1<<9),
   HDMI_3D_STRUCT_SIDE_BY_SIDE_HALF_EVEN_LEFT_ODD_RIGHT = (1<<10),
   HDMI_3D_STRUCT_SIDE_BY_SIDE_HALF_EVEN_LEFT_EVEN_RIGHT = (1<<11),
   HDMI_3D_STRUCT_FRAME_SEQUENTIAL = (1<<12),
} HDMI_3D_STRUCT_T;

/**
 * HDMI notifications (defined as a bit mask to be conveniently returned as a state),
 * make sure this does not clash with the values in vc_sdtv.h
 * SDTV notifications start at bit 16.
 * These values are returned by the TV service in a callback.
 */
typedef enum {
   VC_HDMI_UNPLUGGED = (1 << 0), /**<HDMI cable is detached */
   VC_HDMI_ATTACHED = (1 << 1), /**<HDMI cable is attached but not powered on */
   VC_HDMI_DVI = (1 << 2), /**<HDMI is on but in DVI mode (no audio) */
   VC_HDMI_HDMI = (1 << 3), /**<HDMI is on and HDMI mode is active */
   VC_HDMI_HDCP_UNAUTH = (1 << 4), /**<HDCP authentication is broken (e.g. Ri mismatched) or not active */
   VC_HDMI_HDCP_AUTH = (1 << 5), /**<HDCP is active */
   VC_HDMI_HDCP_KEY_DOWNLOAD = (1 << 6), /**<HDCP key download successful/fail */
   VC_HDMI_HDCP_SRM_DOWNLOAD = (1 << 7), /**<HDCP revocation list download successful/fail */
   VC_HDMI_CHANGING_MODE = (1 << 8), /**<HDMI is starting to change mode, clock has not yet been set */

} VC_HDMI_NOTIFY_T;
#define VC_HDMI_STANDBY (VC_HDMI_ATTACHED)

/**
 * Callback reason and arguments from HDMI middleware
 * Each callback comes with two optional uint32_t parameters.
 * Reason                     param1       param2      remark
 * VC_HDMI_UNPLUGGED            -            -         cable is unplugged
 * VC_HDMI_STANDBY            CEA/DMT      mode code   cable is plugged in and peripheral powered off (preferred mode sent back if available)
 * VC_HDMI_DVI                CEA/DMT      mode code   DVI mode is active at said resolution
 * VC_HDMI_HDMI               CEA(3D)/DMT  mode code   HDMI mode is active at said resolution (in 3D mode if CEA3D)
 * VC_HDMI_HDCP_UNAUTH        HDCP_ERROR_T  retry?     HDCP is inactive, the error can be none if we actively disable HDCP, if retry is non-zero, HDCP will attempt to reauthenticate
 * VC_HDMI_HDCP_AUTH            -            -         HDCP is active
 * VC_HDMI_HDCP_KEY_DOWNLOAD  success?       -         HDCP key download success (zero) or not (non zero)
 * VC_HDMI_HDCP_SRM_DOWNLOAD  no. of keys    -         HDCP revocation list download set no. of keys (zero means failure)
 * VC_HDMI_CHANGING_MODE        0            0         No information is supplied in this callback
 */

/* Some constants which are required on host side */
#define HDCP_KEY_BLOCK_SIZE 328
#define HDCP_KSV_LENGTH 5
#define HDCP_MAX_DEVICE 127
#define HDCP_MAX_DEPTH 7
#define EDID_BLOCKSIZE 128
#define HDMI_NUM_PACKET_BYTES 28
#define HDMI_MAX_EXPLICIT_3D_MODES 31
#define EDID_MONITOR_DESC_SIZE 18
#define EDID_DESC_HEADER_LEN 5
#define EDID_DESC_ASCII_STRING_LEN (EDID_MONITOR_DESC_SIZE - EDID_DESC_HEADER_LEN)
#define EDID_DEVICE_VENDOR_ID_LENGTH 3

/* All CEC related constants now reside in vc_cec.h */

/**
 * General callback function for both HDMI and HDCP middleware
 * reason is the notification nature
 * param1 and param2 have different meanings depending on the notification (see above)
 *
 * @param client_p is the callback context
 *
 * @param reason is the callback reason
 *
 * @param param1 is the first callback argument (meaning as above)
 *
 * @param param2 is the second callback argument (meaning as above)
 *
 * @return void
 */
typedef void (*HDMI_CALLBACK_T)(void *client_p, VC_HDMI_NOTIFY_T reason, uint32_t param1, uint32_t param2);

/* TV service error return code */
typedef enum {
   VC_HDMI_SUCCESS = 0, /** OK */
   VC_HDMI_ERROR_FORMAT_UNSUPPORTED = 1, /** format not supported */
   VC_HDMI_ERROR_INVALID_FORMAT = 2, /** invalid format */
   VC_HDMI_ERROR_INVALID_PROPERTY = 3, /** invalid property */
   VC_HDMI_ERROR_OUT_OF_RANGE = 4, /** invalid values passed to set property */
   VC_HDMI_ERROR_INVALID_INFOFRAME = 5, /** invalid infoframe */
} VC_HDMI_ERROR_T;

/* Defines for backward code compatibility (these were originally in hdmi.h) */
typedef VC_HDMI_ERROR_T HDMI_RESULT_T;
#define HDMI_RESULT_SUCCESS (VC_HDMI_SUCCESS)
#define HDMI_RESULT_FAILED (VC_HDMI_ERROR_FORMAT_UNSUPPORTED)
# 37 "/opt/vc/include/interface/vmcs_host/vc_tvservice_defs.h" 2
# 1 "/opt/vc/include/interface/vmcs_host/vc_sdtv.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * SDTV common host header for TV service
 */


#define _VC_SDTV_H_ 

/** Different SDTV modes */
/** colour */
typedef enum SDTV_COLOUR_
{
   SDTV_COLOUR_UNKNOWN = 0x0,
   SDTV_COLOUR_RGB = 0x4,
   SDTV_COLOUR_YPRPB = 0x8,
   SDTV_COLOUR_FORCE_32BIT = 0x80000000
} SDTV_COLOUR_T;
/** operation mode */
typedef enum SDTV_MODE_T_
{
   SDTV_MODE_NTSC = 0, /**<Normal NTSC */
   SDTV_MODE_NTSC_J = 1, /**<Japanese version of NTSC - no pedestal.*/
   SDTV_MODE_PAL = 2, /**<Normal PAL */
   SDTV_MODE_PAL_M = 3, /**<Brazilian version of PAL - 525/60 rather than 625/50, different subcarrier */
   SDTV_MODE_FORMAT_MASK = 0x3,

   SDTV_MODE_OUTPUT_MASK = 0xc,

   SDTV_MODE_YPRPB_480i = (SDTV_MODE_NTSC | SDTV_COLOUR_YPRPB),
   SDTV_MODE_RGB_480i = (SDTV_MODE_NTSC | SDTV_COLOUR_RGB),
   SDTV_MODE_YPRPB_576i = (SDTV_MODE_PAL | SDTV_COLOUR_YPRPB),
   SDTV_MODE_RGB_576i = (SDTV_MODE_PAL | SDTV_COLOUR_RGB),

   SDTV_MODE_PROGRESSIVE = 0x10, /**<240p progressive output*/

   SDTV_MODE_OFF = 0x80,
   SDTV_MODE_FORCE_32BIT = 0x80000000
} SDTV_MODE_T;

/** Different aspect ratios */
typedef enum SDTV_ASPECT_T_
{
   // TODO: extend this to allow picture placement/size to be communicated.
   SDTV_ASPECT_UNKNOWN = 0, /**<Unknown */
   SDTV_ASPECT_4_3 = 1, /**<4:3 */
   SDTV_ASPECT_14_9 = 2, /**<14:9 */
   SDTV_ASPECT_16_9 = 3, /**<16:9 */
   SDTV_ASPECTFORCE_32BIT = 0x80000000
} SDTV_ASPECT_T;

/** SDTV power on option */
typedef struct SDTV_OPTIONS_T_
{
   SDTV_ASPECT_T aspect;
} SDTV_OPTIONS_T;

/**
 * Different copy protection modes
 * At the moment we have only implemented Macrovision
 */
typedef enum
{
   SDTV_CP_NONE = 0, /**<No copy protection */
   SDTV_CP_MACROVISION_TYPE1 = 1, /**<Macrovision Type 1 */
   SDTV_CP_MACROVISION_TYPE2 = 2, /**<Macrovision Type 2 */
   SDTV_CP_MACROVISION_TYPE3 = 3, /**<Macrovision Type 3 */
   SDTV_CP_MACROVISION_TEST1 = 4, /**<Macrovision Test 1 */
   SDTV_CP_MACROVISION_TEST2 = 5, /**<Macrovision Test 2 */
   SDTV_CP_CGMS_COPYFREE = 6, /**<CGMS copy freely */
   SDTV_CP_CGMS_COPYNOMORE = 7, /**<CGMS copy no more */
   SDTV_CP_CGMS_COPYONCE = 8, /**<CGMS copy once */
   SDTV_CP_CGMS_COPYNEVER = 9, /**<CGMS copy never */
   SDTV_CP_WSS_COPYFREE = 10, /**<WSS no restriction */
   SDTV_CP_WSS_COPYRIGHT_COPYFREE = 11, /**<WSS copyright asserted */
   SDTV_CP_WSS_NOCOPY = 12, /**<WSS copying restricted */
   SDTV_CP_WSS_COPYRIGHT_NOCOPY = 13, /**<WSS copying restriced, copyright asserted */
   SDTV_CP_FORCE_32BIT = 0x80000000
} SDTV_CP_MODE_T;

/**
 * SDTV internal state
 */
typedef struct {
   uint32_t state;
   uint32_t width;
   uint32_t height;
   uint16_t frame_rate;
   uint16_t scan_mode;
   SDTV_MODE_T mode;
   SDTV_OPTIONS_T display_options;
   SDTV_COLOUR_T colour;
   SDTV_CP_MODE_T cp_mode;
} SDTV_DISPLAY_STATE_T;

/**
 * SDTV notifications
 */
typedef enum
{
   VC_SDTV_UNPLUGGED = 1 << 16, /**<SDTV cable unplugged, subject to platform support */
   VC_SDTV_ATTACHED = 1 << 17, /**<SDTV cable is plugged in */
   VC_SDTV_NTSC = 1 << 18, /**<SDTV is in NTSC mode */
   VC_SDTV_PAL = 1 << 19, /**<SDTV is in PAL mode */
   VC_SDTV_CP_INACTIVE = 1 << 20, /**<Copy protection disabled */
   VC_SDTV_CP_ACTIVE = 1 << 21 /**<Copy protection enabled */
} VC_SDTV_NOTIFY_T;
#define VC_SDTV_STANDBY (VC_SDTV_ATTACHED)

/**
 * Callback reason and arguments from vec middleware
 * Each callback comes with two optional uint32_t parameters.
 * Reason                     param1       param2      remark
 * VC_SDTV_UNPLUGGED            -            -         cable is unplugged
 * VC_SDTV_STANDBY              -            -         cable is plugged in
 * VC_SDTV_NTSC              SDTV_MODE_T SDTV_ASPECT_T NTSC mode active with said aspect ratio
 * VC_SDTV_PAL               SDTV_MODE_T SDTV_ASPECT_T PAL  mode active with said aspect ratio
 * VC_SDTV_CP_INACTIVE          -            -         copy protection is inactive
 * VC_SDTV_CP_ACTIVE         SDTV_CP_MODE_T  -         copy protection is active
 */
# 38 "/opt/vc/include/interface/vmcs_host/vc_tvservice_defs.h" 2

#define VC_TVSERVICE_VER 1

#define TVSERVICE_MSGFIFO_SIZE 1024
#define TVSERVICE_CLIENT_NAME MAKE_FOURCC("TVSV")
#define TVSERVICE_NOTIFY_NAME MAKE_FOURCC("TVNT")

#define TVSERVICE_MAX_CALLBACKS 5

//TV service commands
typedef enum {
   VC_TV_GET_STATE = 0,
   VC_TV_HDMI_ON_PREFERRED,
   VC_TV_HDMI_ON_BEST,
   VC_TV_HDMI_ON_EXPLICIT,
   VC_TV_SDTV_ON,
   VC_TV_OFF,
   VC_TV_QUERY_SUPPORTED_MODES,
   VC_TV_QUERY_MODE_SUPPORT,
   VC_TV_QUERY_AUDIO_SUPPORT,
   VC_TV_ENABLE_COPY_PROTECT,
   VC_TV_DISABLE_COPY_PROTECT,
   VC_TV_SHOW_INFO,
   VC_TV_GET_AV_LATENCY,
   VC_TV_HDCP_SET_KEY,
   VC_TV_HDCP_SET_SRM,
   VC_TV_SET_SPD,
   VC_TV_SET_DISPLAY_OPTIONS,
   VC_TV_TEST_MODE_START,
   VC_TV_TEST_MODE_STOP,
   VC_TV_DDC_READ,
   VC_TV_SET_ATTACHED,
   VC_TV_SET_PROP,
   VC_TV_GET_PROP,
   VC_TV_GET_DISPLAY_STATE,
   VC_TV_QUERY_SUPPORTED_MODES_ACTUAL,
   VC_TV_GET_DEVICE_ID,

   VC_TV_GET_ATTACHED_DEVICES,
//Add more commands here

   VC_TV_END_OF_LIST
} VC_TV_CMD_CODE_T;

// Define a bit in the command that sets whether command contains a display ID
#define TVSERVICE_COMMAND_HAS_DISPLAY_ID (1 << 31)

//Parameters for each command (padded to multiple of 16 bytes)
//See vc_hdmi.h and vc_sdtv.h for details

//GET_STATE
//Parameters: none
//Reply: state (flags of VC_HDMI_NOTIFY_T and VC_SDTV_NOTIFY_T)
//       current width
//       current height
//       current refresh rate
//       current scan mode

typedef struct {
   uint32_t state; /**<TV state is a union of bitmask of VC_HDMI_NOTIFY_T and VC_SDTV_NOTIFY_T */
   uint32_t width; /**<Current display width if TV is on */
   uint32_t height; /**<Current display height if TV is on */
   uint16_t frame_rate;/**<Current refresh rate is TV is on */
   uint16_t scan_mode; /**<Current scanmode 0 for progressive, 1 for interlaced */
} TV_GET_STATE_RESP_T;

//Generic single returned interpreted based on the command
typedef struct {
   int32_t ret; //Single return value
} TV_GENERAL_RESP_T;

//HDMI_ON_PREFERRED
//Parameters: 3d mode (on/off)
//Reply: single return value interpreted as HDMI_RESULT_T or SDTV equivalent (all single reply value will be of this form)
typedef struct {
   uint32_t in_3d;
} TV_HDMI_ON_PREFERRED_PARAM_T;

//HDMI_ON_BEST
//Parameters: width, height, frame rate, scan mode, matching flag (EDID_MODE_MATCH_FLAG_T), 3d mode (on/off)
//Reply: single return value interpreted as HDMI_RESULT_T or SDTV equivalent
typedef struct {
   uint32_t width;
   uint32_t height;
   uint32_t frame_rate;
   uint32_t scan_mode;
   uint32_t match_flags;
   uint32_t in_3d;
} TV_HDMI_ON_BEST_PARAM_T;

//HDMI_ON_EXPLICIT
//Parameters: hdmi_mode, standard, mode
//Reply: same as above
typedef struct {
   uint32_t hdmi_mode; //DVI or HDMI
   uint32_t group;
   uint32_t mode;
} TV_HDMI_ON_EXPLICIT_PARAM_T;

//SDTV_ON
//Parameters: SDTV mode, aspect ratio
//Reply: Same as above
typedef struct {
   uint32_t mode;
   uint32_t aspect;
} TV_SDTV_ON_PARAM_T;

//TV_OFF
//Parameters: none
//Reply: none

//TV_QUERY_SUPPORTED_MODES
//Parameters: standard (CEA/DMT) sent as uint32_t
//Reply: how many modes there are in this group,
//       preferred resolution

//TV_QUERY_SUPPORTED_MODES_ACTUAL (This  downloads the array of supported modes)
//Parameters: standard (CEA/DMT) sent as uint32_t,
//            table size supplied
//Reply: how many modes which will be returned,
//       prefer resolution,
//       the actual array of modes (via bulk transfer)

typedef struct {
   uint32_t scan_mode : 1; /**<1 is interlaced, 0 for progressive */
   uint32_t native : 1; /**<1 means native mode, 0 otherwise */
   uint32_t group : 3; /**<group */
   uint32_t code : 7; /**<mode code */
   uint32_t pixel_rep : 3; /**<pixel repetition (zero means no repetition)*/
   uint32_t aspect_ratio : 5; /**<aspect ratio of the format */
   uint16_t frame_rate; /**<frame rate */
   uint16_t width; /**<frame width */
   uint16_t height; /**<frame height */
   uint32_t pixel_freq; /**<pixel clock in Hz */
   uint32_t struct_3d_mask;/**<3D structure supported for this mode, only valid if group == CEA. This is a bitmask of HDMI_3D_STRUCT_T */
} TV_SUPPORTED_MODE_NEW_T;

typedef struct {
   uint16_t scan_mode : 1; /**<1 is interlaced, 0 for progressive */
   uint16_t native : 1; /**<1 means native mode, 0 otherwise */
   uint16_t code : 7; /**<mode code */
   uint16_t frame_rate; /**<frame rate */
   uint16_t width; /**<frame width */
   uint16_t height; /**<frame height */
} TV_SUPPORTED_MODE_T;

typedef struct {
   uint32_t num_supported_modes;
   uint32_t preferred_group;
   uint32_t preferred_mode;
} TV_QUERY_SUPPORTED_MODES_RESP_T;

//num_supported_modes is the no. of modes available in that group for TV_QUERY_SUPPORTED_MODES
//and no. of modes which will be bulk sent across in TV_QUERY_SUPPORTED_MODES_ACTUAL

//For TV_QUERY_SUPPORTED_MODES_ACTUAL, there will be a separate bulk receive
//containing the supported modes array

//TV_QUERY_MODE_SUPPORT
//Parameters: stardard, mode
//Reply: yes/no
//but the return value meaning is reversed (zero is unsupported, non-zero is supported)
typedef struct {
   uint32_t group;
   uint32_t mode;
} TV_QUERY_MODE_SUPPORT_PARAM_T;

//TV_QUERY_AUDIO_SUPPORT
//Parameters: audio format, no. of channels, sampling frequency, bitrate/sample size
//Reply: single value interpreted as flags EDID_AUDIO_SUPPORT_FLAG_T
typedef struct {
   uint32_t audio_format; //EDID_AudioFormat (if format is eExtended, add EDID_AudioCodingExtension to the audio format)
   uint32_t num_channels; // 1-8
   uint32_t fs; // EDID_AudioSampleRate
   uint32_t bitrate; // EDID_AudioSampleSize if format == PCM, bitrate otherwise
} TV_QUERY_AUDIO_SUPPORT_PARAM_T;

//TV_ENABLE_COPY_PROTECT
//Parameters: copy protect mode (for HDMI it will always be HDCP), timeout
//Reply: single return value - cp result arrive via callback
typedef struct {
   uint32_t cp_mode;
   uint32_t timeout;
} TV_ENABLE_COPY_PROTECT_PARAM_T;

//TV_DISABLE_COPY_PROTECT
//Parameters: none
//Reply: single value return - results arrive via callback

//TV_SHOW_INFO
//Parameters: visible
//Reply: none
typedef struct {
   uint32_t visible; //0 to hide the screen
} TV_SHOW_INFO_PARAM_T;

//TV_GET_AV_LATENCY
//Parameters: none
//Reply: single value interpreted as latency in ms


//TV_HDCP_SET_KEY
//Parameters: key block buffer (fixed size HDCP_KEY_BLOCK_SIZE)
//Reply: none, key validity result arrives via callback
typedef struct {
   uint8_t key[328];
} TV_HDCP_SET_KEY_PARAM_T;

//TV_HDCP_SET_SRM
//Parameters: num of keys, pointer to revocation list (transferred as buffer)
//Reply: none, callback indicates no. of keys set
typedef struct {
   uint32_t num_keys;
} TV_HDCP_SET_SRM_PARAM_T;

//TV_SET_SPD
//Parameters: name [8], description [16], type
//Reply: none
#define TV_SPD_NAME_LEN 8
#define TV_SPD_DESC_LEN 16
typedef struct {
   char manufacturer[8];
   char description[16];
   uint32_t type;
} TV_SET_SPD_PARAM_T;

//TV_SET_DISPLAY_OPTIONS
//Parameters: aspect ratio (HDMI_ASPECT_T), vert bar present (bool),
//            left bar width, right bar width, horiz bar present (bool)
//            top bar height, bottom bar height
//Reply: none
typedef struct {
   uint32_t aspect;
   uint32_t vertical_bar_present;
   uint32_t left_bar_width;
   uint32_t right_bar_width;
   uint32_t horizontal_bar_present;
   uint32_t top_bar_height;
   uint32_t bottom_bar_height;
   uint32_t overscan_flags;
} TV_SET_DISPLAY_OPTIONS_PARAM_T;

//TV_TEST_MODE_START
//Parameters: rgb colour, test mode
//Reply: none

//Actual enums used for test mode
typedef enum {
   TV_TEST_MODE_DISABLED = 0, //Test mode disabled
   TV_TEST_MODE_SOLID_BACKGND = 1, //Solid background colur
   TV_TEST_MODE_SOLID_VERTICAL = 2, //Vertical bars
   TV_TEST_MODE_SHADED_VERTICAL = 3, //Shaded vertical bars
   TV_TEST_MODE_SHADED_WHITE_V = 4, //White vertical bars
   TV_TEST_MODE_SHADED_WHITE_H = 5, //White horizontal bars
   TV_TEST_MODE_SHADED_RGB = 6, //Shaded RGB + white bars
   TV_TEST_MODE_WALKING = 7, //Walking one across 24-bit RGB
   TV_TEST_MODE_DELAYED = 8, //Delayed shaded RGB bars
   TV_TEST_MODE_HVD = 9, //Horizontal G, Vert. B, Diag. R bars
   TV_TEST_MODE_ODD_CH =10, //Odd field crosshairs
   TV_TEST_MODE_EVEN_CH =11, //Even field crosshairs
   TV_TEST_MODE_32x32 =12, //32x32 white grid
   TV_TEST_MODE_WYCGMRBK_SOLID =13, //Solid blah blah
   TV_TEST_MODE_WYCGMRBK_SHADED =14, //Shaded blah blah
   TV_TEST_MODE_32x32_DIAGONAL =15 //32x32 white diagonal grid
} TV_TEST_MODE_T;

typedef struct {
   uint32_t colour; //RGB colour
   uint32_t test_mode; //one of the TV_TEST_MODE_T enums above
} TV_TEST_MODE_START_PARAM_T;

//TV_TEST_MODE_STOP
//Parameters: none
//Reply: none

//TV_DDC_READ
//Parameters: offset, length
//Reply: length of data actually read (so zero means error),
//and fills in the passed in buffer if no error
typedef struct {
   uint32_t offset;
   uint32_t length;
} TV_DDC_READ_PARAM_T;

//TV_SET_ATTACHED
//Parameters: uint32_t attached or not (0 = hotplug low, 1 = hotplug high)

//TV_SET_PROP
//Parameters: HDMI_PROPERTY_PARAM_T
//Reply: 0 = set successful, non-zero if error (int32_t) 
#define HDMI_PROPERTY_SIZE_IN_WORDS (sizeof(HDMI_PROPERTY_T)/sizeof(uint32_t))

//TV_GET_PROP
//Parameters: parameter type (sent as uint32_t)
//Reply param1/param2 of the passed in property and return code
typedef struct {
   int32_t ret; /**<Return code */
   HDMI_PROPERTY_PARAM_T property; /**<HDMI_PROPERTY_PARAM_T */
} TV_GET_PROP_PARAM_T;

//TV_GET_DISPLAY_STATE
//Parameters: none
//Return TV display state
typedef struct {
   uint32_t state; /** This will be the state of HDMI | SDTV */
   union {
      SDTV_DISPLAY_STATE_T sdtv; /** If SDTV is active, this is the state of SDTV */
      HDMI_DISPLAY_STATE_T hdmi; /** If HDMI is active, this is the state of HDMI */
   } display;
} TV_DISPLAY_STATE_T;

//TV_GET_DEVICE_ID
//Parameter: none
//Return device ID information from EDID
typedef struct {
   char vendor[3 +1];
   char monitor_name[(18 - 5)+1];
   uint32_t serial_num;
} TV_DEVICE_ID_T;

// state flag for LCD attached
enum {
   VC_LCD_ATTACHED_DEFAULT = (1 <<22), /**<LCD display is attached and default */
};

#define TV_MAX_ATTACHED_DISPLAYS 16
typedef struct {
   int32_t num_attached; /** How many devices are attached **/
   uint8_t display_number[16]; /** The display number of attached devices in order
                                    Display number example  DISPMANX_ID_MAIN_LCD, see vc_dispmanx_types.h **/
} TV_ATTACHED_DEVICES_T;
# 41 "opt/vc/include/interface/vmcs_host/vc_tvservice.h" 2
# 1 "/opt/vc/include/interface/vmcs_host/vc_hdmi.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * HDMI common host header for TV service, defines resolution code which host applications should
 * use for power up command for HDMI
 */
# 42 "opt/vc/include/interface/vmcs_host/vc_tvservice.h" 2
# 1 "/opt/vc/include/interface/vmcs_host/vc_sdtv.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * SDTV common host header for TV service
 */
# 43 "opt/vc/include/interface/vmcs_host/vc_tvservice.h" 2

/**
 * \file
 *
 * This API defines the controls for both HDMI and analogue TVs. It allows
 * the user to dynamically switch between HDMI and SDTV without having
 * to worry about switch one off before turning the other on. It also
 * allows the user to query the supported HDMI resolutions and audio
 * formats and turn on/off copy protection.
 *
 * There are three ways to turn on HDMI: preferred mode; best matched mode
 * and explicit mode. See the three power on functions for details.
 */

/**
 * TVSERVICE_CALLBACK_T is the callback function for host side notification.
 * Host applications register a single callback for all TV related notifications.
 * See <DFN>VC_HDMI_NOTIFY_T</DFN> and <DFN>VC_SDTV_NOTIFY_T</DFN> in vc_hdmi.h and vc_sdtv.h
 * respectively for list of reasons and respective param1 and param2
 *
 * @param callback_data is the context passed in during the call to vc_tv_register_callback
 *
 * @param reason is the notification reason
 *
 * @param param1 is the first optional parameter
 *
 * @param param2 is the second optional parameter
 *
 * @return void
 */
typedef void (*TVSERVICE_CALLBACK_T)(void *callback_data, uint32_t reason, uint32_t param1, uint32_t param2);

/* API at application start time */
/**
 * <DFN>vc_vchi_tv_init</DFN> is called at the beginning of the application
 * to initialise the client to TV service
 *
 * @param initialise_instance is the VCHI instance
 *
 * @param array of pointers of connections
 *
 * @param number of connections (currently this is always <DFN>1</DFN>
 *
 * @return Zero is successful A negative return value indicates failure (which may mean it has not been started on VideoCore).
 */
extern int vc_vchi_tv_init(VCHI_INSTANCE_T initialise_instance, VCHI_CONNECTION_T **connections, uint32_t num_connections );

/**
 * <DFN>vc_vchi_tv_stop</DFN> is called to stop the host side of TV service.
 *
 * @param none
 *
 * @return void
 */
extern void vc_vchi_tv_stop( void );

/**
 * Host applications should call <DFN>vc_tv_register_callback</DFN> at
 * the beginning to register a callback function to handle all notifications.
 * See <DFN>TVSERVICE_CALLBACK_T </DFN>
 *
 * @param callback function
 *
 * @param callback_data is the context to be passed when function is called
 *
 * @return void
 */
extern void vc_tv_register_callback(TVSERVICE_CALLBACK_T callback, void *callback_data);

/**
 * <DFN>vc_tv_unregister_callback</DFN> removes a function registered with
 * <DFN>vc_tv_register_callback</DFN> from the list of callbacks.
 *
 * @param callback function
 *
 * @return void
 */
extern void vc_tv_unregister_callback(TVSERVICE_CALLBACK_T callback);

/**
 * <DFN>vc_tv_unregister_callback</DFN> removes a function registered with
 * <DFN>vc_tv_register_callback</DFN> from the list of callbacks.
 * In contrast to vc_tv_unregister_callback this one matches not only the
 * function pointer but also the data pointer before removal.
 *
 * @param callback function
 *
 * @return void
 */
extern void vc_tv_unregister_callback_full(TVSERVICE_CALLBACK_T callback, void *callback_data);

/**
 * In the following API any functions applying to HDMI only will have hdmi_
 * in the name, ditto for SDTV only will have sdtv_ in the name,
 * Otherwise the function applies to both SDTV and HDMI (e.g. power off)
 */

/**
 * <DFN>vc_tv_get_state</DFN> is used to obtain the current TV state.
 * Host applications should call this function right after registering
 * a callback in case any notifications are missed.
 *
 * Now deprecated - use vc_tv_get_display_state instead
 *
 * @param pointer to TV_GET_STATE_RESP_T
 *
 * @return zero if the command is sent successfully, non zero otherwise
 * If the command fails to be sent, passed in state is unchanged
 *
 */
extern int vc_tv_get_state(TV_GET_STATE_RESP_T *tvstate);
extern int vc_tv_get_state_id(uint32_t display_id, TV_GET_STATE_RESP_T *tvstate);

/**
 * <DFN>vc_tv_get_display_state</DFN> is used to obtain the current TV display
 * state. This function supersedes vc_tv_get_state (which is only kept for
 * backward compatibility.
 * Host applications should call this function right after registering
 * a callback in case any notifications are missed.
 *
 * @param pointer to TV_DISPLAY_STATE_T
 *
 * @return zero if the command is sent successfully, non zero otherwise
 * If the command fails to be sent, passed in state is unchanged
 *
 */
extern int vc_tv_get_display_state(TV_DISPLAY_STATE_T *tvstate);
extern int vc_tv_get_display_state_id(uint32_t display_id, TV_DISPLAY_STATE_T *tvstate);

/**
 * Use <DFN>vc_tv_hdmi_power_on_preferred</DFN> if you don't care what resolutions
 * a TV supports and just want to turn on its native resolution. Analogue TV will
 * be powered down if on (same for the following two HDMI power on functions.)
 * If power on is successful, a host application must wait for the power on complete
 * callback before attempting to open the display.
 *
 * @param none
 *
 * @return single value interpreted as HDMI_RESULT_T (zero means success)
 *         if successful, there will be a callback when the power on is complete
 *
 **/
extern int vc_tv_hdmi_power_on_preferred( void );
extern int vc_tv_hdmi_power_on_preferred_id(uint32_t display_id);

/**
 * Same as above, but tell the TV to enter 3D mode. The TV will go to 2D mode
 * if the preferred mode doesn't support 3D.
 **/
extern int vc_tv_hdmi_power_on_preferred_3d( void );
extern int vc_tv_hdmi_power_on_preferred_3d_id(uint32_t display_id);

/**
 * Use <DFN>vc_tv_hdmi_power_on_best</DFN> to power on HDMI at best matched resolution
 * based on passed in parameters. Use HDMI_MODE_MATCH_FRAMERATE if you want to
 * match the frame rate; use HDMI_MODE_MATCH_RESOLUTION if you want to match on
 * screen size; add HDMI_MODE_MATCH_SCANMODE if you want to force
 * interlaced/progressive mode. If no matching mode is found, the native resolution
 * will be used instead.
 *
 * @param width is the desired minimum screen width
 *
 * @param height is the desired minimum screen height
 *
 * @param rate is the desired frame rate
 *
 * @param scan_mode (HDMI_NONINTERLACED / HDMI_INTERLACED) is the desired scan mode
 *
 * @param match flags is the matching flag <DFN>EDID_MODE_MATCH_FLAG_T</DFN>
 *
 * @return same as <DFN>vc_tv_hdmi_power_on_preferred</DFN>
 */
extern int vc_tv_hdmi_power_on_best(uint32_t width, uint32_t height, uint32_t frame_rate,
                                              HDMI_INTERLACED_T scan_mode, EDID_MODE_MATCH_FLAG_T match_flags);
extern int vc_tv_hdmi_power_on_best_id(uint32_t display_id, uint32_t width, uint32_t height, uint32_t frame_rate,
                                                 HDMI_INTERLACED_T scan_mode, EDID_MODE_MATCH_FLAG_T match_flags);

/**
 * Same as above, but tell the TV to enter 3D mode. The TV will go to 2D mode
 * if no suitable 3D mode can be found.
 **/
extern int vc_tv_hdmi_power_on_best_3d(uint32_t width, uint32_t height, uint32_t frame_rate,
                                              HDMI_INTERLACED_T scan_mode, EDID_MODE_MATCH_FLAG_T match_flags);
extern int vc_tv_hdmi_power_on_best_3d_id(uint32_t display_id, uint32_t width, uint32_t height, uint32_t frame_rate,
                                              HDMI_INTERLACED_T scan_mode, EDID_MODE_MATCH_FLAG_T match_flags);

/**
 * Use <DFN>vc_tv_hdmi_power_on_explicit</DFN> if you want full control over what mode
 * the TV is driven. This function is used, for example, when the host has the EDID
 * and HDMI middleware does not know. If HDMI middleware has knowledge of EDID, the
 * passed in mode is still subject to TV's supported modes
 *
 * @param mode (HDMI_MODE_HDMI/HDMI_MODE_DVI/HDMI_MODE_3D)
 *
 * @param group (HDMI_RES_GROUP_CEA/HDMI_RES_GROUP_DMT)
 *
 * @param code either <DFN>HDMI_CEA_RES_CODE_T</DFN> or <DFN>HDMI_DMT_RES_CODE_T</DFN>
 *
 * @return same as <DFN>vc_tv_hdmi_power_on_preferred</DFN>
 */
extern int vc_tv_hdmi_power_on_explicit_new(HDMI_MODE_T mode, HDMI_RES_GROUP_T group, uint32_t code);
extern int vc_tv_hdmi_power_on_explicit_new_id(uint32_t display_id, HDMI_MODE_T mode, HDMI_RES_GROUP_T group, uint32_t code);

/**
 * <DFN>vc_tv_sdtv_power_on</DFN> is used to turn on analogue TV. HDMI will
 * automatically be powered off if on.
 *
 * @param SDTV mode <DFN>SDTV_MODE_T</DFN>
 *
 * @param options <DFN>SDTV_OPTIONS_T</DFN>
 *
 * @return single value (zero means success) if successful, there will be a callback when the power on is complete
 *
 */
extern int vc_tv_sdtv_power_on(SDTV_MODE_T mode, SDTV_OPTIONS_T *options);
extern int vc_tv_sdtv_power_on_id(uint32_t display_id, SDTV_MODE_T mode, SDTV_OPTIONS_T *options);

/**
 * <DFN>vc_tv_power_off</DFN> is used to turn off either analogue or HDMI output.
 * If HDMI is powered down, there will be a callback with reason UNPLUGGED (if no
 * cable is attached) or STANDBY (if a cable is attached)
 *
 * @param none
 *
 * @return whether command is succcessfully sent
 *
 */
extern int vc_tv_power_off( void );
extern int vc_tv_power_off_id(uint32_t display_id);

/**
 * <DFN>vc_tv_hdmi_get_supported_modes</DFN> is used to get a list of supported
 * modes for a particular standard (CEA/DMT/CEA3D). Prefer resolution (group and mode)
 * is also returned, if needed. If there are more modes supported than the size of the array
 * supply, only the array will be filled.
 *
 * @param group(HDMI_RES_GROUP_CEA/HDMI_RES_GROUP_DMT)
 *
 * @param array of <DFN>TV_SUPPORT_MODE_T</DFN> struct
 *
 * @param length of array above (in elements, not bytes)
 *
 * @pointer to preferred group (can be NULL)
 *
 * @pointer to prefer mode code (can be NULL)
 *
 * @return the number of modes actually written in the array,
 *         zero means no modes (no EDID or cable unplugged)
 *
 */
extern int vc_tv_hdmi_get_supported_modes_new(HDMI_RES_GROUP_T group,
                                                    TV_SUPPORTED_MODE_NEW_T *supported_modes,
                                                    uint32_t max_supported_modes,
                                                    HDMI_RES_GROUP_T *preferred_group,
                                                    uint32_t *preferred_mode);
extern int vc_tv_hdmi_get_supported_modes_new_id(uint32_t display_id,
                                                           HDMI_RES_GROUP_T group,
                                                           TV_SUPPORTED_MODE_NEW_T *supported_modes,
                                                           uint32_t max_supported_modes,
                                                           HDMI_RES_GROUP_T *preferred_group,
                                                    uint32_t *preferred_mode);
/**
 * <DFN>vc_tv_hdmi_mode_supported</DFN> is used to query whether a particular mode
 * is supported or not.
 *
 * @param resolution standard (HDMI_RES_GROUP_CEA/HDMI_RES_GROUP_DMT)
 *
 * @param mode code
 *
 * @return > 0 means supported, 0 means unsupported, < 0 means error
 *
 */
extern int vc_tv_hdmi_mode_supported(HDMI_RES_GROUP_T group,
                                               uint32_t mode);
extern int vc_tv_hdmi_mode_supported_id(uint32_t display_d, HDMI_RES_GROUP_T group,
                                               uint32_t mode);

/**
 * <DFN>vc_tv_hdmi_audio_supported</DFN> is used to query whether a
 * particular audio format is supported. By default a device has to support
 * 16-bit stereo PCM at 32/44.1/48 kHz if audio is supported at all.
 * Support of other audio formats allow SPDIF to be used.
 * A return value of zero means the audio format is completely supported.
 * Any non-zero values are interpreted as bit mask (EDID_AUDIO_SUPPORT_FLAG_T).
 * For example, if EDID_AUDIO_NO_SUPPORT is set, the audio format is not supported.
 * If EDID_AUDIO_CHAN_UNSUPPORTED is set, the max no. of channels has exceeded.
 *
 * @param audio format supplied as (<DFN>EDID_AudioFormat</DFN> + <DFN>EDID_AudioCodingExtension</DFN>)
 *
 * @param no. of channels (1-8)
 *
 * @param sample rate <DFN>EDID_AudioSampleRate</DFN> but NOT "refer to header"
 *
 * @param bit rate (or sample size if pcm) use <DFN>EDID_AudioSampleSize</DFN> as sample size argument
 *
 * @return: single value return interpreted as flags in <DFN>EDID_AUDIO_SUPPORT_FLAG_T</DFN>
 *
 */
extern int vc_tv_hdmi_audio_supported(uint32_t audio_format, uint32_t num_channels,
                                                EDID_AudioSampleRate fs, uint32_t bitrate);
extern int vc_tv_hdmi_audio_supported_id(uint32_t display_id, uint32_t audio_format, uint32_t num_channels,
                                                EDID_AudioSampleRate fs, uint32_t bitrate);

/**
 * Use <DFN>vc_tv_enable_copyprotect</DFN> to turn on copy protection.
 * For HDMI, only HDMI_CP_HDCP is recognised.
 * For SDTV, use one of the values in SDTV_CP_MODE_T
 *
 * @param copy protect mode
 *
 * @param time out in milliseconds (only applicable to HDMI)
 *
 * @return 0 means success, additional result via callback
 *
 */
extern int vc_tv_enable_copyprotect(uint32_t cp_mode, uint32_t timeout);
extern int vc_tv_enable_copyprotect_id(uint32_t display_id, uint32_t cp_mode, uint32_t timeout);

/**
 * Use <DFN>vc_tv_disable_copyprotect</DFN> to turn off copy protection
 *
 * @param none
 *
 * @rturn 0 means success, additional result via callback
 *
 */
extern int vc_tv_disable_copyprotect( void );
extern int vc_tv_disable_copyprotect_id(uint32_t display_id);

/**
 * Use <DFN>vc_tv_show_info</DFN> to show or hide info screen.
 * Only usable in HDMI at the moment.
 *
 * @param show (1) or hide (0) info screen
 *
 * @return zero if command is successfully sent
 *
 */
extern int vc_tv_show_info(uint32_t show);
extern int vc_tv_show_info_id(uint32_t display_id, uint32_t show);

/**
 * <DFN>vc_tv_hdmi_get_av_latency</DFN> is used to get the AV latency
 * (in ms) for HDMI (lipsync), only valid if HDMI is currently powered on,
 * otherwise you get zero. The latency is defined as the relative delay
 * of the video stream to the audio stream
 *
 * @param none
 *
 * @return latency (zero if error or latency is not defined),
 *         < 0 if failed to send command)
 *
 */
extern int vc_tv_hdmi_get_av_latency( void );
extern int vc_tv_hdmi_get_av_latency_id(uint32_t display_id);

/**
 * Use <DFN>vc_tv_hdmi_set_hdcp_key</DFN> to download HDCP key to HDCP middleware
 *
 * @param AES encrypted key block (328 bytes)
 *
 * @return single value return indicating queued status
 *         Callback indicates the validity of key
 */
extern int vc_tv_hdmi_set_hdcp_key(const uint8_t *key);
extern int vc_tv_hdmi_set_hdcp_key_id(uint32_t display_id, const uint8_t *key);

/**
 * Use <DFN>vc_tv_hdmi_set_hdcp_revoked_list</DFN> to download SRM
 * revoked list
 *
 * @param list
 *
 * @param size of list (no. of keys)
 *
 * @return single value return indicating queued status
 *         Callback indicates the number of keys set (zero if failed, unless you are clearing the list)
 *
 */
extern int vc_tv_hdmi_set_hdcp_revoked_list(const uint8_t *list, uint32_t num_keys);
extern int vc_tv_hdmi_set_hdcp_revoked_list_id(uint32_t display_id, const uint8_t *list, uint32_t num_keys);

/**
 * <DFN>vc_tv_hdmi_set_spd</DFN> is used to set the SPD infoframe.
 *
 * @param manufacturer (max. 8 characters)
 *
 * @param description (max. 16 characters)
 *
 * @param product type <DFN>HDMI_SPD_TYPE_CODE_T</DFN>
 *
 * @return whether command was sent successfully (zero means success)
 *
 */
extern int vc_tv_hdmi_set_spd(const char *manufacturer, const char *description, HDMI_SPD_TYPE_CODE_T type);
extern int vc_tv_hdmi_set_spd_id(uint32_t display_id, const char *manufacturer, const char *description, HDMI_SPD_TYPE_CODE_T type);

/**
 * <DFN>vc_tv_hdmi_set_display_options</DFN> is used to set the
 * active area for HDMI (bar width/height should be set to zero if absent)
 * This information is conveyed in AVI infoframe.
 *
 * @param aspect ratio <DFN>HDMI_ASPECT_T</DFN>
 *
 * @param left bar width
 *
 * @param right bar width
 *
 * @param top bar height
 *
 * @param bottom bar height
 *
 * @return whether command was sent successfully (zero means success)
 *
 */
extern int vc_tv_hdmi_set_display_options(HDMI_ASPECT_T aspect, uint32_t left_bar_width, uint32_t right_bar_width, uint32_t top_bar_height, uint32_t bottom_bar_height, uint32_t overscan_flags);
extern int vc_tv_hdmi_set_display_options_id(uint32_t display_id, HDMI_ASPECT_T aspect, uint32_t left_bar_width, uint32_t right_bar_width, uint32_t top_bar_height, uint32_t bottom_bar_height, uint32_t overscan_flags);

/**
 * Use <DFN>vc_tv_test_mode_start</DFN> to generate test signal.
 * At the moment only DVI test signal is supported.
 * HDMI must be powered off before this function is called.
 *
 * @param 24-bit background colour (if applicable)
 *
 * @param test mode <DFN>TV_TEST_MODE_T</DFN>
 *
 * @return whether command was sent successfully (zero means success)
 *
 */
extern int vc_tv_test_mode_start(uint32_t colour, TV_TEST_MODE_T test_mode);
extern int vc_tv_test_mode_start_id(uint32_t display_id, uint32_t colour, TV_TEST_MODE_T test_mode);

/**
 * Use <DFN>vc_tv_test_mode_stop</DFN> to stop the test signal and power down
 * HDMI.
 *
 * @param none
 *
 * @return whether command was sent successfully (zero means success)
 *
 */
extern int vc_tv_test_mode_stop( void );
extern int vc_tv_test_mode_stop_id(uint32_t display_id);

/**
 * <DFN>vc_tv_hdmi_ddc_read</DFN> allows an host application to read EDID
 * with DDC protocol.
 *
 * @param offset
 *
 * @param length to read (this is typically 128 bytes to coincide with EDID block size)
 *
 * @param pointer to buffer, must be 16 byte aligned
 *
 * @returns length of data read (so zero means error) and the buffer will be filled
 *          only if there is no error
 *
 */
extern int vc_tv_hdmi_ddc_read(uint32_t offset, uint32_t length, uint8_t *buffer);
extern int vc_tv_hdmi_ddc_read_id(uint32_t display_id, uint32_t offset, uint32_t length, uint8_t *buffer);

/**
 * Sets the TV state to attached.
 * Required when hotplug interrupt is not handled by VideoCore.
 *
 * @param attached  non-zero if the TV is attached or zero for unplugged.
 */
extern int vc_tv_hdmi_set_attached(uint32_t attached);
extern int vc_tv_hdmi_set_attached_id(uint32_t display_id, uint32_t attached);

/**
 * Sets one of the HDMI properties. HDMI properties persist
 * between HDMI power on/off
 *
 * @param property [in]
 *
 * @return zero if successful, non-zero otherwise
 */
extern int vc_tv_hdmi_set_property(const HDMI_PROPERTY_PARAM_T *property);
extern int vc_tv_hdmi_set_property_id(uint32_t display_id, const HDMI_PROPERTY_PARAM_T *property);

/**
 * Gets the current value of an HDMI property.
 *
 * @param property [in/out]
 *
 * @return zero if success (param1/param2 will be set), non-zero otherwise (param1/param2 will not be set)
 */
extern int vc_tv_hdmi_get_property(HDMI_PROPERTY_PARAM_T *property);
extern int vc_tv_hdmi_get_property_id(uint32_t display_id, HDMI_PROPERTY_PARAM_T *property);

/**
 * Converts the notification reason to a string.
 *
 * @param reason is the notification reason
 * @return  The notification reason as a string.
 */
extern const char* vc_tv_notification_name(VC_HDMI_NOTIFY_T reason);
extern const char* vc_tv_notification_name_id(uint32_t display_id, VC_HDMI_NOTIFY_T reason);

/**
 * Get the unique device ID from the EDID
 * @param pointer to device ID struct
 * @return zero if successful, non-zero if failed.
 */
extern int vc_tv_get_device_id(TV_DEVICE_ID_T *id);
extern int vc_tv_get_device_id_id(uint32_t display_id, TV_DEVICE_ID_T *id);

/**
 * Get list of attached devices
 * @param pointer to attached devices struc
 * @return zero if successful, non-zero if failed.
 */
extern int vc_tv_get_attached_devices(TV_ATTACHED_DEVICES_T *devices);

// temporary: maintain backwards compatibility
extern int vc_tv_hdmi_get_supported_modes(HDMI_RES_GROUP_T group,
                                                    TV_SUPPORTED_MODE_T *supported_modes,
                                                    uint32_t max_supported_modes,
                                                    HDMI_RES_GROUP_T *preferred_group,
                                                    uint32_t *preferred_mode);
extern int vc_tv_hdmi_get_supported_modes_id(uint32_t display_id,
                                                       HDMI_RES_GROUP_T group,
                                                       TV_SUPPORTED_MODE_T *supported_modes,
                                                       uint32_t max_supported_modes,
                                                       HDMI_RES_GROUP_T *preferred_group,
                                                       uint32_t *preferred_mode);

// temporary: maintain backwards compatibility
extern int vc_tv_hdmi_power_on_explicit(HDMI_MODE_T mode, HDMI_RES_GROUP_T group, uint32_t code);
extern int vc_tv_hdmi_power_on_explicit_id(uint32_t display_id, HDMI_MODE_T mode, HDMI_RES_GROUP_T group, uint32_t code);
# 52 "opt/vc/include/bcm_host.h" 2
# 1 "opt/vc/include/interface/vmcs_host/vc_cec.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * CEC related constants - shared by both host and vc.
 */


#define _VC_CEC_H_ 


#define STRINGIFY(x) #x
#define TOSTRING(x) STRINGIFY(x)


//Broadcast address and TV logical address
#define CEC_BROADCAST_ADDR 0x0F
#define CEC_TV_ADDRESS 0x00

//Maximum transmit length excluding the header byte */
#define CEC_MAX_XMIT_LENGTH 15
//Invalid physical address
#define CEC_CLEAR_ADDR 0xFFFF

/* ----------------------------------------------------------------------
 * general CEC defines
 * -------------------------------------------------------------------- */
//Maximum transmission length and invalid physical address are now in vc_cec.h
#define CEC_VERSION 0x04
//This OUI ID is registered at the current HQ address in Irvine
#define CEC_VENDOR_ID_BROADCOM (0x18C086L)
//These three OUI IDs are registered with the old address of Irvine office in case you need them
//#define CEC_VENDOR_ID_BROADCOM   (0x000AF7L)
//#define CEC_VENDOR_ID_BROADCOM   (0x001018L)
//#define CEC_VENDOR_ID_BROADCOM   (0x001BE9L)
#define CEC_VENDOR_ID_ONKYO (0x0009B0L)
#define CEC_VENDOR_ID_PANASONIC_EUROPE (0x000F12L)

//If we want to "pretend" to be somebody else use a different company id
#define CEC_VENDOR_ID (0x000000L)

#define CEC_BLOCKING 1
#define CEC_NONBLOCKING 0

/**
 * These are the logical addresses for all possible attached devices
 */
typedef enum CEC_AllDevices {
   CEC_AllDevices_eTV = 0, /**<TV only */
   CEC_AllDevices_eRec1, /**<Address for 1st Recording Device */
   CEC_AllDevices_eRec2, /**<Address for 2nd Recording Device */
   CEC_AllDevices_eSTB1, /**<Address for 1st SetTop Box Device */
   CEC_AllDevices_eDVD1, /**<Address for 1st DVD Device */
   CEC_AllDevices_eAudioSystem, /**<Address for Audio Device */
   CEC_AllDevices_eSTB2, /**<Address for 2nd SetTop Box Device */
   CEC_AllDevices_eSTB3, /**<Address for 3rd SetTop Box Device */
   CEC_AllDevices_eDVD2, /**<Address for 2nd DVD Device */
   CEC_AllDevices_eRec3, /**<Address for 3rd Recording Device */
   CEC_AllDevices_eSTB4, /**<10 Address for 4th Tuner Device */
   CEC_AllDevices_eDVD3, /**<11 Address for 3rd DVD Device */
   CEC_AllDevices_eRsvd3, /**<Reserved and cannot be used */
   CEC_AllDevices_eRsvd4, /**<Reserved and cannot be used */
   CEC_AllDevices_eFreeUse, /**<Free Address, use for any device */
   CEC_AllDevices_eUnRegistered = 15 /**<UnRegistered Devices */
} CEC_AllDevices_T;

/**
 * define device types for <Report Physical Address>
 */
typedef enum CEC_DeviceTypes{
   CEC_DeviceType_TV = 0, /**<TV only */
   CEC_DeviceType_Rec = 1, /**<Recoding device */
   CEC_DeviceType_Reserved = 2, /**<Reserved */
   CEC_DeviceType_Tuner = 3, /**<STB */
   CEC_DeviceType_Playback = 4, /**<DVD player */
   CEC_DeviceType_Audio = 5, /**<AV receiver */
   CEC_DeviceType_Switch = 6, /**<CEC switch */
   CEC_DeviceType_VidProc = 7, /**<Video processor */

   CEC_DeviceType_Invalid = 0xF, //RESERVED - DO NOT USE
} CEC_DEVICE_TYPE_T;

/**
 * Generic CEC opcode
 */
typedef enum {
   CEC_Opcode_FeatureAbort = 0x00,
   CEC_Opcode_ImageViewOn = 0x04,
   CEC_Opcode_TunerStepIncrement = 0x05,
   CEC_Opcode_TunerStepDecrement = 0x06,
   CEC_Opcode_TunerDeviceStatus = 0x07,
   CEC_Opcode_GiveTunerDeviceStatus = 0x08,
   CEC_Opcode_RecordOn = 0x09,
   CEC_Opcode_RecordStatus = 0x0A,
   CEC_Opcode_RecordOff = 0x0B,
   CEC_Opcode_TextViewOn = 0x0D,
   CEC_Opcode_RecordTVScreen = 0x0F,
   CEC_Opcode_GiveDeckStatus = 0x1A,
   CEC_Opcode_DeckStatus = 0x1B,
   CEC_Opcode_SetMenuLanguage = 0x32,
   CEC_Opcode_ClearAnalogTimer = 0x33,
   CEC_Opcode_SetAnalogTimer = 0x34,
   CEC_Opcode_TimerStatus = 0x35,
   CEC_Opcode_Standby = 0x36,
   CEC_Opcode_Play = 0x41,
   CEC_Opcode_DeckControl = 0x42,
   CEC_Opcode_TimerClearedStatus = 0x43,
   CEC_Opcode_UserControlPressed = 0x44,
   CEC_Opcode_UserControlReleased = 0x45,
   CEC_Opcode_GiveOSDName = 0x46,
   CEC_Opcode_SetOSDName = 0x47,
   CEC_Opcode_SetOSDString = 0x64,
   CEC_Opcode_SetTimerProgramTitle = 0x67,
   CEC_Opcode_SystemAudioModeRequest = 0x70,
   CEC_Opcode_GiveAudioStatus = 0x71,
   CEC_Opcode_SetSystemAudioMode = 0x72,
   CEC_Opcode_ReportAudioStatus = 0x7A,
   CEC_Opcode_GiveSystemAudioModeStatus = 0x7D,
   CEC_Opcode_SystemAudioModeStatus = 0x7E,
   CEC_Opcode_RoutingChange = 0x80,
   CEC_Opcode_RoutingInformation = 0x81,
   CEC_Opcode_ActiveSource = 0x82,
   CEC_Opcode_GivePhysicalAddress = 0x83,
   CEC_Opcode_ReportPhysicalAddress = 0x84,
   CEC_Opcode_RequestActiveSource = 0x85,
   CEC_Opcode_SetStreamPath = 0x86,
   CEC_Opcode_DeviceVendorID = 0x87,
   CEC_Opcode_VendorCommand = 0x89,
   CEC_Opcode_VendorRemoteButtonDown = 0x8A,
   CEC_Opcode_VendorRemoteButtonUp = 0x8B,
   CEC_Opcode_GiveDeviceVendorID = 0x8C,
   CEC_Opcode_MenuRequest = 0x8D,
   CEC_Opcode_MenuStatus = 0x8E,
   CEC_Opcode_GiveDevicePowerStatus = 0x8F,
   CEC_Opcode_ReportPowerStatus = 0x90,
   CEC_Opcode_GetMenuLanguage = 0x91,
   CEC_Opcode_SelectAnalogService = 0x92,
   CEC_Opcode_SelectDigitalService = 0x93,
   CEC_Opcode_SetDigitalTimer = 0x97,
   CEC_Opcode_ClearDigitalTimer = 0x99,
   CEC_Opcode_SetAudioRate = 0x9A,
   CEC_Opcode_InactiveSource = 0x9D,
   CEC_Opcode_CECVersion = 0x9E,
   CEC_Opcode_GetCECVersion = 0x9F,
   CEC_Opcode_VendorCommandWithID = 0xA0,
   CEC_Opcode_ClearExternalTimer = 0xA1,
   CEC_Opcode_SetExternalTimer = 0xA2,
   CEC_Opcode_ReportShortAudioDescriptor = 0xA3,
   CEC_Opcode_RequestShortAudioDescriptor = 0xA4,
   CEC_Opcode_InitARC = 0xC0,
   CEC_Opcode_ReportARCInited = 0xC1,
   CEC_Opcode_ReportARCTerminated = 0xC2,
   CEC_Opcode_RequestARCInit = 0xC3,
   CEC_Opcode_RequestARCTermination = 0xC4,
   CEC_Opcode_TerminateARC = 0xC5,
   CEC_Opcode_CDC = 0xF8,
   CEC_Opcode_Abort = 0xFF
} CEC_OPCODE_T;

/**
 * Reason parameter for <Feature Abort>
 */
typedef enum {
   CEC_Abort_Reason_Unrecognised_Opcode = 0,
   CEC_Abort_Reason_Wrong_Mode = 1,
   CEC_Abort_Reason_Cannot_Provide_Source = 2,
   CEC_Abort_Reason_Invalid_Operand = 3,
   CEC_Abort_Reason_Refused = 4,
   CEC_Abort_Reason_Undetermined = 5
} CEC_ABORT_REASON_T;

/**
 * Display control parameter for <Set OSD string>
 */
typedef enum {
   CEC_DISPLAY_CONTROL_DEFAULT_TIME = 0,
   CEC_DISPLAY_CONTROL_UNTIL_CLEARED = (1<<6),
   CEC_DISPLAY_CONTROL_CLEAR_PREV_MSG = (1<<7)
} CEC_DISPLAY_CONTROL_T;

/**
 * Power status parameter for <Report Power Status>
 */
typedef enum {
   CEC_POWER_STATUS_ON = 0,
   CEC_POWER_STATUS_STANDBY = 1,
   CEC_POWER_STATUS_ON_PENDING = 2,
   CEC_POWER_STATUS_STANDBY_PENDING = 3
} CEC_POWER_STATUS_T;

/**
 * Menu state parameter for <Menu Status>
 */
typedef enum {
   CEC_MENU_STATE_ACTIVATED = 0,
   CEC_MENU_STATE_DEACTIVATED = 1,
   CEC_MENU_STATE_QUERY = 2
} CEC_MENU_STATE_T;

/**
 * Deck status parameter for <Deck Status>
 */
typedef enum {
   CEC_DECK_INFO_PLAY = 0x11,
   CEC_DECK_INFO_RECORD = 0x12,
   CEC_DECK_INFO_PLAY_REVERSE = 0x13,
   CEC_DECK_INFO_STILL = 0x14,
   CEC_DECK_INFO_SLOW = 0x15,
   CEC_DECK_INFO_SLOW_REVERSE = 0x16,
   CEC_DECK_INFO_SEARCH_FORWARD = 0x17,
   CEC_DECK_INFO_SEARCH_REVERSE = 0x18,
   CEC_DECK_INFO_NO_MEDIA = 0x19,
   CEC_DECK_INFO_STOP = 0x1A,
   CEC_DECK_INFO_WIND = 0x1B,
   CEC_DECK_INFO_REWIND = 0x1C,
   CEC_DECK_IDX_SEARCH_FORWARD = 0x1D,
   CEC_DECK_IDX_SEARCH_REVERSE = 0x1E,
   CEC_DECK_OTHER_STATUS = 0x1F
} CEC_DECK_INFO_T;

/**
 * Deck control mode for <Deck Control>
 */
typedef enum {
   CEC_DECK_CTRL_FORWARD = 1,
   CEC_DECK_CTRL_BACKWARD = 2,
   CEC_DECK_CTRL_STOP = 3,
   CEC_DECK_CTRL_EJECT = 4
} CEC_DECK_CTRL_MODE_T;

/**
 * Play mode for <Play>
 */
typedef enum {
   CEC_PLAY_FORWARD = 0x24,
   CEC_PLAY_REVERSE = 0x20,
   CEC_PLAY_STILL = 0x25,
   CEC_PLAY_SCAN_FORWARD_MIN_SPEED = 0x05,
   CEC_PLAY_SCAN_FORWARD_MED_SPEED = 0x06,
   CEC_PLAY_SCAN_FORWARD_MAX_SPEED = 0x07,
   CEC_PLAY_SCAN_REVERSE_MIN_SPEED = 0x09,
   CEC_PLAY_SCAN_REVERSE_MED_SPEED = 0x0A,
   CEC_PLAY_SCAN_REVERSE_MAX_SPEED = 0x0B,
   CEC_PLAY_SLOW_FORWARD_MIN_SPEED = 0x15,
   CEC_PLAY_SLOW_FORWARD_MED_SPEED = 0x16,
   CEC_PLAY_SLOW_FORWARD_MAX_SPEED = 0x17,
   CEC_PLAY_SLOW_REVERSE_MIN_SPEED = 0x19,
   CEC_PLAY_SLOW_REVERSE_MED_SPEED = 0x1A,
   CEC_PLAY_SLOW_REVERSE_MAX_SPEED = 0x1B
} CEC_PLAY_MODE_T;

/**
 * Status request for <Give Deck Status>
 */
typedef enum {
   CEC_DECK_STATUS_ON = 1,
   CEC_DECK_STATUS_OFF = 2,
   CEC_DECK_STATUS_ONCE = 3
} CEC_DECK_STATUS_REQUEST_T;

/**
 * Button code for <User Control Pressed>
 */
typedef enum {
   CEC_User_Control_Select = 0x00,
   CEC_User_Control_Up = 0x01,
   CEC_User_Control_Down = 0x02,
   CEC_User_Control_Left = 0x03,
   CEC_User_Control_Right = 0x04,
   CEC_User_Control_RightUp = 0x05,
   CEC_User_Control_RightDown = 0x06,
   CEC_User_Control_LeftUp = 0x07,
   CEC_User_Control_LeftDown = 0x08,
   CEC_User_Control_RootMenu = 0x09,
   CEC_User_Control_SetupMenu = 0x0A,
   CEC_User_Control_ContentsMenu = 0x0B,
   CEC_User_Control_FavoriteMenu = 0x0C,
   CEC_User_Control_Exit = 0x0D,
   CEC_User_Control_Number0 = 0x20,
   CEC_User_Control_Number1 = 0x21,
   CEC_User_Control_Number2 = 0x22,
   CEC_User_Control_Number3 = 0x23,
   CEC_User_Control_Number4 = 0x24,
   CEC_User_Control_Number5 = 0x25,
   CEC_User_Control_Number6 = 0x26,
   CEC_User_Control_Number7 = 0x27,
   CEC_User_Control_Number8 = 0x28,
   CEC_User_Control_Number9 = 0x29,
   CEC_User_Control_Dot = 0x2A,
   CEC_User_Control_Enter = 0x2B,
   CEC_User_Control_Clear = 0x2C,
   CEC_User_Control_ChannelUp = 0x30,
   CEC_User_Control_ChannelDown = 0x31,
   CEC_User_Control_PreviousChannel = 0x32,
   CEC_User_Control_SoundSelect = 0x33,
   CEC_User_Control_InputSelect = 0x34,
   CEC_User_Control_DisplayInformation = 0x35,
   CEC_User_Control_Help = 0x36,
   CEC_User_Control_PageUp = 0x37,
   CEC_User_Control_PageDown = 0x38,
   CEC_User_Control_Power = 0x40,
   CEC_User_Control_VolumeUp = 0x41,
   CEC_User_Control_VolumeDown = 0x42,
   CEC_User_Control_Mute = 0x43,
   CEC_User_Control_Play = 0x44,
   CEC_User_Control_Stop = 0x45,
   CEC_User_Control_Pause = 0x46,
   CEC_User_Control_Record = 0x47,
   CEC_User_Control_Rewind = 0x48,
   CEC_User_Control_FastForward = 0x49,
   CEC_User_Control_Eject = 0x4A,
   CEC_User_Control_Forward = 0x4B,
   CEC_User_Control_Backward = 0x4C,
   CEC_User_Control_Angle = 0x50,
   CEC_User_Control_Subpicture = 0x51,
   CEC_User_Control_VideoOnDemand = 0x52,
   CEC_User_Control_EPG = 0x53,
   CEC_User_Control_TimerProgramming = 0x54,
   CEC_User_Control_InitialConfig = 0x55,
   CEC_User_Control_PlayFunction = 0x60,
   CEC_User_Control_PausePlayFunction = 0x61,
   CEC_User_Control_RecordFunction = 0x62,
   CEC_User_Control_PauseRecordFunction = 0x63,
   CEC_User_Control_StopFunction = 0x64,
   CEC_User_Control_MuteFunction = 0x65,
   CEC_User_Control_RestoreVolumeFunction = 0x66,
   CEC_User_Control_TuneFunction = 0x67,
   CEC_User_Control_SelectDiskFunction = 0x68,
   CEC_User_Control_SelectAVInputFunction = 0x69,
   CEC_User_Control_SelectAudioInputFunction = 0x6A,
   CEC_User_Control_F1Blue = 0x71,
   CEC_User_Control_F2Red = 0x72,
   CEC_User_Control_F3Green = 0x73,
   CEC_User_Control_F4Yellow = 0x74,
   CEC_User_Control_F5 = 0x75
} CEC_USER_CONTROL_T;

/**
 *CEC topology struct
 *
 * Meaning of device_attr is as follows (one per active logical device)
 * bit 3-0 logical address (see CEC_AllDevices_T above)
 * bit 7-4 device type (see CEC_DEVICE_TYPE_T above)
 * bit 11-8 index to upstream device
 * bit 15-12 number of downstream device
 * bit 31-16 index of first 4 downstream devices
 * 
 * To keep life simple we only show the first 4 connected downstream devices
 *
 */
typedef struct {
   uint16_t active_mask; /**<bit n is set if logical device n is active */
   uint16_t num_devices; /**<no. of bits set above, save us from counting */
   uint32_t device_attr[16]; /**<Device attribute, see above for explanation */
} VC_CEC_TOPOLOGY_T;

/**
 * CEC message format (provided for host application's convenience
 * for encapsulating a CEC message
 */
typedef struct {
   uint32_t length; //Length of CEC message without the header, so zero indicates a poll message
   CEC_AllDevices_T initiator;
   CEC_AllDevices_T follower;
   uint8_t payload[15 +1]; //We actually only need 15 bytes, this payload does not include header
} VC_CEC_MESSAGE_T;

/**
 * CEC related notification
 */
typedef enum {
   VC_CEC_NOTIFY_NONE = 0, //Reserved - NOT TO BE USED
   VC_CEC_TX = (1 << 0), /**<A message has been transmitted */
   VC_CEC_RX = (1 << 1), /**<A message has arrived (only for registered commands) */
   VC_CEC_BUTTON_PRESSED = (1 << 2), /**<<User Control Pressed> */
   VC_CEC_BUTTON_RELEASE = (1 << 3), /**<<User Control Release> */
   VC_CEC_REMOTE_PRESSED = (1 << 4), /**<<Vendor Remote Button Down> */
   VC_CEC_REMOTE_RELEASE = (1 << 5), /**<<Vendor Remote Button Up> */
   VC_CEC_LOGICAL_ADDR = (1 << 6), /**<New logical address allocated or released */
   VC_CEC_TOPOLOGY = (1 << 7), /**<Topology is available */
   VC_CEC_LOGICAL_ADDR_LOST = (1 << 15) /**<Only for passive mode, if the logical address is lost for whatever reason, this will be triggered */
} VC_CEC_NOTIFY_T;


/**
 * Callback reason and arguments (for sending back to host) All parameters are uint32_t
 * For the reason parameter
 * Bit 15-0 of reason is the reason code, 
 * Bit 23-16 is length of valid bytes which follows in the 4 32-bit parameters (0 < length <= 16)
 * Bit 31-24 is any return code (if required for this callback)
 *
 * Length of valid bytes for TX/RX/button press/release callbacks will be the length
 * of the actual CEC message
 *
 * Length of valid bytes for logical address will always be 6 (first parameter + 16-bit physical address)
 *
 * Length of valid bytes for topology callback will always be 2 (16-bit mask)
 * 
 * Many CEC callback messages are of variable length so not all bytes 0-15 are available 
 *
 * Reason                  param1          param2       param3      param4           remark
 * VC_CEC_TX               bytes 0-3       bytes 4-7    bytes 8-11  bytes 12-15      A message has been transmitted 
 *                                                                                   Only a message sent from the host will 
                                                                                     generate this callback
                                                                                     (non-zero return code means failure)
                                                     
 * VC_CEC_RX               bytes 0-3       bytes 4-7    bytes 8-11  bytes 12-15      By definition only successful message will be forwarded
 *
 * VC_CEC_BUTTON_PRESSED   bytes 0-3       bytes 4-7     -           -               User Control pressed (byte 2 will be actual user control code)
 * VC_CEC_BUTTON_RELEASE   bytes 0-3          -          -           -               User Control release (byte 2 will be actual user control code)

 * VC_CEC_REMOTE_PRESSED   bytes 0-3       bytes 4-7    bytes 8-11  bytes 12-15      Vendor remote button down
 * VC_CEC_REMOTE_RELEASE   bytes 0-3       bytes 4-7    bytes 8-11  bytes 12-15      Vendor remote button up

 * VC_CEC_LOGICAL_ADDR     Log addr        Phy addr      -           -               Logical address allocated or failure
 * VC_CEC_TOPOLOGY         topology bit 
 *                         mask                                                      New topology is avaiable
 *
 *VC_CEC_LOGICAL_ADDR_LOST Last log addr   Phy addr                                  "Last log addr" is no longer available
 *
 * Notes: 
 * VC_CEC_BUTTON_RELEASE and VC_CEC_REMOTE_RELEASE (<User Control Release> and <Vendor Remote Button Up> messages respectively)
 * returns the code from the most recent <User Control pressed> <Vendor Remote button up> respectively.
 * The host application will need to find out the vendor ID of the initiator
 * separately in the case if <Vendor Remote Button Up>/<Vendor Remote Button Down> commands were received.
 * <User Control Pressed> will not be longer than 6 bytes (including header)
 *
 * VC_CEC_LOGICAL_ADDR returns 0xF in param1 whenever no logical address is in used. If physical address is 0xFFFF, 
 * this means CEC is being disabled. Otherwise physical address is the one read from EDID (and no suitable logical address 
 * is avaiable to be allocated). Host application should only attempt to send message if both param1 is not 0xF AND param2
 * is not 0xFFFF.
 *
 * VC_CEC_TOPOLOGY returns a 16-bit mask in param1 where bit n is set if logical address n is present. Host application
 * must explicitly retrieve the entire topology if it wants to know how devices are connected. The bit mask includes our
 * own logical address.
 *
 * If CEC is running in passive mode, the host will get a VC_CEC_LOGICAL_ADDR_LOST callback if the logical address is
 * lost (e.g. HDMI mode change). In this case the host should try a new logical address. The physical address returned may 
 * also change, so the host should check this.
 */

/**
 * General callback function for notifications from CEC middleware (and CEC service)
 *
 * @param client_p is the callback context passed in by user
 *
 * @param reason is the notification nature (plus message lengths, return code, etc.)
 *
 * @param param1 is the first parameter of notification (see above)
 *
 * @param param2 is the second parameter of notification (see above)
 *
 * @param param3 is the third parameter of notification (see above)
 *
 * @param param4 is the fourth parameter of notification (see above)
 *
 * @return void
 */
typedef void (*CEC_CALLBACK_T)(void *client_p, uint32_t reason, uint32_t param1, uint32_t param2, uint32_t param3, uint32_t param4);

/**
 * Some macros to get some fields from the callback parameters in CEC callback 
 */
//Marcos operating on reason
#define CEC_CB_REASON(x) ((x) & 0xFFFF)
#define CEC_CB_MSG_LENGTH(x) (((x) >> 16) & 0xFF)
#define CEC_CB_RC(x) (((x) >> 24) & 0xFF)

//Macros operating on param1
#define CEC_CB_INITIATOR(x) (((x) >> 4) & 0xF)
#define CEC_CB_FOLLOWER(x) ((x) & 0xF)
#define CEC_CB_OPCODE(x) (((x) >> 8) & 0xFF)
#define CEC_CB_OPERAND1(x) (((x) >> 16) & 0xFF)
#define CEC_CB_OPERAND2(x) (((x) >> 24) & 0xFF)

//CEC service return code
typedef enum {
   VC_CEC_SUCCESS = 0, /** OK */
   VC_CEC_ERROR_NO_ACK = 1, /** No acknowledgement */
   VC_CEC_ERROR_SHUTDOWN = 2, /** In the process of shutting down */
   VC_CEC_ERROR_BUSY = 3, /** block is busy */
   VC_CEC_ERROR_NO_LA = 4, /** No logical address */
   VC_CEC_ERROR_NO_PA = 5, /** No physical address */
   VC_CEC_ERROR_NO_TOPO = 6, /** No topology */
   VC_CEC_ERROR_INVALID_FOLLOWER = 7, /** Invalid follower */
   VC_CEC_ERROR_INVALID_ARGUMENT = 8 /** Invalid arguments */
} VC_CEC_ERROR_T;
# 53 "opt/vc/include/bcm_host.h" 2
# 1 "opt/vc/include/interface/vmcs_host/vc_cecservice.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * CEC service host API, 
 * See vc_cec.h and vc_cecservice_defs.h for related constants
 */


#define _VC_CECSERVICE_H_ 

# 1 "/opt/vc/include/vcinclude/common.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
# 37 "opt/vc/include/interface/vmcs_host/vc_cecservice.h" 2
# 1 "/opt/vc/include/interface/vcos/vcos.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */
# 38 "opt/vc/include/interface/vmcs_host/vc_cecservice.h" 2
# 1 "/opt/vc/include/interface/vchi/vchi.h" 1
/*
Copyright (c) 2012-2014, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Contains the protypes for the vchi functions.
# 382 "/opt/vc/include/interface/vchi/vchi.h"
/****************************** End of file **********************************/
# 39 "opt/vc/include/interface/vmcs_host/vc_cecservice.h" 2
# 1 "/opt/vc/include/interface/vmcs_host/vc_cecservice_defs.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * CEC service command enumeration and parameter types.
 */

/**
 * \file
 * This file contains definition shared by host side and
 * Videocore side CEC service:
 *
 * In general, a zero return value indicates success of the function
 * A non-zero value indicates VCHI error
 * A positive value indicates alternative return value (for some functions).
 *
 */



#define _VC_CECSERVICE_DEFS_H_ 
# 1 "/opt/vc/include/vcinclude/common.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
# 47 "/opt/vc/include/interface/vmcs_host/vc_cecservice_defs.h" 2
# 1 "/opt/vc/include/interface/vcos/vcos.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */
# 48 "/opt/vc/include/interface/vmcs_host/vc_cecservice_defs.h" 2
# 1 "/opt/vc/include/interface/vcos/vcos_logging.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - logging support
=============================================================================*/
# 49 "/opt/vc/include/interface/vmcs_host/vc_cecservice_defs.h" 2
# 1 "/opt/vc/include/interface/vchi/message_drivers/message.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// MPHI videocore message driver
# 197 "/opt/vc/include/interface/vchi/message_drivers/message.h"
/****************************** End of file ***********************************/
# 50 "/opt/vc/include/interface/vmcs_host/vc_cecservice_defs.h" 2

//CEC VCOS logging stuff
#define CECHOST_LOG_CATEGORY (&cechost_log_category)
#define vc_cec_log_trace(...) _VCOS_LOG_X(CECHOST_LOG_CATEGORY, VCOS_LOG_TRACE, __VA_ARGS__)
#define vc_cec_log_warn(...) _VCOS_LOG_X(CECHOST_LOG_CATEGORY, VCOS_LOG_WARN, __VA_ARGS__)
#define vc_cec_log_error(...) _VCOS_LOG_X(CECHOST_LOG_CATEGORY, VCOS_LOG_ERROR, __VA_ARGS__)
#define vc_cec_log_info(...) _VCOS_LOG_X(CECHOST_LOG_CATEGORY, VCOS_LOG_INFO, __VA_ARGS__)
extern VCOS_LOG_CAT_T cechost_log_category; //The actual object lives in CEC host side service code

#define VC_CECSERVICE_VER 1
#define CECSERVICE_MSGFIFO_SIZE 1024
#define CECSERVICE_CLIENT_NAME MAKE_FOURCC("CECS")
#define CECSERVICE_NOTIFY_NAME MAKE_FOURCC("CECN")

//CEC service commands
typedef enum {
   VC_CEC_REGISTER_CMD = 0,
   VC_CEC_REGISTER_ALL,
   VC_CEC_DEREGISTER_CMD,
   VC_CEC_DEREGISTER_ALL,
   VC_CEC_SEND_MSG,
   VC_CEC_GET_LOGICAL_ADDR,
   VC_CEC_ALLOC_LOGICAL_ADDR,
   VC_CEC_RELEASE_LOGICAL_ADDR,
   VC_CEC_GET_TOPOLOGY,
   VC_CEC_SET_VENDOR_ID,
   VC_CEC_SET_OSD_NAME,
   VC_CEC_GET_PHYSICAL_ADDR,
   VC_CEC_GET_VENDOR_ID,

   //The following 3 commands are used when CEC middleware is 
   //running in passive mode (i.e. it does not allocate 
   //logical address automatically)
   VC_CEC_POLL_ADDR,
   VC_CEC_SET_LOGICAL_ADDR,
   VC_CEC_ADD_DEVICE,
   VC_CEC_SET_PASSIVE,
   //Add more commands here
   VC_CEC_END_OF_LIST
} VC_CEC_CMD_CODE_T;

//See vc_cec.h for details
//REGISTER_CMD
//Parameters: opcode to register (CEC_OPCODE_T sent as uint32)
//Reply: none

//REGISTER_ALL
//Parameters: none
//Reply: none

//DEREGISTER_CMD
//Parameters: opcode to deregister (CEC_OPCODE_T sent as uint32)
//Reply: none

//DEREGISTER_ALL
//Parameters: none
//Reply: none

//SEND_MSG
//Parameters: destination, length, 16 bytes buffer (message can only be at most 15 bytes however)
//Reply: none (callback)
typedef struct {
   uint32_t follower;
   uint32_t length;
   uint8_t payload[16]; //max. 15 bytes padded to 16
   uint32_t is_reply; //non-zero if this is a reply, zero otherwise
} CEC_SEND_MSG_PARAM_T;

//GET_LOGICAL_ADDR
//Parameters: none
//Reply: logical address (uint8 returned as uint32)

//ALLOC_LOGICAL_ADDR
//Parameters: none
//Reply: none (callback)

//GET_TOPOLOGY
//Parameters: none
//Reply: topology (see VC_TOPOLOGY_T)

//SET_VENDOR_ID
//Parameters: vendor id (uint32)
//Reply: none

//Set OSD name
//Parameters: 14 byte char
//Reply: none
#define OSD_NAME_LENGTH 14

//GET_PHYSICAL_ADDR
//Parameter: none
//Reply: packed physical address returned as uint16

//GET_VENDOR_ID
//Parameter: logical address (CEC_AllDevices_T sent as uint32_t)
//Reply: (uint32_t vendor id)

//POLL_LOGICAL_ADDR (only for passive mode)
//Used by host to test a logical address to see if it is available for use
//Only available if CEC is compiled in passive mode and while the host
//is testing the availability of a logical address
//Parameter: logical address
//Reply: 

//SET_LOGICAL_ADDR [(only for passive mode) This will be changed when we support multiple logical addresses]
//Set the logical address used 
//Only available if CEC is compiled in passive mode
//Parameter: logical address, device type, vendor ID
//Reply: (int32_t - zero means success, non-zero otherwise)
//This function will result in a VC_CEC_LOGICAL_ADDR callback
typedef struct {
   uint32_t logical_address;
   uint32_t device_type;
   uint32_t vendor_id;
} CEC_SET_LOGICAL_ADDR_PARAM_T;

//ADD_DEVICE (only for passive mode)
//Only available if CEC is compiled in passive mode
//Parameter: logical address, physical address, device type, last device?
//Reply: (int32_t - zero means success, non-zero otherwise)
typedef struct {
   uint32_t logical_address; /**<logical address */
   uint32_t physical_address; /**<16-bit packed physical address in big endian */
   uint32_t device_type; /**<CEC_DEVICE_TYPE_T */
   uint32_t last_device; /**<True (non-zero) or false (zero) */
} CEC_ADD_DEVICE_PARAM_T;

//SET PASSIVE (only for passive mode)
//Enable/disable passive mode
//Parameter: non-zero to enable passive mode, zero to disable
//Reply: (int32_t - zero means success, non-zero otherwise, non zero will be VCHI errors)
# 40 "opt/vc/include/interface/vmcs_host/vc_cecservice.h" 2
# 1 "/opt/vc/include/interface/vmcs_host/vc_cec.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * CEC related constants - shared by both host and vc.
 */
# 41 "opt/vc/include/interface/vmcs_host/vc_cecservice.h" 2

/**
 * \file
 * This API defines the controls for CEC. HDMI must be powered on before
 * CEC is available (subject to CEC support in TV). 
 *
 * In general, a zero return value indicates success; a negative return
 * value indicates error in VCHI layer; a positive return value indicates
 * alternative return value from the server
 */

/**
 * Callback function for host side notification 
 * This is the SAME as the callback function type defined in vc_cec.h
 * Host applications register a single callback for all CEC related notifications.
 * See vc_cec.h for meanings of all parameters
 *
 * @param callback_data is the context passed in by user in <DFN>vc_cec_register_callback</DFN>
 *
 * @param reason bits 15-0 is VC_CEC_NOTIFY_T in vc_cec.h;
 *               bits 23-16 is the valid length of message in param1 to param4 (LSB of param1 is the byte0, MSB of param4 is byte15), little endian
 *               bits 31-24 is the return code (if any)
 *
 * @param param1 is the first parameter
 * 
 * @param param2 is the second parameter
 *
 * @param param3 is the third parameter
 *
 * @param param4 is the fourth parameter
 * 
 * @return void
 */
typedef void (*CECSERVICE_CALLBACK_T)(void *callback_data, uint32_t reason, uint32_t param1, uint32_t param2, uint32_t param3, uint32_t param4);

//API at application start time
/**
 * Call <DFN>vc_vchi_cec_init</DFN> to initialise the CEC service for use.
 *
 * @param initialise_instance is the VCHI instance
 * @param connections are array of pointers to VCHI connections
 * @param num_connections is the number of connections in array
 * @return void
 **********************************************************/
extern void vc_vchi_cec_init(VCHI_INSTANCE_T initialise_instance, VCHI_CONNECTION_T **connections, uint32_t num_connections );

/**
 * Call <DFN>vc_vchi_cec_stop</DFN> to stop host side CEC service.
 *
 * @param none
 * @return void
 **********************************************************/
extern void vc_vchi_cec_stop( void );

/**
 * Host applications use <DFN>vc_cec_register_callaback</DFN> to register
 * callback to handle all CEC notifications. If more than one applications 
 * need to use CEC, there should be ONE central application which acts on
 * behalf of all clients and handles all communications with CEC services.
 *
 * @param callback function 
 * @param context to be passed when function is called
 * @return void
 ***********************************************************/
extern void vc_cec_register_callback(CECSERVICE_CALLBACK_T callback, void *callback_data);

//Service API
/**
 * Use <DFN>vc_cec_register_command</DFN> to register an opcode to
 * to forwarded to the host application. By default <Feature Abort> 
 * is always forwarded. Once an opcode is registered, it is left to
 * the host application to reply to a CEC message (where appropriate).
 * It is recommended NOT to register the following commands as they 
 * are replied to automatically by CEC middleware:
 * <Give Physical Address>, <Give Device Vendor ID>, <Give OSD Name>,
 * <Get CEC Version>, <Give Device Power Status>, <Menu Request>,
 * and <Get Menu Language>
 * In addition, the following opcodes cannot be registered:
 * <User Control Pressed>, <User Control Released>, 
 * <Vendor Remote Button Down>, <Vendor Remote Button Up>,
 * and <Abort>.
 * <Feature Abort> is always forwarded if it is the reply
 * of a command the host sent.
 *
 * @param opcode to be registered.
 *
 * @return zero if the command is successful, non-zero otherwise
 ***********************************************************/
extern int vc_cec_register_command(CEC_OPCODE_T opcode);

/**
 * <DFN>vc_cec_register_all</DFN> registers all opcodes except <Abort>
 *  to be forwarded as CEC_RX notification.
 * Button presses <User Control Pressed>, etc. will still be forwarded 
 * separately as VC_CEC_BUTTON_PRESSED etc. notification.
 *
 * @param None
 *
 * @return zero if the command is successful, non-zero otherwise
 ***********************************************************/
extern int vc_cec_register_all( void );

/**
 * Use <DFN>vc_cec_deregister_command</DFN> to remove an opcode from
 * the filter for forwarding. By default <Feature Abort> is always forwarded.
 * The following opcode cannot be deregistered:
 * <User Control Pressed>, <User Control Released>, 
 * <Vendor Remote Button Down>, <Vendor Remote Button Up>,
 * and <Abort>.
 *
 * @param opcode to be deregistered
 *
 * @return zero if the command is successful, non-zero otherwise
 ***********************************************************/
extern int vc_cec_deregister_command(CEC_OPCODE_T opcode);

/**
 * <DFN>vc_cec_deregister_all</DFN> removes all registered opcodes,
 * except the ones (e.g. button presses) which are always forwarded.
 *
 * @param None
 *
 * @return zero if the command is successful, non-zero otherwise
 ***********************************************************/
extern int vc_cec_deregister_all( void );

/**
 * <DFN>vc_cec_send_message</DFN> allows a host application to 
 * send a CEC message to another device. There are several 
 * built-in functions for sending command messages. The host
 * application MUST have a valid logical address (between 1 and
 * 14 inclusive) before it can send a message.
 * (For poll message set payload to NULL and length to zero).
 *
 * @param Follower's logical address
 *
 * @param Message payload WITHOUT the header byte (can be NULL)
 *
 * @param Payload length WITHOUT the header byte (can be zero)
 *
 * @param VC_TRUE if the message is a reply to an incoming message
 *
 * @return zero if the command is successful, non-zero otherwise
 *         If the command is successful, there will be a Tx callback
 *         in due course to indicate whether the message has been
 *         acknowledged by the recipient or not
 ***********************************************************/
extern int vc_cec_send_message(const uint32_t follower,
                                         const uint8_t *payload,
                                         uint32_t length,
                                         vcos_bool_t is_reply);
/**
 * <DFN>vc_cec_get_logical_address</DFN> gets the logical address, 
 * If one is being allocated 0xF (unregistered) will be set.
 * A address value of 0xF also means CEC system is not yet ready
 * to send or receive any messages.
 *
 * @param pointer to logical address (set to allocated address)
 *
 * @return zero if the command is successful, non-zero otherwise
 *         logical_address is not modified if command failed
 ***********************************************************/
extern int vc_cec_get_logical_address(CEC_AllDevices_T *logical_address);

/**
 * <DFN>vc_cec_alloc_logical_address</DFN> starts the allocation 
 * of a logical address. Logical address is automatically allocated
 * after HDMI power on is complete and AV mute is deassert.
 * The host only needs to call this if the 
 * initial allocation failed (logical address being 0xF and 
 * physical address is NOT 0xFFFF from <DFN>VC_CEC_LOGICAL_ADDR</DFN>
 * notification), or if the host explicitly released its logical 
 * address.
 *
 * @param none
 *
 * @return zero if the command is successful, non-zero otherwise
 *         If successful, there will be a callback notification
 *         <DFN>VC_CEC_LOGICAL_ADDR</DFN>. 
 *         The host should wait for this before calling this 
 *         function again.
 ***********************************************************/
extern int vc_cec_alloc_logical_address( void );

/**
 * Normally <DFN>vc_cec_release_logical_address</DFN> will not 
 * be called by the host application. It is used to release 
 * our logical address. This effectively disables CEC.
 * The host will need to allocate a new logical address before
 * doing any CEC calls (send/receive message, get topology, etc.). 
 *
 * @param none
 *
 * @return zero if the command is successful, non-zero otherwise
 *         The host should get a callback <DFN>VC_CEC_LOGICAL_ADDR</DFN>
 *         with 0xF being the logical address and 0xFFFF 
 *         being the physical address.
 ***********************************************************/
extern int vc_cec_release_logical_address( void );

/**
 * Use <DFN>vc_cec_get_topology</DFN> to get the topology.
 *
 * @param pointer to <DFN>VC_CEC_TOPOLOGY_T</DFN>
 *
 * @return zero if the command is successful, non-zero otherwise
 *         If successful, the topology will be set, otherwise it is unchanged
 *         A topology with only 1 device (us) means CEC is not supported.
 *         If there is no topology available, this also returns a failure.
 ***********************************************************/
extern int vc_cec_get_topology( VC_CEC_TOPOLOGY_T* topology);

/**
 * Use <DFN>vc_cec_set_vendor_id</DFN> to 
 * set the response to <Give Device Vendor ID>
 *
 * @param 24-bit IEEE vendor id
 *
 * @return zero if the command is successful, non-zero otherwise
 ***********************************************************/
extern int vc_cec_set_vendor_id( const uint32_t id );

/**
 * Use <DFN>vc_cec_set_osd_name</DFN> to
 * set the response to <Give OSD Name>
 * 
 * @param OSD name (14 byte char array)
 *
 * @return zero if the command is successful, non-zero otherwise
 ***********************************************************/
extern int vc_cec_set_osd_name( const char* name );

/**
 * <DFN>vc_cec_get_physical_address</DFN> gets our physical address
 *
 * @param pointer to physical address (returned as 16-bit packed value)
 *
 * @return zero if the command is successful, non-zero otherwise
 *          If failed, physical address argument will not be changed
 *          A physical address of 0xFFFF means CEC is not supported
 ***********************************************************/
extern int vc_cec_get_physical_address(uint16_t *physical_address);

/**
 * <DFN>vc_cec_get_vendor_id(</DFN> gets the vendor id of a particular logical address
 *
 * @param logical_address is the logical address of the device [in]
 *
 * @param vendorid is the pointer to vendor ID (24-bit IEEE OUI value) [out]
 *
 * @return zero if the command is successful, non-zero otherwise
 *         If failed, vendor id argument will not be changed
 *         A vendor ID of 0xFFFFFF means the device does not exist
 *         A vendor ID of 0x0 means vendor ID is not known and
 *         the application can send <Give Device Vendor ID> to that device
 ***********************************************************/
extern int vc_cec_get_vendor_id(const CEC_AllDevices_T logical_address, uint32_t *vendor_id);

/**
 * <DFN>vc_cec_device_type(</DFN> returns the default device type of a particular
 * logical address, which can be used as the argument to vc_cec_send_ReportPhysicalAddress.
 *
 * @param logical address
 *
 * @return the default device type, if there is any error, the return device
 *         type will be CEC_DeviceType_Invalid
 *
 ************************************************************/
extern CEC_DEVICE_TYPE_T vc_cec_device_type(const CEC_AllDevices_T logical_address);

/**
 * These couple of functions are provided for host application's convenience:
 * If the xmit message is encapsulate in a VC_CEC_MESSAGE_T
 * then it can be sent as a normal message (not as a reply)
 * and the initiator field is ignored with vc_cec_send_message2
 * and return zero for success
 * 
 * Applications can call vc_cec_param2message to turn the callback parameters
 * into a VC_CEC_MESSAGE_T (not for LOGICAL_ADDR and TOPOLOGY callbacks). 
 * It also returns zero for success.
 */
extern int vc_cec_send_message2(const VC_CEC_MESSAGE_T *message);

extern int vc_cec_param2message( const uint32_t reason, const uint32_t param1,
                                           const uint32_t param2, const uint32_t param3,
                                           const uint32_t param4, VC_CEC_MESSAGE_T *message);

//Extra API if CEC is running in passive mode
//If CEC is not in passive mode the following 3 functions always
//return failure
/**
 * <DFN> vc_cec_poll_address </DFN> sets and polls a particular address to find out
 * its availability in the CEC network. Only available when CEC is running in passive
 * mode. The host can only call this function during logical address allocation stage.
 *
 * @param logical address to try
 *
 * @return 0 if poll is successful (address is occupied)
 *        >0 if poll is unsuccessful (Error code is in VC_CEC_ERROR_T in vc_cec.h)
 *        <0 VCHI errors
 */
extern int vc_cec_poll_address(const CEC_AllDevices_T logical_address);

/**
 * <DFN> vc_cec_set_logical_address </DFN> sets the logical address, device type
 * and vendor ID to be in use. Only available when CEC is running in passive
 * mode. It is the responsibility of the host to make sure the logical address
 * is actually free to be used. Physical address will be what is read from EDID.
 *
 * @param logical address
 *
 * @param device type
 *
 * @param vendor ID
 *
 * @return 0 if successful, non-zero otherwise
 */
extern int vc_cec_set_logical_address(const CEC_AllDevices_T logical_address,
                                                const CEC_DEVICE_TYPE_T device_type,
                                                const uint32_t vendor_id);

/**
 * <DFN> vc_cec_add_device </DFN> adds a new device to topology. 
 * Only available when CEC is running in passive mode. Device will be
 * automatically removed from topology if a failed xmit is detected.
 * If last_device is true, it will trigger a topology computation
 * (and may trigger a topology callback).
 *
 * @param logical address
 * 
 * @param physical address
 *
 * @param device type
 *
 * @param true if this is the last device, false otherwise
 *
 * @return 0 if successful, non-zero otherwise
 */
extern int vc_cec_add_device(const CEC_AllDevices_T logical_address,
                                       const uint16_t physical_address,
                                       const CEC_DEVICE_TYPE_T device_type,
                                       vcos_bool_t last_device);

/**
 * <DFN> vc_cec_set_passive </DFN> enables and disables passive mode.
 * Call this function first (with VC_TRUE as the argument) to enable
 * passive mode before calling any of the above passive API functions
 *
 * @param TRUE to enable passive mode, FALSE to disable
 * 
 * @return 0 if successful, non-zero otherwise
 */
extern int vc_cec_set_passive(vcos_bool_t enabled);


//API for some common CEC messages
/** 
 * Functions beginning with vc_cec_send_xxx make it easier for the 
 * host application to send CEC message xxx to other devices
 */
/**
 * <DFN>vc_cec_send_FeatureAbort</DFN> sends <Feature Abort> 
 * for a received command.
 *
 * @param follower (cannot be 0xF)
 *
 * @param rejected opcode
 *
 * @param reject reason <DFN>CEC_ABORT_REASON_T</DFN>
 *
 * @return zero if the command is successful, non-zero otherwise
 *         Tx callback if successful
 ***********************************************************/
extern int vc_cec_send_FeatureAbort(uint32_t follower,
                                              CEC_OPCODE_T opcode,
                                              CEC_ABORT_REASON_T reason);

/**
 * <DFN>vc_cec_send_ActiveSource</DFN> broadcasts
 * <Active Source> to all devices
 *
 * @param physical address (16-bit packed)
 *
 * @param reply or not (normally not)
 *
 * @return zero if the command is successful, non-zero otherwise
 *         Tx callback if successful
 ***********************************************************/
extern int vc_cec_send_ActiveSource(uint16_t physical_address, vcos_bool_t is_reply);

/**
 * <DFN>vc_cec_send_ImageViewOn</DFN> sends <Image View On>
 * 
 * @param follower
 *
 * @param reply or not (normally not)
 *
 * @return zero if the command is successful, non-zero otherwise
 *         Tx callback if successful
 ***********************************************************/
extern int vc_cec_send_ImageViewOn(uint32_t follower, vcos_bool_t is_reply);

/**
 * <DFN>vc_cec_send_SetOSDString</DFN> sends <Set OSD String>
 *
 * @param follower 
 *
 * @param string (char[13]) 
 *
 * @param display control <DFN>CEC_DISPLAY_CONTROL_T</DFN>
 *
 * @param reply or not (normally not)
 *
 * @return zero if the command is successful, non-zero otherwise
 *         Tx callback if successful
 ***********************************************************/
extern int vc_cec_send_SetOSDString(uint32_t follower,
                                              CEC_DISPLAY_CONTROL_T disp_ctrl,
                                              const char* string,
                                              vcos_bool_t is_reply);

/**
 * <DFN>vc_cec_send_Standby</DFN> sends <Standby>.
 * This will put any/all devices to standby if they support
 * this CEC message.
 *
 * @param follower (can be 0xF)
 *
 * @param reply or not (normally not)
 *
 * @return zero if the command is successful, non-zero otherwise
 *         Tx callback if successful
 ***********************************************************/
extern int vc_cec_send_Standby(uint32_t follower, vcos_bool_t is_reply);

/**
 * <DFN>vc_cec_send_MenuStatus</DFN> sends <Menu Status> 
 * (response to <Menu Request>)
 *
 * @param follower
 * 
 * @param menu state <DFN>CEC_MENU_STATE_T</DFN> but NOT CEC_MENU_STATE_QUERY
 *
 * @param reply or not (should always be yes)
 *
 * @return zero if the command is successful, non-zero otherwise
 *         Tx callback if successful
 ***********************************************************/
extern int vc_cec_send_MenuStatus(uint32_t follower,
                                            CEC_MENU_STATE_T menu_state,
                                            vcos_bool_t is_reply);

/**
 * <DFN>vc_cec_send_ReportPhysicalAddress</DFN> broadcasts
 * <Report Physical Address> to all devices. Note although
 * the passed in device type can be override the default one 
 * associated the allocated logical address, it is not 
 * recommended to do so. One can use <DFN>vc_cec_device_type</DFN>
 * to get the default device type associated with the logical 
 * address returned via VC_CEC_LOGICAL_ADDR callback.
 *
 * @param physical address (16-bit packed)
 *
 * @param device type to be broadcasted
 *
 * @param reply or not (normally not)
 *
 * @return zero if the command is successful, non-zero otherwise
 *         Tx callback if successful
 ***********************************************************/
extern int vc_cec_send_ReportPhysicalAddress(uint16_t physical_address,
                                                       CEC_DEVICE_TYPE_T device_type,
                                                       vcos_bool_t is_reply);
# 54 "opt/vc/include/bcm_host.h" 2
# 1 "opt/vc/include/interface/vmcs_host/vcgencmd.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// General command service API


#define GENCMD_H 

# 1 "opt/vc/include/interface/vmcs_host/vchost_platform_config.h" 1
/*
Copyright (c) 2016, Raspberry Pi (Trading) Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


# 1 "opt/vc/include/interface/vmcs_host/linux/vchost_config.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#define VCHOST_CONFIG_H 

# 1 "/opt/vc/include/interface/vcos/vcos.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */
# 32 "opt/vc/include/interface/vmcs_host/linux/vchost_config.h" 2
# 48 "opt/vc/include/interface/vmcs_host/linux/vchost_config.h"
/* On this platform we need to be able to release the host-side software resources. */
extern void vc_os_close(void);
# 58 "opt/vc/include/interface/vmcs_host/linux/vchost_config.h"
#define VCCPRE_ 
# 30 "opt/vc/include/interface/vmcs_host/vchost_platform_config.h" 2
# 34 "opt/vc/include/interface/vmcs_host/vcgencmd.h" 2
# 1 "/opt/vc/include/interface/vchi/vchi.h" 1
/*
Copyright (c) 2012-2014, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Contains the protypes for the vchi functions.
# 382 "/opt/vc/include/interface/vchi/vchi.h"
/****************************** End of file **********************************/
# 35 "opt/vc/include/interface/vmcs_host/vcgencmd.h" 2

extern void vc_vchi_gencmd_init(VCHI_INSTANCE_T initialise_instance, VCHI_CONNECTION_T **connections, uint32_t num_connections );


/* Initialise general command service. Returns it's interface number. This initialises
   the host side of the interface, it does not send anything to VideoCore. */

extern int vc_gencmd_init(void);

/* Stop the service from being used. */

extern void vc_gencmd_stop(void);

/* Return the service number (-1 if not running). */
extern int vc_gencmd_inum(void);

/******************************************************************************
Send commands to VideoCore.
These all return 0 for success. They return VC_MSGFIFO_FIFO_FULL if there is
insufficient space for the whole message in the fifo, and none of the message is
sent.
******************************************************************************/

/*  send command to general command service */
extern int vc_gencmd_send( const char *format, ... );

/*  get response from general command service */
extern int vc_gencmd_read_response(char *response, int maxlen);

/* convenience function to send command and receive the response */
extern int vc_gencmd(char *response, int maxlen, const char *format, ...);

/* read part of a response from the general command service */
extern int vc_gencmd_read_response_partial(char *response, int nbytes);

/* if reading with vc_gencmd_read_response_partial end response reads with this */
extern int vc_gencmd_close_response_partial(void);

/* get state of reading of response */
extern int vc_gencmd_read_partial_state(void);

/******************************************************************************
Utilities to help interpret the responses.
******************************************************************************/

/* Read the value of a property=value type pair from a string (typically VideoCore's
   response to a general command). Return non-zero if found. */
extern int vc_gencmd_string_property(char *text, const char *property, char **value, int *length);

/* Read the numeric value of a property=number field from a response string. Return
   non-zero if found. */
extern int vc_gencmd_number_property(char *text, const char *property, int *number);

/* Send a command until the desired response is received, the error message is detected, or the timeout */
extern int vc_gencmd_until( char *cmd,
                                      const char *property,
                                      char *value,
                                      const char *error_string,
                                      int timeout);
# 55 "opt/vc/include/bcm_host.h" 2
# 107 "pifunk.c" 2
# 1 "opt/vc/include/interface/vcos/vcos.h" 1
/*
Copyright (c) 2012, Broadcom Europe Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the copyright holder nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*=============================================================================
VideoCore OS Abstraction Layer - public header file
=============================================================================*/

/**
  * \mainpage OS Abstraction Layer
  *
  * \section intro Introduction
  *
  * This abstraction layer is here to allow the underlying OS to be easily changed (e.g. from
  * Nucleus to ThreadX) and to aid in porting host applications to new targets.
  *
  * \subsection error Error handling
  *
  * Wherever possible, VCOS functions assert internally and return void. The only exceptions
  * are creation functions (which might fail due to lack of resources) and functions that
  * might timeout or fail due to lack of space. Errors that might be reported by the underlying
  * OS API (e.g. invalid mutex) are treated as a programming error, and are merely asserted on.
  *
  * \section thread_synch Threads and synchronisation
  *
  * \subsection thread Threads
  *
  * The thread API is somewhat different to that found in Nucleus. In particular, threads
  * cannot just be destroyed at arbitrary times and nor can they merely exit. This is so
  * that the same API can be implemented across all interesting platforms without too much
  * difficulty. See vcos_thread.h for details. Thread attributes are configured via
  * the VCOS_THREAD_ATTR_T structure, found in vcos_thread_attr.h.
  *
  * \subsection sema Semaphores
  *
  * Counted semaphores (c.f. Nucleus NU_SEMAPHORE) are created with VCOS_SEMAPHORE_T.
  * Under ThreadX on VideoCore, semaphores are implemented using VideoCore spinlocks, and
  * so are quite a lot faster than ordinary ThreadX semaphores. See vcos_semaphore.h.
  *
  * \subsection mtx Mutexes
  *
  * Mutexes are used for locking. Attempts to take a mutex twice, or to unlock it
  * in a different thread to the one in which it was locked should be expected to fail.
  * Mutexes are not re-entrant (see vcos_reentrant_mutex.h for a slightly slower
  * re-entrant mutex).
  *
  * \subsection evflags Event flags
  *
  * Event flags (the ThreadX name - also known as event groups under Nucleus) provide
  * 32 flags which can be waited on by multiple clients, and signalled by multiple clients.
  * A timeout can be specified. See vcos_event_flags.h. An alternative to this is the
  * VCOS_EVENT_T (see vcos_event.h) which is akin to the Win32 auto-reset event, or a
  * saturating counted semaphore.
  *
  * \subsection event Events
  *
  * A VCOS_EVENT_T is a bit like a saturating semaphore. No matter how many times it
  * is signalled, the waiter will only wake up once. See vcos_event.h. You might think this
  * is useful if you suspect that the cost of reading the semaphore count (perhaps via a
  * system call) is expensive on your platform.
  *
  * \subsection tls Thread local storage
  *
  * Thread local storage is supported using vcos_tls.h. This is emulated on Nucleus
  * and ThreadX.
  *
  * \section int Interrupts
  *
  * The legacy LISR/HISR scheme found in Nucleus is supported via the legacy ISR API,
  * which is also supported on ThreadX. New code should avoid this, and old code should
  * be migrated away from it, since it is slow. See vcos_legacy_isr.h.
  *
  * Registering an interrupt handler, and disabling/restoring interrupts, is handled
  * using the functions in vcos_isr.h.
  *
  */

/**
  * \file vcos.h
  *
  * This is the top level header file. Clients include this. It pulls in the platform-specific
  * header file (vcos_platform.h) together with header files defining the expected APIs, such
  * as vcos_mutex.h, vcos_semaphore.h, etc. It is also possible to include these header files
  * directly.
  *
  */
# 108 "pifunk.c" 2
//#include <common.h>

// on posix linux
# 1 "/usr/include/arm-linux-gnueabihf/sys/cdefs.h" 1 3 4

# 1 "/usr/include/arm-linux-gnueabihf/sys/cdefs.h" 3 4
/* Copyright (C) 1992-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 112 "pifunk.c" 2
# 1 "/usr/include/arm-linux-gnueabihf/sys/time.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _SYS_TIME_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 22 "/usr/include/arm-linux-gnueabihf/sys/time.h" 2 3 4

# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 24 "/usr/include/arm-linux-gnueabihf/sys/time.h" 2 3 4
#define __need_time_t 
# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 26 "/usr/include/arm-linux-gnueabihf/sys/time.h" 2 3 4
#define __need_timeval 
# 1 "/usr/include/arm-linux-gnueabihf/bits/time.h" 1 3 4
/* System-dependent timing definitions.  Linux version.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <time.h> instead.
 */
# 101 "/usr/include/arm-linux-gnueabihf/bits/time.h" 3 4
#undef __need_timeval
# 28 "/usr/include/arm-linux-gnueabihf/sys/time.h" 2 3 4

# 1 "/usr/include/arm-linux-gnueabihf/sys/select.h" 1 3 4
/* `fd_set' type and related macros, and `select'/`pselect' declarations.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*	POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>  */
# 30 "/usr/include/arm-linux-gnueabihf/sys/time.h" 2 3 4










/* Macros for converting between `struct timeval' and `struct timespec'.  */
#define TIMEVAL_TO_TIMESPEC(tv,ts) { (ts)->tv_sec = (tv)->tv_sec; (ts)->tv_nsec = (tv)->tv_usec * 1000; }



#define TIMESPEC_TO_TIMEVAL(tv,ts) { (tv)->tv_sec = (ts)->tv_sec; (tv)->tv_usec = (ts)->tv_nsec / 1000; }







/* Structure crudely representing a timezone.
   This is obsolete and should never be used.  */
struct timezone
  {
    int tz_minuteswest; /* Minutes west of GMT.  */
    int tz_dsttime; /* Nonzero if DST is ever in effect.  */
  };

typedef struct timezone *__restrict __timezone_ptr_t;




/* Get the current time of day and timezone information,
   putting it into *TV and *TZ.  If TZ is NULL, *TZ is not filled.
   Returns 0 on success, -1 on errors.
   NOTE: This form of timezone information is obsolete.
   Use the functions and variables declared in <time.h> instead.  */
extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Set the current time of day and timezone information.
   This call is restricted to the super-user.  */
extern int settimeofday (const struct timeval *__tv,
    const struct timezone *__tz)
     __attribute__ ((__nothrow__ , __leaf__));

/* Adjust the current time of day by the amount in DELTA.
   If OLDDELTA is not NULL, it is filled in with the amount
   of time adjustment remaining to be done from the last `adjtime' call.
   This call is restricted to the super-user.  */
extern int adjtime (const struct timeval *__delta,
      struct timeval *__olddelta) __attribute__ ((__nothrow__ , __leaf__));



/* Values for the first argument to `getitimer' and `setitimer'.  */
enum __itimer_which
  {
    /* Timers run in real time.  */
    ITIMER_REAL = 0,
#define ITIMER_REAL ITIMER_REAL
    /* Timers run only when the process is executing.  */
    ITIMER_VIRTUAL = 1,
#define ITIMER_VIRTUAL ITIMER_VIRTUAL
    /* Timers run when the process is executing and when
       the system is executing on behalf of the process.  */
    ITIMER_PROF = 2
#define ITIMER_PROF ITIMER_PROF
  };

/* Type of the second argument to `getitimer' and
   the second and third arguments `setitimer'.  */
struct itimerval
  {
    /* Value to put into `it_value' when the timer expires.  */
    struct timeval it_interval;
    /* Time to the next timer expiration.  */
    struct timeval it_value;
  };


/* Use the nicer parameter type only in GNU mode and not for C++ since the
   strict C++ rules prevent the automatic promotion.  */
typedef enum __itimer_which __itimer_which_t;




/* Set *VALUE to the current setting of timer WHICH.
   Return 0 on success, -1 on errors.  */
extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) __attribute__ ((__nothrow__ , __leaf__));

/* Set the timer WHICH to *NEW.  If OLD is not NULL,
   set *OLD to the old value of timer WHICH.
   Returns 0 on success, -1 on errors.  */
extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) __attribute__ ((__nothrow__ , __leaf__));

/* Change the access time of FILE to TVP[0] and the modification time of
   FILE to TVP[1].  If TVP is a null pointer, use the current time instead.
   Returns 0 on success, -1 on errors.  */
extern int utimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Same as `utimes', but does not follow symbolic links.  */
extern int lutimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

/* Same as `utimes', but takes an open file descriptor instead of a name.  */
extern int futimes (int __fd, const struct timeval __tvp[2]) __attribute__ ((__nothrow__ , __leaf__));



/* Change the access time of FILE relative to FD to TVP[0] and the
   modification time of FILE to TVP[1].  If TVP is a null pointer, use
   the current time instead.  Returns 0 on success, -1 on errors.  */
extern int futimesat (int __fd, const char *__file,
        const struct timeval __tvp[2]) __attribute__ ((__nothrow__ , __leaf__));




/* Convenience macros for operations on timevals.
   NOTE: `timercmp' does not work for >= or <=.  */
#define timerisset(tvp) ((tvp)->tv_sec || (tvp)->tv_usec)
#define timerclear(tvp) ((tvp)->tv_sec = (tvp)->tv_usec = 0)
#define timercmp(a,b,CMP) (((a)->tv_sec == (b)->tv_sec) ? ((a)->tv_usec CMP (b)->tv_usec) : ((a)->tv_sec CMP (b)->tv_sec))



#define timeradd(a,b,result) do { (result)->tv_sec = (a)->tv_sec + (b)->tv_sec; (result)->tv_usec = (a)->tv_usec + (b)->tv_usec; if ((result)->tv_usec >= 1000000) { ++(result)->tv_sec; (result)->tv_usec -= 1000000; } } while (0)
# 178 "/usr/include/arm-linux-gnueabihf/sys/time.h" 3 4
#define timersub(a,b,result) do { (result)->tv_sec = (a)->tv_sec - (b)->tv_sec; (result)->tv_usec = (a)->tv_usec - (b)->tv_usec; if ((result)->tv_usec < 0) { --(result)->tv_sec; (result)->tv_usec += 1000000; } } while (0)
# 189 "/usr/include/arm-linux-gnueabihf/sys/time.h" 3 4

# 113 "pifunk.c" 2
# 1 "/usr/include/arm-linux-gnueabihf/sys/timex.h" 1 3 4
/* Copyright (C) 1995-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _SYS_TIMEX_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 22 "/usr/include/arm-linux-gnueabihf/sys/timex.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/sys/time.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 23 "/usr/include/arm-linux-gnueabihf/sys/timex.h" 2 3 4

/* These definitions from linux/timex.h as of 2.6.30.  */

# 1 "/usr/include/arm-linux-gnueabihf/bits/timex.h" 1 3 4
/* Copyright (C) 1995-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 27 "/usr/include/arm-linux-gnueabihf/sys/timex.h" 2 3 4

#define NTP_API 4

struct ntptimeval
{
  struct timeval time; /* current time (ro) */
  long int maxerror; /* maximum error (us) (ro) */
  long int esterror; /* estimated error (us) (ro) */
  long int tai; /* TAI offset (ro) */

  long int __glibc_reserved1;
  long int __glibc_reserved2;
  long int __glibc_reserved3;
  long int __glibc_reserved4;
};

/* Clock states (time_state) */
#define TIME_OK 0
#define TIME_INS 1
#define TIME_DEL 2
#define TIME_OOP 3
#define TIME_WAIT 4
#define TIME_ERROR 5
#define TIME_BAD TIME_ERROR

/* Maximum time constant of the PLL.  */
#define MAXTC 6



extern int __adjtimex (struct timex *__ntx) __attribute__ ((__nothrow__ , __leaf__));
extern int adjtimex (struct timex *__ntx) __attribute__ ((__nothrow__ , __leaf__));


extern int ntp_gettime (struct ntptimeval *__ntv) __asm__ ("" "ntp_gettimex") __attribute__ ((__nothrow__ , __leaf__))
                   ;




extern int ntp_adjtime (struct timex *__tntx) __attribute__ ((__nothrow__ , __leaf__));


# 114 "pifunk.c" 2
# 1 "/usr/include/arm-linux-gnueabihf/sys/types.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */
# 115 "pifunk.c" 2
# 1 "/usr/include/arm-linux-gnueabihf/sys/stat.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 5.6 File Characteristics	<sys/stat.h>
 */


#define _SYS_STAT_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/arm-linux-gnueabihf/sys/stat.h" 2 3 4

# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 28 "/usr/include/arm-linux-gnueabihf/sys/stat.h" 2 3 4



#define __need_time_t 


#define __need_timespec 

# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 37 "/usr/include/arm-linux-gnueabihf/sys/stat.h" 2 3 4



/* The Single Unix specification says that some more types are
   available here.  */
# 102 "/usr/include/arm-linux-gnueabihf/sys/stat.h" 3 4


# 1 "/usr/include/arm-linux-gnueabihf/bits/stat.h" 1 3 4
/* Copyright (C) 1992-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 105 "/usr/include/arm-linux-gnueabihf/sys/stat.h" 2 3 4


#define S_IFMT __S_IFMT
#define S_IFDIR __S_IFDIR
#define S_IFCHR __S_IFCHR
#define S_IFBLK __S_IFBLK
#define S_IFREG __S_IFREG

#define S_IFIFO __S_IFIFO


#define S_IFLNK __S_IFLNK



#define S_IFSOCK __S_IFSOCK



/* Test macros for file types.	*/

#define __S_ISTYPE(mode,mask) (((mode) & __S_IFMT) == (mask))

#define S_ISDIR(mode) __S_ISTYPE((mode), __S_IFDIR)
#define S_ISCHR(mode) __S_ISTYPE((mode), __S_IFCHR)
#define S_ISBLK(mode) __S_ISTYPE((mode), __S_IFBLK)
#define S_ISREG(mode) __S_ISTYPE((mode), __S_IFREG)

#define S_ISFIFO(mode) __S_ISTYPE((mode), __S_IFIFO)


#define S_ISLNK(mode) __S_ISTYPE((mode), __S_IFLNK)
# 145 "/usr/include/arm-linux-gnueabihf/sys/stat.h" 3 4
#define S_ISSOCK(mode) __S_ISTYPE((mode), __S_IFSOCK)




/* These are from POSIX.1b.  If the objects are not implemented using separate
   distinct file types, the macros always will evaluate to zero.  Unlike the
   other S_* macros the following three take a pointer to a `struct stat'
   object as the argument.  */

#define S_TYPEISMQ(buf) __S_TYPEISMQ(buf)
#define S_TYPEISSEM(buf) __S_TYPEISSEM(buf)
#define S_TYPEISSHM(buf) __S_TYPEISSHM(buf)



/* Protection bits.  */

#define S_ISUID __S_ISUID
#define S_ISGID __S_ISGID


/* Save swapped text after use (sticky bit).  This is pretty well obsolete.  */
#define S_ISVTX __S_ISVTX


#define S_IRUSR __S_IREAD
#define S_IWUSR __S_IWRITE
#define S_IXUSR __S_IEXEC
/* Read, write, and execute by owner.  */
#define S_IRWXU (__S_IREAD|__S_IWRITE|__S_IEXEC)


#define S_IREAD S_IRUSR
#define S_IWRITE S_IWUSR
#define S_IEXEC S_IXUSR


#define S_IRGRP (S_IRUSR >> 3)
#define S_IWGRP (S_IWUSR >> 3)
#define S_IXGRP (S_IXUSR >> 3)
/* Read, write, and execute by group.  */
#define S_IRWXG (S_IRWXU >> 3)

#define S_IROTH (S_IRGRP >> 3)
#define S_IWOTH (S_IWGRP >> 3)
#define S_IXOTH (S_IXGRP >> 3)
/* Read, write, and execute by others.  */
#define S_IRWXO (S_IRWXG >> 3)



/* Macros for common mode bit masks.  */
#define ACCESSPERMS (S_IRWXU|S_IRWXG|S_IRWXO)
#define ALLPERMS (S_ISUID|S_ISGID|S_ISVTX|S_IRWXU|S_IRWXG|S_IRWXO)
#define DEFFILEMODE (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)

#define S_BLKSIZE 512




/* Get file attributes for FILE and put them in BUF.  */
extern int stat (const char *__restrict __file,
   struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

/* Get file attributes for the file, device, pipe, or socket
   that file descriptor FD is open on and put them in BUF.  */
extern int fstat (int __fd, struct stat *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 227 "/usr/include/arm-linux-gnueabihf/sys/stat.h" 3 4
extern int stat64 (const char *__restrict __file,
     struct stat64 *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



/* Similar to stat, get the attributes for FILE and put them in BUF.
   Relative path names are interpreted relative to FD unless FD is
   AT_FDCWD.  */

extern int fstatat (int __fd, const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 252 "/usr/include/arm-linux-gnueabihf/sys/stat.h" 3 4
extern int fstatat64 (int __fd, const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));





/* Get file attributes about FILE and put them in BUF.
   If FILE is a symbolic link, do not follow it.  */
extern int lstat (const char *__restrict __file,
    struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 275 "/usr/include/arm-linux-gnueabihf/sys/stat.h" 3 4
extern int lstat64 (const char *__restrict __file,
      struct stat64 *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



/* Set file access permissions for FILE to MODE.
   If FILE is a symbolic link, this affects its target instead.  */
extern int chmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Set file access permissions for FILE to MODE.
   If FILE is a symbolic link, this affects the link itself
   rather than its target.  */
extern int lchmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Set file access permissions of the file FD is open on to MODE.  */

extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__ , __leaf__));



/* Set file access permissions of FILE relative to
   the directory FD is open on.  */
extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;




/* Set the file creation mask of the current process to MASK,
   and return the old creation mask.  */
extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__ , __leaf__));


/* Get the current `umask' value without changing it.
   This function is only available under the GNU Hurd.  */
extern __mode_t getumask (void) __attribute__ ((__nothrow__ , __leaf__));


/* Create a new directory named PATH, with permission bits MODE.  */
extern int mkdir (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Like mkdir, create a new directory with permission bits MODE.  But
   interpret relative PATH names relative to the directory associated
   with FD.  */
extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


/* Create a device file named PATH, with permission and special bits MODE
   and device number DEV (which can be constructed from major and minor
   device numbers with the `makedev' macro above).  */

extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Like mknod, create a new device file with permission bits MODE and
   device number DEV.  But interpret relative PATH names relative to
   the directory associated with FD.  */
extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




/* Create a new FIFO named PATH, with permission bits MODE.  */
extern int mkfifo (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


/* Like mkfifo, create a new FIFO with permission bits MODE.  But
   interpret relative PATH names relative to the directory associated
   with FD.  */
extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



/* Set file access and modification times relative to directory file
   descriptor.  */
extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



/* Set file access and modification times of the file associated with FD.  */
extern int futimens (int __fd, const struct timespec __times[2]) __attribute__ ((__nothrow__ , __leaf__));


/* To allow the `struct stat' structure and the file type `mode_t'
   bits to vary without changing shared library major version number,
   the `stat' family of functions and `mknod' are in fact inline
   wrappers around calls to `xstat', `fxstat', `lxstat', and `xmknod',
   which all take a leading version-number argument designating the
   data structure and bits used.  <bits/stat.h> defines _STAT_VER with
   the version number corresponding to `struct stat' as defined in
   that file; and _MKNOD_VER with the version number corresponding to
   the S_IF* macros defined therein.  It is arranged that when not
   inlined these function are always statically linked; that way a
   dynamically-linked executable always encodes the version number
   corresponding to the data structures it uses, so the `x' functions
   in the shared library can adapt without needing to recompile all
   callers.  */
# 396 "/usr/include/arm-linux-gnueabihf/sys/stat.h" 3 4
/* Wrappers for stat and mknod system calls.  */

extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, const char *__filename,
      struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, const char *__filename,
       struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, const char *__filename,
         struct stat *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));
# 431 "/usr/include/arm-linux-gnueabihf/sys/stat.h" 3 4
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat64 (int __ver, const char *__filename,
        struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat64 (int __ver, const char *__filename,
         struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat64 (int __ver, int __fildes, const char *__filename,
    struct stat64 *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));

extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
       __dev_t *__dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, const char *__path,
         __mode_t __mode, __dev_t *__dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 5)));


/* Inlined versions of the real stat and mknod functions.  */

extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) stat (const char *__path, struct stat *__statbuf)
{
  return __xstat (3, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) lstat (const char *__path, struct stat *__statbuf)
{
  return __lxstat (3, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) fstat (int __fd, struct stat *__statbuf)
{
  return __fxstat (3, __fd, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) fstatat (int __fd, const char *__filename, struct stat *__statbuf, int __flag)

{
  return __fxstatat (3, __fd, __filename, __statbuf, __flag);
}



extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) mknod (const char *__path, __mode_t __mode, __dev_t __dev)
{
  return __xmknod (1, __path, __mode, &__dev);
}



extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) mknodat (int __fd, const char *__path, __mode_t __mode, __dev_t __dev)

{
  return __xmknodat (1, __fd, __path, __mode, &__dev);
}





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) stat64 (const char *__path, struct stat64 *__statbuf)
{
  return __xstat64 (3, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) lstat64 (const char *__path, struct stat64 *__statbuf)
{
  return __lxstat64 (3, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) fstat64 (int __fd, struct stat64 *__statbuf)
{
  return __fxstat64 (3, __fd, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) fstatat64 (int __fd, const char *__filename, struct stat64 *__statbuf, int __flag)

{
  return __fxstatat64 (3, __fd, __filename, __statbuf, __flag);
}







# 116 "pifunk.c" 2
# 1 "/usr/include/arm-linux-gnueabihf/sys/mman.h" 1 3 4
/* Definitions for BSD-style memory management.
   Copyright (C) 1994-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _SYS_MMAN_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 23 "/usr/include/arm-linux-gnueabihf/sys/mman.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 24 "/usr/include/arm-linux-gnueabihf/sys/mman.h" 2 3 4
#define __need_size_t 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 160 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 347 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_wchar_t
# 362 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 26 "/usr/include/arm-linux-gnueabihf/sys/mman.h" 2 3 4
# 41 "/usr/include/arm-linux-gnueabihf/sys/mman.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/mman.h" 1 3 4
/* Definitions for POSIX memory map interface.  Linux/ARM version.
   Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */





/* The following definitions basically come from the kernel headers.
   But the kernel header is not namespace clean.  */

/* These are Linux-specific.  */

#define MAP_GROWSDOWN 0x00100
#define MAP_DENYWRITE 0x00800
#define MAP_EXECUTABLE 0x01000
#define MAP_LOCKED 0x02000
#define MAP_NORESERVE 0x04000
#define MAP_POPULATE 0x08000
#define MAP_NONBLOCK 0x10000
#define MAP_STACK 0x20000
#define MAP_HUGETLB 0x40000


/* Include generic Linux declarations.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/mman-linux.h" 1 3 4
/* Definitions for POSIX memory map interface.  Linux generic version.
   Copyright (C) 2001-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* The following definitions basically come from the kernel headers.
   But the kernel header is not namespace clean.

   This file is also used by some non-Linux configurations of the
   GNU C Library, for other systems that use these same bit values.  */


/* Protections are chosen from these bits, OR'd together.  The
   implementation does not necessarily support PROT_EXEC or PROT_WRITE
   without PROT_READ.  The only guarantees are that no writing will be
   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */

#define PROT_READ 0x1
#define PROT_WRITE 0x2
#define PROT_EXEC 0x4
#define PROT_NONE 0x0
#define PROT_GROWSDOWN 0x01000000

#define PROT_GROWSUP 0x02000000


/* Sharing types (must choose one and only one of these).  */
#define MAP_SHARED 0x01
#define MAP_PRIVATE 0x02

#define MAP_TYPE 0x0f


/* Other flags.  */
#define MAP_FIXED 0x10

#define MAP_FILE 0



#define MAP_ANONYMOUS 0x20

#define MAP_ANON MAP_ANONYMOUS
/* When MAP_HUGETLB is set bits [26:31] encode the log2 of the huge page size.  */
#define MAP_HUGE_SHIFT 26
#define MAP_HUGE_MASK 0x3f


/* Flags to `msync'.  */
#define MS_ASYNC 1
#define MS_SYNC 4
#define MS_INVALIDATE 2

/* Flags for `mremap'.  */

#define MREMAP_MAYMOVE 1
#define MREMAP_FIXED 2


/* Advice to `madvise'.  */

#define MADV_NORMAL 0
#define MADV_RANDOM 1
#define MADV_SEQUENTIAL 2
#define MADV_WILLNEED 3
#define MADV_DONTNEED 4
#define MADV_FREE 8
#define MADV_REMOVE 9
#define MADV_DONTFORK 10
#define MADV_DOFORK 11
#define MADV_MERGEABLE 12
#define MADV_UNMERGEABLE 13
#define MADV_HUGEPAGE 14
#define MADV_NOHUGEPAGE 15
#define MADV_DONTDUMP 16

#define MADV_DODUMP 17
#define MADV_HWPOISON 100


/* The POSIX people had to invent similar names for the same things.  */

#define POSIX_MADV_NORMAL 0
#define POSIX_MADV_RANDOM 1
#define POSIX_MADV_SEQUENTIAL 2
#define POSIX_MADV_WILLNEED 3
#define POSIX_MADV_DONTNEED 4


/* Flags for `mlockall'.  */

#define MCL_CURRENT 1
#define MCL_FUTURE 2

#define MCL_ONFAULT 4
# 40 "/usr/include/arm-linux-gnueabihf/bits/mman.h" 2 3 4
# 42 "/usr/include/arm-linux-gnueabihf/sys/mman.h" 2 3 4

/* Return value of `mmap' in case of an error.  */
#define MAP_FAILED ((void *) -1)


/* Map addresses starting near ADDR and extending for LEN bytes.  from
   OFFSET into the file FD describes according to PROT and FLAGS.  If ADDR
   is nonzero, it is the desired mapping address.  If the MAP_FIXED bit is
   set in FLAGS, the mapping will be at ADDR exactly (which must be
   page-aligned); otherwise the system chooses a convenient nearby address.
   The return value is the actual mapping address chosen or MAP_FAILED
   for errors (in which case `errno' is set).  A successful `mmap' call
   deallocates any previous mapping for the affected region.  */


extern void *mmap (void *__addr, size_t __len, int __prot,
     int __flags, int __fd, __off_t __offset) __attribute__ ((__nothrow__ , __leaf__));
# 70 "/usr/include/arm-linux-gnueabihf/sys/mman.h" 3 4
extern void *mmap64 (void *__addr, size_t __len, int __prot,
       int __flags, int __fd, __off64_t __offset) __attribute__ ((__nothrow__ , __leaf__));


/* Deallocate any mapping for the region starting at ADDR and extending LEN
   bytes.  Returns 0 if successful, -1 for errors (and sets errno).  */
extern int munmap (void *__addr, size_t __len) __attribute__ ((__nothrow__ , __leaf__));

/* Change the memory protection of the region starting at ADDR and
   extending LEN bytes to PROT.  Returns 0 if successful, -1 for errors
   (and sets errno).  */
extern int mprotect (void *__addr, size_t __len, int __prot) __attribute__ ((__nothrow__ , __leaf__));

/* Synchronize the region starting at ADDR and extending LEN bytes with the
   file it maps.  Filesystem operations on a file being mapped are
   unpredictable before this is done.  Flags are from the MS_* set.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int msync (void *__addr, size_t __len, int __flags);


/* Advise the system about particular usage patterns the program follows
   for the region starting at ADDR and extending LEN bytes.  */
extern int madvise (void *__addr, size_t __len, int __advice) __attribute__ ((__nothrow__ , __leaf__));


/* This is the POSIX name for this function.  */
extern int posix_madvise (void *__addr, size_t __len, int __advice) __attribute__ ((__nothrow__ , __leaf__));


/* Guarantee all whole pages mapped by the range [ADDR,ADDR+LEN) to
   be memory resident.  */
extern int mlock (const void *__addr, size_t __len) __attribute__ ((__nothrow__ , __leaf__));

/* Unlock whole pages previously mapped by the range [ADDR,ADDR+LEN).  */
extern int munlock (const void *__addr, size_t __len) __attribute__ ((__nothrow__ , __leaf__));

/* Cause all currently mapped pages of the process to be memory resident
   until unlocked by a call to the `munlockall', until the process exits,
   or until the process calls `execve'.  */
extern int mlockall (int __flags) __attribute__ ((__nothrow__ , __leaf__));

/* All currently mapped pages of the process' address space become
   unlocked.  */
extern int munlockall (void) __attribute__ ((__nothrow__ , __leaf__));


/* mincore returns the memory residency status of the pages in the
   current process's address space specified by [start, start + len).
   The status is returned in a vector of bytes.  The least significant
   bit of each byte is 1 if the referenced page is in memory, otherwise
   it is zero.  */
extern int mincore (void *__start, size_t __len, unsigned char *__vec)
     __attribute__ ((__nothrow__ , __leaf__));



/* Remap pages mapped by the range [ADDR,ADDR+OLD_LEN) to new length
   NEW_LEN.  If MREMAP_MAYMOVE is set in FLAGS the returned address
   may differ from ADDR.  If MREMAP_FIXED is set in FLAGS the function
   takes another parameter which is a fixed address at which the block
   resides after a successful call.  */
extern void *mremap (void *__addr, size_t __old_len, size_t __new_len,
       int __flags, ...) __attribute__ ((__nothrow__ , __leaf__));

/* Remap arbitrary pages of a shared backing store within an existing
   VMA.  */
extern int remap_file_pages (void *__start, size_t __size, int __prot,
        size_t __pgoff, int __flags) __attribute__ ((__nothrow__ , __leaf__));



/* Open shared memory segment.  */
extern int shm_open (const char *__name, int __oflag, mode_t __mode);

/* Remove shared memory segment.  */
extern int shm_unlink (const char *__name);


# 117 "pifunk.c" 2
# 1 "/usr/include/arm-linux-gnueabihf/sys/select.h" 1 3 4
/* `fd_set' type and related macros, and `select'/`pselect' declarations.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*	POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>  */
# 118 "pifunk.c" 2
# 1 "/usr/include/arm-linux-gnueabihf/sys/file.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _SYS_FILE_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 22 "/usr/include/arm-linux-gnueabihf/sys/file.h" 2 3 4








/* Alternate names for values for the WHENCE argument to `lseek'.
   These are the same as SEEK_SET, SEEK_CUR, and SEEK_END, respectively.  */







/* Operations for the `flock' call.  */
#define LOCK_SH 1
#define LOCK_EX 2
#define LOCK_UN 8
#define __LOCK_ATOMIC 16

/* Can be OR'd in to one of the above.  */
#define LOCK_NB 4


/* Apply or remove an advisory lock, according to OPERATION,
   on the file FD refers to.  */
extern int flock (int __fd, int __operation) __attribute__ ((__nothrow__ , __leaf__));



# 119 "pifunk.c" 2
# 1 "/usr/include/arm-linux-gnueabihf/sys/sysmacros.h" 1 3 4
/* Definitions of macros to access `dev_t' values.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 120 "pifunk.c" 2
# 1 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 1 3 4
/* Declarations of socket constants, types, and functions.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _SYS_SOCKET_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 23 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 2 3 4



# 1 "/usr/include/arm-linux-gnueabihf/sys/uio.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _SYS_UIO_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 22 "/usr/include/arm-linux-gnueabihf/sys/uio.h" 2 3 4

# 1 "/usr/include/arm-linux-gnueabihf/sys/types.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */
# 24 "/usr/include/arm-linux-gnueabihf/sys/uio.h" 2 3 4



/* This file defines `struct iovec'.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/uio.h" 1 3 4
/* Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 54 "/usr/include/arm-linux-gnueabihf/bits/uio.h" 3 4
#define _BITS_UIO_H_FOR_SYS_UIO_H 1



/* Read from another process' address space.  */
extern ssize_t process_vm_readv (pid_t __pid, const struct iovec *__lvec,
     unsigned long int __liovcnt,
     const struct iovec *__rvec,
     unsigned long int __riovcnt,
     unsigned long int __flags)
  __attribute__ ((__nothrow__ , __leaf__));

/* Write to another process' address space.  */
extern ssize_t process_vm_writev (pid_t __pid, const struct iovec *__lvec,
      unsigned long int __liovcnt,
      const struct iovec *__rvec,
      unsigned long int __riovcnt,
      unsigned long int __flags)
  __attribute__ ((__nothrow__ , __leaf__));


# 29 "/usr/include/arm-linux-gnueabihf/sys/uio.h" 2 3 4


/* Read data from file descriptor FD, and put the result in the
   buffers described by IOVEC, which is a vector of COUNT 'struct iovec's.
   The buffers are filled in the order specified.
   Operates just like 'read' (see <unistd.h>) except that data are
   put in IOVEC instead of a contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t readv (int __fd, const struct iovec *__iovec, int __count)
  ;

/* Write data pointed by the buffers described by IOVEC, which
   is a vector of COUNT 'struct iovec's, to file descriptor FD.
   The data is written in the order specified.
   Operates just like 'write' (see <unistd.h>) except that the data
   are taken from IOVEC instead of a contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t writev (int __fd, const struct iovec *__iovec, int __count)
  ;




/* Read data from file descriptor FD at the given position OFFSET
   without change the file pointer, and put the result in the buffers
   described by IOVEC, which is a vector of COUNT 'struct iovec's.
   The buffers are filled in the order specified.  Operates just like
   'pread' (see <unistd.h>) except that data are put in IOVEC instead
   of a contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t preadv (int __fd, const struct iovec *__iovec, int __count,
         __off_t __offset) ;

/* Write data pointed by the buffers described by IOVEC, which is a
   vector of COUNT 'struct iovec's, to file descriptor FD at the given
   position OFFSET without change the file pointer.  The data is
   written in the order specified.  Operates just like 'pwrite' (see
   <unistd.h>) except that the data are taken from IOVEC instead of a
   contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t pwritev (int __fd, const struct iovec *__iovec, int __count,
   __off_t __offset) ;
# 94 "/usr/include/arm-linux-gnueabihf/sys/uio.h" 3 4
/* Read data from file descriptor FD at the given position OFFSET
   without change the file pointer, and put the result in the buffers
   described by IOVEC, which is a vector of COUNT 'struct iovec's.
   The buffers are filled in the order specified.  Operates just like
   'pread' (see <unistd.h>) except that data are put in IOVEC instead
   of a contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t preadv64 (int __fd, const struct iovec *__iovec, int __count,
    __off64_t __offset) ;

/* Write data pointed by the buffers described by IOVEC, which is a
   vector of COUNT 'struct iovec's, to file descriptor FD at the given
   position OFFSET without change the file pointer.  The data is
   written in the order specified.  Operates just like 'pwrite' (see
   <unistd.h>) except that the data are taken from IOVEC instead of a
   contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t pwritev64 (int __fd, const struct iovec *__iovec, int __count,
     __off64_t __offset) ;




# 27 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 2 3 4
#define __need_size_t 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 160 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 347 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_wchar_t
# 362 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 29 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 2 3 4

/* Get the __sigset_t definition.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/sigset.h" 1 3 4
/* __sig_atomic_t, __sigset_t, and related definitions.  Linux version.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 35 "/usr/include/arm-linux-gnueabihf/bits/sigset.h" 3 4
/* We only want to define these functions if <signal.h> was actually
   included; otherwise we were included just to define the types.  Since we
   are namespace-clean, it wouldn't hurt to define extra macros.  But
   trouble can be caused by functions being defined (e.g., any global
   register vars declared later will cause compilation errors).  */
# 32 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 2 3 4



/* This operating system-specific header file defines the SOCK_*, PF_*,
   AF_*, MSG_*, SOL_*, and SO_* constants, and the `struct sockaddr',
   `struct msghdr', and `struct linger' types.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 1 3 4
/* System-specific socket constants and types.  Linux version.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define __BITS_SOCKET_H 





#define __need_size_t 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 160 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 347 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_wchar_t
# 362 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 28 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 2 3 4

# 1 "/usr/include/arm-linux-gnueabihf/sys/types.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */
# 30 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 2 3 4

/* Type for length arguments in socket calls.  */





/* Get the architecture-dependent definition of enum __socket_type.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/socket_type.h" 1 3 4
/* Define enum __socket_type for generic Linux.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* Types of sockets.  */
enum __socket_type
{
  SOCK_STREAM = 1, /* Sequenced, reliable, connection-based
				   byte streams.  */
#define SOCK_STREAM SOCK_STREAM
  SOCK_DGRAM = 2, /* Connectionless, unreliable datagrams
				   of fixed maximum length.  */
#define SOCK_DGRAM SOCK_DGRAM
  SOCK_RAW = 3, /* Raw protocol interface.  */
#define SOCK_RAW SOCK_RAW
  SOCK_RDM = 4, /* Reliably-delivered messages.  */
#define SOCK_RDM SOCK_RDM
  SOCK_SEQPACKET = 5, /* Sequenced, reliable, connection-based,
				   datagrams of fixed maximum length.  */
#define SOCK_SEQPACKET SOCK_SEQPACKET
  SOCK_DCCP = 6, /* Datagram Congestion Control Protocol.  */
#define SOCK_DCCP SOCK_DCCP
  SOCK_PACKET = 10, /* Linux specific way of getting packets
				   at the dev level.  For writing rarp and
				   other similar things on the user level. */
#define SOCK_PACKET SOCK_PACKET

  /* Flags to be ORed into the type parameter of socket and socketpair and
     used for the flags parameter of paccept.  */

  SOCK_CLOEXEC = 02000000, /* Atomically set close-on-exec flag for the
				   new descriptor(s).  */
#define SOCK_CLOEXEC SOCK_CLOEXEC
  SOCK_NONBLOCK = 00004000 /* Atomically mark descriptor(s) as
				   non-blocking.  */
#define SOCK_NONBLOCK SOCK_NONBLOCK
};
# 39 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 2 3 4

/* Protocol families.  */
#define PF_UNSPEC 0
#define PF_LOCAL 1
#define PF_UNIX PF_LOCAL
#define PF_FILE PF_LOCAL
#define PF_INET 2
#define PF_AX25 3
#define PF_IPX 4
#define PF_APPLETALK 5
#define PF_NETROM 6
#define PF_BRIDGE 7
#define PF_ATMPVC 8
#define PF_X25 9
#define PF_INET6 10
#define PF_ROSE 11
#define PF_DECnet 12
#define PF_NETBEUI 13
#define PF_SECURITY 14
#define PF_KEY 15
#define PF_NETLINK 16
#define PF_ROUTE PF_NETLINK
#define PF_PACKET 17
#define PF_ASH 18
#define PF_ECONET 19
#define PF_ATMSVC 20
#define PF_RDS 21
#define PF_SNA 22
#define PF_IRDA 23
#define PF_PPPOX 24
#define PF_WANPIPE 25
#define PF_LLC 26
#define PF_IB 27
#define PF_MPLS 28
#define PF_CAN 29
#define PF_TIPC 30
#define PF_BLUETOOTH 31
#define PF_IUCV 32
#define PF_RXRPC 33
#define PF_ISDN 34
#define PF_PHONET 35
#define PF_IEEE802154 36
#define PF_CAIF 37
#define PF_ALG 38
#define PF_NFC 39
#define PF_VSOCK 40
#define PF_KCM 41
#define PF_MAX 42

/* Address families.  */
#define AF_UNSPEC PF_UNSPEC
#define AF_LOCAL PF_LOCAL
#define AF_UNIX PF_UNIX
#define AF_FILE PF_FILE
#define AF_INET PF_INET
#define AF_AX25 PF_AX25
#define AF_IPX PF_IPX
#define AF_APPLETALK PF_APPLETALK
#define AF_NETROM PF_NETROM
#define AF_BRIDGE PF_BRIDGE
#define AF_ATMPVC PF_ATMPVC
#define AF_X25 PF_X25
#define AF_INET6 PF_INET6
#define AF_ROSE PF_ROSE
#define AF_DECnet PF_DECnet
#define AF_NETBEUI PF_NETBEUI
#define AF_SECURITY PF_SECURITY
#define AF_KEY PF_KEY
#define AF_NETLINK PF_NETLINK
#define AF_ROUTE PF_ROUTE
#define AF_PACKET PF_PACKET
#define AF_ASH PF_ASH
#define AF_ECONET PF_ECONET
#define AF_ATMSVC PF_ATMSVC
#define AF_RDS PF_RDS
#define AF_SNA PF_SNA
#define AF_IRDA PF_IRDA
#define AF_PPPOX PF_PPPOX
#define AF_WANPIPE PF_WANPIPE
#define AF_LLC PF_LLC
#define AF_IB PF_IB
#define AF_MPLS PF_MPLS
#define AF_CAN PF_CAN
#define AF_TIPC PF_TIPC
#define AF_BLUETOOTH PF_BLUETOOTH
#define AF_IUCV PF_IUCV
#define AF_RXRPC PF_RXRPC
#define AF_ISDN PF_ISDN
#define AF_PHONET PF_PHONET
#define AF_IEEE802154 PF_IEEE802154
#define AF_CAIF PF_CAIF
#define AF_ALG PF_ALG
#define AF_NFC PF_NFC
#define AF_VSOCK PF_VSOCK
#define AF_KCM PF_KCM
#define AF_MAX PF_MAX

/* Socket level values.  Others are defined in the appropriate headers.

   XXX These definitions also should go into the appropriate headers as
   far as they are available.  */
#define SOL_RAW 255
#define SOL_DECNET 261
#define SOL_X25 262
#define SOL_PACKET 263
#define SOL_ATM 264
#define SOL_AAL 265
#define SOL_IRDA 266
#define SOL_NETBEUI 267
#define SOL_LLC 268
#define SOL_DCCP 269
#define SOL_NETLINK 270
#define SOL_TIPC 271
#define SOL_RXRPC 272
#define SOL_PPPOL2TP 273
#define SOL_BLUETOOTH 274
#define SOL_PNPIPE 275
#define SOL_RDS 276
#define SOL_IUCV 277
#define SOL_CAIF 278
#define SOL_ALG 279
#define SOL_NFC 280
#define SOL_KCM 281

/* Maximum queue length specifiable by listen.  */
#define SOMAXCONN 128

/* Get the definition of the macro to define the common sockaddr members.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/sockaddr.h" 1 3 4
/* Definition of struct sockaddr_* common members and sizes, generic version.
   Copyright (C) 1995-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/socket.h> instead.
 */


#define _BITS_SOCKADDR_H 1


/* POSIX.1g specifies this type name for the `sa_family' member.  */
typedef unsigned short int sa_family_t;

/* This macro is used to declare the initial common members
   of the data types used for socket addresses, `struct sockaddr',
   `struct sockaddr_in', `struct sockaddr_un', etc.  */

#define __SOCKADDR_COMMON(sa_prefix) sa_family_t sa_prefix ##family


#define __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))

/* Size of struct sockaddr_storage.  */
#define _SS_SIZE 128
# 168 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 2 3 4

/* Structure describing a generic socket address.  */
struct sockaddr
  {
    sa_family_t sa_family; /* Common data: address family and length.  */
    char sa_data[14]; /* Address data.  */
  };


/* Structure large enough to hold any socket address (with the historical
   exception of AF_UNIX).  */
#define __ss_aligntype unsigned long int
#define _SS_PADSIZE (_SS_SIZE - __SOCKADDR_COMMON_SIZE - sizeof (__ss_aligntype))


struct sockaddr_storage
  {
    sa_family_t ss_family; /* Address family, etc.  */
    char __ss_padding[(128 - (sizeof (unsigned short int)) - sizeof (unsigned long int))];
    unsigned long int __ss_align; /* Force desired alignment.  */
  };


/* Bits in the FLAGS argument to `send', `recv', et al.  */
enum
  {
    MSG_OOB = 0x01, /* Process out-of-band data.  */
#define MSG_OOB MSG_OOB
    MSG_PEEK = 0x02, /* Peek at incoming messages.  */
#define MSG_PEEK MSG_PEEK
    MSG_DONTROUTE = 0x04, /* Don't use local routing.  */
#define MSG_DONTROUTE MSG_DONTROUTE

    /* DECnet uses a different name.  */
    MSG_TRYHARD = MSG_DONTROUTE,
#define MSG_TRYHARD MSG_DONTROUTE

    MSG_CTRUNC = 0x08, /* Control data lost before delivery.  */
#define MSG_CTRUNC MSG_CTRUNC
    MSG_PROXY = 0x10, /* Supply or ask second address.  */
#define MSG_PROXY MSG_PROXY
    MSG_TRUNC = 0x20,
#define MSG_TRUNC MSG_TRUNC
    MSG_DONTWAIT = 0x40, /* Nonblocking IO.  */
#define MSG_DONTWAIT MSG_DONTWAIT
    MSG_EOR = 0x80, /* End of record.  */
#define MSG_EOR MSG_EOR
    MSG_WAITALL = 0x100, /* Wait for a full request.  */
#define MSG_WAITALL MSG_WAITALL
    MSG_FIN = 0x200,
#define MSG_FIN MSG_FIN
    MSG_SYN = 0x400,
#define MSG_SYN MSG_SYN
    MSG_CONFIRM = 0x800, /* Confirm path validity.  */
#define MSG_CONFIRM MSG_CONFIRM
    MSG_RST = 0x1000,
#define MSG_RST MSG_RST
    MSG_ERRQUEUE = 0x2000, /* Fetch message from error queue.  */
#define MSG_ERRQUEUE MSG_ERRQUEUE
    MSG_NOSIGNAL = 0x4000, /* Do not generate SIGPIPE.  */
#define MSG_NOSIGNAL MSG_NOSIGNAL
    MSG_MORE = 0x8000, /* Sender will send more.  */
#define MSG_MORE MSG_MORE
    MSG_WAITFORONE = 0x10000, /* Wait for at least one packet to return.*/
#define MSG_WAITFORONE MSG_WAITFORONE
    MSG_BATCH = 0x40000, /* sendmmsg: more messages coming.  */
#define MSG_BATCH MSG_BATCH
    MSG_FASTOPEN = 0x20000000, /* Send data in TCP SYN.  */
#define MSG_FASTOPEN MSG_FASTOPEN

    MSG_CMSG_CLOEXEC = 0x40000000 /* Set close_on_exit for file
					   descriptor received through
					   SCM_RIGHTS.  */
#define MSG_CMSG_CLOEXEC MSG_CMSG_CLOEXEC
  };


/* Structure describing messages sent by
   `sendmsg' and received by `recvmsg'.  */
struct msghdr
  {
    void *msg_name; /* Address to send to/receive from.  */
    socklen_t msg_namelen; /* Length of address data.  */

    struct iovec *msg_iov; /* Vector of data to send/receive into.  */
    size_t msg_iovlen; /* Number of elements in the vector.  */

    void *msg_control; /* Ancillary data (eg BSD filedesc passing). */
    size_t msg_controllen; /* Ancillary data buffer length.
				   !! The type should be socklen_t but the
				   definition of the kernel is incompatible
				   with this.  */

    int msg_flags; /* Flags on received message.  */
  };

/* Structure used for storage of ancillary data object information.  */
struct cmsghdr
  {
    size_t cmsg_len; /* Length of data in cmsg_data plus length
				   of cmsghdr structure.
				   !! The type should be socklen_t but the
				   definition of the kernel is incompatible
				   with this.  */
    int cmsg_level; /* Originating protocol.  */
    int cmsg_type; /* Protocol specific type.  */

    __extension__ unsigned char __cmsg_data []; /* Ancillary data.  */

  };

/* Ancillary data object manipulation macros.  */

#define CMSG_DATA(cmsg) ((cmsg)->__cmsg_data)



#define CMSG_NXTHDR(mhdr,cmsg) __cmsg_nxthdr (mhdr, cmsg)
#define CMSG_FIRSTHDR(mhdr) ((size_t) (mhdr)->msg_controllen >= sizeof (struct cmsghdr) ? (struct cmsghdr *) (mhdr)->msg_control : (struct cmsghdr *) 0)


#define CMSG_ALIGN(len) (((len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1))

#define CMSG_SPACE(len) (CMSG_ALIGN (len) + CMSG_ALIGN (sizeof (struct cmsghdr)))

#define CMSG_LEN(len) (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))

extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
          struct cmsghdr *__cmsg) __attribute__ ((__nothrow__ , __leaf__));




extern __inline __attribute__ ((__gnu_inline__)) struct cmsghdr *
__attribute__ ((__nothrow__ , __leaf__)) __cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg)
{
  if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))
    /* The kernel header does this so there may be a reason.  */
    return (struct cmsghdr *) 0;

  __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
          + (((__cmsg->cmsg_len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1)));
  if ((unsigned char *) (__cmsg + 1) > ((unsigned char *) __mhdr->msg_control
     + __mhdr->msg_controllen)
      || ((unsigned char *) __cmsg + (((__cmsg->cmsg_len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1))
   > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))
    /* No more entries.  */
    return (struct cmsghdr *) 0;
  return __cmsg;
}


/* Socket level message types.  This must match the definitions in
   <linux/socket.h>.  */
enum
  {
    SCM_RIGHTS = 0x01 /* Transfer file descriptors.  */
#define SCM_RIGHTS SCM_RIGHTS

    , SCM_CREDENTIALS = 0x02 /* Credentials passing.  */
#define SCM_CREDENTIALS SCM_CREDENTIALS

  };


/* User visible structure for SCM_CREDENTIALS message */
struct ucred
{
  pid_t pid; /* PID of sending process.  */
  uid_t uid; /* UID of sending process.  */
  gid_t gid; /* GID of sending process.  */
};


/* Ugly workaround for unclean kernel headers.  */
# 367 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 3 4
/* Get socket manipulation related informations from kernel headers.  */
# 1 "/usr/include/arm-linux-gnueabihf/asm/socket.h" 1 3 4
# 1 "/usr/include/asm-generic/socket.h" 1 3 4

#define __ASM_GENERIC_SOCKET_H 

# 1 "/usr/include/arm-linux-gnueabihf/asm/sockios.h" 1 3 4
# 1 "/usr/include/asm-generic/sockios.h" 1 3 4

#define __ASM_GENERIC_SOCKIOS_H 

/* Socket-level I/O control calls. */
#define FIOSETOWN 0x8901
#define SIOCSPGRP 0x8902
#define FIOGETOWN 0x8903
#define SIOCGPGRP 0x8904
#define SIOCATMARK 0x8905
#define SIOCGSTAMP 0x8906
#define SIOCGSTAMPNS 0x8907
# 1 "/usr/include/arm-linux-gnueabihf/asm/sockios.h" 2 3 4
# 5 "/usr/include/asm-generic/socket.h" 2 3 4

/* For setsockopt(2) */
#define SOL_SOCKET 1

#define SO_DEBUG 1
#define SO_REUSEADDR 2
#define SO_TYPE 3
#define SO_ERROR 4
#define SO_DONTROUTE 5
#define SO_BROADCAST 6
#define SO_SNDBUF 7
#define SO_RCVBUF 8
#define SO_SNDBUFFORCE 32
#define SO_RCVBUFFORCE 33
#define SO_KEEPALIVE 9
#define SO_OOBINLINE 10
#define SO_NO_CHECK 11
#define SO_PRIORITY 12
#define SO_LINGER 13
#define SO_BSDCOMPAT 14
#define SO_REUSEPORT 15

#define SO_PASSCRED 16
#define SO_PEERCRED 17
#define SO_RCVLOWAT 18
#define SO_SNDLOWAT 19
#define SO_RCVTIMEO 20
#define SO_SNDTIMEO 21


/* Security levels - as per NRL IPv6 - don't actually do anything */
#define SO_SECURITY_AUTHENTICATION 22
#define SO_SECURITY_ENCRYPTION_TRANSPORT 23
#define SO_SECURITY_ENCRYPTION_NETWORK 24

#define SO_BINDTODEVICE 25

/* Socket filtering */
#define SO_ATTACH_FILTER 26
#define SO_DETACH_FILTER 27
#define SO_GET_FILTER SO_ATTACH_FILTER

#define SO_PEERNAME 28
#define SO_TIMESTAMP 29
#define SCM_TIMESTAMP SO_TIMESTAMP

#define SO_ACCEPTCONN 30

#define SO_PEERSEC 31
#define SO_PASSSEC 34
#define SO_TIMESTAMPNS 35
#define SCM_TIMESTAMPNS SO_TIMESTAMPNS

#define SO_MARK 36

#define SO_TIMESTAMPING 37
#define SCM_TIMESTAMPING SO_TIMESTAMPING

#define SO_PROTOCOL 38
#define SO_DOMAIN 39

#define SO_RXQ_OVFL 40

#define SO_WIFI_STATUS 41
#define SCM_WIFI_STATUS SO_WIFI_STATUS
#define SO_PEEK_OFF 42

/* Instruct lower device to use last 4-bytes of skb data as FCS */
#define SO_NOFCS 43

#define SO_LOCK_FILTER 44

#define SO_SELECT_ERR_QUEUE 45

#define SO_BUSY_POLL 46

#define SO_MAX_PACING_RATE 47

#define SO_BPF_EXTENSIONS 48

#define SO_INCOMING_CPU 49

#define SO_ATTACH_BPF 50
#define SO_DETACH_BPF SO_DETACH_FILTER

#define SO_ATTACH_REUSEPORT_CBPF 51
#define SO_ATTACH_REUSEPORT_EBPF 52

#define SO_CNX_ADVICE 53
# 1 "/usr/include/arm-linux-gnueabihf/asm/socket.h" 2 3 4
# 369 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 2 3 4
# 401 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 3 4
/* Structure used to manipulate the SO_LINGER option.  */
struct linger
  {
    int l_onoff; /* Nonzero to linger on close.  */
    int l_linger; /* Time to linger.  */
  };
# 39 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 2 3 4


/* This is the 4.3 BSD `struct sockaddr' format, which is used as wire
   format in the grotty old 4.3 `talk' protocol.  */
struct osockaddr
  {
    unsigned short int sa_family;
    unsigned char sa_data[14];
  };


/* The following constants should be used for the second parameter of
   `shutdown'.  */
enum
{
  SHUT_RD = 0, /* No more receptions.  */
#define SHUT_RD SHUT_RD
  SHUT_WR, /* No more transmissions.  */
#define SHUT_WR SHUT_WR
  SHUT_RDWR /* No more receptions or transmissions.  */
#define SHUT_RDWR SHUT_RDWR
};

/* This is the type we use for generic socket address arguments.

   With GCC 2.7 and later, the funky union causes redeclarations or
   uses with any of the listed types to be allowed without complaint.
   G++ 2.7 does not support transparent unions so there we want the
   old-style declaration, too.  */




/* Add more `struct sockaddr_AF' types here as necessary.
   These are all the ones I found on NetBSD and Linux.  */
#define __SOCKADDR_ALLTYPES __SOCKADDR_ONETYPE (sockaddr) __SOCKADDR_ONETYPE (sockaddr_at) __SOCKADDR_ONETYPE (sockaddr_ax25) __SOCKADDR_ONETYPE (sockaddr_dl) __SOCKADDR_ONETYPE (sockaddr_eon) __SOCKADDR_ONETYPE (sockaddr_in) __SOCKADDR_ONETYPE (sockaddr_in6) __SOCKADDR_ONETYPE (sockaddr_inarp) __SOCKADDR_ONETYPE (sockaddr_ipx) __SOCKADDR_ONETYPE (sockaddr_iso) __SOCKADDR_ONETYPE (sockaddr_ns) __SOCKADDR_ONETYPE (sockaddr_un) __SOCKADDR_ONETYPE (sockaddr_x25)
# 89 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 3 4
#define __SOCKADDR_ONETYPE(type) struct type *__restrict __ ##type ##__;
typedef union { struct sockaddr *__restrict __sockaddr__; struct sockaddr_at *__restrict __sockaddr_at__; struct sockaddr_ax25 *__restrict __sockaddr_ax25__; struct sockaddr_dl *__restrict __sockaddr_dl__; struct sockaddr_eon *__restrict __sockaddr_eon__; struct sockaddr_in *__restrict __sockaddr_in__; struct sockaddr_in6 *__restrict __sockaddr_in6__; struct sockaddr_inarp *__restrict __sockaddr_inarp__; struct sockaddr_ipx *__restrict __sockaddr_ipx__; struct sockaddr_iso *__restrict __sockaddr_iso__; struct sockaddr_ns *__restrict __sockaddr_ns__; struct sockaddr_un *__restrict __sockaddr_un__; struct sockaddr_x25 *__restrict __sockaddr_x25__;
       } __SOCKADDR_ARG __attribute__ ((__transparent_union__));
#undef __SOCKADDR_ONETYPE
#define __SOCKADDR_ONETYPE(type) const struct type *__restrict __ ##type ##__;
typedef union { const struct sockaddr *__restrict __sockaddr__; const struct sockaddr_at *__restrict __sockaddr_at__; const struct sockaddr_ax25 *__restrict __sockaddr_ax25__; const struct sockaddr_dl *__restrict __sockaddr_dl__; const struct sockaddr_eon *__restrict __sockaddr_eon__; const struct sockaddr_in *__restrict __sockaddr_in__; const struct sockaddr_in6 *__restrict __sockaddr_in6__; const struct sockaddr_inarp *__restrict __sockaddr_inarp__; const struct sockaddr_ipx *__restrict __sockaddr_ipx__; const struct sockaddr_iso *__restrict __sockaddr_iso__; const struct sockaddr_ns *__restrict __sockaddr_ns__; const struct sockaddr_un *__restrict __sockaddr_un__; const struct sockaddr_x25 *__restrict __sockaddr_x25__;
       } __CONST_SOCKADDR_ARG __attribute__ ((__transparent_union__));
#undef __SOCKADDR_ONETYPE



/* For `recvmmsg' and `sendmmsg'.  */
struct mmsghdr
  {
    struct msghdr msg_hdr; /* Actual message header.  */
    unsigned int msg_len; /* Number of received or sent bytes for the
				   entry.  */
  };



/* Create a new socket of type TYPE in domain DOMAIN, using
   protocol PROTOCOL.  If PROTOCOL is zero, one is chosen automatically.
   Returns a file descriptor for the new socket, or -1 for errors.  */
extern int socket (int __domain, int __type, int __protocol) __attribute__ ((__nothrow__ , __leaf__));

/* Create two new sockets, of type TYPE in domain DOMAIN and using
   protocol PROTOCOL, which are connected to each other, and put file
   descriptors for them in FDS[0] and FDS[1].  If PROTOCOL is zero,
   one will be chosen automatically.  Returns 0 on success, -1 for errors.  */
extern int socketpair (int __domain, int __type, int __protocol,
         int __fds[2]) __attribute__ ((__nothrow__ , __leaf__));

/* Give the socket FD the local address ADDR (which is LEN bytes long).  */
extern int bind (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len)
     __attribute__ ((__nothrow__ , __leaf__));

/* Put the local address of FD into *ADDR and its length in *LEN.  */
extern int getsockname (int __fd, __SOCKADDR_ARG __addr,
   socklen_t *__restrict __len) __attribute__ ((__nothrow__ , __leaf__));

/* Open a connection on socket FD to peer at ADDR (which LEN bytes long).
   For connectionless socket types, just set the default address to send to
   and the only address from which to accept transmissions.
   Return 0 on success, -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int connect (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len);

/* Put the address of the peer connected to socket FD into *ADDR
   (which is *LEN bytes long), and its actual length into *LEN.  */
extern int getpeername (int __fd, __SOCKADDR_ARG __addr,
   socklen_t *__restrict __len) __attribute__ ((__nothrow__ , __leaf__));


/* Send N bytes of BUF to socket FD.  Returns the number sent or -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t send (int __fd, const void *__buf, size_t __n, int __flags);

/* Read N bytes into BUF from socket FD.
   Returns the number read or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags);

/* Send N bytes of BUF on socket FD to peer at address ADDR (which is
   ADDR_LEN bytes long).  Returns the number sent, or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t sendto (int __fd, const void *__buf, size_t __n,
         int __flags, __CONST_SOCKADDR_ARG __addr,
         socklen_t __addr_len);

/* Read N bytes into BUF through socket FD.
   If ADDR is not NULL, fill in *ADDR_LEN bytes of it with tha address of
   the sender, and store the actual size of the address in *ADDR_LEN.
   Returns the number of bytes read or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n,
    int __flags, __SOCKADDR_ARG __addr,
    socklen_t *__restrict __addr_len);


/* Send a message described MESSAGE on socket FD.
   Returns the number of bytes sent, or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t sendmsg (int __fd, const struct msghdr *__message,
   int __flags);


/* Send a VLEN messages as described by VMESSAGES to socket FD.
   Returns the number of datagrams successfully written or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int sendmmsg (int __fd, struct mmsghdr *__vmessages,
       unsigned int __vlen, int __flags);


/* Receive a message as described by MESSAGE from socket FD.
   Returns the number of bytes read or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t recvmsg (int __fd, struct msghdr *__message, int __flags);


/* Receive up to VLEN messages as described by VMESSAGES from socket FD.
   Returns the number of messages received or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int recvmmsg (int __fd, struct mmsghdr *__vmessages,
       unsigned int __vlen, int __flags,
       struct timespec *__tmo);



/* Put the current value for socket FD's option OPTNAME at protocol level LEVEL
   into OPTVAL (which is *OPTLEN bytes long), and set *OPTLEN to the value's
   actual length.  Returns 0 on success, -1 for errors.  */
extern int getsockopt (int __fd, int __level, int __optname,
         void *__restrict __optval,
         socklen_t *__restrict __optlen) __attribute__ ((__nothrow__ , __leaf__));

/* Set socket FD's option OPTNAME at protocol level LEVEL
   to *OPTVAL (which is OPTLEN bytes long).
   Returns 0 on success, -1 for errors.  */
extern int setsockopt (int __fd, int __level, int __optname,
         const void *__optval, socklen_t __optlen) __attribute__ ((__nothrow__ , __leaf__));


/* Prepare to accept connections on socket FD.
   N connection requests will be queued before further requests are refused.
   Returns 0 on success, -1 for errors.  */
extern int listen (int __fd, int __n) __attribute__ ((__nothrow__ , __leaf__));

/* Await a connection on socket FD.
   When a connection arrives, open a new socket to communicate with it,
   set *ADDR (which is *ADDR_LEN bytes long) to the address of the connecting
   peer and *ADDR_LEN to the address's actual length, and return the
   new socket's descriptor, or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int accept (int __fd, __SOCKADDR_ARG __addr,
     socklen_t *__restrict __addr_len);


/* Similar to 'accept' but takes an additional parameter to specify flags.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int accept4 (int __fd, __SOCKADDR_ARG __addr,
      socklen_t *__restrict __addr_len, int __flags);


/* Shut down all or part of the connection open on socket FD.
   HOW determines what to shut down:
     SHUT_RD   = No more receptions;
     SHUT_WR   = No more transmissions;
     SHUT_RDWR = No more receptions or transmissions.
   Returns 0 on success, -1 for errors.  */
extern int shutdown (int __fd, int __how) __attribute__ ((__nothrow__ , __leaf__));



/* Determine wheter socket is at a out-of-band mark.  */
extern int sockatmark (int __fd) __attribute__ ((__nothrow__ , __leaf__));




/* FDTYPE is S_IFSOCK or another S_IF* macro defined in <sys/stat.h>;
   returns 1 if FD is open on an object of the indicated type, 0 if not,
   or -1 for errors (setting errno).  */
extern int isfdtype (int __fd, int __fdtype) __attribute__ ((__nothrow__ , __leaf__));



/* Define some macros helping to catch buffer overflows.  */





# 121 "pifunk.c" 2
# 1 "/usr/include/arm-linux-gnueabihf/sys/ioctl.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _SYS_IOCTL_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 22 "/usr/include/arm-linux-gnueabihf/sys/ioctl.h" 2 3 4



/* Get the list of `ioctl' requests and related constants.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/ioctls.h" 1 3 4
/* Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* Use the definitions from the kernel header files.  */
# 1 "/usr/include/arm-linux-gnueabihf/asm/ioctls.h" 1 3 4

#define __ASM_ARM_IOCTLS_H 

#define FIOQSIZE 0x545E

# 1 "/usr/include/asm-generic/ioctls.h" 1 3 4

#define __ASM_GENERIC_IOCTLS_H 

# 1 "/usr/include/linux/ioctl.h" 1 3 4

#define _LINUX_IOCTL_H 

# 1 "/usr/include/arm-linux-gnueabihf/asm/ioctl.h" 1 3 4
# 1 "/usr/include/asm-generic/ioctl.h" 1 3 4

#define _ASM_GENERIC_IOCTL_H 

/* ioctl command encoding: 32 bits total, command in lower 16 bits,
 * size of the parameter structure in the lower 14 bits of the
 * upper 16 bits.
 * Encoding the size of the parameter structure in the ioctl request
 * is useful for catching programs compiled with old versions
 * and to avoid overwriting user space outside the user buffer area.
 * The highest 2 bits are reserved for indicating the ``access mode''.
 * NOTE: This limits the max parameter size to 16kB -1 !
 */

/*
 * The following is for compatibility across the various Linux
 * platforms.  The generic ioctl numbering scheme doesn't really enforce
 * a type field.  De facto, however, the top 8 bits of the lower 16
 * bits are indeed used as a type field, so we might just as well make
 * this explicit here.  Please be sure to use the decoding macros
 * below from now on.
 */
#define _IOC_NRBITS 8
#define _IOC_TYPEBITS 8

/*
 * Let any architecture override either of the following before
 * including this file.
 */


#define _IOC_SIZEBITS 14



#define _IOC_DIRBITS 2


#define _IOC_NRMASK ((1 << _IOC_NRBITS)-1)
#define _IOC_TYPEMASK ((1 << _IOC_TYPEBITS)-1)
#define _IOC_SIZEMASK ((1 << _IOC_SIZEBITS)-1)
#define _IOC_DIRMASK ((1 << _IOC_DIRBITS)-1)

#define _IOC_NRSHIFT 0
#define _IOC_TYPESHIFT (_IOC_NRSHIFT+_IOC_NRBITS)
#define _IOC_SIZESHIFT (_IOC_TYPESHIFT+_IOC_TYPEBITS)
#define _IOC_DIRSHIFT (_IOC_SIZESHIFT+_IOC_SIZEBITS)

/*
 * Direction bits, which any architecture can choose to override
 * before including this file.
 */


#define _IOC_NONE 0U



#define _IOC_WRITE 1U



#define _IOC_READ 2U


#define _IOC(dir,type,nr,size) (((dir) << _IOC_DIRSHIFT) | ((type) << _IOC_TYPESHIFT) | ((nr) << _IOC_NRSHIFT) | ((size) << _IOC_SIZESHIFT))





#define _IOC_TYPECHECK(t) (sizeof(t))

/* used to create numbers */
#define _IO(type,nr) _IOC(_IOC_NONE,(type),(nr),0)
#define _IOR(type,nr,size) _IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))
#define _IOW(type,nr,size) _IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
#define _IOWR(type,nr,size) _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
#define _IOR_BAD(type,nr,size) _IOC(_IOC_READ,(type),(nr),sizeof(size))
#define _IOW_BAD(type,nr,size) _IOC(_IOC_WRITE,(type),(nr),sizeof(size))
#define _IOWR_BAD(type,nr,size) _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))

/* used to decode ioctl numbers.. */
#define _IOC_DIR(nr) (((nr) >> _IOC_DIRSHIFT) & _IOC_DIRMASK)
#define _IOC_TYPE(nr) (((nr) >> _IOC_TYPESHIFT) & _IOC_TYPEMASK)
#define _IOC_NR(nr) (((nr) >> _IOC_NRSHIFT) & _IOC_NRMASK)
#define _IOC_SIZE(nr) (((nr) >> _IOC_SIZESHIFT) & _IOC_SIZEMASK)

/* ...and for the drivers/sound files... */

#define IOC_IN (_IOC_WRITE << _IOC_DIRSHIFT)
#define IOC_OUT (_IOC_READ << _IOC_DIRSHIFT)
#define IOC_INOUT ((_IOC_WRITE|_IOC_READ) << _IOC_DIRSHIFT)
#define IOCSIZE_MASK (_IOC_SIZEMASK << _IOC_SIZESHIFT)
#define IOCSIZE_SHIFT (_IOC_SIZESHIFT)
# 1 "/usr/include/arm-linux-gnueabihf/asm/ioctl.h" 2 3 4
# 5 "/usr/include/linux/ioctl.h" 2 3 4
# 5 "/usr/include/asm-generic/ioctls.h" 2 3 4

/*
 * These are the most common definitions for tty ioctl numbers.
 * Most of them do not use the recommended _IOC(), but there is
 * probably some source code out there hardcoding the number,
 * so we might as well use them for all new platforms.
 *
 * The architectures that use different values here typically
 * try to be compatible with some Unix variants for the same
 * architecture.
 */

/* 0x54 is just a magic number to make these relatively unique ('T') */

#define TCGETS 0x5401
#define TCSETS 0x5402
#define TCSETSW 0x5403
#define TCSETSF 0x5404
#define TCGETA 0x5405
#define TCSETA 0x5406
#define TCSETAW 0x5407
#define TCSETAF 0x5408
#define TCSBRK 0x5409
#define TCXONC 0x540A
#define TCFLSH 0x540B
#define TIOCEXCL 0x540C
#define TIOCNXCL 0x540D
#define TIOCSCTTY 0x540E
#define TIOCGPGRP 0x540F
#define TIOCSPGRP 0x5410
#define TIOCOUTQ 0x5411
#define TIOCSTI 0x5412
#define TIOCGWINSZ 0x5413
#define TIOCSWINSZ 0x5414
#define TIOCMGET 0x5415
#define TIOCMBIS 0x5416
#define TIOCMBIC 0x5417
#define TIOCMSET 0x5418
#define TIOCGSOFTCAR 0x5419
#define TIOCSSOFTCAR 0x541A
#define FIONREAD 0x541B
#define TIOCINQ FIONREAD
#define TIOCLINUX 0x541C
#define TIOCCONS 0x541D
#define TIOCGSERIAL 0x541E
#define TIOCSSERIAL 0x541F
#define TIOCPKT 0x5420
#define FIONBIO 0x5421
#define TIOCNOTTY 0x5422
#define TIOCSETD 0x5423
#define TIOCGETD 0x5424
#define TCSBRKP 0x5425
#define TIOCSBRK 0x5427
#define TIOCCBRK 0x5428
#define TIOCGSID 0x5429
#define TCGETS2 _IOR('T', 0x2A, struct termios2)
#define TCSETS2 _IOW('T', 0x2B, struct termios2)
#define TCSETSW2 _IOW('T', 0x2C, struct termios2)
#define TCSETSF2 _IOW('T', 0x2D, struct termios2)
#define TIOCGRS485 0x542E

#define TIOCSRS485 0x542F

#define TIOCGPTN _IOR('T', 0x30, unsigned int)
#define TIOCSPTLCK _IOW('T', 0x31, int)
#define TIOCGDEV _IOR('T', 0x32, unsigned int)
#define TCGETX 0x5432
#define TCSETX 0x5433
#define TCSETXF 0x5434
#define TCSETXW 0x5435
#define TIOCSIG _IOW('T', 0x36, int)
#define TIOCVHANGUP 0x5437
#define TIOCGPKT _IOR('T', 0x38, int)
#define TIOCGPTLCK _IOR('T', 0x39, int)
#define TIOCGEXCL _IOR('T', 0x40, int)

#define FIONCLEX 0x5450
#define FIOCLEX 0x5451
#define FIOASYNC 0x5452
#define TIOCSERCONFIG 0x5453
#define TIOCSERGWILD 0x5454
#define TIOCSERSWILD 0x5455
#define TIOCGLCKTRMIOS 0x5456
#define TIOCSLCKTRMIOS 0x5457
#define TIOCSERGSTRUCT 0x5458
#define TIOCSERGETLSR 0x5459
#define TIOCSERGETMULTI 0x545A
#define TIOCSERSETMULTI 0x545B

#define TIOCMIWAIT 0x545C
#define TIOCGICOUNT 0x545D

/*
 * Some arches already define FIOQSIZE due to a historical
 * conflict with a Hayes modem-specific ioctl value.
 */




/* Used for packet mode */
#define TIOCPKT_DATA 0
#define TIOCPKT_FLUSHREAD 1
#define TIOCPKT_FLUSHWRITE 2
#define TIOCPKT_STOP 4
#define TIOCPKT_START 8
#define TIOCPKT_NOSTOP 16
#define TIOCPKT_DOSTOP 32
#define TIOCPKT_IOCTL 64

#define TIOCSER_TEMT 0x01
# 7 "/usr/include/arm-linux-gnueabihf/asm/ioctls.h" 2 3 4
# 24 "/usr/include/arm-linux-gnueabihf/bits/ioctls.h" 2 3 4

/* Routing table calls.  */
#define SIOCADDRT 0x890B
#define SIOCDELRT 0x890C
#define SIOCRTMSG 0x890D

/* Socket configuration controls. */
#define SIOCGIFNAME 0x8910
#define SIOCSIFLINK 0x8911
#define SIOCGIFCONF 0x8912
#define SIOCGIFFLAGS 0x8913
#define SIOCSIFFLAGS 0x8914
#define SIOCGIFADDR 0x8915
#define SIOCSIFADDR 0x8916
#define SIOCGIFDSTADDR 0x8917
#define SIOCSIFDSTADDR 0x8918
#define SIOCGIFBRDADDR 0x8919
#define SIOCSIFBRDADDR 0x891a
#define SIOCGIFNETMASK 0x891b
#define SIOCSIFNETMASK 0x891c
#define SIOCGIFMETRIC 0x891d
#define SIOCSIFMETRIC 0x891e
#define SIOCGIFMEM 0x891f
#define SIOCSIFMEM 0x8920
#define SIOCGIFMTU 0x8921
#define SIOCSIFMTU 0x8922
#define SIOCSIFNAME 0x8923
#define SIOCSIFHWADDR 0x8924
#define SIOCGIFENCAP 0x8925
#define SIOCSIFENCAP 0x8926
#define SIOCGIFHWADDR 0x8927
#define SIOCGIFSLAVE 0x8929
#define SIOCSIFSLAVE 0x8930
#define SIOCADDMULTI 0x8931
#define SIOCDELMULTI 0x8932
#define SIOCGIFINDEX 0x8933
#define SIOGIFINDEX SIOCGIFINDEX
#define SIOCSIFPFLAGS 0x8934
#define SIOCGIFPFLAGS 0x8935
#define SIOCDIFADDR 0x8936
#define SIOCSIFHWBROADCAST 0x8937
#define SIOCGIFCOUNT 0x8938

#define SIOCGIFBR 0x8940
#define SIOCSIFBR 0x8941

#define SIOCGIFTXQLEN 0x8942
#define SIOCSIFTXQLEN 0x8943


/* ARP cache control calls. */
      /*  0x8950 - 0x8952  * obsolete calls, don't re-use */
#define SIOCDARP 0x8953
#define SIOCGARP 0x8954
#define SIOCSARP 0x8955

/* RARP cache control calls. */
#define SIOCDRARP 0x8960
#define SIOCGRARP 0x8961
#define SIOCSRARP 0x8962

/* Driver configuration calls */

#define SIOCGIFMAP 0x8970
#define SIOCSIFMAP 0x8971

/* DLCI configuration calls */

#define SIOCADDDLCI 0x8980
#define SIOCDELDLCI 0x8981

/* Device private ioctl calls.  */

/* These 16 ioctls are available to devices via the do_ioctl() device
   vector.  Each device should include this file and redefine these
   names as their own. Because these are device dependent it is a good
   idea _NOT_ to issue them to random objects and hope.  */

#define SIOCDEVPRIVATE 0x89F0

/*
 *	These 16 ioctl calls are protocol private
 */

#define SIOCPROTOPRIVATE 0x89E0
# 27 "/usr/include/arm-linux-gnueabihf/sys/ioctl.h" 2 3 4

/* Define some types used by `ioctl' requests.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/ioctl-types.h" 1 3 4
/* Structure types for pre-termios terminal ioctls.  Linux version.
   Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */





/* Get definition of constants for use with `ioctl'.  */



struct winsize
  {
    unsigned short int ws_row;
    unsigned short int ws_col;
    unsigned short int ws_xpixel;
    unsigned short int ws_ypixel;
  };

#define NCC 8
struct termio
  {
    unsigned short int c_iflag; /* input mode flags */
    unsigned short int c_oflag; /* output mode flags */
    unsigned short int c_cflag; /* control mode flags */
    unsigned short int c_lflag; /* local mode flags */
    unsigned char c_line; /* line discipline */
    unsigned char c_cc[8]; /* control characters */
};

/* modem lines */
#define TIOCM_LE 0x001
#define TIOCM_DTR 0x002
#define TIOCM_RTS 0x004
#define TIOCM_ST 0x008
#define TIOCM_SR 0x010
#define TIOCM_CTS 0x020
#define TIOCM_CAR 0x040
#define TIOCM_RNG 0x080
#define TIOCM_DSR 0x100
#define TIOCM_CD TIOCM_CAR
#define TIOCM_RI TIOCM_RNG

/* ioctl (fd, TIOCSERGETLSR, &result) where result may be as below */

/* line disciplines */
#define N_TTY 0
#define N_SLIP 1
#define N_MOUSE 2
#define N_PPP 3
#define N_STRIP 4
#define N_AX25 5
#define N_X25 6
#define N_6PACK 7
#define N_MASC 8
#define N_R3964 9
#define N_PROFIBUS_FDL 10
#define N_IRDA 11
#define N_SMSBLOCK 12
#define N_HDLC 13
#define N_SYNC_PPP 14
#define N_HCI 15
# 30 "/usr/include/arm-linux-gnueabihf/sys/ioctl.h" 2 3 4

/* On a Unix system, the system <sys/ioctl.h> probably defines some of
   the symbols we define in <sys/ttydefaults.h> (usually with the same
   values).  The code to generate <bits/ioctls.h> has omitted these
   symbols to avoid the conflict, but a Unix program expects <sys/ioctl.h>
   to define them, so we must include <sys/ttydefaults.h> here.  */
# 1 "/usr/include/arm-linux-gnueabihf/sys/ttydefaults.h" 1 3 4
/*-
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ttydefaults.h	8.4 (Berkeley) 1/21/94
 */

/*
 * System wide defaults for terminal state.  Linux version.
 */
# 90 "/usr/include/arm-linux-gnueabihf/sys/ttydefaults.h" 3 4
/*
 * #define TTYDEFCHARS to include an array of default control characters.
 */
# 37 "/usr/include/arm-linux-gnueabihf/sys/ioctl.h" 2 3 4

/* Perform the I/O control operation specified by REQUEST on FD.
   One argument may follow; its presence and type depend on REQUEST.
   Return value depends on REQUEST.  Usually -1 indicates error.  */
extern int ioctl (int __fd, unsigned long int __request, ...) __attribute__ ((__nothrow__ , __leaf__));


# 122 "pifunk.c" 2

# 1 "/usr/include/linux/spi/spidev.h" 1 3 4
/*
 * include/linux/spi/spidev.h
 *
 * Copyright (C) 2006 SWAPP
 *	Andrea Paterniani <a.paterniani@swapp-eng.it>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */


#define SPIDEV_H 

# 1 "/usr/include/linux/types.h" 1 3 4

#define _LINUX_TYPES_H 

# 1 "/usr/include/arm-linux-gnueabihf/asm/types.h" 1 3 4

#define _ASM_TYPES_H 

# 1 "/usr/include/asm-generic/int-ll64.h" 1 3 4
/*
 * asm-generic/int-ll64.h
 *
 * Integer declarations for architectures which use "long long"
 * for 64-bit types.
 */


#define _ASM_GENERIC_INT_LL64_H 

# 1 "/usr/include/arm-linux-gnueabihf/asm/bitsperlong.h" 1 3 4
# 1 "/usr/include/asm-generic/bitsperlong.h" 1 3 4

#define __ASM_GENERIC_BITS_PER_LONG 

/*
 * There seems to be no way of detecting this automatically from user
 * space, so 64 bit architectures should override this in their
 * bitsperlong.h. In particular, an architecture that supports
 * both 32 and 64 bit user space must not rely on CONFIG_64BIT
 * to decide it, but rather check a compiler provided macro.
 */

#define __BITS_PER_LONG 32
# 1 "/usr/include/arm-linux-gnueabihf/asm/bitsperlong.h" 2 3 4
# 12 "/usr/include/asm-generic/int-ll64.h" 2 3 4


/*
 * __xx is ok: it doesn't pollute the POSIX namespace. Use these in the
 * header files exported to user space
 */

typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;


__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;
# 5 "/usr/include/arm-linux-gnueabihf/asm/types.h" 2 3 4

/*
 * The C99 types uintXX_t that are usually defined in 'stdint.h' are not as
 * unambiguous on ARM as you would expect. For the types below, there is a
 * difference on ARM between GCC built for bare metal ARM, GCC built for glibc
 * and the kernel itself, which results in build errors if you try to build with
 * -ffreestanding and include 'stdint.h' (such as when you include 'arm_neon.h'
 * in order to use NEON intrinsics)
 *
 * As the typedefs for these types in 'stdint.h' are based on builtin defines
 * supplied by GCC, we can tweak these to align with the kernel's idea of those
 * types, so 'linux/types.h' and 'stdint.h' can be safely included from the same
 * source file (provided that -ffreestanding is used).
 *
 *                    int32_t         uint32_t               uintptr_t
 * bare metal GCC     long            unsigned long          unsigned int
 * glibc GCC          int             unsigned int           unsigned int
 * kernel             int             unsigned int           unsigned long
 */


#undef __INT32_TYPE__
#define __INT32_TYPE__ int



#undef __UINT32_TYPE__
#define __UINT32_TYPE__ unsigned int



#undef __UINTPTR_TYPE__
#define __UINTPTR_TYPE__ unsigned long
# 5 "/usr/include/linux/types.h" 2 3 4



# 1 "/usr/include/linux/posix_types.h" 1 3 4

#define _LINUX_POSIX_TYPES_H 

# 1 "/usr/include/linux/stddef.h" 1 3 4
# 5 "/usr/include/linux/posix_types.h" 2 3 4

/*
 * This allows for 1024 file descriptors: if NR_OPEN is ever grown
 * beyond that you'll have to change this too. But 1024 fd's seem to be
 * enough even for such "real" unices like OSF/1, so hopefully this is
 * one limit that doesn't have to be changed [again].
 *
 * Note that POSIX wants the FD_CLEAR(fd,fdsetp) defines to be in
 * <sys/time.h> (and thus <linux/time.h>) - but this is a more logical
 * place for them. Solved by having dummy defines in <sys/time.h>.
 */

/*
 * This macro may have been defined in <gnu/types.h>. But we always
 * use the one here.
 */
#undef __FD_SETSIZE
#define __FD_SETSIZE 1024

typedef struct {
 unsigned long fds_bits[1024 / (8 * sizeof(long))];
} __kernel_fd_set;

/* Type of a signal handler.  */
typedef void (*__kernel_sighandler_t)(int);

/* Type of a SYSV IPC key.  */
typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

# 1 "/usr/include/arm-linux-gnueabihf/asm/posix_types.h" 1 3 4
/*
 *  arch/arm/include/asm/posix_types.h
 *
 *  Copyright (C) 1996-1998 Russell King.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 *  Changelog:
 *   27-06-1996	RMK	Created
 */

#define __ARCH_ARM_POSIX_TYPES_H 

/*
 * This file is generally used by user-level software, so you need to
 * be a little careful about namespace pollution etc.  Also, we cannot
 * assume GCC is being used.
 */

typedef unsigned short __kernel_mode_t;
#define __kernel_mode_t __kernel_mode_t

typedef unsigned short __kernel_ipc_pid_t;
#define __kernel_ipc_pid_t __kernel_ipc_pid_t

typedef unsigned short __kernel_uid_t;
typedef unsigned short __kernel_gid_t;
#define __kernel_uid_t __kernel_uid_t

typedef unsigned short __kernel_old_dev_t;
#define __kernel_old_dev_t __kernel_old_dev_t

# 1 "/usr/include/asm-generic/posix_types.h" 1 3 4

#define __ASM_GENERIC_POSIX_TYPES_H 

# 1 "/usr/include/arm-linux-gnueabihf/asm/bitsperlong.h" 1 3 4
# 5 "/usr/include/asm-generic/posix_types.h" 2 3 4
/*
 * This file is generally used by user-level software, so you need to
 * be a little careful about namespace pollution etc.
 *
 * First the types that are often defined in different ways across
 * architectures, so that you can override them.
 */


typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;



typedef __kernel_ulong_t __kernel_ino_t;







typedef int __kernel_pid_t;
# 40 "/usr/include/asm-generic/posix_types.h" 3 4
typedef __kernel_long_t __kernel_suseconds_t;



typedef int __kernel_daddr_t;



typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;



typedef __kernel_uid_t __kernel_old_uid_t;
typedef __kernel_gid_t __kernel_old_gid_t;






/*
 * Most 32 bit architectures use "unsigned int" size_t,
 * and all 64 bit architectures use "unsigned long" size_t.
 */


typedef unsigned int __kernel_size_t;
typedef int __kernel_ssize_t;
typedef int __kernel_ptrdiff_t;
# 78 "/usr/include/asm-generic/posix_types.h" 3 4
typedef struct {
 int val[2];
} __kernel_fsid_t;


/*
 * anything below here should be completely generic
 */
typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_time_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
# 36 "/usr/include/arm-linux-gnueabihf/asm/posix_types.h" 2 3 4
# 36 "/usr/include/linux/posix_types.h" 2 3 4
# 9 "/usr/include/linux/types.h" 2 3 4


/*
 * Below are truly Linux-specific types that should never collide with
 * any application/library that wants linux/types.h.
 */




#define __bitwise__ 




#define __bitwise 


typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;

typedef __u16 __sum16;
typedef __u32 __wsum;

/*
 * aligned_u64 should be used in defining kernel<->userspace ABIs to avoid
 * common 32/64-bit compat problems.
 * 64-bit values align to 4-byte boundaries on x86_32 (and possibly other
 * architectures) and to 8-byte boundaries on 64-bit architectures.  The new
 * aligned_64 type enforces 8-byte alignment so that structs containing
 * aligned_64 values have the same alignment on 32-bit and 64-bit architectures.
 * No conversions are necessary between 32-bit user-space and a 64-bit kernel.
 */
#define __aligned_u64 __u64 __attribute__((aligned(8)))
#define __aligned_be64 __be64 __attribute__((aligned(8)))
#define __aligned_le64 __le64 __attribute__((aligned(8)))
# 26 "/usr/include/linux/spi/spidev.h" 2 3 4


/* User space versions of kernel symbols for SPI clocking modes,
 * matching <linux/spi/spi.h>
 */

#define SPI_CPHA 0x01
#define SPI_CPOL 0x02

#define SPI_MODE_0 (0|0)
#define SPI_MODE_1 (0|SPI_CPHA)
#define SPI_MODE_2 (SPI_CPOL|0)
#define SPI_MODE_3 (SPI_CPOL|SPI_CPHA)

#define SPI_CS_HIGH 0x04
#define SPI_LSB_FIRST 0x08
#define SPI_3WIRE 0x10
#define SPI_LOOP 0x20
#define SPI_NO_CS 0x40
#define SPI_READY 0x80
#define SPI_TX_DUAL 0x100
#define SPI_TX_QUAD 0x200
#define SPI_RX_DUAL 0x400
#define SPI_RX_QUAD 0x800

/*---------------------------------------------------------------------------*/

/* IOCTL commands */

#define SPI_IOC_MAGIC 'k'

/**
 * struct spi_ioc_transfer - describes a single SPI transfer
 * @tx_buf: Holds pointer to userspace buffer with transmit data, or null.
 *	If no data is provided, zeroes are shifted out.
 * @rx_buf: Holds pointer to userspace buffer for receive data, or null.
 * @len: Length of tx and rx buffers, in bytes.
 * @speed_hz: Temporary override of the device's bitrate.
 * @bits_per_word: Temporary override of the device's wordsize.
 * @delay_usecs: If nonzero, how long to delay after the last bit transfer
 *	before optionally deselecting the device before the next transfer.
 * @cs_change: True to deselect device before starting the next transfer.
 *
 * This structure is mapped directly to the kernel spi_transfer structure;
 * the fields have the same meanings, except of course that the pointers
 * are in a different address space (and may be of different sizes in some
 * cases, such as 32-bit i386 userspace over a 64-bit x86_64 kernel).
 * Zero-initialize the structure, including currently unused fields, to
 * accommodate potential future updates.
 *
 * SPI_IOC_MESSAGE gives userspace the equivalent of kernel spi_sync().
 * Pass it an array of related transfers, they'll execute together.
 * Each transfer may be half duplex (either direction) or full duplex.
 *
 *	struct spi_ioc_transfer mesg[4];
 *	...
 *	status = ioctl(fd, SPI_IOC_MESSAGE(4), mesg);
 *
 * So for example one transfer might send a nine bit command (right aligned
 * in a 16-bit word), the next could read a block of 8-bit data before
 * terminating that command by temporarily deselecting the chip; the next
 * could send a different nine bit command (re-selecting the chip), and the
 * last transfer might write some register values.
 */
struct spi_ioc_transfer {
 __u64 tx_buf;
 __u64 rx_buf;

 __u32 len;
 __u32 speed_hz;

 __u16 delay_usecs;
 __u8 bits_per_word;
 __u8 cs_change;
 __u8 tx_nbits;
 __u8 rx_nbits;
 __u16 pad;

 /* If the contents of 'struct spi_ioc_transfer' ever change
	 * incompatibly, then the ioctl number (currently 0) must change;
	 * ioctls with constant size fields get a bit more in the way of
	 * error checking than ones (like this) where that field varies.
	 *
	 * NOTE: struct layout is the same in 64bit and 32bit userspace.
	 */
};

/* not all platforms use <asm-generic/ioctl.h> or _IOC_TYPECHECK() ... */
#define SPI_MSGSIZE(N) ((((N)*(sizeof (struct spi_ioc_transfer))) < (1 << _IOC_SIZEBITS)) ? ((N)*(sizeof (struct spi_ioc_transfer))) : 0)


#define SPI_IOC_MESSAGE(N) _IOW(SPI_IOC_MAGIC, 0, char[SPI_MSGSIZE(N)])


/* Read / Write of SPI mode (SPI_MODE_0..SPI_MODE_3) (limited to 8 bits) */
#define SPI_IOC_RD_MODE _IOR(SPI_IOC_MAGIC, 1, __u8)
#define SPI_IOC_WR_MODE _IOW(SPI_IOC_MAGIC, 1, __u8)

/* Read / Write SPI bit justification */
#define SPI_IOC_RD_LSB_FIRST _IOR(SPI_IOC_MAGIC, 2, __u8)
#define SPI_IOC_WR_LSB_FIRST _IOW(SPI_IOC_MAGIC, 2, __u8)

/* Read / Write SPI device word length (1..N) */
#define SPI_IOC_RD_BITS_PER_WORD _IOR(SPI_IOC_MAGIC, 3, __u8)
#define SPI_IOC_WR_BITS_PER_WORD _IOW(SPI_IOC_MAGIC, 3, __u8)

/* Read / Write SPI device default max speed hz */
#define SPI_IOC_RD_MAX_SPEED_HZ _IOR(SPI_IOC_MAGIC, 4, __u32)
#define SPI_IOC_WR_MAX_SPEED_HZ _IOW(SPI_IOC_MAGIC, 4, __u32)

/* Read / Write of the SPI mode field */
#define SPI_IOC_RD_MODE32 _IOR(SPI_IOC_MAGIC, 5, __u32)
#define SPI_IOC_WR_MODE32 _IOW(SPI_IOC_MAGIC, 5, __u32)
# 124 "pifunk.c" 2

# 124 "pifunk.c"
//#include <missing.h>

// ip host socket
# 1 "/usr/include/arpa/inet.h" 1 3 4

# 1 "/usr/include/arpa/inet.h" 3 4
/* Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _ARPA_INET_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 22 "/usr/include/arpa/inet.h" 2 3 4
# 1 "/usr/include/netinet/in.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _NETINET_IN_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 22 "/usr/include/netinet/in.h" 2 3 4

# 1 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 1 3 4
/* Declarations of socket constants, types, and functions.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 24 "/usr/include/netinet/in.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */
# 25 "/usr/include/netinet/in.h" 2 3 4




/* Internet address.  */
typedef uint32_t in_addr_t;
struct in_addr
  {
    in_addr_t s_addr;
  };

/* Get system-specific definitions.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/in.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* Linux version.  */





/* If the application has already included linux/in6.h from a linux-based
   kernel then we will not define the IPv6 IPPROTO_* defines, in6_addr (nor the
   defines), sockaddr_in6, or ipv6_mreq. Same for in6_ptkinfo or ip6_mtuinfo
   in linux/ipv6.h. The ABI used by the linux-kernel and glibc match exactly.
   Neither the linux kernel nor glibc should break this ABI without coordination.
   In upstream kernel 56c176c9 the _UAPI prefix was stripped so we need to check
   for _LINUX_IN6_H and _IPV6_H now, and keep checking the old versions for
   maximum backwards compatibility.  */
# 41 "/usr/include/arm-linux-gnueabihf/bits/in.h" 3 4
#define __USE_KERNEL_IPV6_DEFS 0


/* Options for use with `getsockopt' and `setsockopt' at the IP level.
   The first word in the comment at the right is the data type used;
   "bool" means a boolean value stored in an `int'.  */
#define IP_OPTIONS 4
#define IP_HDRINCL 3
#define IP_TOS 1
#define IP_TTL 2
#define IP_RECVOPTS 6
/* For BSD compatibility.  */
#define IP_RECVRETOPTS IP_RETOPTS
#define IP_RETOPTS 7
#define IP_MULTICAST_IF 32
#define IP_MULTICAST_TTL 33
#define IP_MULTICAST_LOOP 34
#define IP_ADD_MEMBERSHIP 35
#define IP_DROP_MEMBERSHIP 36
#define IP_UNBLOCK_SOURCE 37
#define IP_BLOCK_SOURCE 38
#define IP_ADD_SOURCE_MEMBERSHIP 39
#define IP_DROP_SOURCE_MEMBERSHIP 40
#define IP_MSFILTER 41

#define MCAST_JOIN_GROUP 42
#define MCAST_BLOCK_SOURCE 43
#define MCAST_UNBLOCK_SOURCE 44
#define MCAST_LEAVE_GROUP 45
#define MCAST_JOIN_SOURCE_GROUP 46
#define MCAST_LEAVE_SOURCE_GROUP 47
#define MCAST_MSFILTER 48
#define IP_MULTICAST_ALL 49
#define IP_UNICAST_IF 50

#define MCAST_EXCLUDE 0
#define MCAST_INCLUDE 1


#define IP_ROUTER_ALERT 5
#define IP_PKTINFO 8
#define IP_PKTOPTIONS 9
#define IP_PMTUDISC 10
#define IP_MTU_DISCOVER 10
#define IP_RECVERR 11
#define IP_RECVTTL 12
#define IP_RECVTOS 13
#define IP_MTU 14
#define IP_FREEBIND 15
#define IP_IPSEC_POLICY 16
#define IP_XFRM_POLICY 17
#define IP_PASSSEC 18
#define IP_TRANSPARENT 19
#define IP_MULTICAST_ALL 49

/* TProxy original addresses */
#define IP_ORIGDSTADDR 20
#define IP_RECVORIGDSTADDR IP_ORIGDSTADDR

#define IP_MINTTL 21
#define IP_NODEFRAG 22
#define IP_CHECKSUM 23
#define IP_BIND_ADDRESS_NO_PORT 24

/* IP_MTU_DISCOVER arguments.  */
#define IP_PMTUDISC_DONT 0
#define IP_PMTUDISC_WANT 1
#define IP_PMTUDISC_DO 2
#define IP_PMTUDISC_PROBE 3
/* Always use interface mtu (ignores dst pmtu) but don't set DF flag.
   Also incoming ICMP frag_needed notifications will be ignored on
   this socket to prevent accepting spoofed ones.  */
#define IP_PMTUDISC_INTERFACE 4
/* Like IP_PMTUDISC_INTERFACE but allow packets to be fragmented.  */
#define IP_PMTUDISC_OMIT 5

#define IP_MULTICAST_IF 32
#define IP_MULTICAST_TTL 33
#define IP_MULTICAST_LOOP 34
#define IP_ADD_MEMBERSHIP 35
#define IP_DROP_MEMBERSHIP 36
#define IP_UNBLOCK_SOURCE 37
#define IP_BLOCK_SOURCE 38
#define IP_ADD_SOURCE_MEMBERSHIP 39
#define IP_DROP_SOURCE_MEMBERSHIP 40
#define IP_MSFILTER 41
#define IP_MULTICAST_ALL 49
#define IP_UNICAST_IF 50

/* To select the IP level.  */
#define SOL_IP 0

#define IP_DEFAULT_MULTICAST_TTL 1
#define IP_DEFAULT_MULTICAST_LOOP 1
#define IP_MAX_MEMBERSHIPS 20


/* Structure used to describe IP options for IP_OPTIONS and IP_RETOPTS.
   The `ip_dst' field is used for the first-hop gateway when using a
   source route (this gets put into the header proper).  */
struct ip_opts
  {
    struct in_addr ip_dst; /* First hop; zero without source route.  */
    char ip_opts[40]; /* Actually variable in size.  */
  };

/* Like `struct ip_mreq' but including interface specification by index.  */
struct ip_mreqn
  {
    struct in_addr imr_multiaddr; /* IP multicast address of group */
    struct in_addr imr_address; /* local IP address of interface */
    int imr_ifindex; /* Interface index */
  };

/* Structure used for IP_PKTINFO.  */
struct in_pktinfo
  {
    int ipi_ifindex; /* Interface index  */
    struct in_addr ipi_spec_dst; /* Routing destination address  */
    struct in_addr ipi_addr; /* Header destination address  */
  };


/* Options for use with `getsockopt' and `setsockopt' at the IPv6 level.
   The first word in the comment at the right is the data type used;
   "bool" means a boolean value stored in an `int'.  */
#define IPV6_ADDRFORM 1
#define IPV6_2292PKTINFO 2
#define IPV6_2292HOPOPTS 3
#define IPV6_2292DSTOPTS 4
#define IPV6_2292RTHDR 5
#define IPV6_2292PKTOPTIONS 6
#define IPV6_CHECKSUM 7
#define IPV6_2292HOPLIMIT 8

#define SCM_SRCRT IPV6_RXSRCRT

#define IPV6_NEXTHOP 9
#define IPV6_AUTHHDR 10
#define IPV6_UNICAST_HOPS 16
#define IPV6_MULTICAST_IF 17
#define IPV6_MULTICAST_HOPS 18
#define IPV6_MULTICAST_LOOP 19
#define IPV6_JOIN_GROUP 20
#define IPV6_LEAVE_GROUP 21
#define IPV6_ROUTER_ALERT 22
#define IPV6_MTU_DISCOVER 23
#define IPV6_MTU 24
#define IPV6_RECVERR 25
#define IPV6_V6ONLY 26
#define IPV6_JOIN_ANYCAST 27
#define IPV6_LEAVE_ANYCAST 28
#define IPV6_IPSEC_POLICY 34
#define IPV6_XFRM_POLICY 35
#define IPV6_HDRINCL 36

/* Advanced API (RFC3542) (1).  */
#define IPV6_RECVPKTINFO 49
#define IPV6_PKTINFO 50
#define IPV6_RECVHOPLIMIT 51
#define IPV6_HOPLIMIT 52
#define IPV6_RECVHOPOPTS 53
#define IPV6_HOPOPTS 54
#define IPV6_RTHDRDSTOPTS 55
#define IPV6_RECVRTHDR 56
#define IPV6_RTHDR 57
#define IPV6_RECVDSTOPTS 58
#define IPV6_DSTOPTS 59
#define IPV6_RECVPATHMTU 60
#define IPV6_PATHMTU 61
#define IPV6_DONTFRAG 62

/* Advanced API (RFC3542) (2).  */
#define IPV6_RECVTCLASS 66
#define IPV6_TCLASS 67

/* Obsolete synonyms for the above.  */

#define IPV6_ADD_MEMBERSHIP IPV6_JOIN_GROUP
#define IPV6_DROP_MEMBERSHIP IPV6_LEAVE_GROUP

#define IPV6_RXHOPOPTS IPV6_HOPOPTS
#define IPV6_RXDSTOPTS IPV6_DSTOPTS

/* IPV6_MTU_DISCOVER values.  */
#define IPV6_PMTUDISC_DONT 0
#define IPV6_PMTUDISC_WANT 1
#define IPV6_PMTUDISC_DO 2
#define IPV6_PMTUDISC_PROBE 3
#define IPV6_PMTUDISC_INTERFACE 4
#define IPV6_PMTUDISC_OMIT 5

/* Socket level values for IPv6.  */
#define SOL_IPV6 41
#define SOL_ICMPV6 58

/* Routing header options for IPv6.  */
#define IPV6_RTHDR_LOOSE 0
#define IPV6_RTHDR_STRICT 1

#define IPV6_RTHDR_TYPE_0 0
# 38 "/usr/include/netinet/in.h" 2 3 4

/* Standard well-defined IP protocols.  */
enum
  {
    IPPROTO_IP = 0, /* Dummy protocol for TCP.  */
#define IPPROTO_IP IPPROTO_IP
    IPPROTO_ICMP = 1, /* Internet Control Message Protocol.  */
#define IPPROTO_ICMP IPPROTO_ICMP
    IPPROTO_IGMP = 2, /* Internet Group Management Protocol. */
#define IPPROTO_IGMP IPPROTO_IGMP
    IPPROTO_IPIP = 4, /* IPIP tunnels (older KA9Q tunnels use 94).  */
#define IPPROTO_IPIP IPPROTO_IPIP
    IPPROTO_TCP = 6, /* Transmission Control Protocol.  */
#define IPPROTO_TCP IPPROTO_TCP
    IPPROTO_EGP = 8, /* Exterior Gateway Protocol.  */
#define IPPROTO_EGP IPPROTO_EGP
    IPPROTO_PUP = 12, /* PUP protocol.  */
#define IPPROTO_PUP IPPROTO_PUP
    IPPROTO_UDP = 17, /* User Datagram Protocol.  */
#define IPPROTO_UDP IPPROTO_UDP
    IPPROTO_IDP = 22, /* XNS IDP protocol.  */
#define IPPROTO_IDP IPPROTO_IDP
    IPPROTO_TP = 29, /* SO Transport Protocol Class 4.  */
#define IPPROTO_TP IPPROTO_TP
    IPPROTO_DCCP = 33, /* Datagram Congestion Control Protocol.  */
#define IPPROTO_DCCP IPPROTO_DCCP
    IPPROTO_IPV6 = 41, /* IPv6 header.  */
#define IPPROTO_IPV6 IPPROTO_IPV6
    IPPROTO_RSVP = 46, /* Reservation Protocol.  */
#define IPPROTO_RSVP IPPROTO_RSVP
    IPPROTO_GRE = 47, /* General Routing Encapsulation.  */
#define IPPROTO_GRE IPPROTO_GRE
    IPPROTO_ESP = 50, /* encapsulating security payload.  */
#define IPPROTO_ESP IPPROTO_ESP
    IPPROTO_AH = 51, /* authentication header.  */
#define IPPROTO_AH IPPROTO_AH
    IPPROTO_MTP = 92, /* Multicast Transport Protocol.  */
#define IPPROTO_MTP IPPROTO_MTP
    IPPROTO_BEETPH = 94, /* IP option pseudo header for BEET.  */
#define IPPROTO_BEETPH IPPROTO_BEETPH
    IPPROTO_ENCAP = 98, /* Encapsulation Header.  */
#define IPPROTO_ENCAP IPPROTO_ENCAP
    IPPROTO_PIM = 103, /* Protocol Independent Multicast.  */
#define IPPROTO_PIM IPPROTO_PIM
    IPPROTO_COMP = 108, /* Compression Header Protocol.  */
#define IPPROTO_COMP IPPROTO_COMP
    IPPROTO_SCTP = 132, /* Stream Control Transmission Protocol.  */
#define IPPROTO_SCTP IPPROTO_SCTP
    IPPROTO_UDPLITE = 136, /* UDP-Lite protocol.  */
#define IPPROTO_UDPLITE IPPROTO_UDPLITE
    IPPROTO_MPLS = 137, /* MPLS in IP.  */
#define IPPROTO_MPLS IPPROTO_MPLS
    IPPROTO_RAW = 255, /* Raw IP packets.  */
#define IPPROTO_RAW IPPROTO_RAW
    IPPROTO_MAX
  };

/* If __USE_KERNEL_IPV6_DEFS is 1 then the user has included the kernel
   network headers first and we should use those ABI-identical definitions
   instead of our own, otherwise 0.  */

enum
  {
    IPPROTO_HOPOPTS = 0, /* IPv6 Hop-by-Hop options.  */
#define IPPROTO_HOPOPTS IPPROTO_HOPOPTS
    IPPROTO_ROUTING = 43, /* IPv6 routing header.  */
#define IPPROTO_ROUTING IPPROTO_ROUTING
    IPPROTO_FRAGMENT = 44, /* IPv6 fragmentation header.  */
#define IPPROTO_FRAGMENT IPPROTO_FRAGMENT
    IPPROTO_ICMPV6 = 58, /* ICMPv6.  */
#define IPPROTO_ICMPV6 IPPROTO_ICMPV6
    IPPROTO_NONE = 59, /* IPv6 no next header.  */
#define IPPROTO_NONE IPPROTO_NONE
    IPPROTO_DSTOPTS = 60, /* IPv6 destination options.  */
#define IPPROTO_DSTOPTS IPPROTO_DSTOPTS
    IPPROTO_MH = 135 /* IPv6 mobility header.  */
#define IPPROTO_MH IPPROTO_MH
  };


/* Type to represent a port.  */
typedef uint16_t in_port_t;

/* Standard well-known ports.  */
enum
  {
    IPPORT_ECHO = 7, /* Echo service.  */
    IPPORT_DISCARD = 9, /* Discard transmissions service.  */
    IPPORT_SYSTAT = 11, /* System status service.  */
    IPPORT_DAYTIME = 13, /* Time of day service.  */
    IPPORT_NETSTAT = 15, /* Network status service.  */
    IPPORT_FTP = 21, /* File Transfer Protocol.  */
    IPPORT_TELNET = 23, /* Telnet protocol.  */
    IPPORT_SMTP = 25, /* Simple Mail Transfer Protocol.  */
    IPPORT_TIMESERVER = 37, /* Timeserver service.  */
    IPPORT_NAMESERVER = 42, /* Domain Name Service.  */
    IPPORT_WHOIS = 43, /* Internet Whois service.  */
    IPPORT_MTP = 57,

    IPPORT_TFTP = 69, /* Trivial File Transfer Protocol.  */
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79, /* Finger service.  */
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95, /* SUPDUP protocol.  */


    IPPORT_EXECSERVER = 512, /* execd service.  */
    IPPORT_LOGINSERVER = 513, /* rlogind service.  */
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,

    /* UDP ports.  */
    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,

    /* Ports less than this value are reserved for privileged processes.  */
    IPPORT_RESERVED = 1024,

    /* Ports greater this value are reserved for (non-privileged) servers.  */
    IPPORT_USERRESERVED = 5000
  };

/* Definitions of the bits in an Internet address integer.

   On subnets, host and network parts are found according to
   the subnet mask, not these masks.  */

#define IN_CLASSA(a) ((((in_addr_t)(a)) & 0x80000000) == 0)
#define IN_CLASSA_NET 0xff000000
#define IN_CLASSA_NSHIFT 24
#define IN_CLASSA_HOST (0xffffffff & ~IN_CLASSA_NET)
#define IN_CLASSA_MAX 128

#define IN_CLASSB(a) ((((in_addr_t)(a)) & 0xc0000000) == 0x80000000)
#define IN_CLASSB_NET 0xffff0000
#define IN_CLASSB_NSHIFT 16
#define IN_CLASSB_HOST (0xffffffff & ~IN_CLASSB_NET)
#define IN_CLASSB_MAX 65536

#define IN_CLASSC(a) ((((in_addr_t)(a)) & 0xe0000000) == 0xc0000000)
#define IN_CLASSC_NET 0xffffff00
#define IN_CLASSC_NSHIFT 8
#define IN_CLASSC_HOST (0xffffffff & ~IN_CLASSC_NET)

#define IN_CLASSD(a) ((((in_addr_t)(a)) & 0xf0000000) == 0xe0000000)
#define IN_MULTICAST(a) IN_CLASSD(a)

#define IN_EXPERIMENTAL(a) ((((in_addr_t)(a)) & 0xe0000000) == 0xe0000000)
#define IN_BADCLASS(a) ((((in_addr_t)(a)) & 0xf0000000) == 0xf0000000)

/* Address to accept any incoming messages.  */
#define INADDR_ANY ((in_addr_t) 0x00000000)
/* Address to send to all hosts.  */
#define INADDR_BROADCAST ((in_addr_t) 0xffffffff)
/* Address indicating an error return.  */
#define INADDR_NONE ((in_addr_t) 0xffffffff)

/* Network number for local host loopback.  */
#define IN_LOOPBACKNET 127
/* Address to loopback in software to local host.  */

#define INADDR_LOOPBACK ((in_addr_t) 0x7f000001)


/* Defines for Multicast INADDR.  */
#define INADDR_UNSPEC_GROUP ((in_addr_t) 0xe0000000)
#define INADDR_ALLHOSTS_GROUP ((in_addr_t) 0xe0000001)
#define INADDR_ALLRTRS_GROUP ((in_addr_t) 0xe0000002)
#define INADDR_MAX_LOCAL_GROUP ((in_addr_t) 0xe00000ff)


/* IPv6 address */
struct in6_addr
  {
    union
      {
 uint8_t __u6_addr8[16];

 uint16_t __u6_addr16[8];
 uint32_t __u6_addr32[4];

      } __in6_u;
#define s6_addr __in6_u.__u6_addr8

#define s6_addr16 __in6_u.__u6_addr16
#define s6_addr32 __in6_u.__u6_addr32

  };


extern const struct in6_addr in6addr_any; /* :: */
extern const struct in6_addr in6addr_loopback; /* ::1 */
#define IN6ADDR_ANY_INIT { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } } }
#define IN6ADDR_LOOPBACK_INIT { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 } } }

#define INET_ADDRSTRLEN 16
#define INET6_ADDRSTRLEN 46


/* Structure describing an Internet socket address.  */
struct sockaddr_in
  {
    sa_family_t sin_family;
    in_port_t sin_port; /* Port number.  */
    struct in_addr sin_addr; /* Internet address.  */

    /* Pad to size of `struct sockaddr'.  */
    unsigned char sin_zero[sizeof (struct sockaddr) -
      (sizeof (unsigned short int)) -
      sizeof (in_port_t) -
      sizeof (struct in_addr)];
  };


/* Ditto, for IPv6.  */
struct sockaddr_in6
  {
    sa_family_t sin6_family;
    in_port_t sin6_port; /* Transport layer port # */
    uint32_t sin6_flowinfo; /* IPv6 flow information */
    struct in6_addr sin6_addr; /* IPv6 address */
    uint32_t sin6_scope_id; /* IPv6 scope-id */
  };



/* IPv4 multicast request.  */
struct ip_mreq
  {
    /* IP multicast address of group.  */
    struct in_addr imr_multiaddr;

    /* Local IP address of interface.  */
    struct in_addr imr_interface;
  };

struct ip_mreq_source
  {
    /* IP multicast address of group.  */
    struct in_addr imr_multiaddr;

    /* IP address of source.  */
    struct in_addr imr_interface;

    /* IP address of interface.  */
    struct in_addr imr_sourceaddr;
  };



/* Likewise, for IPv6.  */
struct ipv6_mreq
  {
    /* IPv6 multicast address of group */
    struct in6_addr ipv6mr_multiaddr;

    /* local interface */
    unsigned int ipv6mr_interface;
  };



/* Multicast group request.  */
struct group_req
  {
    /* Interface index.  */
    uint32_t gr_interface;

    /* Group address.  */
    struct sockaddr_storage gr_group;
  };

struct group_source_req
  {
    /* Interface index.  */
    uint32_t gsr_interface;

    /* Group address.  */
    struct sockaddr_storage gsr_group;

    /* Source address.  */
    struct sockaddr_storage gsr_source;
  };


/* Full-state filter operations.  */
struct ip_msfilter
  {
    /* IP multicast address of group.  */
    struct in_addr imsf_multiaddr;

    /* Local IP address of interface.  */
    struct in_addr imsf_interface;

    /* Filter mode.  */
    uint32_t imsf_fmode;

    /* Number of source addresses.  */
    uint32_t imsf_numsrc;
    /* Source addresses.  */
    struct in_addr imsf_slist[1];
  };

#define IP_MSFILTER_SIZE(numsrc) (sizeof (struct ip_msfilter) - sizeof (struct in_addr) + (numsrc) * sizeof (struct in_addr))



struct group_filter
  {
    /* Interface index.  */
    uint32_t gf_interface;

    /* Group address.  */
    struct sockaddr_storage gf_group;

    /* Filter mode.  */
    uint32_t gf_fmode;

    /* Number of source addresses.  */
    uint32_t gf_numsrc;
    /* Source addresses.  */
    struct sockaddr_storage gf_slist[1];
};

#define GROUP_FILTER_SIZE(numsrc) (sizeof (struct group_filter) - sizeof (struct sockaddr_storage) + ((numsrc) * sizeof (struct sockaddr_storage)))





/* Functions to convert between host and network byte order.

   Please note that these functions normally take `unsigned long int' or
   `unsigned short int' values as arguments and also return them.  But
   this was a short-sighted decision since on different systems the types
   may have different representations but the values are always the same.  */

extern uint32_t ntohl (uint32_t __netlong) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint16_t ntohs (uint16_t __netshort)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint32_t htonl (uint32_t __hostlong)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint16_t htons (uint16_t __hostshort)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

# 1 "/usr/include/endian.h" 1 3 4
/* Copyright (C) 1992-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 385 "/usr/include/netinet/in.h" 2 3 4

/* Get machine dependent optimized versions of byte swapping functions.  */
# 1 "/usr/include/arm-linux-gnueabihf/bits/byteswap.h" 1 3 4
/* Macros to swap the order of bytes in integer values.
   Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 388 "/usr/include/netinet/in.h" 2 3 4


/* We can optimize calls to the conversion functions.  Either nothing has
   to be done or we are using directly the byte-swapping functions which
   often can be inlined.  */
# 402 "/usr/include/netinet/in.h" 3 4
#define ntohl(x) __bswap_32 (x)
#define ntohs(x) __bswap_16 (x)
#define htonl(x) __bswap_32 (x)
#define htons(x) __bswap_16 (x)





#define IN6_IS_ADDR_UNSPECIFIED(a) (__extension__ ({ const struct in6_addr *__a = (const struct in6_addr *) (a); __a->s6_addr32[0] == 0 && __a->s6_addr32[1] == 0 && __a->s6_addr32[2] == 0 && __a->s6_addr32[3] == 0; }))







#define IN6_IS_ADDR_LOOPBACK(a) (__extension__ ({ const struct in6_addr *__a = (const struct in6_addr *) (a); __a->s6_addr32[0] == 0 && __a->s6_addr32[1] == 0 && __a->s6_addr32[2] == 0 && __a->s6_addr32[3] == htonl (1); }))







#define IN6_IS_ADDR_LINKLOCAL(a) (__extension__ ({ const struct in6_addr *__a = (const struct in6_addr *) (a); (__a->s6_addr32[0] & htonl (0xffc00000)) == htonl (0xfe800000); }))




#define IN6_IS_ADDR_SITELOCAL(a) (__extension__ ({ const struct in6_addr *__a = (const struct in6_addr *) (a); (__a->s6_addr32[0] & htonl (0xffc00000)) == htonl (0xfec00000); }))




#define IN6_IS_ADDR_V4MAPPED(a) (__extension__ ({ const struct in6_addr *__a = (const struct in6_addr *) (a); __a->s6_addr32[0] == 0 && __a->s6_addr32[1] == 0 && __a->s6_addr32[2] == htonl (0xffff); }))






#define IN6_IS_ADDR_V4COMPAT(a) (__extension__ ({ const struct in6_addr *__a = (const struct in6_addr *) (a); __a->s6_addr32[0] == 0 && __a->s6_addr32[1] == 0 && __a->s6_addr32[2] == 0 && ntohl (__a->s6_addr32[3]) > 1; }))







#define IN6_ARE_ADDR_EQUAL(a,b) (__extension__ ({ const struct in6_addr *__a = (const struct in6_addr *) (a); const struct in6_addr *__b = (const struct in6_addr *) (b); __a->s6_addr32[0] == __b->s6_addr32[0] && __a->s6_addr32[1] == __b->s6_addr32[1] && __a->s6_addr32[2] == __b->s6_addr32[2] && __a->s6_addr32[3] == __b->s6_addr32[3]; }))
# 499 "/usr/include/netinet/in.h" 3 4
#define IN6_IS_ADDR_MULTICAST(a) (((const uint8_t *) (a))[0] == 0xff)


/* Bind socket to a privileged IP port.  */
extern int bindresvport (int __sockfd, struct sockaddr_in *__sock_in) __attribute__ ((__nothrow__ , __leaf__));

/* The IPv6 version of this function.  */
extern int bindresvport6 (int __sockfd, struct sockaddr_in6 *__sock_in)
     __attribute__ ((__nothrow__ , __leaf__));



#define IN6_IS_ADDR_MC_NODELOCAL(a) (IN6_IS_ADDR_MULTICAST(a) && ((((const uint8_t *) (a))[1] & 0xf) == 0x1))



#define IN6_IS_ADDR_MC_LINKLOCAL(a) (IN6_IS_ADDR_MULTICAST(a) && ((((const uint8_t *) (a))[1] & 0xf) == 0x2))



#define IN6_IS_ADDR_MC_SITELOCAL(a) (IN6_IS_ADDR_MULTICAST(a) && ((((const uint8_t *) (a))[1] & 0xf) == 0x5))



#define IN6_IS_ADDR_MC_ORGLOCAL(a) (IN6_IS_ADDR_MULTICAST(a) && ((((const uint8_t *) (a))[1] & 0xf) == 0x8))



#define IN6_IS_ADDR_MC_GLOBAL(a) (IN6_IS_ADDR_MULTICAST(a) && ((((const uint8_t *) (a))[1] & 0xf) == 0xe))





struct cmsghdr; /* Forward declaration.  */


/* IPv6 packet information.  */
struct in6_pktinfo
  {
    struct in6_addr ipi6_addr; /* src/dst IPv6 address */
    unsigned int ipi6_ifindex; /* send/recv interface index */
  };

/* IPv6 MTU information.  */
struct ip6_mtuinfo
  {
    struct sockaddr_in6 ip6m_addr; /* dst address including zone ID */
    uint32_t ip6m_mtu; /* path MTU in host byte order */
  };


/* Obsolete hop-by-hop and Destination Options Processing (RFC 2292).  */
extern int inet6_option_space (int __nbytes)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_init (void *__bp, struct cmsghdr **__cmsgp,
         int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_append (struct cmsghdr *__cmsg,
    const uint8_t *__typep, int __multx,
    int __plusy) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern uint8_t *inet6_option_alloc (struct cmsghdr *__cmsg, int __datalen,
        int __multx, int __plusy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_next (const struct cmsghdr *__cmsg,
         uint8_t **__tptrp)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_find (const struct cmsghdr *__cmsg,
         uint8_t **__tptrp, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


/* Hop-by-Hop and Destination Options Processing (RFC 3542).  */
extern int inet6_opt_init (void *__extbuf, socklen_t __extlen) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_append (void *__extbuf, socklen_t __extlen, int __offset,
        uint8_t __type, socklen_t __len, uint8_t __align,
        void **__databufp) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_finish (void *__extbuf, socklen_t __extlen, int __offset)
     __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_set_val (void *__databuf, int __offset, void *__val,
         socklen_t __vallen) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_next (void *__extbuf, socklen_t __extlen, int __offset,
      uint8_t *__typep, socklen_t *__lenp,
      void **__databufp) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_find (void *__extbuf, socklen_t __extlen, int __offset,
      uint8_t __type, socklen_t *__lenp,
      void **__databufp) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_get_val (void *__databuf, int __offset, void *__val,
         socklen_t __vallen) __attribute__ ((__nothrow__ , __leaf__));


/* Routing Header Option (RFC 3542).  */
extern socklen_t inet6_rth_space (int __type, int __segments) __attribute__ ((__nothrow__ , __leaf__));
extern void *inet6_rth_init (void *__bp, socklen_t __bp_len, int __type,
        int __segments) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_rth_add (void *__bp, const struct in6_addr *__addr) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_rth_reverse (const void *__in, void *__out) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_rth_segments (const void *__bp) __attribute__ ((__nothrow__ , __leaf__));
extern struct in6_addr *inet6_rth_getaddr (const void *__bp, int __index)
     __attribute__ ((__nothrow__ , __leaf__));


/* Multicast source filter support.  */

/* Get IPv4 source filter.  */
extern int getipv4sourcefilter (int __s, struct in_addr __interface_addr,
    struct in_addr __group, uint32_t *__fmode,
    uint32_t *__numsrc, struct in_addr *__slist)
     __attribute__ ((__nothrow__ , __leaf__));

/* Set IPv4 source filter.  */
extern int setipv4sourcefilter (int __s, struct in_addr __interface_addr,
    struct in_addr __group, uint32_t __fmode,
    uint32_t __numsrc,
    const struct in_addr *__slist)
     __attribute__ ((__nothrow__ , __leaf__));


/* Get source filter.  */
extern int getsourcefilter (int __s, uint32_t __interface_addr,
       const struct sockaddr *__group,
       socklen_t __grouplen, uint32_t *__fmode,
       uint32_t *__numsrc,
       struct sockaddr_storage *__slist) __attribute__ ((__nothrow__ , __leaf__));

/* Set source filter.  */
extern int setsourcefilter (int __s, uint32_t __interface_addr,
       const struct sockaddr *__group,
       socklen_t __grouplen, uint32_t __fmode,
       uint32_t __numsrc,
       const struct sockaddr_storage *__slist) __attribute__ ((__nothrow__ , __leaf__));



# 23 "/usr/include/arpa/inet.h" 2 3 4

/* Type for length arguments in socket calls.  */







/* Convert Internet host address from numbers-and-dots notation in CP
   into binary data in network byte order.  */
extern in_addr_t inet_addr (const char *__cp) __attribute__ ((__nothrow__ , __leaf__));

/* Return the local host address part of the Internet address in IN.  */
extern in_addr_t inet_lnaof (struct in_addr __in) __attribute__ ((__nothrow__ , __leaf__));

/* Make Internet host address in network byte order by combining the
   network number NET with the local address HOST.  */
extern struct in_addr inet_makeaddr (in_addr_t __net, in_addr_t __host)
     __attribute__ ((__nothrow__ , __leaf__));

/* Return network number part of the Internet address IN.  */
extern in_addr_t inet_netof (struct in_addr __in) __attribute__ ((__nothrow__ , __leaf__));

/* Extract the network number in network byte order from the address
   in numbers-and-dots natation starting at CP.  */
extern in_addr_t inet_network (const char *__cp) __attribute__ ((__nothrow__ , __leaf__));

/* Convert Internet number in IN to ASCII representation.  The return value
   is a pointer to an internal array containing the string.  */
extern char *inet_ntoa (struct in_addr __in) __attribute__ ((__nothrow__ , __leaf__));

/* Convert from presentation format of an Internet number in buffer
   starting at CP to the binary network format and store result for
   interface type AF in buffer starting at BUF.  */
extern int inet_pton (int __af, const char *__restrict __cp,
        void *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));

/* Convert a Internet address in binary network format for interface
   type AF in buffer starting at CP to presentation form and place
   result in buffer of length LEN astarting at BUF.  */
extern const char *inet_ntop (int __af, const void *__restrict __cp,
         char *__restrict __buf, socklen_t __len)
     __attribute__ ((__nothrow__ , __leaf__));


/* The following functions are not part of XNS 5.2.  */

/* Convert Internet host address from numbers-and-dots notation in CP
   into binary data and store the result in the structure INP.  */
extern int inet_aton (const char *__cp, struct in_addr *__inp) __attribute__ ((__nothrow__ , __leaf__));

/* Format a network number NET into presentation format and place result
   in buffer starting at BUF with length of LEN bytes.  */
extern char *inet_neta (in_addr_t __net, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));

/* Convert network number for interface type AF in buffer starting at
   CP to presentation format.  The result will specifiy BITS bits of
   the number.  */
extern char *inet_net_ntop (int __af, const void *__cp, int __bits,
       char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));

/* Convert network number for interface type AF from presentation in
   buffer starting at CP to network format and store result int
   buffer starting at BUF of size LEN.  */
extern int inet_net_pton (int __af, const char *__cp,
     void *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));

/* Convert ASCII representation in hexadecimal form of the Internet
   address to binary form and place result in buffer of length LEN
   starting at BUF.  */
extern unsigned int inet_nsap_addr (const char *__cp,
        unsigned char *__buf, int __len) __attribute__ ((__nothrow__ , __leaf__));

/* Convert internet address in binary form in LEN bytes starting at CP
   a presentation form and place result in BUF.  */
extern char *inet_nsap_ntoa (int __len, const unsigned char *__cp,
        char *__buf) __attribute__ ((__nothrow__ , __leaf__));



# 128 "pifunk.c" 2
# 1 "/usr/include/netinet/in.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 129 "pifunk.c" 2
# 1 "/usr/include/netinet/tcp.h" 1 3 4
/*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)tcp.h	8.1 (Berkeley) 6/10/93
 */


#define _NETINET_TCP_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 36 "/usr/include/netinet/tcp.h" 2 3 4

/*
 * User-settable options (used with setsockopt).
 */
#define TCP_NODELAY 1
#define TCP_MAXSEG 2
#define TCP_CORK 3
#define TCP_KEEPIDLE 4
#define TCP_KEEPINTVL 5
#define TCP_KEEPCNT 6
#define TCP_SYNCNT 7
#define TCP_LINGER2 8
#define TCP_DEFER_ACCEPT 9
#define TCP_WINDOW_CLAMP 10
#define TCP_INFO 11
#define TCP_QUICKACK 12
#define TCP_CONGESTION 13
#define TCP_MD5SIG 14
#define TCP_COOKIE_TRANSACTIONS 15
#define TCP_THIN_LINEAR_TIMEOUTS 16
#define TCP_THIN_DUPACK 17
#define TCP_USER_TIMEOUT 18
#define TCP_REPAIR 19
#define TCP_REPAIR_QUEUE 20
#define TCP_QUEUE_SEQ 21
#define TCP_REPAIR_OPTIONS 22
#define TCP_FASTOPEN 23
#define TCP_TIMESTAMP 24
#define TCP_NOTSENT_LOWAT 25

#define TCP_CC_INFO 26

#define TCP_SAVE_SYN 27

#define TCP_SAVED_SYN 28



# 1 "/usr/include/arm-linux-gnueabihf/sys/types.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */
# 75 "/usr/include/netinet/tcp.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 1 3 4
/* Declarations of socket constants, types, and functions.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 76 "/usr/include/netinet/tcp.h" 2 3 4

typedef u_int32_t tcp_seq;
/*
 * TCP header.
 * Per RFC 793, September, 1981.
 */
struct tcphdr
  {
    __extension__ union
    {
      struct
      {
 u_int16_t th_sport; /* source port */
 u_int16_t th_dport; /* destination port */
 tcp_seq th_seq; /* sequence number */
 tcp_seq th_ack; /* acknowledgement number */

 u_int8_t th_x2:4; /* (unused) */
 u_int8_t th_off:4; /* data offset */





 u_int8_t th_flags;
#define TH_FIN 0x01
#define TH_SYN 0x02
#define TH_RST 0x04
#define TH_PUSH 0x08
#define TH_ACK 0x10
#define TH_URG 0x20
 u_int16_t th_win; /* window */
 u_int16_t th_sum; /* checksum */
 u_int16_t th_urp; /* urgent pointer */
      };
      struct
      {
 u_int16_t source;
 u_int16_t dest;
 u_int32_t seq;
 u_int32_t ack_seq;

 u_int16_t res1:4;
 u_int16_t doff:4;
 u_int16_t fin:1;
 u_int16_t syn:1;
 u_int16_t rst:1;
 u_int16_t psh:1;
 u_int16_t ack:1;
 u_int16_t urg:1;
 u_int16_t res2:2;
# 140 "/usr/include/netinet/tcp.h" 3 4
 u_int16_t window;
 u_int16_t check;
 u_int16_t urg_ptr;
      };
    };
};

enum
{
  TCP_ESTABLISHED = 1,
  TCP_SYN_SENT,
  TCP_SYN_RECV,
  TCP_FIN_WAIT1,
  TCP_FIN_WAIT2,
  TCP_TIME_WAIT,
  TCP_CLOSE,
  TCP_CLOSE_WAIT,
  TCP_LAST_ACK,
  TCP_LISTEN,
  TCP_CLOSING /* now a valid state */
};

#define TCPOPT_EOL 0
#define TCPOPT_NOP 1
#define TCPOPT_MAXSEG 2
#define TCPOLEN_MAXSEG 4
#define TCPOPT_WINDOW 3
#define TCPOLEN_WINDOW 3
#define TCPOPT_SACK_PERMITTED 4
#define TCPOLEN_SACK_PERMITTED 2
#define TCPOPT_SACK 5
#define TCPOPT_TIMESTAMP 8
#define TCPOLEN_TIMESTAMP 10
#define TCPOLEN_TSTAMP_APPA (TCPOLEN_TIMESTAMP+2)

#define TCPOPT_TSTAMP_HDR (TCPOPT_NOP<<24|TCPOPT_NOP<<16|TCPOPT_TIMESTAMP<<8|TCPOLEN_TIMESTAMP)


/*
 * Default maximum segment size for TCP.
 * With an IP MSS of 576, this is 536,
 * but 512 is probably more convenient.
 * This should be defined as MIN(512, IP_MSS - sizeof (struct tcpiphdr)).
 */
#define TCP_MSS 512

#define TCP_MAXWIN 65535

#define TCP_MAX_WINSHIFT 14

#define SOL_TCP 6


#define TCPI_OPT_TIMESTAMPS 1
#define TCPI_OPT_SACK 2
#define TCPI_OPT_WSCALE 4
#define TCPI_OPT_ECN 8
#define TCPI_OPT_ECN_SEEN 16
#define TCPI_OPT_SYN_DATA 32

/* Values for tcpi_state.  */
enum tcp_ca_state
{
  TCP_CA_Open = 0,
  TCP_CA_Disorder = 1,
  TCP_CA_CWR = 2,
  TCP_CA_Recovery = 3,
  TCP_CA_Loss = 4
};

struct tcp_info
{
  u_int8_t tcpi_state;
  u_int8_t tcpi_ca_state;
  u_int8_t tcpi_retransmits;
  u_int8_t tcpi_probes;
  u_int8_t tcpi_backoff;
  u_int8_t tcpi_options;
  u_int8_t tcpi_snd_wscale : 4, tcpi_rcv_wscale : 4;

  u_int32_t tcpi_rto;
  u_int32_t tcpi_ato;
  u_int32_t tcpi_snd_mss;
  u_int32_t tcpi_rcv_mss;

  u_int32_t tcpi_unacked;
  u_int32_t tcpi_sacked;
  u_int32_t tcpi_lost;
  u_int32_t tcpi_retrans;
  u_int32_t tcpi_fackets;

  /* Times. */
  u_int32_t tcpi_last_data_sent;
  u_int32_t tcpi_last_ack_sent; /* Not remembered, sorry.  */
  u_int32_t tcpi_last_data_recv;
  u_int32_t tcpi_last_ack_recv;

  /* Metrics. */
  u_int32_t tcpi_pmtu;
  u_int32_t tcpi_rcv_ssthresh;
  u_int32_t tcpi_rtt;
  u_int32_t tcpi_rttvar;
  u_int32_t tcpi_snd_ssthresh;
  u_int32_t tcpi_snd_cwnd;
  u_int32_t tcpi_advmss;
  u_int32_t tcpi_reordering;

  u_int32_t tcpi_rcv_rtt;
  u_int32_t tcpi_rcv_space;

  u_int32_t tcpi_total_retrans;
};


/* For TCP_MD5SIG socket option.  */
#define TCP_MD5SIG_MAXKEYLEN 80

struct tcp_md5sig
{
  struct sockaddr_storage tcpm_addr; /* Address associated.  */
  u_int16_t __tcpm_pad1; /* Zero.  */
  u_int16_t tcpm_keylen; /* Key length.  */
  u_int32_t __tcpm_pad2; /* Zero.  */
  u_int8_t tcpm_key[80]; /* Key (binary).  */
};

/* For socket repair options.  */
struct tcp_repair_opt
{
  u_int32_t opt_code;
  u_int32_t opt_val;
};

/* Queue to repair, for TCP_REPAIR_QUEUE.  */
enum
{
  TCP_NO_QUEUE,
  TCP_RECV_QUEUE,
  TCP_SEND_QUEUE,
  TCP_QUEUES_NR,
};

/* For cookie transactions socket options.  */
#define TCP_COOKIE_MIN 8
#define TCP_COOKIE_MAX 16
#define TCP_COOKIE_PAIR_SIZE (2*TCP_COOKIE_MAX)

/* Flags for both getsockopt and setsockopt */
#define TCP_COOKIE_IN_ALWAYS (1 << 0)
#define TCP_COOKIE_OUT_NEVER (1 << 1)


/* Flags for getsockopt */
#define TCP_S_DATA_IN (1 << 2)
#define TCP_S_DATA_OUT (1 << 3)

#define TCP_MSS_DEFAULT 536U
#define TCP_MSS_DESIRED 1220U

struct tcp_cookie_transactions
{
  u_int16_t tcpct_flags;
  u_int8_t __tcpct_pad1;
  u_int8_t tcpct_cookie_desired;
  u_int16_t tcpct_s_data_desired;
  u_int16_t tcpct_used;
  u_int8_t tcpct_value[536U];
};
# 130 "pifunk.c" 2
# 1 "/usr/include/net/if.h" 1 3 4
/* net/if.h -- declarations for inquiring about network interfaces
   Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _NET_IF_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 23 "/usr/include/net/if.h" 2 3 4


# 1 "/usr/include/arm-linux-gnueabihf/sys/types.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */
# 26 "/usr/include/net/if.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 1 3 4
/* Declarations of socket constants, types, and functions.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 27 "/usr/include/net/if.h" 2 3 4



/* Length of interface name.  */
#define IF_NAMESIZE 16

struct if_nameindex
  {
    unsigned int if_index; /* 1, 2, ... */
    char *if_name; /* null terminated name: "eth0", ... */
  };



/* Standard interface flags. */
enum
  {
    IFF_UP = 0x1, /* Interface is up.  */
#define IFF_UP IFF_UP
    IFF_BROADCAST = 0x2, /* Broadcast address valid.  */
#define IFF_BROADCAST IFF_BROADCAST
    IFF_DEBUG = 0x4, /* Turn on debugging.  */
#define IFF_DEBUG IFF_DEBUG
    IFF_LOOPBACK = 0x8, /* Is a loopback net.  */
#define IFF_LOOPBACK IFF_LOOPBACK
    IFF_POINTOPOINT = 0x10, /* Interface is point-to-point link.  */
#define IFF_POINTOPOINT IFF_POINTOPOINT
    IFF_NOTRAILERS = 0x20, /* Avoid use of trailers.  */
#define IFF_NOTRAILERS IFF_NOTRAILERS
    IFF_RUNNING = 0x40, /* Resources allocated.  */
#define IFF_RUNNING IFF_RUNNING
    IFF_NOARP = 0x80, /* No address resolution protocol.  */
#define IFF_NOARP IFF_NOARP
    IFF_PROMISC = 0x100, /* Receive all packets.  */
#define IFF_PROMISC IFF_PROMISC

    /* Not supported */
    IFF_ALLMULTI = 0x200, /* Receive all multicast packets.  */
#define IFF_ALLMULTI IFF_ALLMULTI

    IFF_MASTER = 0x400, /* Master of a load balancer.  */
#define IFF_MASTER IFF_MASTER
    IFF_SLAVE = 0x800, /* Slave of a load balancer.  */
#define IFF_SLAVE IFF_SLAVE

    IFF_MULTICAST = 0x1000, /* Supports multicast.  */
#define IFF_MULTICAST IFF_MULTICAST

    IFF_PORTSEL = 0x2000, /* Can set media type.  */
#define IFF_PORTSEL IFF_PORTSEL
    IFF_AUTOMEDIA = 0x4000, /* Auto media select active.  */
#define IFF_AUTOMEDIA IFF_AUTOMEDIA
    IFF_DYNAMIC = 0x8000 /* Dialup device with changing addresses.  */
#define IFF_DYNAMIC IFF_DYNAMIC
  };

/* The ifaddr structure contains information about one address of an
   interface.  They are maintained by the different address families,
   are allocated and attached when an address is set, and are linked
   together so all addresses for an interface can be located.  */

struct ifaddr
  {
    struct sockaddr ifa_addr; /* Address of interface.  */
    union
      {
 struct sockaddr ifu_broadaddr;
 struct sockaddr ifu_dstaddr;
      } ifa_ifu;
    struct iface *ifa_ifp; /* Back-pointer to interface.  */
    struct ifaddr *ifa_next; /* Next address for interface.  */
  };

#define ifa_broadaddr ifa_ifu.ifu_broadaddr
#define ifa_dstaddr ifa_ifu.ifu_dstaddr

/* Device mapping structure. I'd just gone off and designed a
   beautiful scheme using only loadable modules with arguments for
   driver options and along come the PCMCIA people 8)

   Ah well. The get() side of this is good for WDSETUP, and it'll be
   handy for debugging things. The set side is fine for now and being
   very small might be worth keeping for clean configuration.  */

struct ifmap
  {
    unsigned long int mem_start;
    unsigned long int mem_end;
    unsigned short int base_addr;
    unsigned char irq;
    unsigned char dma;
    unsigned char port;
    /* 3 bytes spare */
  };

/* Interface request structure used for socket ioctl's.  All interface
   ioctl's must have parameter definitions which begin with ifr_name.
   The remainder may be interface specific.  */

struct ifreq
  {
#define IFHWADDRLEN 6
#define IFNAMSIZ IF_NAMESIZE
    union
      {
 char ifrn_name[16]; /* Interface name, e.g. "en0".  */
      } ifr_ifrn;

    union
      {
 struct sockaddr ifru_addr;
 struct sockaddr ifru_dstaddr;
 struct sockaddr ifru_broadaddr;
 struct sockaddr ifru_netmask;
 struct sockaddr ifru_hwaddr;
 short int ifru_flags;
 int ifru_ivalue;
 int ifru_mtu;
 struct ifmap ifru_map;
 char ifru_slave[16]; /* Just fits the size */
 char ifru_newname[16];
 __caddr_t ifru_data;
      } ifr_ifru;
  };
#define ifr_name ifr_ifrn.ifrn_name
#define ifr_hwaddr ifr_ifru.ifru_hwaddr
#define ifr_addr ifr_ifru.ifru_addr
#define ifr_dstaddr ifr_ifru.ifru_dstaddr
#define ifr_broadaddr ifr_ifru.ifru_broadaddr
#define ifr_netmask ifr_ifru.ifru_netmask
#define ifr_flags ifr_ifru.ifru_flags
#define ifr_metric ifr_ifru.ifru_ivalue
#define ifr_mtu ifr_ifru.ifru_mtu
#define ifr_map ifr_ifru.ifru_map
#define ifr_slave ifr_ifru.ifru_slave
#define ifr_data ifr_ifru.ifru_data
#define ifr_ifindex ifr_ifru.ifru_ivalue
#define ifr_bandwidth ifr_ifru.ifru_ivalue
#define ifr_qlen ifr_ifru.ifru_ivalue
#define ifr_newname ifr_ifru.ifru_newname
#define _IOT_ifreq _IOT(_IOTS(char),IFNAMSIZ,_IOTS(char),16,0,0)
#define _IOT_ifreq_short _IOT(_IOTS(char),IFNAMSIZ,_IOTS(short),1,0,0)
#define _IOT_ifreq_int _IOT(_IOTS(char),IFNAMSIZ,_IOTS(int),1,0,0)


/* Structure used in SIOCGIFCONF request.  Used to retrieve interface
   configuration for machine (useful for programs which must know all
   networks accessible).  */

struct ifconf
  {
    int ifc_len; /* Size of buffer.  */
    union
      {
 __caddr_t ifcu_buf;
 struct ifreq *ifcu_req;
      } ifc_ifcu;
  };
#define ifc_buf ifc_ifcu.ifcu_buf
#define ifc_req ifc_ifcu.ifcu_req
#define _IOT_ifconf _IOT(_IOTS(struct ifconf),1,0,0,0,0)




/* Convert an interface name to an index, and vice versa.  */
extern unsigned int if_nametoindex (const char *__ifname) __attribute__ ((__nothrow__ , __leaf__));
extern char *if_indextoname (unsigned int __ifindex, char *__ifname) __attribute__ ((__nothrow__ , __leaf__));

/* Return a list of all interfaces and their indices.  */
extern struct if_nameindex *if_nameindex (void) __attribute__ ((__nothrow__ , __leaf__));

/* Free the data returned from if_nameindex.  */
extern void if_freenameindex (struct if_nameindex *__ptr) __attribute__ ((__nothrow__ , __leaf__));


# 131 "pifunk.c" 2
# 1 "/usr/include/netdb.h" 1 3 4
  /* Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* All data returned by the network data base library are supplied in
   host order and returned in network order (suitable for use in
   system calls).  */


#define _NETDB_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 26 "/usr/include/netdb.h" 2 3 4

# 1 "/usr/include/netinet/in.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 28 "/usr/include/netdb.h" 2 3 4


/* This is necessary to make this include file properly replace the
   Sun version.  */
# 1 "/usr/include/rpc/netdb.h" 1 3 4
/* @(#)netdb.h	2.1 88/07/29 3.9 RPCSRC */
/*
 * Copyright (c) 2010, Oracle America, Inc.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the "Oracle America, Inc." nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* Cleaned up for GNU C library roland@gnu.ai.mit.edu:
   added multiple inclusion protection and use of <sys/cdefs.h>.
   In GNU this file is #include'd by <netdb.h>.  */


#define _RPC_NETDB_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 40 "/usr/include/rpc/netdb.h" 2 3 4

#define __need_size_t 
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 160 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 347 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
#undef __need_wchar_t
# 362 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/lib/gcc/arm-linux-gnueabihf/6/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 43 "/usr/include/rpc/netdb.h" 2 3 4



struct rpcent
{
  char *r_name; /* Name of server for this rpc program.  */
  char **r_aliases; /* Alias list.  */
  int r_number; /* RPC program number.  */
};

extern void setrpcent (int __stayopen) __attribute__ ((__nothrow__ , __leaf__));
extern void endrpcent (void) __attribute__ ((__nothrow__ , __leaf__));
extern struct rpcent *getrpcbyname (const char *__name) __attribute__ ((__nothrow__ , __leaf__));
extern struct rpcent *getrpcbynumber (int __number) __attribute__ ((__nothrow__ , __leaf__));
extern struct rpcent *getrpcent (void) __attribute__ ((__nothrow__ , __leaf__));


extern int getrpcbyname_r (const char *__name, struct rpcent *__result_buf,
      char *__buffer, size_t __buflen,
      struct rpcent **__result) __attribute__ ((__nothrow__ , __leaf__));

extern int getrpcbynumber_r (int __number, struct rpcent *__result_buf,
        char *__buffer, size_t __buflen,
        struct rpcent **__result) __attribute__ ((__nothrow__ , __leaf__));

extern int getrpcent_r (struct rpcent *__result_buf, char *__buffer,
   size_t __buflen, struct rpcent **__result) __attribute__ ((__nothrow__ , __leaf__));



# 33 "/usr/include/netdb.h" 2 3 4



#define __need_sigevent_t 
# 1 "/usr/include/arm-linux-gnueabihf/bits/siginfo.h" 1 3 4
/* siginfo_t, sigevent and constants.  Linux version.
   Copyright (C) 1997-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






# 1 "/usr/include/arm-linux-gnueabihf/bits/wordsize.h" 1 3 4
/* Copyright (C) 1999-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#define __WORDSIZE 32
# 25 "/usr/include/arm-linux-gnueabihf/bits/siginfo.h" 2 3 4
# 38 "/usr/include/netdb.h" 2 3 4
#define __need_timespec 
# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 40 "/usr/include/netdb.h" 2 3 4


# 1 "/usr/include/arm-linux-gnueabihf/bits/netdb.h" 1 3 4
/* Copyright (C) 1996-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */






/* Description of data base entry for a single network.  NOTE: here a
   poor assumption is made.  The network number is expected to fit
   into an unsigned long int variable.  */
struct netent
{
  char *n_name; /* Official name of network.  */
  char **n_aliases; /* Alias list.  */
  int n_addrtype; /* Net address type.  */
  uint32_t n_net; /* Network number.  */
};
# 43 "/usr/include/netdb.h" 2 3 4

/* Absolute file name for network data base files.  */
#define _PATH_HEQUIV "/etc/hosts.equiv"
#define _PATH_HOSTS "/etc/hosts"
#define _PATH_NETWORKS "/etc/networks"
#define _PATH_NSSWITCH_CONF "/etc/nsswitch.conf"
#define _PATH_PROTOCOLS "/etc/protocols"
#define _PATH_SERVICES "/etc/services"





/* Error status for non-reentrant lookup functions.
   We use a macro to access always the thread-specific `h_errno' variable.  */
#define h_errno (*__h_errno_location ())

/* Function to get address of global `h_errno' variable.  */
extern int *__h_errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


/* Possible values left in `h_errno'.  */
#define HOST_NOT_FOUND 1
#define TRY_AGAIN 2

#define NO_RECOVERY 3

#define NO_DATA 4



#define NETDB_INTERNAL -1
#define NETDB_SUCCESS 0
#define NO_ADDRESS NO_DATA



/* Highest reserved Internet port number.  */
#define IPPORT_RESERVED 1024



/* Scope delimiter for getaddrinfo(), getnameinfo().  */
#define SCOPE_DELIMITER '%'



/* Print error indicated by `h_errno' variable on standard error.  STR
   if non-null is printed before the error string.  */
extern void herror (const char *__str) __attribute__ ((__nothrow__ , __leaf__));

/* Return string associated with error ERR_NUM.  */
extern const char *hstrerror (int __err_num) __attribute__ ((__nothrow__ , __leaf__));



/* Description of data base entry for a single host.  */
struct hostent
{
  char *h_name; /* Official name of host.  */
  char **h_aliases; /* Alias list.  */
  int h_addrtype; /* Host address type.  */
  int h_length; /* Length of address.  */
  char **h_addr_list; /* List of addresses from name server.  */

#define h_addr h_addr_list[0]

};

/* Open host data base files and mark them as staying open even after
   a later search if STAY_OPEN is non-zero.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void sethostent (int __stay_open);

/* Close host data base files and clear `stay open' flag.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void endhostent (void);

/* Get next entry from host data base file.  Open data base if
   necessary.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct hostent *gethostent (void);

/* Return entry from host data base which address match ADDR with
   length LEN and type TYPE.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct hostent *gethostbyaddr (const void *__addr, __socklen_t __len,
          int __type);

/* Return entry from host data base for host with NAME.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct hostent *gethostbyname (const char *__name);


/* Return entry from host data base for host with NAME.  AF must be
   set to the address type which is `AF_INET' for IPv4 or `AF_INET6'
   for IPv6.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern struct hostent *gethostbyname2 (const char *__name, int __af);

/* Reentrant versions of the functions above.  The additional
   arguments specify a buffer of BUFLEN starting at BUF.  The last
   argument is a pointer to a variable which gets the value which
   would be stored in the global variable `herrno' by the
   non-reentrant functions.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern int gethostent_r (struct hostent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct hostent **__restrict __result,
    int *__restrict __h_errnop);

extern int gethostbyaddr_r (const void *__restrict __addr, __socklen_t __len,
       int __type,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname_r (const char *__restrict __name,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname2_r (const char *__restrict __name, int __af,
        struct hostent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct hostent **__restrict __result,
        int *__restrict __h_errnop);



/* Open network data base files and mark them as staying open even
   after a later search if STAY_OPEN is non-zero.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void setnetent (int __stay_open);

/* Close network data base files and clear `stay open' flag.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void endnetent (void);

/* Get next entry from network data base file.  Open data base if
   necessary.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct netent *getnetent (void);

/* Return entry from network data base which address match NET and
   type TYPE.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct netent *getnetbyaddr (uint32_t __net, int __type);

/* Return entry from network data base for network with NAME.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct netent *getnetbyname (const char *__name);


/* Reentrant versions of the functions above.  The additional
   arguments specify a buffer of BUFLEN starting at BUF.  The last
   argument is a pointer to a variable which gets the value which
   would be stored in the global variable `herrno' by the
   non-reentrant functions.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern int getnetent_r (struct netent *__restrict __result_buf,
   char *__restrict __buf, size_t __buflen,
   struct netent **__restrict __result,
   int *__restrict __h_errnop);

extern int getnetbyaddr_r (uint32_t __net, int __type,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);

extern int getnetbyname_r (const char *__restrict __name,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);



/* Description of data base entry for a single service.  */
struct servent
{
  char *s_name; /* Official service name.  */
  char **s_aliases; /* Alias list.  */
  int s_port; /* Port number.  */
  char *s_proto; /* Protocol to use.  */
};

/* Open service data base files and mark them as staying open even
   after a later search if STAY_OPEN is non-zero.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void setservent (int __stay_open);

/* Close service data base files and clear `stay open' flag.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void endservent (void);

/* Get next entry from service data base file.  Open data base if
   necessary.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct servent *getservent (void);

/* Return entry from network data base for network with NAME and
   protocol PROTO.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct servent *getservbyname (const char *__name, const char *__proto);

/* Return entry from service data base which matches port PORT and
   protocol PROTO.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct servent *getservbyport (int __port, const char *__proto);



/* Reentrant versions of the functions above.  The additional
   arguments specify a buffer of BUFLEN starting at BUF.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern int getservent_r (struct servent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct servent **__restrict __result);

extern int getservbyname_r (const char *__restrict __name,
       const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);

extern int getservbyport_r (int __port, const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);



/* Description of data base entry for a single service.  */
struct protoent
{
  char *p_name; /* Official protocol name.  */
  char **p_aliases; /* Alias list.  */
  int p_proto; /* Protocol number.  */
};

/* Open protocol data base files and mark them as staying open even
   after a later search if STAY_OPEN is non-zero.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void setprotoent (int __stay_open);

/* Close protocol data base files and clear `stay open' flag.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void endprotoent (void);

/* Get next entry from protocol data base file.  Open data base if
   necessary.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct protoent *getprotoent (void);

/* Return entry from protocol data base for network with NAME.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct protoent *getprotobyname (const char *__name);

/* Return entry from protocol data base which number is PROTO.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern struct protoent *getprotobynumber (int __proto);



/* Reentrant versions of the functions above.  The additional
   arguments specify a buffer of BUFLEN starting at BUF.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern int getprotoent_r (struct protoent *__restrict __result_buf,
     char *__restrict __buf, size_t __buflen,
     struct protoent **__restrict __result);

extern int getprotobyname_r (const char *__restrict __name,
        struct protoent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct protoent **__restrict __result);

extern int getprotobynumber_r (int __proto,
          struct protoent *__restrict __result_buf,
          char *__restrict __buf, size_t __buflen,
          struct protoent **__restrict __result);


/* Establish network group NETGROUP for enumeration.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int setnetgrent (const char *__netgroup);

/* Free all space allocated by previous `setnetgrent' call.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern void endnetgrent (void);

/* Get next member of netgroup established by last `setnetgrent' call
   and return pointers to elements in HOSTP, USERP, and DOMAINP.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int getnetgrent (char **__restrict __hostp,
   char **__restrict __userp,
   char **__restrict __domainp);


/* Test whether NETGROUP contains the triple (HOST,USER,DOMAIN).

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int innetgr (const char *__netgroup, const char *__host,
      const char *__user, const char *__domain);

/* Reentrant version of `getnetgrent' where result is placed in BUFFER.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int getnetgrent_r (char **__restrict __hostp,
     char **__restrict __userp,
     char **__restrict __domainp,
     char *__restrict __buffer, size_t __buflen);




/* Call `rshd' at port RPORT on remote machine *AHOST to execute CMD.
   The local user is LOCUSER, on the remote machine the command is
   executed as REMUSER.  In *FD2P the descriptor to the socket for the
   connection is returned.  The caller must have the right to use a
   reserved port.  When the function returns *AHOST contains the
   official host name.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int rcmd (char **__restrict __ahost, unsigned short int __rport,
   const char *__restrict __locuser,
   const char *__restrict __remuser,
   const char *__restrict __cmd, int *__restrict __fd2p);

/* This is the equivalent function where the protocol can be selected
   and which therefore can be used for IPv6.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int rcmd_af (char **__restrict __ahost, unsigned short int __rport,
      const char *__restrict __locuser,
      const char *__restrict __remuser,
      const char *__restrict __cmd, int *__restrict __fd2p,
      sa_family_t __af);

/* Call `rexecd' at port RPORT on remote machine *AHOST to execute
   CMD.  The process runs at the remote machine using the ID of user
   NAME whose cleartext password is PASSWD.  In *FD2P the descriptor
   to the socket for the connection is returned.  When the function
   returns *AHOST contains the official host name.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int rexec (char **__restrict __ahost, int __rport,
    const char *__restrict __name,
    const char *__restrict __pass,
    const char *__restrict __cmd, int *__restrict __fd2p);

/* This is the equivalent function where the protocol can be selected
   and which therefore can be used for IPv6.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int rexec_af (char **__restrict __ahost, int __rport,
       const char *__restrict __name,
       const char *__restrict __pass,
       const char *__restrict __cmd, int *__restrict __fd2p,
       sa_family_t __af);

/* Check whether user REMUSER on system RHOST is allowed to login as LOCUSER.
   If SUSER is not zero the user tries to become superuser.  Return 0 if
   it is possible.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int ruserok (const char *__rhost, int __suser,
      const char *__remuser, const char *__locuser);

/* This is the equivalent function where the protocol can be selected
   and which therefore can be used for IPv6.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int ruserok_af (const char *__rhost, int __suser,
         const char *__remuser, const char *__locuser,
         sa_family_t __af);

/* Check whether user REMUSER on system indicated by IPv4 address
   RADDR is allowed to login as LOCUSER.  Non-IPv4 (e.g., IPv6) are
   not supported.  If SUSER is not zero the user tries to become
   superuser.  Return 0 if it is possible.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int iruserok (uint32_t __raddr, int __suser,
       const char *__remuser, const char *__locuser);

/* This is the equivalent function where the pfamiliy if the address
   pointed to by RADDR is determined by the value of AF.  It therefore
   can be used for IPv6

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int iruserok_af (const void *__raddr, int __suser,
   const char *__remuser, const char *__locuser,
   sa_family_t __af);

/* Try to allocate reserved port, returning a descriptor for a socket opened
   at this port or -1 if unsuccessful.  The search for an available port
   will start at ALPORT and continues with lower numbers.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int rresvport (int *__alport);

/* This is the equivalent function where the protocol can be selected
   and which therefore can be used for IPv6.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int rresvport_af (int *__alport, sa_family_t __af);



/* Extension from POSIX.1:2001.  */

/* Structure to contain information about address of a service provider.  */
struct addrinfo
{
  int ai_flags; /* Input flags.  */
  int ai_family; /* Protocol family for socket.  */
  int ai_socktype; /* Socket type.  */
  int ai_protocol; /* Protocol for socket.  */
  socklen_t ai_addrlen; /* Length of socket address.  */
  struct sockaddr *ai_addr; /* Socket address for socket.  */
  char *ai_canonname; /* Canonical name for service location.  */
  struct addrinfo *ai_next; /* Pointer to next in list.  */
};


/* Structure used as control block for asynchronous lookup.  */
struct gaicb
{
  const char *ar_name; /* Name to look up.  */
  const char *ar_service; /* Service name.  */
  const struct addrinfo *ar_request; /* Additional request specification.  */
  struct addrinfo *ar_result; /* Pointer to result.  */
  /* The following are internal elements.  */
  int __return;
  int __glibc_reserved[5];
};

/* Lookup mode.  */
#define GAI_WAIT 0
#define GAI_NOWAIT 1


/* Possible values for `ai_flags' field in `addrinfo' structure.  */
#define AI_PASSIVE 0x0001
#define AI_CANONNAME 0x0002
#define AI_NUMERICHOST 0x0004
#define AI_V4MAPPED 0x0008
#define AI_ALL 0x0010
#define AI_ADDRCONFIG 0x0020


#define AI_IDN 0x0040


#define AI_CANONIDN 0x0080
#define AI_IDN_ALLOW_UNASSIGNED 0x0100

#define AI_IDN_USE_STD3_ASCII_RULES 0x0200


#define AI_NUMERICSERV 0x0400

/* Error values for `getaddrinfo' function.  */
#define EAI_BADFLAGS -1
#define EAI_NONAME -2
#define EAI_AGAIN -3
#define EAI_FAIL -4
#define EAI_FAMILY -6
#define EAI_SOCKTYPE -7
#define EAI_SERVICE -8
#define EAI_MEMORY -10
#define EAI_SYSTEM -11
#define EAI_OVERFLOW -12

#define EAI_NODATA -5
#define EAI_ADDRFAMILY -9
#define EAI_INPROGRESS -100
#define EAI_CANCELED -101
#define EAI_NOTCANCELED -102
#define EAI_ALLDONE -103
#define EAI_INTR -104
#define EAI_IDN_ENCODE -105



#define NI_MAXHOST 1025
#define NI_MAXSERV 32


#define NI_NUMERICHOST 1
#define NI_NUMERICSERV 2
#define NI_NOFQDN 4
#define NI_NAMEREQD 8
#define NI_DGRAM 16

#define NI_IDN 32
#define NI_IDN_ALLOW_UNASSIGNED 64

#define NI_IDN_USE_STD3_ASCII_RULES 128



/* Translate name of a service location and/or a service name to set of
   socket addresses.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int getaddrinfo (const char *__restrict __name,
   const char *__restrict __service,
   const struct addrinfo *__restrict __req,
   struct addrinfo **__restrict __pai);

/* Free `addrinfo' structure AI including associated storage.  */
extern void freeaddrinfo (struct addrinfo *__ai) __attribute__ ((__nothrow__ , __leaf__));

/* Convert error return from getaddrinfo() to a string.  */
extern const char *gai_strerror (int __ecode) __attribute__ ((__nothrow__ , __leaf__));

/* Translate a socket address to a location and service name.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int getnameinfo (const struct sockaddr *__restrict __sa,
   socklen_t __salen, char *__restrict __host,
   socklen_t __hostlen, char *__restrict __serv,
   socklen_t __servlen, int __flags);



/* Enqueue ENT requests from the LIST.  If MODE is GAI_WAIT wait until all
   requests are handled.  If WAIT is GAI_NOWAIT return immediately after
   queueing the requests and signal completion according to SIG.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int getaddrinfo_a (int __mode, struct gaicb *__list[__restrict],
     int __ent, struct sigevent *__restrict __sig);

/* Suspend execution of the thread until at least one of the ENT requests
   in LIST is handled.  If TIMEOUT is not a null pointer it specifies the
   longest time the function keeps waiting before returning with an error.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int gai_suspend (const struct gaicb *const __list[], int __ent,
   const struct timespec *__timeout);

/* Get the error status of the request REQ.  */
extern int gai_error (struct gaicb *__req) __attribute__ ((__nothrow__ , __leaf__));

/* Cancel the requests associated with GAICBP.  */
extern int gai_cancel (struct gaicb *__gaicbp) __attribute__ ((__nothrow__ , __leaf__));



# 132 "pifunk.c" 2
# 1 "/usr/include/ifaddrs.h" 1 3 4
/* ifaddrs.h -- declarations for getting network interface addresses
   Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */


#define _IFADDRS_H 1

# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 23 "/usr/include/ifaddrs.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 1 3 4
/* Declarations of socket constants, types, and functions.
   Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 24 "/usr/include/ifaddrs.h" 2 3 4



/* The `getifaddrs' function generates a linked list of these structures.
   Each element of the list describes one network interface.  */
struct ifaddrs
{
  struct ifaddrs *ifa_next; /* Pointer to the next structure.  */

  char *ifa_name; /* Name of this network interface.  */
  unsigned int ifa_flags; /* Flags as from SIOCGIFFLAGS ioctl.  */

  struct sockaddr *ifa_addr; /* Network address of this interface.  */
  struct sockaddr *ifa_netmask; /* Netmask of this interface.  */
  union
  {
    /* At most one of the following two is valid.  If the IFF_BROADCAST
       bit is set in `ifa_flags', then `ifa_broadaddr' is valid.  If the
       IFF_POINTOPOINT bit is set, then `ifa_dstaddr' is valid.
       It is never the case that both these bits are set at once.  */
    struct sockaddr *ifu_broadaddr; /* Broadcast address of this interface. */
    struct sockaddr *ifu_dstaddr; /* Point-to-point destination address.  */
  } ifa_ifu;
  /* These very same macros are defined by <net/if.h> for `struct ifaddr'.
     So if they are defined already, the existing definitions will be fine.  */







  void *ifa_data; /* Address-specific data (may be unused).  */
};


/* Create a linked list of `struct ifaddrs' structures, one for each
   network interface on the host machine.  If successful, store the
   list in *IFAP and return 0.  On errors, return -1 and set `errno'.

   The storage returned in *IFAP is allocated dynamically and can
   only be properly freed by passing it to `freeifaddrs'.  */
extern int getifaddrs (struct ifaddrs **__ifap) __attribute__ ((__nothrow__ , __leaf__));

/* Reclaim the storage allocated by a previous `getifaddrs' call.  */
extern void freeifaddrs (struct ifaddrs *__ifa) __attribute__ ((__nothrow__ , __leaf__));


# 133 "pifunk.c" 2


# 134 "pifunk.c"
//for c++11/14/17
/*
#include <iostream.h>
#include <sstream.h>
#include <threads.h>
#include <cstdlib.h>
#include <csignal.h>
#include <cmath.h>
#include <cstdint.h>
#include <iomanip.h>
#include <algorithm.h>
#include <vector.h>
#include <stdalign.h>
#include <stdnoreturn.h>
#include <stdatomic.h>
#include <uchar.h>
#include <cstring.h>
using namespace std;
*/

// windows (10) if needed for maybe rpi3
/*
#include <windows.h>
#include <win.h>
#include <windef.h>
#include <winnt.h>
#include <winbase.h>
#include <conio.h> // dos-header
*/

// broadcom arm processor for mapping phys. addresses
# 1 "bcm2835/src/bcm2835.h" 1
/* bcm2835.h
  
   C and C++ support for Broadcom BCM 2835 as used in Raspberry Pi
  
   Author: Mike McCauley
   Copyright (C) 2011-2013 Mike McCauley
   $Id: bcm2835.h,v 1.23 2018/01/16 21:55:07 mikem Exp mikem $
*/

/*! \mainpage C library for Broadcom BCM 2835 as used in Raspberry Pi
  
  This is a C library for Raspberry Pi (RPi). It provides access to 
  GPIO and other IO functions on the Broadcom BCM 2835 chip, as used in the RaspberryPi,
  allowing access to the GPIO pins on the
  26 pin IDE plug on the RPi board so you can control and interface with various external devices.
  
  It provides functions for reading digital inputs and setting digital outputs, using SPI and I2C,
  and for accessing the system timers.
  Pin event detection is supported by polling (interrupts are not supported).
  
  It is C++ compatible, and installs as a header file and non-shared library on 
  any Linux-based distro (but clearly is no use except on Raspberry Pi or another board with 
  BCM 2835).
  
  The version of the package that this documentation refers to can be downloaded 
  from http://www.airspayce.com/mikem/bcm2835/bcm2835-1.55.tar.gz
  You can find the latest version at http://www.airspayce.com/mikem/bcm2835
  
  Several example programs are provided.
  
  Based on data in http://elinux.org/RPi_Low-level_peripherals and 
  http://www.raspberrypi.org/wp-content/uploads/2012/02/BCM2835-ARM-Peripherals.pdf
  and http://www.scribd.com/doc/101830961/GPIO-Pads-Control2
  
  You can also find online help and discussion at http://groups.google.com/group/bcm2835
  Please use that group for all questions and discussions on this topic. 
  Do not contact the author directly, unless it is to discuss commercial licensing.
  Before asking a question or reporting a bug, please read 
  - http://en.wikipedia.org/wiki/Wikipedia:Reference_desk/How_to_ask_a_software_question
  - http://www.catb.org/esr/faqs/smart-questions.html
  - http://www.chiark.greenend.org.uk/~shgtatham/bugs.html
  
  Tested on debian6-19-04-2012, 2012-07-15-wheezy-raspbian, 2013-07-26-wheezy-raspbian
  and Occidentalisv01, 2016-02-09 Raspbian Jessie.
  CAUTION: it has been observed that when detect enables such as bcm2835_gpio_len() 
  are used and the pin is pulled LOW
  it can cause temporary hangs on 2012-07-15-wheezy-raspbian, 2013-07-26-wheezy-raspbian
  and Occidentalisv01.
  Reason for this is not yet determined, but we suspect that an interrupt handler is
  hitting a hard loop on those OSs.
  If you must use bcm2835_gpio_len() and friends, make sure you disable the pins with 
  bcm2835_gpio_clr_len() and friends after use. 
  
  \par Running as root

  Prior to the release of Raspbian Jessie in Feb 2016, access to any
  peripheral device via /dev/mem on the RPi required the process to
  run as root. Raspbian Jessie permits non-root users to access the
  GPIO peripheral (only) via /dev/gpiomem, and this library supports
  that limited mode of operation.

  If the library runs with effective UID of 0 (ie root), then
  bcm2835_init() will attempt to open /dev/mem, and, if successful, it
  will permit use of all peripherals and library functions.

  If the library runs with any other effective UID (ie not root), then
  bcm2835_init() will attempt to open /dev/gpiomem, and, if
  successful, will only permit GPIO operations. In particular,
  bcm2835_spi_begin() and bcm2835_i2c_begin() will return false and all
  other non-gpio operations may fail silently or crash.

  \par Installation
  
  This library consists of a single non-shared library and header file, which will be
  installed in the usual places by make install
  
  \code
  # download the latest version of the library, say bcm2835-1.xx.tar.gz, then:
  tar zxvf bcm2835-1.xx.tar.gz
  cd bcm2835-1.xx
  ./configure
  make
  sudo make check
  sudo make install
  \endcode
  
  \par Physical Addresses
  
  The functions bcm2835_peri_read(), bcm2835_peri_write() and bcm2835_peri_set_bits() 
  are low level peripheral register access functions. They are designed to use
  physical addresses as described in section 1.2.3 ARM physical addresses
  of the BCM2835 ARM Peripherals manual. 
  Physical addresses range from 0x20000000 to 0x20FFFFFF for peripherals. The bus
  addresses for peripherals are set up to map onto the peripheral bus address range starting at
  0x7E000000. Thus a peripheral advertised in the manual at bus address 0x7Ennnnnn is available at
  physical address 0x20nnnnnn.
  
  On RPI 2, the peripheral addresses are different and the bcm2835 library gets them 
  from reading /proc/device-tree/soc/ranges. This is only availble with recent versions of the kernel on RPI 2.
  
  After initialisation, the base address of the various peripheral 
  registers are available with the following
  externals:
  bcm2835_gpio
  bcm2835_pwm
  bcm2835_clk
  bcm2835_pads
  bcm2835_spio0
  bcm2835_st
  bcm2835_bsc0
  bcm2835_bsc1
  bcm2835_aux
  bcm2835_spi1

  \par Raspberry Pi 2 (RPI2)

  For this library to work correctly on RPI2, you MUST have the device tree support enabled in the kernel.
  You should also ensure you are using the latest version of Linux. The library has been tested on RPI2
  with 2015-02-16-raspbian-wheezy and ArchLinuxARM-rpi-2 as of 2015-03-29.

  When device tree suport is enabled, the file /proc/device-tree/soc/ranges will appear in the file system, 
  and the bcm2835 module relies on its presence to correctly run on RPI2 (it is optional for RPI1). 
  Without device tree support enabled and the presence of this file, it will not work on RPI2.

  To enable device tree support:

  \code
  sudo raspi-config
   under Advanced Options - enable Device Tree
   Reboot.
  \endcode
  
  \par Pin Numbering
  
  The GPIO pin numbering as used by RPi is different to and inconsistent with the underlying 
  BCM 2835 chip pin numbering. http://elinux.org/RPi_BCM2835_GPIOs
   
  RPi has a 26 pin IDE header that provides access to some of the GPIO pins on the BCM 2835,
  as well as power and ground pins. Not all GPIO pins on the BCM 2835 are available on the 
  IDE header.
  
  RPi Version 2 also has a P5 connector with 4 GPIO pins, 5V, 3.3V and Gnd.
  
  The functions in this library are designed to be passed the BCM 2835 GPIO pin number and _not_ 
  the RPi pin number. There are symbolic definitions for each of the available pins
  that you should use for convenience. See \ref RPiGPIOPin.
  
  \par SPI Pins
   
  The bcm2835_spi_* functions allow you to control the BCM 2835 SPI0 interface, 
  allowing you to send and received data by SPI (Serial Peripheral Interface).
  For more information about SPI, see http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus
  
  When bcm2835_spi_begin() is called it changes the bahaviour of the SPI interface pins from their 
  default GPIO behaviour in order to support SPI. While SPI is in use, you will not be able 
  to control the state of the SPI pins through the usual bcm2835_spi_gpio_write().
  When bcm2835_spi_end() is called, the SPI pins will all revert to inputs, and can then be
  configured and controled with the usual bcm2835_gpio_* calls.
  
  The Raspberry Pi GPIO pins used for SPI are:
   
  - P1-19 (MOSI)
  - P1-21 (MISO) 
  - P1-23 (CLK) 
  - P1-24 (CE0) 
  - P1-26 (CE1)

  Although it is possible to select high speeds for the SPI interface, up to 125MHz (see bcm2835_spi_setClockDivider())
  you should not expect to actually achieve those sorts of speeds with the RPi wiring. Our tests on RPi 2 show that the
  SPI CLK line when unloaded has a resonant frequency of about 40MHz, and when loaded, the MOSI and MISO lines
  ring at an even lower frequency. Measurements show that SPI waveforms are very poor and unusable at 62 and 125MHz.
  Dont expect any speed faster than 31MHz to work reliably.

  The bcm2835_aux_spi_* functions allow you to control the BCM 2835 SPI1 interface,
  allowing you to send and received data by SPI (Serial Peripheral Interface).

  The Raspberry Pi GPIO pins used for AUX SPI (SPI1) are:

  - P1-38 (MOSI)
  - P1-35 (MISO)
  - P1-40 (CLK)
  - P1-36 (CE2)

  \par I2C Pins
  
  The bcm2835_i2c_* functions allow you to control the BCM 2835 BSC interface,
  allowing you to send and received data by I2C ("eye-squared cee"; generically referred to as "two-wire interface") .
  For more information about I?C, see http://en.wikipedia.org/wiki/I%C2%B2C
  
  The Raspberry Pi V2 GPIO pins used for I2C are:
  
  - P1-03 (SDA)
  - P1-05 (SLC)
  
  \par PWM
  
  The BCM2835 supports hardware PWM on a limited subset of GPIO pins. This bcm2835 library provides 
  functions for configuring and controlling PWM output on these pins.
  
  The BCM2835 contains 2 independent PWM channels (0 and 1), each of which be connnected to a limited subset of 
  GPIO pins. The following GPIO pins may be connected to the following PWM channels (from section 9.5):
  \code
  GPIO PIN    RPi pin  PWM Channel    ALT FUN
  12                    0            0
  13                    1            0
  18         1-12       0            5
  19                    1            5
  40                    0            0
  41                    1            0
  45                    1            0
  52                    0            1
  53                    1            1
  \endcode
  In order for a GPIO pin to emit output from its PWM channel, it must be set to the Alt Function given above.
  Note carefully that current versions of the Raspberry Pi only expose one of these pins (GPIO 18 = RPi Pin 1-12)
  on the IO headers, and therefore this is the only IO pin on the RPi that can be used for PWM.
  Further it must be set to ALT FUN 5 to get PWM output.
  
  Both PWM channels are driven by the same PWM clock, whose clock dvider can be varied using 
  bcm2835_pwm_set_clock(). Each channel can be separately enabled with bcm2835_pwm_set_mode().
  The average output of the PWM channel is determined by the ratio of DATA/RANGE for that channel.
  Use bcm2835_pwm_set_range() to set the range and bcm2835_pwm_set_data() to set the data in that ratio
  
  Each PWM channel can run in either Balanced or Mark-Space mode. In Balanced mode, the hardware 
  sends a combination of clock pulses that results in an overall DATA pulses per RANGE pulses.
  In Mark-Space mode, the hardware sets the output HIGH for DATA clock pulses wide, followed by 
  LOW for RANGE-DATA clock pulses. 
  
  The PWM clock can be set to control the PWM pulse widths. The PWM clock is derived from 
  a 19.2MHz clock. You can set any divider, but some common ones are provided by the BCM2835_PWM_CLOCK_DIVIDER_*
  values of \ref bcm2835PWMClockDivider.
   
  For example, say you wanted to drive a DC motor with PWM at about 1kHz, 
  and control the speed in 1/1024 increments from 
  0/1024 (stopped) through to 1024/1024 (full on). In that case you might set the 
  clock divider to be 16, and the RANGE to 1024. The pulse repetition frequency will be
  1.2MHz/1024 = 1171.875Hz.
  
  \par Interactions with other systems
 
  In order for bcm2835 library SPI to work, you may need to disable the SPI kernel module using:

  \code
  sudo raspi-config
   under Advanced Options - enable Device Tree
   under Advanced Options - disable SPI
   Reboot.
  \endcode

  Since bcm2835 accesses the lowest level hardware interfaces (in eh intererests of speed and flexibility)
  there can be intercations with other low level software trying to do similar things.

  It seems that with "latest" 8.0 Jessie 4.9.24-v7+ kernel PWM just won't 
  work unless you disable audio. There's a line
  \code
  dtparam=audio=on
  \endcode
  in the /boot/config.txt. 
  Comment it out like this:
  \code
  #dtparam=audio=on
  \endcode

  \par Real Time performance constraints
  
  The bcm2835 is a library for user programs (i.e. they run in 'userland'). 
  Such programs are not part of the kernel and are usually
  subject to paging and swapping by the kernel while it does other things besides running your program. 
  This means that you should not expect to get real-time performance or 
  real-time timing constraints from such programs. In particular, there is no guarantee that the 
  bcm2835_delay() and bcm2835_delayMicroseconds() will return after exactly the time requested. 
  In fact, depending on other activity on the host, IO etc, you might get significantly longer delay times
  than the one you asked for. So please dont expect to get exactly the time delay you request.
  
  Arjan reports that you can prevent swapping on Linux with the following code fragment:
  
  \code
  #define <sched.h>
  #define <sys/mman.h>

  struct sched_param sp;
  memset(&sp, 0, sizeof(sp));
  sp.sched_priority = sched_get_priority_max(SCHED_FIFO);
  sched_setscheduler(0, SCHED_FIFO, &sp);
  mlockall(MCL_CURRENT | MCL_FUTURE);
  \endcode
  
  \par Bindings to other languages
  
  mikem has made Perl bindings available at CPAN:
  http://search.cpan.org/~mikem/Device-BCM2835-1.9/lib/Device/BCM2835.pm
  Matthew Baker has kindly made Python bindings available at:
  https:  github.com/mubeta06/py-libbcm2835
  Gary Marks has created a Serial Peripheral Interface (SPI) command-line utility 
  for Raspberry Pi, based on the bcm2835 library. The 
  utility, spincl, is licensed under Open Source GNU GPLv3 by iP Solutions (http://ipsolutionscorp.com), as a 
  free download with source included: http://ipsolutionscorp.com/raspberry-pi-spi-utility/
  
  \par Open Source Licensing GPL V2
  
  This is the appropriate option if you want to share the source code of your
  application with everyone you distribute it to, and you also want to give them
  the right to share who uses it. If you wish to use this software under Open
  Source Licensing, you must contribute all your source code to the open source
  community in accordance with the GPL Version 2 when your application is
  distributed. See https://www.gnu.org/licenses/gpl-2.0.html and COPYING
  
  \par Commercial Licensing

 This is the appropriate option if you are creating proprietary applications
 and you are not prepared to distribute and share the source code of your
 application. Purchase commercial licenses at http://airspayce.binpress.com

  \par Acknowledgements
  
  Some of this code has been inspired by Dom and Gert.
  The I2C code has been inspired by Alan Barr.
   
  \par Revision History
  
  \version 1.0 Initial release

  \version 1.1 Minor bug fixes

  \version 1.2 Added support for SPI

  \version 1.3 Added bcm2835_spi_transfern()

  \version 1.4 Fixed a problem that prevented SPI CE1 being used. Reported by David Robinson.

  \version 1.5 Added bcm2835_close() to deinit the library. Suggested by C?sar Ortiz

  \version 1.6 Document testing on 2012-07-15-wheezy-raspbian and Occidentalisv01
  Functions bcm2835_gpio_ren(), bcm2835_gpio_fen(), bcm2835_gpio_hen()
  bcm2835_gpio_len(), bcm2835_gpio_aren() and bcm2835_gpio_afen() now 
  changes only the pin specified. Other pins that were already previously
  enabled stay enabled.
  Added  bcm2835_gpio_clr_ren(), bcm2835_gpio_clr_fen(), bcm2835_gpio_clr_hen()
  bcm2835_gpio_clr_len(), bcm2835_gpio_clr_aren(), bcm2835_gpio_clr_afen() 
  to clear the enable for individual pins, suggested by Andreas Sundstrom.

  \version 1.7 Added bcm2835_spi_transfernb to support different buffers for read and write.

  \version 1.8 Improvements to read barrier, as suggested by maddin.

  \version 1.9 Improvements contributed by mikew: 
  I noticed that it was mallocing memory for the mmaps on /dev/mem.
  It's not necessary to do that, you can just mmap the file directly,
  so I've removed the mallocs (and frees).
  I've also modified delayMicroseconds() to use nanosleep() for long waits,
  and a busy wait on a high resolution timer for the rest. This is because
  I've found that calling nanosleep() takes at least 100-200 us.
  You need to link using '-lrt' using this version.
  I've added some unsigned casts to the debug prints to silence compiler
  warnings I was getting, fixed some typos, and changed the value of
  BCM2835_PAD_HYSTERESIS_ENABLED to 0x08 as per Gert van Loo's doc at
  http://www.scribd.com/doc/101830961/GPIO-Pads-Control2
  Also added a define for the passwrd value that Gert says is needed to
  change pad control settings.

  \version 1.10 Changed the names of the delay functions to bcm2835_delay() 
  and bcm2835_delayMicroseconds() to prevent collisions with wiringPi.
  Macros to map delay()-> bcm2835_delay() and
  Macros to map delayMicroseconds()-> bcm2835_delayMicroseconds(), which
  can be disabled by defining BCM2835_NO_DELAY_COMPATIBILITY

  \version 1.11 Fixed incorrect link to download file

  \version 1.12 New GPIO pin definitions for RPi version 2 (which has a different GPIO mapping)             

  \version 1.13 New GPIO pin definitions for RPi version 2 plug P5
  Hardware base pointers are now available (after initialisation) externally as bcm2835_gpio
  bcm2835_pwm bcm2835_clk bcm2835_pads bcm2835_spi0.

  \version 1.14 Now compiles even if CLOCK_MONOTONIC_RAW is not available, uses CLOCK_MONOTONIC instead.
  Fixed errors in documentation of SPI divider frequencies based on 250MHz clock. 
  Reported by Ben Simpson.

  \version 1.15 Added bcm2835_close() to end of examples as suggested by Mark Wolfe.

  \version 1.16 Added bcm2835_gpio_set_multi, bcm2835_gpio_clr_multi and bcm2835_gpio_write_multi
  to allow a mask of pins to be set all at once. Requested by Sebastian Loncar.

  \version 1.17  Added bcm2835_gpio_write_mask. Requested by Sebastian Loncar.

  \version 1.18 Added bcm2835_i2c_* functions. Changes to bcm2835_delayMicroseconds: 
  now uses the RPi system timer counter, instead of clock_gettime, for improved accuracy. 
  No need to link with -lrt now. Contributed by Arjan van Vught.
  \version 1.19 Removed inlines added by previous patch since they don't seem to work everywhere. 
  Reported by olly.

  \version 1.20 Patch from Mark Dootson to close /dev/mem after access to the peripherals has been granted.

  \version 1.21 delayMicroseconds is now not susceptible to 32 bit timer overruns. 
  Patch courtesy Jeremy Mortis.

  \version 1.22 Fixed incorrect definition of BCM2835_GPFEN0 which broke the ability to set 
  falling edge events. Reported by Mark Dootson.

  \version 1.23 Added bcm2835_i2c_set_baudrate and bcm2835_i2c_read_register_rs. 
  Improvements to bcm2835_i2c_read and bcm2835_i2c_write functions
  to fix ocasional reads not completing. Patched by Mark Dootson.

  \version 1.24 Mark Dootson p[atched a problem with his previously submitted code
  under high load from other processes. 

  \version 1.25 Updated author and distribution location details to airspayce.com

  \version 1.26 Added missing unmapmem for pads in bcm2835_close to prevent a memory leak. 
  Reported by Hartmut Henkel.

  \version 1.27 bcm2835_gpio_set_pad() no longer needs BCM2835_PAD_PASSWRD: it is
  now automatically included.
  Added suport for PWM mode with bcm2835_pwm_* functions.

  \version 1.28 Fixed a problem where bcm2835_spi_writenb() would have problems with transfers of more than
  64 bytes dues to read buffer filling. Patched by Peter Würtz.

  \version 1.29 Further fix to SPI from Peter Würtz.

  \version 1.30 10 microsecond delays from bcm2835_spi_transfer and bcm2835_spi_transfern for
  significant performance improvements, Patch by Alan Watson.

  \version 1.31 Fix a GCC warning about dummy variable, patched by Alan Watson. Thanks.

  \version 1.32 Added option I2C_V1 definition to compile for version 1 RPi. 
  By default I2C code is generated for the V2 RPi which has SDA1 and SCL1 connected.
  Contributed by Malcolm Wiles based on work by Arvi Govindaraj.

  \version 1.33 Added command line utilities i2c and gpio to examples. Contributed by Shahrooz Shahparnia.

  \version 1.34 Added bcm2835_i2c_write_read_rs() which writes an arbitrary number of bytes, 
  sends a repeat start, and reads from the device. Contributed by Eduardo Steinhorst.

  \version 1.35 Fix build errors when compiled under Qt. Also performance improvements with SPI transfers. Contributed b Udo Klaas.

  \version 1.36 Make automake's test runner detect that we're skipping tests when not root, the second
  one makes us skip the test when using fakeroot (as used when building
  Debian packages). Contributed by Guido Günther.

  \version 1.37 Moved confiure.in to configure.ac as receommnded by autoreconf.<br>
  Improvements to bcm2835_st_read to account for possible timer overflow, contributed by 'Ed'.<br>
  Added definitions for Raspberry Pi B+ J8 header GPIO pins.<br>

  \version 1.38 Added bcm2835_regbase for the benefit of C# wrappers, patch by Frank Hommers <br>

  \version 1.39 Beta version of RPi2 compatibility. Not tested here on RPi2 hardware. 
  Testers please confirm correct operation on RPi2.<br>
  Unneccessary 'volatile' qualifiers removed from all variables and signatures.<br>
  Removed unsupportable PWM dividers, based on a report from Christophe Cecillon.<br>
  Minor improvements to spi.c example.<br>

  \version 1.40 Correct operation on RPi2 has been confirmed.<br>
  Fixed a number of compiler errors and warnings that occur when bcm2835.h is included
  in code compiled with -Wall -Woverflow -Wstrict-overflow -Wshadow -Wextra -pedantic.
  Reported by tlhackque.<br>
  Fixed a problem where calling bcm2835_delayMicroseconds loops forever when debug is set. Reported by tlhackque.<br>
  Reinstated use of volatile in 2 functions where there was a danger of lost reads or writes. Reported by tlhackque.<br>
  
  \version 1.41 Added BCM2835_VERSION macro and new function bcm2835_version(); Requested by tlhackque.<br>
  Improvements to peripheral memory barriers as suggested by tlhackque.<br>
  Reinstated some necessary volatile declarations as requested by tlhackque.<br>

  \version 1.42 Further improvements to memory barriers with the patient assistance and patches of tlhackque.<br>

  \version 1.43 Fixed problems with compiling barriers on RPI 2 with Arch Linux and gcc 4.9.2. 
  Reported and patched by Lars Christensen.<br>
  Testing on RPI 2, with ArchLinuxARM-rpi-2-latest and 2015-02-16-raspbian-wheezy.<br>

  \version 1.44 Added documention about the need for device tree to be enabled on RPI2.<br>
  Improvements to detection of availablity of DMB instruction based on value of __ARM_ARCH macro.<br>

  \version 1.45 Fixed an error in the pad group offsets that would prevent bcm2835_gpio_set_pad() 
  and bcm2835_gpio_pad() working correctly with non-0 pad groups. Reported by Guido.

  \version 1.46 2015-09-18
  Added symbolic definitions for remaining pins on 40 pin GPIO header on RPi 2. <br>

  \version 1.47 2015-11-18
  Fixed possibly incorrect reads in bcm2835_i2c_read_register_rs, patch from Eckhardt Ulrich.<br>

  \version 1.48 2015-12-08
  Added patch from Eckhardt Ulrich that fixed problems that could cause hanging with bcm2835_i2c_read_register_rs
  and others.

  \version 1.49 2016-01-05
  Added patch from Jonathan Perkin with new functions bcm2835_gpio_eds_multi() and bcm2835_gpio_set_eds_multi().

  \version 1.50 2016-02-28
  Added support for running as non-root, permitting access to GPIO only. Functions
  bcm2835_spi_begin() and bcm2835_i2c_begin() will now return 0 if not running as root 
  (which prevents access to the SPI and I2C peripherals, amongst others). 
  Testing on Raspbian Jessie.

  \version 1.51 2016-11-03
  Added documentation about SPI clock divider and resulting SPI speeds on RPi3.
  Fixed a problem where seg fault could occur in bcm2835_delayMicroseconds() if not running as root. Patch from Pok.

  \version 1.52 2017-02-03
  Added link to commercial license purchasing.

  \version 1.53 2018-01-14
  Added support for AUX SPI (SPI1)
  Contributed by Arjan van Vught (http://www.raspberrypi-dmx.org/)

  \version 1.54 2018-01-17
  Fixed compile errors in new AUX spi code under some circumstances.

  \version 1.55 2018-01-20
  Fixed version numbers.
  Fixed some warnings.

  \author  Mike McCauley (mikem@airspayce.com) DO NOT CONTACT THE AUTHOR DIRECTLY: USE THE LISTS
*/


/* Defines for BCM2835 */

#define BCM2835_H 



#define BCM2835_VERSION 10055

/* RPi 2 is ARM v7, and has DMB instruction for memory barriers.
   Older RPis are ARM v6 and don't, so a coprocessor instruction must be used instead.
   However, not all versions of gcc in all distros support the dmb assembler instruction even on conmpatible processors.
   This test is so any ARMv7 or higher processors with suitable GCC will use DMB.
*/




/*! \defgroup constants Constants for passing to and from library functions
  The values here are designed to be passed to various functions in the bcm2835 library.
  @{
*/

/*! This means pin HIGH, true, 3.3volts on a pin. */
#define HIGH 0x1
/*! This means pin LOW, false, 0volts on a pin. */
#define LOW 0x0

/*! Return the minimum of 2 numbers */

#define MIN(a,b) (a < b ? a : b)


/*! Speed of the core clock core_clk */
#define BCM2835_CORE_CLK_HZ 250000000

/*! On RPi2 with BCM2836, and all recent OSs, the base of the peripherals is read from a /proc file */
#define BMC2835_RPI2_DT_FILENAME "/proc/device-tree/soc/ranges"
/*! Offset into BMC2835_RPI2_DT_FILENAME for the peripherals base address */
#define BMC2835_RPI2_DT_PERI_BASE_ADDRESS_OFFSET 4
/*! Offset into BMC2835_RPI2_DT_FILENAME for the peripherals size address */
#define BMC2835_RPI2_DT_PERI_SIZE_OFFSET 8

/*! Physical addresses for various peripheral register sets
  Base Physical Address of the BCM 2835 peripheral registers
  Note this is different for the RPi2 BCM2836, where this is derived from /proc/device-tree/soc/ranges
  If /proc/device-tree/soc/ranges exists on a RPi 1 OS, it would be expected to contain the
  following numbers:
*/
/*! Peripherals block base address on RPi 1 */
#define BCM2835_PERI_BASE 0x20000000
/*! Size of the peripherals block on RPi 1 */
#define BCM2835_PERI_SIZE 0x01000000

/*! Offsets for the bases of various peripherals within the peripherals block
  /   Base Address of the System Timer registers
*/
#define BCM2835_ST_BASE 0x3000
/*! Base Address of the Pads registers */
#define BCM2835_GPIO_PADS 0x100000
/*! Base Address of the Clock/timer registers */
#define BCM2835_CLOCK_BASE 0x101000
/*! Base Address of the GPIO registers */
#define BCM2835_GPIO_BASE 0x200000
/*! Base Address of the SPI0 registers */
#define BCM2835_SPI0_BASE 0x204000
/*! Base Address of the BSC0 registers */
#define BCM2835_BSC0_BASE 0x205000
/*! Base Address of the PWM registers */
#define BCM2835_GPIO_PWM 0x20C000
/*! Base Address of the AUX registers */
#define BCM2835_AUX_BASE 0x215000
/*! Base Address of the AUX_SPI1 registers */
#define BCM2835_SPI1_BASE 0x215080
/*! Base Address of the AUX_SPI2 registers */
#define BCM2835_SPI2_BASE 0x2150C0
/*! Base Address of the BSC1 registers */
#define BCM2835_BSC1_BASE 0x804000


/*! Physical address and size of the peripherals block
  May be overridden on RPi2
*/
extern uint32_t *bcm2835_peripherals_base;
/*! Size of the peripherals block to be mapped */
extern uint32_t bcm2835_peripherals_size;

/*! Virtual memory address of the mapped peripherals block */
extern uint32_t *bcm2835_peripherals;

/*! Base of the ST (System Timer) registers.
  Available after bcm2835_init has been called (as root)
*/
extern volatile uint32_t *bcm2835_st;

/*! Base of the GPIO registers.
  Available after bcm2835_init has been called
*/
extern volatile uint32_t *bcm2835_gpio;

/*! Base of the PWM registers.
  Available after bcm2835_init has been called (as root)
*/
extern volatile uint32_t *bcm2835_pwm;

/*! Base of the CLK registers.
  Available after bcm2835_init has been called (as root)
*/
extern volatile uint32_t *bcm2835_clk;

/*! Base of the PADS registers.
  Available after bcm2835_init has been called (as root)
*/
extern volatile uint32_t *bcm2835_pads;

/*! Base of the SPI0 registers.
  Available after bcm2835_init has been called (as root)
*/
extern volatile uint32_t *bcm2835_spi0;

/*! Base of the BSC0 registers.
  Available after bcm2835_init has been called (as root)
*/
extern volatile uint32_t *bcm2835_bsc0;

/*! Base of the BSC1 registers.
  Available after bcm2835_init has been called (as root)
*/
extern volatile uint32_t *bcm2835_bsc1;

/*! Base of the AUX registers.
  Available after bcm2835_init has been called (as root)
*/
extern volatile uint32_t *bcm2835_aux;

/*! Base of the SPI1 registers.
  Available after bcm2835_init has been called (as root)
*/
extern volatile uint32_t *bcm2835_spi1;


/*! \brief bcm2835RegisterBase
  Register bases for bcm2835_regbase()
*/
typedef enum
{
    BCM2835_REGBASE_ST = 1, /*!< Base of the ST (System Timer) registers. */
    BCM2835_REGBASE_GPIO = 2, /*!< Base of the GPIO registers. */
    BCM2835_REGBASE_PWM = 3, /*!< Base of the PWM registers. */
    BCM2835_REGBASE_CLK = 4, /*!< Base of the CLK registers. */
    BCM2835_REGBASE_PADS = 5, /*!< Base of the PADS registers. */
    BCM2835_REGBASE_SPI0 = 6, /*!< Base of the SPI0 registers. */
    BCM2835_REGBASE_BSC0 = 7, /*!< Base of the BSC0 registers. */
    BCM2835_REGBASE_BSC1 = 8, /*!< Base of the BSC1 registers. */
 BCM2835_REGBASE_AUX = 9, /*!< Base of the AUX registers. */
 BCM2835_REGBASE_SPI1 = 10 /*!< Base of the SPI1 registers. */
} bcm2835RegisterBase;

/*! Size of memory page on RPi */
#define BCM2835_PAGE_SIZE (4*1024)
/*! Size of memory block on RPi */
#define BCM2835_BLOCK_SIZE (4*1024)


/* Defines for GPIO
   The BCM2835 has 54 GPIO pins.
   BCM2835 data sheet, Page 90 onwards.
*/
/*! GPIO register offsets from BCM2835_GPIO_BASE. 
  Offsets into the GPIO Peripheral block in bytes per 6.1 Register View 
*/
#define BCM2835_GPFSEL0 0x0000
#define BCM2835_GPFSEL1 0x0004
#define BCM2835_GPFSEL2 0x0008
#define BCM2835_GPFSEL3 0x000c
#define BCM2835_GPFSEL4 0x0010
#define BCM2835_GPFSEL5 0x0014
#define BCM2835_GPSET0 0x001c
#define BCM2835_GPSET1 0x0020
#define BCM2835_GPCLR0 0x0028
#define BCM2835_GPCLR1 0x002c
#define BCM2835_GPLEV0 0x0034
#define BCM2835_GPLEV1 0x0038
#define BCM2835_GPEDS0 0x0040
#define BCM2835_GPEDS1 0x0044
#define BCM2835_GPREN0 0x004c
#define BCM2835_GPREN1 0x0050
#define BCM2835_GPFEN0 0x0058
#define BCM2835_GPFEN1 0x005c
#define BCM2835_GPHEN0 0x0064
#define BCM2835_GPHEN1 0x0068
#define BCM2835_GPLEN0 0x0070
#define BCM2835_GPLEN1 0x0074
#define BCM2835_GPAREN0 0x007c
#define BCM2835_GPAREN1 0x0080
#define BCM2835_GPAFEN0 0x0088
#define BCM2835_GPAFEN1 0x008c
#define BCM2835_GPPUD 0x0094
#define BCM2835_GPPUDCLK0 0x0098
#define BCM2835_GPPUDCLK1 0x009c

/*!   \brief bcm2835PortFunction
  Port function select modes for bcm2835_gpio_fsel()
*/
typedef enum
{
    BCM2835_GPIO_FSEL_INPT = 0x00, /*!< Input 0b000 */
    BCM2835_GPIO_FSEL_OUTP = 0x01, /*!< Output 0b001 */
    BCM2835_GPIO_FSEL_ALT0 = 0x04, /*!< Alternate function 0 0b100 */
    BCM2835_GPIO_FSEL_ALT1 = 0x05, /*!< Alternate function 1 0b101 */
    BCM2835_GPIO_FSEL_ALT2 = 0x06, /*!< Alternate function 2 0b110, */
    BCM2835_GPIO_FSEL_ALT3 = 0x07, /*!< Alternate function 3 0b111 */
    BCM2835_GPIO_FSEL_ALT4 = 0x03, /*!< Alternate function 4 0b011 */
    BCM2835_GPIO_FSEL_ALT5 = 0x02, /*!< Alternate function 5 0b010 */
    BCM2835_GPIO_FSEL_MASK = 0x07 /*!< Function select bits mask 0b111 */
} bcm2835FunctionSelect;

/*! \brief bcm2835PUDControl
  Pullup/Pulldown defines for bcm2835_gpio_pud()
*/
typedef enum
{
    BCM2835_GPIO_PUD_OFF = 0x00, /*!< Off ? disable pull-up/down 0b00 */
    BCM2835_GPIO_PUD_DOWN = 0x01, /*!< Enable Pull Down control 0b01 */
    BCM2835_GPIO_PUD_UP = 0x02 /*!< Enable Pull Up control 0b10  */
} bcm2835PUDControl;

/*! Pad control register offsets from BCM2835_GPIO_PADS */
#define BCM2835_PADS_GPIO_0_27 0x002c
#define BCM2835_PADS_GPIO_28_45 0x0030
#define BCM2835_PADS_GPIO_46_53 0x0034

/*! Pad Control masks */
#define BCM2835_PAD_PASSWRD (0x5A << 24)
#define BCM2835_PAD_SLEW_RATE_UNLIMITED 0x10
#define BCM2835_PAD_HYSTERESIS_ENABLED 0x08
#define BCM2835_PAD_DRIVE_2mA 0x00
#define BCM2835_PAD_DRIVE_4mA 0x01
#define BCM2835_PAD_DRIVE_6mA 0x02
#define BCM2835_PAD_DRIVE_8mA 0x03
#define BCM2835_PAD_DRIVE_10mA 0x04
#define BCM2835_PAD_DRIVE_12mA 0x05
#define BCM2835_PAD_DRIVE_14mA 0x06
#define BCM2835_PAD_DRIVE_16mA 0x07

/*! \brief bcm2835PadGroup
  Pad group specification for bcm2835_gpio_pad()
*/
typedef enum
{
    BCM2835_PAD_GROUP_GPIO_0_27 = 0, /*!< Pad group for GPIO pads 0 to 27 */
    BCM2835_PAD_GROUP_GPIO_28_45 = 1, /*!< Pad group for GPIO pads 28 to 45 */
    BCM2835_PAD_GROUP_GPIO_46_53 = 2 /*!< Pad group for GPIO pads 46 to 53 */
} bcm2835PadGroup;

/*! \brief GPIO Pin Numbers
  
  Here we define Raspberry Pin GPIO pins on P1 in terms of the underlying BCM GPIO pin numbers.
  These can be passed as a pin number to any function requiring a pin.
  Not all pins on the RPi 26 bin IDE plug are connected to GPIO pins
  and some can adopt an alternate function.
  RPi version 2 has some slightly different pinouts, and these are values RPI_V2_*.
  RPi B+ has yet differnet pinouts and these are defined in RPI_BPLUS_*.
  At bootup, pins 8 and 10 are set to UART0_TXD, UART0_RXD (ie the alt0 function) respectively
  When SPI0 is in use (ie after bcm2835_spi_begin()), SPI0 pins are dedicated to SPI
  and cant be controlled independently.
  If you are using the RPi Compute Module, just use the GPIO number: there is no need to use one of these
  symbolic names
*/
typedef enum
{
    RPI_GPIO_P1_03 = 0, /*!< Version 1, Pin P1-03 */
    RPI_GPIO_P1_05 = 1, /*!< Version 1, Pin P1-05 */
    RPI_GPIO_P1_07 = 4, /*!< Version 1, Pin P1-07 */
    RPI_GPIO_P1_08 = 14, /*!< Version 1, Pin P1-08, defaults to alt function 0 UART0_TXD */
    RPI_GPIO_P1_10 = 15, /*!< Version 1, Pin P1-10, defaults to alt function 0 UART0_RXD */
    RPI_GPIO_P1_11 = 17, /*!< Version 1, Pin P1-11 */
    RPI_GPIO_P1_12 = 18, /*!< Version 1, Pin P1-12, can be PWM channel 0 in ALT FUN 5 */
    RPI_GPIO_P1_13 = 21, /*!< Version 1, Pin P1-13 */
    RPI_GPIO_P1_15 = 22, /*!< Version 1, Pin P1-15 */
    RPI_GPIO_P1_16 = 23, /*!< Version 1, Pin P1-16 */
    RPI_GPIO_P1_18 = 24, /*!< Version 1, Pin P1-18 */
    RPI_GPIO_P1_19 = 10, /*!< Version 1, Pin P1-19, MOSI when SPI0 in use */
    RPI_GPIO_P1_21 = 9, /*!< Version 1, Pin P1-21, MISO when SPI0 in use */
    RPI_GPIO_P1_22 = 25, /*!< Version 1, Pin P1-22 */
    RPI_GPIO_P1_23 = 11, /*!< Version 1, Pin P1-23, CLK when SPI0 in use */
    RPI_GPIO_P1_24 = 8, /*!< Version 1, Pin P1-24, CE0 when SPI0 in use */
    RPI_GPIO_P1_26 = 7, /*!< Version 1, Pin P1-26, CE1 when SPI0 in use */

    /* RPi Version 2 */
    RPI_V2_GPIO_P1_03 = 2, /*!< Version 2, Pin P1-03 */
    RPI_V2_GPIO_P1_05 = 3, /*!< Version 2, Pin P1-05 */
    RPI_V2_GPIO_P1_07 = 4, /*!< Version 2, Pin P1-07 */
    RPI_V2_GPIO_P1_08 = 14, /*!< Version 2, Pin P1-08, defaults to alt function 0 UART0_TXD */
    RPI_V2_GPIO_P1_10 = 15, /*!< Version 2, Pin P1-10, defaults to alt function 0 UART0_RXD */
    RPI_V2_GPIO_P1_11 = 17, /*!< Version 2, Pin P1-11 */
    RPI_V2_GPIO_P1_12 = 18, /*!< Version 2, Pin P1-12, can be PWM channel 0 in ALT FUN 5 */
    RPI_V2_GPIO_P1_13 = 27, /*!< Version 2, Pin P1-13 */
    RPI_V2_GPIO_P1_15 = 22, /*!< Version 2, Pin P1-15 */
    RPI_V2_GPIO_P1_16 = 23, /*!< Version 2, Pin P1-16 */
    RPI_V2_GPIO_P1_18 = 24, /*!< Version 2, Pin P1-18 */
    RPI_V2_GPIO_P1_19 = 10, /*!< Version 2, Pin P1-19, MOSI when SPI0 in use */
    RPI_V2_GPIO_P1_21 = 9, /*!< Version 2, Pin P1-21, MISO when SPI0 in use */
    RPI_V2_GPIO_P1_22 = 25, /*!< Version 2, Pin P1-22 */
    RPI_V2_GPIO_P1_23 = 11, /*!< Version 2, Pin P1-23, CLK when SPI0 in use */
    RPI_V2_GPIO_P1_24 = 8, /*!< Version 2, Pin P1-24, CE0 when SPI0 in use */
    RPI_V2_GPIO_P1_26 = 7, /*!< Version 2, Pin P1-26, CE1 when SPI0 in use */
    RPI_V2_GPIO_P1_29 = 5, /*!< Version 2, Pin P1-29 */
    RPI_V2_GPIO_P1_31 = 6, /*!< Version 2, Pin P1-31 */
    RPI_V2_GPIO_P1_32 = 12, /*!< Version 2, Pin P1-32 */
    RPI_V2_GPIO_P1_33 = 13, /*!< Version 2, Pin P1-33 */
    RPI_V2_GPIO_P1_35 = 19, /*!< Version 2, Pin P1-35, can be PWM channel 1 in ALT FUN 5  */
    RPI_V2_GPIO_P1_36 = 16, /*!< Version 2, Pin P1-36 */
    RPI_V2_GPIO_P1_37 = 26, /*!< Version 2, Pin P1-37 */
    RPI_V2_GPIO_P1_38 = 20, /*!< Version 2, Pin P1-38 */
    RPI_V2_GPIO_P1_40 = 21, /*!< Version 2, Pin P1-40 */

    /* RPi Version 2, new plug P5 */
    RPI_V2_GPIO_P5_03 = 28, /*!< Version 2, Pin P5-03 */
    RPI_V2_GPIO_P5_04 = 29, /*!< Version 2, Pin P5-04 */
    RPI_V2_GPIO_P5_05 = 30, /*!< Version 2, Pin P5-05 */
    RPI_V2_GPIO_P5_06 = 31, /*!< Version 2, Pin P5-06 */

    /* RPi B+ J8 header, also RPi 2 40 pin GPIO header */
    RPI_BPLUS_GPIO_J8_03 = 2, /*!< B+, Pin J8-03 */
    RPI_BPLUS_GPIO_J8_05 = 3, /*!< B+, Pin J8-05 */
    RPI_BPLUS_GPIO_J8_07 = 4, /*!< B+, Pin J8-07 */
    RPI_BPLUS_GPIO_J8_08 = 14, /*!< B+, Pin J8-08, defaults to alt function 0 UART0_TXD */
    RPI_BPLUS_GPIO_J8_10 = 15, /*!< B+, Pin J8-10, defaults to alt function 0 UART0_RXD */
    RPI_BPLUS_GPIO_J8_11 = 17, /*!< B+, Pin J8-11 */
    RPI_BPLUS_GPIO_J8_12 = 18, /*!< B+, Pin J8-12, can be PWM channel 0 in ALT FUN 5 */
    RPI_BPLUS_GPIO_J8_13 = 27, /*!< B+, Pin J8-13 */
    RPI_BPLUS_GPIO_J8_15 = 22, /*!< B+, Pin J8-15 */
    RPI_BPLUS_GPIO_J8_16 = 23, /*!< B+, Pin J8-16 */
    RPI_BPLUS_GPIO_J8_18 = 24, /*!< B+, Pin J8-18 */
    RPI_BPLUS_GPIO_J8_19 = 10, /*!< B+, Pin J8-19, MOSI when SPI0 in use */
    RPI_BPLUS_GPIO_J8_21 = 9, /*!< B+, Pin J8-21, MISO when SPI0 in use */
    RPI_BPLUS_GPIO_J8_22 = 25, /*!< B+, Pin J8-22 */
    RPI_BPLUS_GPIO_J8_23 = 11, /*!< B+, Pin J8-23, CLK when SPI0 in use */
    RPI_BPLUS_GPIO_J8_24 = 8, /*!< B+, Pin J8-24, CE0 when SPI0 in use */
    RPI_BPLUS_GPIO_J8_26 = 7, /*!< B+, Pin J8-26, CE1 when SPI0 in use */
    RPI_BPLUS_GPIO_J8_29 = 5, /*!< B+, Pin J8-29,  */
    RPI_BPLUS_GPIO_J8_31 = 6, /*!< B+, Pin J8-31,  */
    RPI_BPLUS_GPIO_J8_32 = 12, /*!< B+, Pin J8-32,  */
    RPI_BPLUS_GPIO_J8_33 = 13, /*!< B+, Pin J8-33,  */
    RPI_BPLUS_GPIO_J8_35 = 19, /*!< B+, Pin J8-35, can be PWM channel 1 in ALT FUN 5 */
    RPI_BPLUS_GPIO_J8_36 = 16, /*!< B+, Pin J8-36,  */
    RPI_BPLUS_GPIO_J8_37 = 26, /*!< B+, Pin J8-37,  */
    RPI_BPLUS_GPIO_J8_38 = 20, /*!< B+, Pin J8-38,  */
    RPI_BPLUS_GPIO_J8_40 = 21 /*!< B+, Pin J8-40,  */
} RPiGPIOPin;

/* Defines for AUX
  GPIO register offsets from BCM2835_AUX_BASE.
*/
#define BCM2835_AUX_IRQ 0x0000
#define BCM2835_AUX_ENABLE 0x0004

#define BCM2835_AUX_ENABLE_UART1 0x01
#define BCM2835_AUX_ENABLE_SPI0 0x02
#define BCM2835_AUX_ENABLE_SPI1 0x04


#define BCM2835_AUX_SPI_CNTL0 0x0000
#define BCM2835_AUX_SPI_CNTL1 0x0004
#define BCM2835_AUX_SPI_STAT 0x0008
#define BCM2835_AUX_SPI_PEEK 0x000C
#define BCM2835_AUX_SPI_IO 0x0020
#define BCM2835_AUX_SPI_TXHOLD 0x0030

#define BCM2835_AUX_SPI_CLOCK_MIN 30500
#define BCM2835_AUX_SPI_CLOCK_MAX 125000000

#define BCM2835_AUX_SPI_CNTL0_SPEED 0xFFF00000
#define BCM2835_AUX_SPI_CNTL0_SPEED_MAX 0xFFF
#define BCM2835_AUX_SPI_CNTL0_SPEED_SHIFT 20

#define BCM2835_AUX_SPI_CNTL0_CS0_N 0x000C0000
#define BCM2835_AUX_SPI_CNTL0_CS1_N 0x000A0000
#define BCM2835_AUX_SPI_CNTL0_CS2_N 0x00060000

#define BCM2835_AUX_SPI_CNTL0_POSTINPUT 0x00010000
#define BCM2835_AUX_SPI_CNTL0_VAR_CS 0x00008000
#define BCM2835_AUX_SPI_CNTL0_VAR_WIDTH 0x00004000
#define BCM2835_AUX_SPI_CNTL0_DOUTHOLD 0x00003000
#define BCM2835_AUX_SPI_CNTL0_ENABLE 0x00000800
#define BCM2835_AUX_SPI_CNTL0_CPHA_IN 0x00000400
#define BCM2835_AUX_SPI_CNTL0_CLEARFIFO 0x00000200
#define BCM2835_AUX_SPI_CNTL0_CPHA_OUT 0x00000100
#define BCM2835_AUX_SPI_CNTL0_CPOL 0x00000080
#define BCM2835_AUX_SPI_CNTL0_MSBF_OUT 0x00000040
#define BCM2835_AUX_SPI_CNTL0_SHIFTLEN 0x0000003F

#define BCM2835_AUX_SPI_CNTL1_CSHIGH 0x00000700
#define BCM2835_AUX_SPI_CNTL1_IDLE 0x00000080
#define BCM2835_AUX_SPI_CNTL1_TXEMPTY 0x00000040
#define BCM2835_AUX_SPI_CNTL1_MSBF_IN 0x00000002
#define BCM2835_AUX_SPI_CNTL1_KEEP_IN 0x00000001

#define BCM2835_AUX_SPI_STAT_TX_LVL 0xFF000000
#define BCM2835_AUX_SPI_STAT_RX_LVL 0x00FF0000
#define BCM2835_AUX_SPI_STAT_TX_FULL 0x00000400
#define BCM2835_AUX_SPI_STAT_TX_EMPTY 0x00000200
#define BCM2835_AUX_SPI_STAT_RX_FULL 0x00000100
#define BCM2835_AUX_SPI_STAT_RX_EMPTY 0x00000080
#define BCM2835_AUX_SPI_STAT_BUSY 0x00000040
#define BCM2835_AUX_SPI_STAT_BITCOUNT 0x0000003F

/* Defines for SPI
   GPIO register offsets from BCM2835_SPI0_BASE. 
   Offsets into the SPI Peripheral block in bytes per 10.5 SPI Register Map
*/
#define BCM2835_SPI0_CS 0x0000
#define BCM2835_SPI0_FIFO 0x0004
#define BCM2835_SPI0_CLK 0x0008
#define BCM2835_SPI0_DLEN 0x000c
#define BCM2835_SPI0_LTOH 0x0010
#define BCM2835_SPI0_DC 0x0014

/* Register masks for SPI0_CS */
#define BCM2835_SPI0_CS_LEN_LONG 0x02000000
#define BCM2835_SPI0_CS_DMA_LEN 0x01000000
#define BCM2835_SPI0_CS_CSPOL2 0x00800000
#define BCM2835_SPI0_CS_CSPOL1 0x00400000
#define BCM2835_SPI0_CS_CSPOL0 0x00200000
#define BCM2835_SPI0_CS_RXF 0x00100000
#define BCM2835_SPI0_CS_RXR 0x00080000
#define BCM2835_SPI0_CS_TXD 0x00040000
#define BCM2835_SPI0_CS_RXD 0x00020000
#define BCM2835_SPI0_CS_DONE 0x00010000
#define BCM2835_SPI0_CS_TE_EN 0x00008000
#define BCM2835_SPI0_CS_LMONO 0x00004000
#define BCM2835_SPI0_CS_LEN 0x00002000
#define BCM2835_SPI0_CS_REN 0x00001000
#define BCM2835_SPI0_CS_ADCS 0x00000800
#define BCM2835_SPI0_CS_INTR 0x00000400
#define BCM2835_SPI0_CS_INTD 0x00000200
#define BCM2835_SPI0_CS_DMAEN 0x00000100
#define BCM2835_SPI0_CS_TA 0x00000080
#define BCM2835_SPI0_CS_CSPOL 0x00000040
#define BCM2835_SPI0_CS_CLEAR 0x00000030
#define BCM2835_SPI0_CS_CLEAR_RX 0x00000020
#define BCM2835_SPI0_CS_CLEAR_TX 0x00000010
#define BCM2835_SPI0_CS_CPOL 0x00000008
#define BCM2835_SPI0_CS_CPHA 0x00000004
#define BCM2835_SPI0_CS_CS 0x00000003

/*! \brief bcm2835SPIBitOrder SPI Bit order
  Specifies the SPI data bit ordering for bcm2835_spi_setBitOrder()
*/
typedef enum
{
    BCM2835_SPI_BIT_ORDER_LSBFIRST = 0, /*!< LSB First */
    BCM2835_SPI_BIT_ORDER_MSBFIRST = 1 /*!< MSB First */
}bcm2835SPIBitOrder;

/*! \brief SPI Data mode
  Specify the SPI data mode to be passed to bcm2835_spi_setDataMode()
*/
typedef enum
{
    BCM2835_SPI_MODE0 = 0, /*!< CPOL = 0, CPHA = 0 */
    BCM2835_SPI_MODE1 = 1, /*!< CPOL = 0, CPHA = 1 */
    BCM2835_SPI_MODE2 = 2, /*!< CPOL = 1, CPHA = 0 */
    BCM2835_SPI_MODE3 = 3 /*!< CPOL = 1, CPHA = 1 */
}bcm2835SPIMode;

/*! \brief bcm2835SPIChipSelect
  Specify the SPI chip select pin(s)
*/
typedef enum
{
    BCM2835_SPI_CS0 = 0, /*!< Chip Select 0 */
    BCM2835_SPI_CS1 = 1, /*!< Chip Select 1 */
    BCM2835_SPI_CS2 = 2, /*!< Chip Select 2 (ie pins CS1 and CS2 are asserted) */
    BCM2835_SPI_CS_NONE = 3 /*!< No CS, control it yourself */
} bcm2835SPIChipSelect;

/*! \brief bcm2835SPIClockDivider
  Specifies the divider used to generate the SPI clock from the system clock.
  Figures below give the divider, clock period and clock frequency.
  Clock divided is based on nominal core clock rate of 250MHz on RPi1 and RPi2, and 400MHz on RPi3.
  It is reported that (contrary to the documentation) any even divider may used.
  The frequencies shown for each divider have been confirmed by measurement on RPi1 and RPi2.
  The system clock frequency on RPi3 is different, so the frequency you get from a given divider will be different.
  See comments in 'SPI Pins' for information about reliable SPI speeds.
  Note: it is possible to change the core clock rate of the RPi 3 back to 250MHz, by putting 
  \code
  core_freq=250
  \endcode
  in the config.txt
*/
typedef enum
{
    BCM2835_SPI_CLOCK_DIVIDER_65536 = 0, /*!< 65536 = 3.814697260kHz on Rpi2, 6.1035156kHz on RPI3 */
    BCM2835_SPI_CLOCK_DIVIDER_32768 = 32768, /*!< 32768 = 7.629394531kHz on Rpi2, 12.20703125kHz on RPI3 */
    BCM2835_SPI_CLOCK_DIVIDER_16384 = 16384, /*!< 16384 = 15.25878906kHz on Rpi2, 24.4140625kHz on RPI3 */
    BCM2835_SPI_CLOCK_DIVIDER_8192 = 8192, /*!< 8192 = 30.51757813kHz on Rpi2, 48.828125kHz on RPI3 */
    BCM2835_SPI_CLOCK_DIVIDER_4096 = 4096, /*!< 4096 = 61.03515625kHz on Rpi2, 97.65625kHz on RPI3 */
    BCM2835_SPI_CLOCK_DIVIDER_2048 = 2048, /*!< 2048 = 122.0703125kHz on Rpi2, 195.3125kHz on RPI3 */
    BCM2835_SPI_CLOCK_DIVIDER_1024 = 1024, /*!< 1024 = 244.140625kHz on Rpi2, 390.625kHz on RPI3 */
    BCM2835_SPI_CLOCK_DIVIDER_512 = 512, /*!< 512 = 488.28125kHz on Rpi2, 781.25kHz on RPI3 */
    BCM2835_SPI_CLOCK_DIVIDER_256 = 256, /*!< 256 = 976.5625kHz on Rpi2, 1.5625MHz on RPI3 */
    BCM2835_SPI_CLOCK_DIVIDER_128 = 128, /*!< 128 = 1.953125MHz on Rpi2, 3.125MHz on RPI3 */
    BCM2835_SPI_CLOCK_DIVIDER_64 = 64, /*!< 64 = 3.90625MHz on Rpi2, 6.250MHz on RPI3 */
    BCM2835_SPI_CLOCK_DIVIDER_32 = 32, /*!< 32 = 7.8125MHz on Rpi2, 12.5MHz on RPI3 */
    BCM2835_SPI_CLOCK_DIVIDER_16 = 16, /*!< 16 = 15.625MHz on Rpi2, 25MHz on RPI3 */
    BCM2835_SPI_CLOCK_DIVIDER_8 = 8, /*!< 8 = 31.25MHz on Rpi2, 50MHz on RPI3 */
    BCM2835_SPI_CLOCK_DIVIDER_4 = 4, /*!< 4 = 62.5MHz on Rpi2, 100MHz on RPI3. Dont expect this speed to work reliably. */
    BCM2835_SPI_CLOCK_DIVIDER_2 = 2, /*!< 2 = 125MHz on Rpi2, 200MHz on RPI3, fastest you can get. Dont expect this speed to work reliably.*/
    BCM2835_SPI_CLOCK_DIVIDER_1 = 1 /*!< 1 = 3.814697260kHz on Rpi2, 6.1035156kHz on RPI3, same as 0/65536 */
} bcm2835SPIClockDivider;

/* Defines for I2C
   GPIO register offsets from BCM2835_BSC*_BASE.
   Offsets into the BSC Peripheral block in bytes per 3.1 BSC Register Map
*/
#define BCM2835_BSC_C 0x0000
#define BCM2835_BSC_S 0x0004
#define BCM2835_BSC_DLEN 0x0008
#define BCM2835_BSC_A 0x000c
#define BCM2835_BSC_FIFO 0x0010
#define BCM2835_BSC_DIV 0x0014
#define BCM2835_BSC_DEL 0x0018
#define BCM2835_BSC_CLKT 0x001c

/* Register masks for BSC_C */
#define BCM2835_BSC_C_I2CEN 0x00008000
#define BCM2835_BSC_C_INTR 0x00000400
#define BCM2835_BSC_C_INTT 0x00000200
#define BCM2835_BSC_C_INTD 0x00000100
#define BCM2835_BSC_C_ST 0x00000080
#define BCM2835_BSC_C_CLEAR_1 0x00000020
#define BCM2835_BSC_C_CLEAR_2 0x00000010
#define BCM2835_BSC_C_READ 0x00000001

/* Register masks for BSC_S */
#define BCM2835_BSC_S_CLKT 0x00000200
#define BCM2835_BSC_S_ERR 0x00000100
#define BCM2835_BSC_S_RXF 0x00000080
#define BCM2835_BSC_S_TXE 0x00000040
#define BCM2835_BSC_S_RXD 0x00000020
#define BCM2835_BSC_S_TXD 0x00000010
#define BCM2835_BSC_S_RXR 0x00000008
#define BCM2835_BSC_S_TXW 0x00000004
#define BCM2835_BSC_S_DONE 0x00000002
#define BCM2835_BSC_S_TA 0x00000001

#define BCM2835_BSC_FIFO_SIZE 16

/*! \brief bcm2835I2CClockDivider
  Specifies the divider used to generate the I2C clock from the system clock.
  Clock divided is based on nominal base clock rate of 250MHz
*/
typedef enum
{
    BCM2835_I2C_CLOCK_DIVIDER_2500 = 2500, /*!< 2500 = 10us = 100 kHz */
    BCM2835_I2C_CLOCK_DIVIDER_626 = 626, /*!< 622 = 2.504us = 399.3610 kHz */
    BCM2835_I2C_CLOCK_DIVIDER_150 = 150, /*!< 150 = 60ns = 1.666 MHz (default at reset) */
    BCM2835_I2C_CLOCK_DIVIDER_148 = 148 /*!< 148 = 59ns = 1.689 MHz */
} bcm2835I2CClockDivider;

/*! \brief bcm2835I2CReasonCodes
  Specifies the reason codes for the bcm2835_i2c_write and bcm2835_i2c_read functions.
*/
typedef enum
{
    BCM2835_I2C_REASON_OK = 0x00, /*!< Success */
    BCM2835_I2C_REASON_ERROR_NACK = 0x01, /*!< Received a NACK */
    BCM2835_I2C_REASON_ERROR_CLKT = 0x02, /*!< Received Clock Stretch Timeout */
    BCM2835_I2C_REASON_ERROR_DATA = 0x04 /*!< Not all data is sent / received */
} bcm2835I2CReasonCodes;

/* Defines for ST
   GPIO register offsets from BCM2835_ST_BASE.
   Offsets into the ST Peripheral block in bytes per 12.1 System Timer Registers
   The System Timer peripheral provides four 32-bit timer channels and a single 64-bit free running counter.
   BCM2835_ST_CLO is the System Timer Counter Lower bits register.
   The system timer free-running counter lower register is a read-only register that returns the current value
   of the lower 32-bits of the free running counter.
   BCM2835_ST_CHI is the System Timer Counter Upper bits register.
   The system timer free-running counter upper register is a read-only register that returns the current value
   of the upper 32-bits of the free running counter.
*/
#define BCM2835_ST_CS 0x0000
#define BCM2835_ST_CLO 0x0004
#define BCM2835_ST_CHI 0x0008

/*! @} */


/* Defines for PWM, word offsets (ie 4 byte multiples) */
#define BCM2835_PWM_CONTROL 0
#define BCM2835_PWM_STATUS 1
#define BCM2835_PWM_DMAC 2
#define BCM2835_PWM0_RANGE 4
#define BCM2835_PWM0_DATA 5
#define BCM2835_PWM_FIF1 6
#define BCM2835_PWM1_RANGE 8
#define BCM2835_PWM1_DATA 9

/* Defines for PWM Clock, word offsets (ie 4 byte multiples) */
#define BCM2835_PWMCLK_CNTL 40
#define BCM2835_PWMCLK_DIV 41
#define BCM2835_PWM_PASSWRD (0x5A << 24)

#define BCM2835_PWM1_MS_MODE 0x8000
#define BCM2835_PWM1_USEFIFO 0x2000
#define BCM2835_PWM1_REVPOLAR 0x1000
#define BCM2835_PWM1_OFFSTATE 0x0800
#define BCM2835_PWM1_REPEATFF 0x0400
#define BCM2835_PWM1_SERIAL 0x0200
#define BCM2835_PWM1_ENABLE 0x0100

#define BCM2835_PWM0_MS_MODE 0x0080
#define BCM2835_PWM_CLEAR_FIFO 0x0040
#define BCM2835_PWM0_USEFIFO 0x0020
#define BCM2835_PWM0_REVPOLAR 0x0010
#define BCM2835_PWM0_OFFSTATE 0x0008
#define BCM2835_PWM0_REPEATFF 0x0004
#define BCM2835_PWM0_SERIAL 0x0002
#define BCM2835_PWM0_ENABLE 0x0001

/*! \brief bcm2835PWMClockDivider
  Specifies the divider used to generate the PWM clock from the system clock.
  Figures below give the divider, clock period and clock frequency.
  Clock divided is based on nominal PWM base clock rate of 19.2MHz
  The frequencies shown for each divider have been confirmed by measurement
*/
typedef enum
{
    BCM2835_PWM_CLOCK_DIVIDER_2048 = 2048, /*!< 2048 = 9.375kHz */
    BCM2835_PWM_CLOCK_DIVIDER_1024 = 1024, /*!< 1024 = 18.75kHz */
    BCM2835_PWM_CLOCK_DIVIDER_512 = 512, /*!< 512 = 37.5kHz */
    BCM2835_PWM_CLOCK_DIVIDER_256 = 256, /*!< 256 = 75kHz */
    BCM2835_PWM_CLOCK_DIVIDER_128 = 128, /*!< 128 = 150kHz */
    BCM2835_PWM_CLOCK_DIVIDER_64 = 64, /*!< 64 = 300kHz */
    BCM2835_PWM_CLOCK_DIVIDER_32 = 32, /*!< 32 = 600.0kHz */
    BCM2835_PWM_CLOCK_DIVIDER_16 = 16, /*!< 16 = 1.2MHz */
    BCM2835_PWM_CLOCK_DIVIDER_8 = 8, /*!< 8 = 2.4MHz */
    BCM2835_PWM_CLOCK_DIVIDER_4 = 4, /*!< 4 = 4.8MHz */
    BCM2835_PWM_CLOCK_DIVIDER_2 = 2, /*!< 2 = 9.6MHz, fastest you can get */
    BCM2835_PWM_CLOCK_DIVIDER_1 = 1 /*!< 1 = 4.6875kHz, same as divider 4096 */
} bcm2835PWMClockDivider;

/* Historical name compatibility */

#define delay(x) bcm2835_delay(x)
#define delayMicroseconds(x) bcm2835_delayMicroseconds(x)






    /*! \defgroup init Library initialisation and management
      These functions allow you to intialise and control the bcm2835 library
      @{
    */

    /*! Initialise the library by opening /dev/mem (if you are root) 
      or /dev/gpiomem (if you are not)
      and getting pointers to the 
      internal memory for BCM 2835 device registers. You must call this (successfully)
      before calling any other 
      functions in this library (except bcm2835_set_debug). 
      If bcm2835_init() fails by returning 0, 
      calling any other function may result in crashes or other failures.
      If bcm2835_init() succeeds but you are not running as root, then only gpio operations
      are permitted, and calling any other functions may result in crashes or other failures. .
      Prints messages to stderr in case of errors.
      \return 1 if successful else 0
    */
    extern int bcm2835_init(void);

    /*! Close the library, deallocating any allocated memory and closing /dev/mem
      \return 1 if successful else 0
    */
    extern int bcm2835_close(void);

    /*! Sets the debug level of the library.
      A value of 1 prevents mapping to /dev/mem, and makes the library print out
      what it would do, rather than accessing the GPIO registers.
      A value of 0, the default, causes normal operation.
      Call this before calling bcm2835_init();
      \param[in] debug The new debug level. 1 means debug
    */
    extern void bcm2835_set_debug(uint8_t debug);

    /*! Returns the version number of the library, same as BCM2835_VERSION
       \return the current library version number
    */
    extern unsigned int bcm2835_version(void);

    /*! @} */

    /*! \defgroup lowlevel Low level register access
      These functions provide low level register access, and should not generally
      need to be used 
       
      @{
    */

    /*! Gets the base of a register
      \param[in] regbase You can use one of the common values BCM2835_REGBASE_*
      in \ref bcm2835RegisterBase
      \return the register base
      \sa Physical Addresses
    */
    extern uint32_t* bcm2835_regbase(uint8_t regbase);

    /*! Reads 32 bit value from a peripheral address WITH a memory barrier before and after each read.
      This is safe, but slow.  The MB before protects this read from any in-flight reads that didn't
      use a MB.  The MB after protects subsequent reads from another peripheral.

      \param[in] paddr Physical address to read from. See BCM2835_GPIO_BASE etc.
      \return the value read from the 32 bit register
      \sa Physical Addresses
    */
    extern uint32_t bcm2835_peri_read(volatile uint32_t* paddr);

    /*! Reads 32 bit value from a peripheral address WITHOUT the read barriers
      You should only use this when:
      o your code has previously called bcm2835_peri_read() for a register
      within the same peripheral, and no read or write to another peripheral has occurred since.
      o your code has called bcm2835_memory_barrier() since the last access to ANOTHER peripheral.

      \param[in] paddr Physical address to read from. See BCM2835_GPIO_BASE etc.
      \return the value read from the 32 bit register
      \sa Physical Addresses
    */
    extern uint32_t bcm2835_peri_read_nb(volatile uint32_t* paddr);


    /*! Writes 32 bit value from a peripheral address WITH a memory barrier before and after each write
      This is safe, but slow.  The MB before ensures that any in-flight write to another peripheral
      completes before this write is issued.  The MB after ensures that subsequent reads and writes
      to another peripheral will see the effect of this write.

      This is a tricky optimization; if you aren't sure, use the barrier version.

      \param[in] paddr Physical address to read from. See BCM2835_GPIO_BASE etc.
      \param[in] value The 32 bit value to write
      \sa Physical Addresses
    */
    extern void bcm2835_peri_write(volatile uint32_t* paddr, uint32_t value);

    /*! Writes 32 bit value from a peripheral address without the write barrier
      You should only use this when:
      o your code has previously called bcm2835_peri_write() for a register
      within the same peripheral, and no other peripheral access has occurred since.
      o your code has called bcm2835_memory_barrier() since the last access to ANOTHER peripheral.

      This is a tricky optimization; if you aren't sure, use the barrier version.

      \param[in] paddr Physical address to read from. See BCM2835_GPIO_BASE etc.
      \param[in] value The 32 bit value to write
      \sa Physical Addresses
    */
    extern void bcm2835_peri_write_nb(volatile uint32_t* paddr, uint32_t value);

    /*! Alters a number of bits in a 32 peripheral regsiter.
      It reads the current valu and then alters the bits defines as 1 in mask, 
      according to the bit value in value. 
      All other bits that are 0 in the mask are unaffected.
      Use this to alter a subset of the bits in a register.
      Memory barriers are used.  Note that this is not atomic; an interrupt
      routine can cause unexpected results.
      \param[in] paddr Physical address to read from. See BCM2835_GPIO_BASE etc.
      \param[in] value The 32 bit value to write, masked in by mask.
      \param[in] mask Bitmask that defines the bits that will be altered in the register.
      \sa Physical Addresses
    */
    extern void bcm2835_peri_set_bits(volatile uint32_t* paddr, uint32_t value, uint32_t mask);
    /*! @}    end of lowlevel */

    /*! \defgroup gpio GPIO register access
      These functions allow you to control the GPIO interface. You can set the 
      function of each GPIO pin, read the input state and set the output state.
      @{
    */

    /*! Sets the Function Select register for the given pin, which configures
      the pin as Input, Output or one of the 6 alternate functions.
      \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
      \param[in] mode Mode to set the pin to, one of BCM2835_GPIO_FSEL_* from \ref bcm2835FunctionSelect
    */
    extern void bcm2835_gpio_fsel(uint8_t pin, uint8_t mode);

    /*! Sets the specified pin output to 
      HIGH.
      \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
      \sa bcm2835_gpio_write()
    */
    extern void bcm2835_gpio_set(uint8_t pin);

    /*! Sets the specified pin output to 
      LOW.
      \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
      \sa bcm2835_gpio_write()
    */
    extern void bcm2835_gpio_clr(uint8_t pin);

    /*! Sets any of the first 32 GPIO output pins specified in the mask to 
      HIGH.
      \param[in] mask Mask of pins to affect. Use eg: (1 << RPI_GPIO_P1_03) | (1 << RPI_GPIO_P1_05)
      \sa bcm2835_gpio_write_multi()
    */
    extern void bcm2835_gpio_set_multi(uint32_t mask);

    /*! Sets any of the first 32 GPIO output pins specified in the mask to 
      LOW.
      \param[in] mask Mask of pins to affect. Use eg: (1 << RPI_GPIO_P1_03) | (1 << RPI_GPIO_P1_05)
      \sa bcm2835_gpio_write_multi()
    */
    extern void bcm2835_gpio_clr_multi(uint32_t mask);

    /*! Reads the current level on the specified 
      pin and returns either HIGH or LOW. Works whether or not the pin
      is an input or an output.
      \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
      \return the current level  either HIGH or LOW
    */
    extern uint8_t bcm2835_gpio_lev(uint8_t pin);

    /*! Event Detect Status.
      Tests whether the specified pin has detected a level or edge
      as requested by bcm2835_gpio_ren(), bcm2835_gpio_fen(), bcm2835_gpio_hen(), 
      bcm2835_gpio_len(), bcm2835_gpio_aren(), bcm2835_gpio_afen().
      Clear the flag for a given pin by calling bcm2835_gpio_set_eds(pin);
      \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
      \return HIGH if the event detect status for the given pin is true.
    */
    extern uint8_t bcm2835_gpio_eds(uint8_t pin);

    /*! Same as bcm2835_gpio_eds() but checks if any of the pins specified in
      the mask have detected a level or edge.
      \param[in] mask Mask of pins to check. Use eg: (1 << RPI_GPIO_P1_03) | (1 << RPI_GPIO_P1_05)
      \return Mask of pins HIGH if the event detect status for the given pin is true.
    */
    extern uint32_t bcm2835_gpio_eds_multi(uint32_t mask);

    /*! Sets the Event Detect Status register for a given pin to 1, 
      which has the effect of clearing the flag. Use this afer seeing
      an Event Detect Status on the pin.
      \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
    */
    extern void bcm2835_gpio_set_eds(uint8_t pin);

    /*! Same as bcm2835_gpio_set_eds() but clears the flag for any pin which
      is set in the mask.
      \param[in] mask Mask of pins to clear. Use eg: (1 << RPI_GPIO_P1_03) | (1 << RPI_GPIO_P1_05)
    */
    extern void bcm2835_gpio_set_eds_multi(uint32_t mask);

    /*! Enable Rising Edge Detect Enable for the specified pin.
      When a rising edge is detected, sets the appropriate pin in Event Detect Status.
      The GPRENn registers use
      synchronous edge detection. This means the input signal is sampled using the
      system clock and then it is looking for a ?011? pattern on the sampled signal. This
      has the effect of suppressing glitches.
      \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
    */
    extern void bcm2835_gpio_ren(uint8_t pin);

    /*! Disable Rising Edge Detect Enable for the specified pin.
      \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
    */
    extern void bcm2835_gpio_clr_ren(uint8_t pin);

    /*! Enable Falling Edge Detect Enable for the specified pin.
      When a falling edge is detected, sets the appropriate pin in Event Detect Status.
      The GPRENn registers use
      synchronous edge detection. This means the input signal is sampled using the
      system clock and then it is looking for a ?100? pattern on the sampled signal. This
      has the effect of suppressing glitches.
      \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
    */
    extern void bcm2835_gpio_fen(uint8_t pin);

    /*! Disable Falling Edge Detect Enable for the specified pin.
      \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
    */
    extern void bcm2835_gpio_clr_fen(uint8_t pin);

    /*! Enable High Detect Enable for the specified pin.
      When a HIGH level is detected on the pin, sets the appropriate pin in Event Detect Status.
      \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
    */
    extern void bcm2835_gpio_hen(uint8_t pin);

    /*! Disable High Detect Enable for the specified pin.
      \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
    */
    extern void bcm2835_gpio_clr_hen(uint8_t pin);

    /*! Enable Low Detect Enable for the specified pin.
      When a LOW level is detected on the pin, sets the appropriate pin in Event Detect Status.
      \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
    */
    extern void bcm2835_gpio_len(uint8_t pin);

    /*! Disable Low Detect Enable for the specified pin.
      \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
    */
    extern void bcm2835_gpio_clr_len(uint8_t pin);

    /*! Enable Asynchronous Rising Edge Detect Enable for the specified pin.
      When a rising edge is detected, sets the appropriate pin in Event Detect Status.
      Asynchronous means the incoming signal is not sampled by the system clock. As such
      rising edges of very short duration can be detected.
      \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
    */
    extern void bcm2835_gpio_aren(uint8_t pin);

    /*! Disable Asynchronous Rising Edge Detect Enable for the specified pin.
      \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
    */
    extern void bcm2835_gpio_clr_aren(uint8_t pin);

    /*! Enable Asynchronous Falling Edge Detect Enable for the specified pin.
      When a falling edge is detected, sets the appropriate pin in Event Detect Status.
      Asynchronous means the incoming signal is not sampled by the system clock. As such
      falling edges of very short duration can be detected.
      \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
    */
    extern void bcm2835_gpio_afen(uint8_t pin);

    /*! Disable Asynchronous Falling Edge Detect Enable for the specified pin.
      \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
    */
    extern void bcm2835_gpio_clr_afen(uint8_t pin);

    /*! Sets the Pull-up/down register for the given pin. This is
      used with bcm2835_gpio_pudclk() to set the  Pull-up/down resistor for the given pin.
      However, it is usually more convenient to use bcm2835_gpio_set_pud().
      \param[in] pud The desired Pull-up/down mode. One of BCM2835_GPIO_PUD_* from bcm2835PUDControl
      \sa bcm2835_gpio_set_pud()
    */
    extern void bcm2835_gpio_pud(uint8_t pud);

    /*! Clocks the Pull-up/down value set earlier by bcm2835_gpio_pud() into the pin.
      \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
      \param[in] on HIGH to clock the value from bcm2835_gpio_pud() into the pin. 
      LOW to remove the clock. 
      \sa bcm2835_gpio_set_pud()
    */
    extern void bcm2835_gpio_pudclk(uint8_t pin, uint8_t on);

    /*! Reads and returns the Pad Control for the given GPIO group.
      Caution: requires root access.
      \param[in] group The GPIO pad group number, one of BCM2835_PAD_GROUP_GPIO_*
      \return Mask of bits from BCM2835_PAD_* from \ref bcm2835PadGroup
    */
    extern uint32_t bcm2835_gpio_pad(uint8_t group);

    /*! Sets the Pad Control for the given GPIO group.
      Caution: requires root access.
      \param[in] group The GPIO pad group number, one of BCM2835_PAD_GROUP_GPIO_*
      \param[in] control Mask of bits from BCM2835_PAD_* from \ref bcm2835PadGroup. Note 
      that it is not necessary to include BCM2835_PAD_PASSWRD in the mask as this
      is automatically included.
    */
    extern void bcm2835_gpio_set_pad(uint8_t group, uint32_t control);

    /*! Delays for the specified number of milliseconds.
      Uses nanosleep(), and therefore does not use CPU until the time is up.
      However, you are at the mercy of nanosleep(). From the manual for nanosleep():
      If the interval specified in req is not an exact multiple of the granularity  
      underlying  clock  (see  time(7)),  then the interval will be
      rounded up to the next multiple. Furthermore, after the sleep completes, 
      there may still be a delay before the CPU becomes free to once
      again execute the calling thread.
      \param[in] millis Delay in milliseconds
    */
    extern void bcm2835_delay (unsigned int millis);

    /*! Delays for the specified number of microseconds.
      Uses a combination of nanosleep() and a busy wait loop on the BCM2835 system timers,
      However, you are at the mercy of nanosleep(). From the manual for nanosleep():
      If the interval specified in req is not an exact multiple of the granularity  
      underlying  clock  (see  time(7)),  then the interval will be
      rounded up to the next multiple. Furthermore, after the sleep completes, 
      there may still be a delay before the CPU becomes free to once
      again execute the calling thread.
      For times less than about 450 microseconds, uses a busy wait on the System Timer.
      It is reported that a delay of 0 microseconds on RaspberryPi will in fact
      result in a delay of about 80 microseconds. Your mileage may vary.
      \param[in] micros Delay in microseconds
    */
    extern void bcm2835_delayMicroseconds (uint64_t micros);

    /*! Sets the output state of the specified pin
      \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
      \param[in] on HIGH sets the output to HIGH and LOW to LOW.
    */
    extern void bcm2835_gpio_write(uint8_t pin, uint8_t on);

    /*! Sets any of the first 32 GPIO output pins specified in the mask to the state given by on
      \param[in] mask Mask of pins to affect. Use eg: (1 << RPI_GPIO_P1_03) | (1 << RPI_GPIO_P1_05)
      \param[in] on HIGH sets the output to HIGH and LOW to LOW.
    */
    extern void bcm2835_gpio_write_multi(uint32_t mask, uint8_t on);

    /*! Sets the first 32 GPIO output pins specified in the mask to the value given by value
      \param[in] value values required for each bit masked in by mask, eg: (1 << RPI_GPIO_P1_03) | (1 << RPI_GPIO_P1_05)
      \param[in] mask Mask of pins to affect. Use eg: (1 << RPI_GPIO_P1_03) | (1 << RPI_GPIO_P1_05)
    */
    extern void bcm2835_gpio_write_mask(uint32_t value, uint32_t mask);

    /*! Sets the Pull-up/down mode for the specified pin. This is more convenient than
      clocking the mode in with bcm2835_gpio_pud() and bcm2835_gpio_pudclk().
      \param[in] pin GPIO number, or one of RPI_GPIO_P1_* from \ref RPiGPIOPin.
      \param[in] pud The desired Pull-up/down mode. One of BCM2835_GPIO_PUD_* from bcm2835PUDControl
    */
    extern void bcm2835_gpio_set_pud(uint8_t pin, uint8_t pud);

    /*! @}  */

    /*! \defgroup spi SPI access
      These functions let you use SPI0 (Serial Peripheral Interface) to 
      interface with an external SPI device.
      @{
    */

    /*! Start SPI operations.
      Forces RPi SPI0 pins P1-19 (MOSI), P1-21 (MISO), P1-23 (CLK), P1-24 (CE0) and P1-26 (CE1)
      to alternate function ALT0, which enables those pins for SPI interface.
      You should call bcm2835_spi_end() when all SPI funcitons are complete to return the pins to 
      their default functions.
      \sa  bcm2835_spi_end()
      \return 1 if successful, 0 otherwise (perhaps because you are not running as root)
    */
    extern int bcm2835_spi_begin(void);

    /*! End SPI operations.
      SPI0 pins P1-19 (MOSI), P1-21 (MISO), P1-23 (CLK), P1-24 (CE0) and P1-26 (CE1)
      are returned to their default INPUT behaviour.
    */
    extern void bcm2835_spi_end(void);

    /*! Sets the SPI bit order
      NOTE: has no effect. Not supported by SPI0.
      Defaults to 
      \param[in] order The desired bit order, one of BCM2835_SPI_BIT_ORDER_*, 
      see \ref bcm2835SPIBitOrder
    */
    extern void bcm2835_spi_setBitOrder(uint8_t order);

    /*! Sets the SPI clock divider and therefore the 
      SPI clock speed. 
      \param[in] divider The desired SPI clock divider, one of BCM2835_SPI_CLOCK_DIVIDER_*, 
      see \ref bcm2835SPIClockDivider
    */
    extern void bcm2835_spi_setClockDivider(uint16_t divider);

    /*! Sets the SPI data mode
      Sets the clock polariy and phase
      \param[in] mode The desired data mode, one of BCM2835_SPI_MODE*, 
      see \ref bcm2835SPIMode
    */
    extern void bcm2835_spi_setDataMode(uint8_t mode);

    /*! Sets the chip select pin(s)
      When an bcm2835_spi_transfer() is made, the selected pin(s) will be asserted during the
      transfer.
      \param[in] cs Specifies the CS pins(s) that are used to activate the desired slave. 
      One of BCM2835_SPI_CS*, see \ref bcm2835SPIChipSelect
    */
    extern void bcm2835_spi_chipSelect(uint8_t cs);

    /*! Sets the chip select pin polarity for a given pin
      When an bcm2835_spi_transfer() occurs, the currently selected chip select pin(s) 
      will be asserted to the 
      value given by active. When transfers are not happening, the chip select pin(s) 
      return to the complement (inactive) value.
      \param[in] cs The chip select pin to affect
      \param[in] active Whether the chip select pin is to be active HIGH
    */
    extern void bcm2835_spi_setChipSelectPolarity(uint8_t cs, uint8_t active);

    /*! Transfers one byte to and from the currently selected SPI slave.
      Asserts the currently selected CS pins (as previously set by bcm2835_spi_chipSelect) 
      during the transfer.
      Clocks the 8 bit value out on MOSI, and simultaneously clocks in data from MISO. 
      Returns the read data byte from the slave.
      Uses polled transfer as per section 10.6.1 of the BCM 2835 ARM Peripherls manual
      \param[in] value The 8 bit data byte to write to MOSI
      \return The 8 bit byte simultaneously read from  MISO
      \sa bcm2835_spi_transfern()
    */
    extern uint8_t bcm2835_spi_transfer(uint8_t value);

    /*! Transfers any number of bytes to and from the currently selected SPI slave.
      Asserts the currently selected CS pins (as previously set by bcm2835_spi_chipSelect) 
      during the transfer.
      Clocks the len 8 bit bytes out on MOSI, and simultaneously clocks in data from MISO. 
      The data read read from the slave is placed into rbuf. rbuf must be at least len bytes long
      Uses polled transfer as per section 10.6.1 of the BCM 2835 ARM Peripherls manual
      \param[in] tbuf Buffer of bytes to send. 
      \param[out] rbuf Received bytes will by put in this buffer
      \param[in] len Number of bytes in the tbuf buffer, and the number of bytes to send/received
      \sa bcm2835_spi_transfer()
    */
    extern void bcm2835_spi_transfernb(char* tbuf, char* rbuf, uint32_t len);

    /*! Transfers any number of bytes to and from the currently selected SPI slave
      using bcm2835_spi_transfernb.
      The returned data from the slave replaces the transmitted data in the buffer.
      \param[in,out] buf Buffer of bytes to send. Received bytes will replace the contents
      \param[in] len Number of bytes int eh buffer, and the number of bytes to send/received
      \sa bcm2835_spi_transfer()
    */
    extern void bcm2835_spi_transfern(char* buf, uint32_t len);

    /*! Transfers any number of bytes to the currently selected SPI slave.
      Asserts the currently selected CS pins (as previously set by bcm2835_spi_chipSelect)
      during the transfer.
      \param[in] buf Buffer of bytes to send.
      \param[in] len Number of bytes in the buf buffer, and the number of bytes to send
    */
    extern void bcm2835_spi_writenb(const char* buf, uint32_t len);

    /*! Transfers half-word to and from the currently selected SPI slave.
      Asserts the currently selected CS pins (as previously set by bcm2835_spi_chipSelect)
      during the transfer.
      Clocks the 8 bit value out on MOSI, and simultaneously clocks in data from MISO.
      Returns the read data byte from the slave.
      Uses polled transfer as per section 10.6.1 of the BCM 2835 ARM Peripherls manual
      \param[in] value The 8 bit data byte to write to MOSI
      \sa bcm2835_spi_writenb()
    */
    extern void bcm2835_spi_write(uint16_t data);

    /*! Start AUX SPI operations.
      Forces RPi AUX SPI pins P1-36 (MOSI), P1-38 (MISO), P1-40 (CLK) and P1-36 (CE2)
      to alternate function ALT4, which enables those pins for SPI interface.
      \return 1 if successful, 0 otherwise (perhaps because you are not running as root)
    */
    extern int bcm2835_aux_spi_begin(void);

    /*! End AUX SPI operations.
       SPI1 pins P1-36 (MOSI), P1-38 (MISO), P1-40 (CLK) and P1-36 (CE2)
       are returned to their default INPUT behaviour.
     */
    extern void bcm2835_aux_spi_end(void);

    /*! Sets the AUX SPI clock divider and therefore the AUX SPI clock speed.
      \param[in] divider The desired AUX SPI clock divider.
    */
    extern void bcm2835_aux_spi_setClockDivider(uint16_t);

    /*!
     * Calculates the input for \sa bcm2835_aux_spi_setClockDivider
     * @param speed_hz A value between \sa BCM2835_AUX_SPI_CLOCK_MIN and \sa BCM2835_AUX_SPI_CLOCK_MAX
     * @return Input for \sa bcm2835_aux_spi_setClockDivider
     */
    extern uint16_t bcm2835_aux_spi_CalcClockDivider(uint32_t speed_hz);

    /*! Transfers half-word to and from the AUX SPI slave.
      Asserts the currently selected CS pins during the transfer.
      \param[in] value The 8 bit data byte to write to MOSI
      \return The 8 bit byte simultaneously read from  MISO
      \sa bcm2835_spi_transfern()
    */
    extern void bcm2835_aux_spi_write(uint16_t);

    /*! Transfers any number of bytes to the AUX SPI slave.
      Asserts the CE2 pin during the transfer.
      \param[in] buf Buffer of bytes to send.
      \param[in] len Number of bytes in the tbuf buffer, and the number of bytes to send
    */
    extern void bcm2835_aux_spi_writenb(const char *buf, uint32_t len);

    /*! Transfers any number of bytes to and from the AUX SPI slave
      using bcm2835_aux_spi_transfernb.
      The returned data from the slave replaces the transmitted data in the buffer.
      \param[in,out] buf Buffer of bytes to send. Received bytes will replace the contents
      \param[in] len Number of bytes int eh buffer, and the number of bytes to send/received
      \sa bcm2835_aux_spi_transfer()
    */
    extern void bcm2835_aux_spi_transfern(char *, uint32_t);

    /*! Transfers any number of bytes to and from the AUX SPI slave.
      Asserts the CE2 pin during the transfer.
      Clocks the len 8 bit bytes out on MOSI, and simultaneously clocks in data from MISO.
      The data read read from the slave is placed into rbuf. rbuf must be at least len bytes long
      \param[in] tbuf Buffer of bytes to send.
      \param[out] rbuf Received bytes will by put in this buffer
      \param[in] len Number of bytes in the tbuf buffer, and the number of bytes to send/received
    */
    extern void bcm2835_aux_spi_transfernb(const char *, char *, uint32_t);

    /*! @} */

    /*! \defgroup i2c I2C access
      These functions let you use I2C (The Broadcom Serial Control bus with the Philips
      I2C bus/interface version 2.1 January 2000.) to interface with an external I2C device.
      @{
    */

    /*! Start I2C operations.
      Forces RPi I2C pins P1-03 (SDA) and P1-05 (SCL)
      to alternate function ALT0, which enables those pins for I2C interface.
      You should call bcm2835_i2c_end() when all I2C functions are complete to return the pins to
      their default functions
      \return 1 if successful, 0 otherwise (perhaps because you are not running as root)
      \sa  bcm2835_i2c_end()
    */
    extern int bcm2835_i2c_begin(void);

    /*! End I2C operations.
      I2C pins P1-03 (SDA) and P1-05 (SCL)
      are returned to their default INPUT behaviour.
    */
    extern void bcm2835_i2c_end(void);

    /*! Sets the I2C slave address.
      \param[in] addr The I2C slave address.
    */
    extern void bcm2835_i2c_setSlaveAddress(uint8_t addr);

    /*! Sets the I2C clock divider and therefore the I2C clock speed.
      \param[in] divider The desired I2C clock divider, one of BCM2835_I2C_CLOCK_DIVIDER_*,
      see \ref bcm2835I2CClockDivider
    */
    extern void bcm2835_i2c_setClockDivider(uint16_t divider);

    /*! Sets the I2C clock divider by converting the baudrate parameter to
      the equivalent I2C clock divider. ( see \sa bcm2835_i2c_setClockDivider)
      For the I2C standard 100khz you would set baudrate to 100000
      The use of baudrate corresponds to its use in the I2C kernel device
      driver. (Of course, bcm2835 has nothing to do with the kernel driver)
    */
    extern void bcm2835_i2c_set_baudrate(uint32_t baudrate);

    /*! Transfers any number of bytes to the currently selected I2C slave.
      (as previously set by \sa bcm2835_i2c_setSlaveAddress)
      \param[in] buf Buffer of bytes to send.
      \param[in] len Number of bytes in the buf buffer, and the number of bytes to send.
      \return reason see \ref bcm2835I2CReasonCodes
    */
    extern uint8_t bcm2835_i2c_write(const char * buf, uint32_t len);

    /*! Transfers any number of bytes from the currently selected I2C slave.
      (as previously set by \sa bcm2835_i2c_setSlaveAddress)
      \param[in] buf Buffer of bytes to receive.
      \param[in] len Number of bytes in the buf buffer, and the number of bytes to received.
      \return reason see \ref bcm2835I2CReasonCodes
    */
    extern uint8_t bcm2835_i2c_read(char* buf, uint32_t len);

    /*! Allows reading from I2C slaves that require a repeated start (without any prior stop)
      to read after the required slave register has been set. For example, the popular
      MPL3115A2 pressure and temperature sensor. Note that your device must support or
      require this mode. If your device does not require this mode then the standard
      combined:
      \sa bcm2835_i2c_write
      \sa bcm2835_i2c_read
      are a better choice.
      Will read from the slave previously set by \sa bcm2835_i2c_setSlaveAddress
      \param[in] regaddr Buffer containing the slave register you wish to read from.
      \param[in] buf Buffer of bytes to receive.
      \param[in] len Number of bytes in the buf buffer, and the number of bytes to received.
      \return reason see \ref bcm2835I2CReasonCodes
    */
    extern uint8_t bcm2835_i2c_read_register_rs(char* regaddr, char* buf, uint32_t len);

    /*! Allows sending an arbitrary number of bytes to I2C slaves before issuing a repeated
      start (with no prior stop) and reading a response.
      Necessary for devices that require such behavior, such as the MLX90620.
      Will write to and read from the slave previously set by \sa bcm2835_i2c_setSlaveAddress
      \param[in] cmds Buffer containing the bytes to send before the repeated start condition.
      \param[in] cmds_len Number of bytes to send from cmds buffer
      \param[in] buf Buffer of bytes to receive.
      \param[in] buf_len Number of bytes to receive in the buf buffer.
      \return reason see \ref bcm2835I2CReasonCodes
    */
    extern uint8_t bcm2835_i2c_write_read_rs(char* cmds, uint32_t cmds_len, char* buf, uint32_t buf_len);

    /*! @} */

    /*! \defgroup st System Timer access
      Allows access to and delays using the System Timer Counter.
      @{
    */

    /*! Read the System Timer Counter register.
      \return the value read from the System Timer Counter Lower 32 bits register
    */
    extern uint64_t bcm2835_st_read(void);

    /*! Delays for the specified number of microseconds with offset.
      \param[in] offset_micros Offset in microseconds
      \param[in] micros Delay in microseconds
    */
    extern void bcm2835_st_delay(uint64_t offset_micros, uint64_t micros);

    /*! @}  */

    /*! \defgroup pwm Pulse Width Modulation
      Allows control of 2 independent PWM channels. A limited subset of GPIO pins
      can be connected to one of these 2 channels, allowing PWM control of GPIO pins.
      You have to set the desired pin into a particular Alt Fun to PWM output. See the PWM
      documentation on the Main Page.
      @{
    */

    /*! Sets the PWM clock divisor, 
      to control the basic PWM pulse widths.
      \param[in] divisor Divides the basic 19.2MHz PWM clock. You can use one of the common
      values BCM2835_PWM_CLOCK_DIVIDER_* in \ref bcm2835PWMClockDivider
    */
    extern void bcm2835_pwm_set_clock(uint32_t divisor);

    /*! Sets the mode of the given PWM channel,
      allowing you to control the PWM mode and enable/disable that channel
      \param[in] channel The PWM channel. 0 or 1.
      \param[in] markspace Set true if you want Mark-Space mode. 0 for Balanced mode.
      \param[in] enabled Set true to enable this channel and produce PWM pulses.
    */
    extern void bcm2835_pwm_set_mode(uint8_t channel, uint8_t markspace, uint8_t enabled);

    /*! Sets the maximum range of the PWM output.
      The data value can vary between 0 and this range to control PWM output
      \param[in] channel The PWM channel. 0 or 1.
      \param[in] range The maximum value permitted for DATA.
    */
    extern void bcm2835_pwm_set_range(uint8_t channel, uint32_t range);

    /*! Sets the PWM pulse ratio to emit to DATA/RANGE, 
      where RANGE is set by bcm2835_pwm_set_range().
      \param[in] channel The PWM channel. 0 or 1.
      \param[in] data Controls the PWM output ratio as a fraction of the range. 
      Can vary from 0 to RANGE.
    */
    extern void bcm2835_pwm_set_data(uint8_t channel, uint32_t data);

    /*! @}  */






/*! @example blink.c
  Blinks RPi GPIO pin 11 on and off
*/

/*! @example input.c
  Reads the state of an RPi input pin
*/

/*! @example event.c
  Shows how to use event detection on an input pin
*/

/*! @example spi.c
  Shows how to use SPI interface to transfer a byte to and from an SPI device
*/

/*! @example spin.c
  Shows how to use SPI interface to transfer a number of bytes to and from an SPI device
*/

/*! @example pwm.c
  Shows how to use PWM to control GPIO pins
*/

/*! @example i2c.c
Command line utility for executing i2c commands with the 
Broadcom bcm2835. Contributed by Shahrooz Shahparnia.
*/

/*! example gpio.c
  Command line utility for executing gpio commands with the 
  Broadcom bcm2835. Contributed by Shahrooz Shahparnia.
*/
# 166 "pifunk.c" 2

//GPIO includes here 0.6.5 used
//#include "RPI.GPIO/source/c_gpio.h"
# 1 "RPI.GPIO/source/event_gpio.h" 1
/*
Copyright (c) 2013-2015 Ben Croston

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define NO_EDGE 0
#define RISING_EDGE 1
#define FALLING_EDGE 2
#define BOTH_EDGE 3

int add_edge_detect(unsigned int gpio, unsigned int edge, int bouncetime);
void remove_edge_detect(unsigned int gpio);
int add_edge_callback(unsigned int gpio, void (*func)(unsigned int gpio));
int event_detected(unsigned int gpio);
int gpio_event_added(unsigned int gpio);
int event_initialise(void);
void event_cleanup(int gpio);
void event_cleanup_all(void);
int blocking_wait_for_edge(unsigned int gpio, unsigned int edge, int bouncetime, int timeout);
# 170 "pifunk.c" 2
//#include "RPI.GPIO/source/py_pwm.h"
# 1 "RPI.GPIO/source/soft_pwm.h" 1
/*
Copyright (c) 2013-2018 Ben Croston

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

/* Software PWM using threads */

void pwm_set_duty_cycle(unsigned int gpio, float dutycycle);
void pwm_set_frequency(unsigned int gpio, float freq);
void pwm_start(unsigned int gpio);
void pwm_stop(unsigned int gpio);
int pwm_exists(unsigned int gpio);
# 172 "pifunk.c" 2
//#include "RPI.GPIO/source/constants.h"
# 1 "RPI.GPIO/source/common.h" 1
/*
Copyright (c) 2013-2015 Ben Croston

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

# 1 "RPI.GPIO/source/cpuinfo.h" 1
/*
Copyright (c) 2012-2015 Ben Croston

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/


#define CPUINFO_H 
typedef struct
{
   int p1_revision;
   char *ram;
   char *manufacturer;
   char *processor;
   char *type;
   char revision[1024];
} rpi_info;


int get_rpi_info(rpi_info *info);
# 24 "RPI.GPIO/source/common.h" 2

#define MODE_UNKNOWN -1
#define BOARD 10
#define BCM 11
#define SERIAL 40
#define SPI 41
#define I2C 42
#define PWM 43

int gpio_mode;
const int pin_to_gpio_rev1[41];
const int pin_to_gpio_rev2[41];
const int pin_to_gpio_rev3[41];
const int (*pin_to_gpio)[41];
int gpio_direction[54];
rpi_info rpiinfo;
int setup_error;
int module_setup;
int check_gpio_priv(void);
int get_gpio_number(int channel, unsigned int *gpio);
# 174 "pifunk.c" 2
# 1 "RPI.GPIO/source/cpuinfo.h" 1
/*
Copyright (c) 2012-2015 Ben Croston

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
# 36 "RPI.GPIO/source/cpuinfo.h"
int get_rpi_info(rpi_info *info);
# 175 "pifunk.c" 2

// see http://www.mega-nerd.com/libsndfile/api.html for API needed for am -> ALSA sound
// download from mainpage http://www.alsa-project.org/main/index.php/Main_Page
//#include "include/sndfile.h" // has problems with @typedef sf_count somehow -> set as int

//extra library https://github.com/libusb/libusb
//for usb soundcards for mic and alsa usage
# 1 "libusb/libusb/libusb.h" 1
/*
 * Public libusb header file
 * Copyright © 2001 Johannes Erdfelt <johannes@erdfelt.com>
 * Copyright © 2007-2008 Daniel Drake <dsd@gentoo.org>
 * Copyright © 2012 Pete Batard <pete@akeo.ie>
 * Copyright © 2012 Nathan Hjelm <hjelmn@cs.unm.edu>
 * For more information, please visit: http://libusb.info
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */


#define LIBUSB_H 
# 44 "libusb/libusb/libusb.h"
/* stdint.h is not available on older MSVC */
# 54 "libusb/libusb/libusb.h"
# 1 "/usr/include/arm-linux-gnueabihf/sys/types.h" 1 3 4

# 1 "/usr/include/arm-linux-gnueabihf/sys/types.h" 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */
# 55 "libusb/libusb/libusb.h" 2



# 1 "/usr/include/arm-linux-gnueabihf/sys/time.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 59 "libusb/libusb/libusb.h" 2


# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */
# 62 "libusb/libusb/libusb.h" 2
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/6/include-fixed/limits.h" 1 3 4
/* Copyright (C) 1992-2016 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */
# 63 "libusb/libusb/libusb.h" 2


#define ZERO_SIZED_ARRAY 





# 70 "libusb/libusb/libusb.h"
/* 'interface' might be defined as a macro on Windows, so we need to
 * undefine it so as not to break the current libusb API, because
 * libusb_config_descriptor has an 'interface' member
 * As this can be problematic if you include windows.h after libusb.h
 * in your sources, we force windows.h to be included first. */
# 86 "libusb/libusb/libusb.h"
#define LIBUSB_DEPRECATED_FOR(f) __attribute__((deprecated("Use " #f " instead")))







/** \def LIBUSB_CALL
 * \ingroup libusb_misc
 * libusb's Windows calling convention.
 *
 * Under Windows, the selection of available compilers and configurations
 * means that, unlike other platforms, there is not <em>one true calling
 * convention</em> (calling convention: the manner in which parameters are
 * passed to functions in the generated assembly code).
 *
 * Matching the Windows API itself, libusb uses the WINAPI convention (which
 * translates to the <tt>stdcall</tt> convention) and guarantees that the
 * library is compiled in this way. The public header file also includes
 * appropriate annotations so that your own software will use the right
 * convention, even if another convention is being used by default within
 * your codebase.
 *
 * The one consideration that you must apply in your software is to mark
 * all functions which you use as libusb callbacks with this LIBUSB_CALL
 * annotation, so that they too get compiled for the correct calling
 * convention.
 *
 * On non-Windows operating systems, this macro is defined as nothing. This
 * means that you can apply it to your code without worrying about
 * cross-platform compatibility.
 */
/* LIBUSB_CALL must be defined on both definition and declaration of libusb
 * functions. You'd think that declaration would be enough, but cygwin will
 * complain about conflicting types unless both are marked this way.
 * The placement of this macro is important too; it must appear after the
 * return type, before the function name. See internal documentation for
 * API_EXPORTED.
 */



#define LIBUSB_CALL 


/** \def LIBUSB_API_VERSION
 * \ingroup libusb_misc
 * libusb's API version.
 *
 * Since version 1.0.13, to help with feature detection, libusb defines
 * a LIBUSB_API_VERSION macro that gets increased every time there is a
 * significant change to the API, such as the introduction of a new call,
 * the definition of a new macro/enum member, or any other element that
 * libusb applications may want to detect at compilation time.
 *
 * The macro is typically used in an application as follows:
 * \code
 * #if defined(LIBUSB_API_VERSION) && (LIBUSB_API_VERSION >= 0x01001234)
 * // Use one of the newer features from the libusb API
 * #endif
 * \endcode
 *
 * Internally, LIBUSB_API_VERSION is defined as follows:
 * (libusb major << 24) | (libusb minor << 16) | (16 bit incremental)
 */
#define LIBUSB_API_VERSION 0x01000106

/* The following is kept for compatibility, but will be deprecated in the future */
#define LIBUSBX_API_VERSION LIBUSB_API_VERSION





/**
 * \ingroup libusb_misc
 * Convert a 16-bit value from host-endian to little-endian format. On
 * little endian systems, this function does nothing. On big endian systems,
 * the bytes are swapped.
 * \param x the host-endian value to convert
 * \returns the value in little-endian byte order
 */
static inline uint16_t libusb_cpu_to_le16(const uint16_t x)
{
 union {
  uint8_t b8[2];
  uint16_t b16;
 } _tmp;
 _tmp.b8[1] = (uint8_t) (x >> 8);
 _tmp.b8[0] = (uint8_t) (x & 0xff);
 return _tmp.b16;
}

/** \def libusb_le16_to_cpu
 * \ingroup libusb_misc
 * Convert a 16-bit value from little-endian to host-endian format. On
 * little endian systems, this function does nothing. On big endian systems,
 * the bytes are swapped.
 * \param x the little-endian value to convert
 * \returns the value in host-endian byte order
 */
#define libusb_le16_to_cpu libusb_cpu_to_le16

/* standard USB stuff */

/** \ingroup libusb_desc
 * Device and/or Interface Class codes */
enum libusb_class_code {
 /** In the context of a \ref libusb_device_descriptor "device descriptor",
	 * this bDeviceClass value indicates that each interface specifies its
	 * own class information and all interfaces operate independently.
	 */
 LIBUSB_CLASS_PER_INTERFACE = 0,

 /** Audio class */
 LIBUSB_CLASS_AUDIO = 1,

 /** Communications class */
 LIBUSB_CLASS_COMM = 2,

 /** Human Interface Device class */
 LIBUSB_CLASS_HID = 3,

 /** Physical */
 LIBUSB_CLASS_PHYSICAL = 5,

 /** Printer class */
 LIBUSB_CLASS_PRINTER = 7,

 /** Image class */
 LIBUSB_CLASS_PTP = 6, /* legacy name from libusb-0.1 usb.h */
 LIBUSB_CLASS_IMAGE = 6,

 /** Mass storage class */
 LIBUSB_CLASS_MASS_STORAGE = 8,

 /** Hub class */
 LIBUSB_CLASS_HUB = 9,

 /** Data class */
 LIBUSB_CLASS_DATA = 10,

 /** Smart Card */
 LIBUSB_CLASS_SMART_CARD = 0x0b,

 /** Content Security */
 LIBUSB_CLASS_CONTENT_SECURITY = 0x0d,

 /** Video */
 LIBUSB_CLASS_VIDEO = 0x0e,

 /** Personal Healthcare */
 LIBUSB_CLASS_PERSONAL_HEALTHCARE = 0x0f,

 /** Diagnostic Device */
 LIBUSB_CLASS_DIAGNOSTIC_DEVICE = 0xdc,

 /** Wireless class */
 LIBUSB_CLASS_WIRELESS = 0xe0,

 /** Application class */
 LIBUSB_CLASS_APPLICATION = 0xfe,

 /** Class is vendor-specific */
 LIBUSB_CLASS_VENDOR_SPEC = 0xff
};

/** \ingroup libusb_desc
 * Descriptor types as defined by the USB specification. */
enum libusb_descriptor_type {
 /** Device descriptor. See libusb_device_descriptor. */
 LIBUSB_DT_DEVICE = 0x01,

 /** Configuration descriptor. See libusb_config_descriptor. */
 LIBUSB_DT_CONFIG = 0x02,

 /** String descriptor */
 LIBUSB_DT_STRING = 0x03,

 /** Interface descriptor. See libusb_interface_descriptor. */
 LIBUSB_DT_INTERFACE = 0x04,

 /** Endpoint descriptor. See libusb_endpoint_descriptor. */
 LIBUSB_DT_ENDPOINT = 0x05,

 /** BOS descriptor */
 LIBUSB_DT_BOS = 0x0f,

 /** Device Capability descriptor */
 LIBUSB_DT_DEVICE_CAPABILITY = 0x10,

 /** HID descriptor */
 LIBUSB_DT_HID = 0x21,

 /** HID report descriptor */
 LIBUSB_DT_REPORT = 0x22,

 /** Physical descriptor */
 LIBUSB_DT_PHYSICAL = 0x23,

 /** Hub descriptor */
 LIBUSB_DT_HUB = 0x29,

 /** SuperSpeed Hub descriptor */
 LIBUSB_DT_SUPERSPEED_HUB = 0x2a,

 /** SuperSpeed Endpoint Companion descriptor */
 LIBUSB_DT_SS_ENDPOINT_COMPANION = 0x30
};

/* Descriptor sizes per descriptor type */
#define LIBUSB_DT_DEVICE_SIZE 18
#define LIBUSB_DT_CONFIG_SIZE 9
#define LIBUSB_DT_INTERFACE_SIZE 9
#define LIBUSB_DT_ENDPOINT_SIZE 7
#define LIBUSB_DT_ENDPOINT_AUDIO_SIZE 9
#define LIBUSB_DT_HUB_NONVAR_SIZE 7
#define LIBUSB_DT_SS_ENDPOINT_COMPANION_SIZE 6
#define LIBUSB_DT_BOS_SIZE 5
#define LIBUSB_DT_DEVICE_CAPABILITY_SIZE 3

/* BOS descriptor sizes */
#define LIBUSB_BT_USB_2_0_EXTENSION_SIZE 7
#define LIBUSB_BT_SS_USB_DEVICE_CAPABILITY_SIZE 10
#define LIBUSB_BT_CONTAINER_ID_SIZE 20

/* We unwrap the BOS => define its max size */
#define LIBUSB_DT_BOS_MAX_SIZE ((LIBUSB_DT_BOS_SIZE) + (LIBUSB_BT_USB_2_0_EXTENSION_SIZE) + (LIBUSB_BT_SS_USB_DEVICE_CAPABILITY_SIZE) + (LIBUSB_BT_CONTAINER_ID_SIZE))




#define LIBUSB_ENDPOINT_ADDRESS_MASK 0x0f
#define LIBUSB_ENDPOINT_DIR_MASK 0x80

/** \ingroup libusb_desc
 * Endpoint direction. Values for bit 7 of the
 * \ref libusb_endpoint_descriptor::bEndpointAddress "endpoint address" scheme.
 */
enum libusb_endpoint_direction {
 /** In: device-to-host */
 LIBUSB_ENDPOINT_IN = 0x80,

 /** Out: host-to-device */
 LIBUSB_ENDPOINT_OUT = 0x00
};

#define LIBUSB_TRANSFER_TYPE_MASK 0x03

/** \ingroup libusb_desc
 * Endpoint transfer type. Values for bits 0:1 of the
 * \ref libusb_endpoint_descriptor::bmAttributes "endpoint attributes" field.
 */
enum libusb_transfer_type {
 /** Control endpoint */
 LIBUSB_TRANSFER_TYPE_CONTROL = 0,

 /** Isochronous endpoint */
 LIBUSB_TRANSFER_TYPE_ISOCHRONOUS = 1,

 /** Bulk endpoint */
 LIBUSB_TRANSFER_TYPE_BULK = 2,

 /** Interrupt endpoint */
 LIBUSB_TRANSFER_TYPE_INTERRUPT = 3,

 /** Stream endpoint */
 LIBUSB_TRANSFER_TYPE_BULK_STREAM = 4,
};

/** \ingroup libusb_misc
 * Standard requests, as defined in table 9-5 of the USB 3.0 specifications */
enum libusb_standard_request {
 /** Request status of the specific recipient */
 LIBUSB_REQUEST_GET_STATUS = 0x00,

 /** Clear or disable a specific feature */
 LIBUSB_REQUEST_CLEAR_FEATURE = 0x01,

 /* 0x02 is reserved */

 /** Set or enable a specific feature */
 LIBUSB_REQUEST_SET_FEATURE = 0x03,

 /* 0x04 is reserved */

 /** Set device address for all future accesses */
 LIBUSB_REQUEST_SET_ADDRESS = 0x05,

 /** Get the specified descriptor */
 LIBUSB_REQUEST_GET_DESCRIPTOR = 0x06,

 /** Used to update existing descriptors or add new descriptors */
 LIBUSB_REQUEST_SET_DESCRIPTOR = 0x07,

 /** Get the current device configuration value */
 LIBUSB_REQUEST_GET_CONFIGURATION = 0x08,

 /** Set device configuration */
 LIBUSB_REQUEST_SET_CONFIGURATION = 0x09,

 /** Return the selected alternate setting for the specified interface */
 LIBUSB_REQUEST_GET_INTERFACE = 0x0A,

 /** Select an alternate interface for the specified interface */
 LIBUSB_REQUEST_SET_INTERFACE = 0x0B,

 /** Set then report an endpoint's synchronization frame */
 LIBUSB_REQUEST_SYNCH_FRAME = 0x0C,

 /** Sets both the U1 and U2 Exit Latency */
 LIBUSB_REQUEST_SET_SEL = 0x30,

 /** Delay from the time a host transmits a packet to the time it is
	  * received by the device. */
 LIBUSB_SET_ISOCH_DELAY = 0x31,
};

/** \ingroup libusb_misc
 * Request type bits of the
 * \ref libusb_control_setup::bmRequestType "bmRequestType" field in control
 * transfers. */
enum libusb_request_type {
 /** Standard */
 LIBUSB_REQUEST_TYPE_STANDARD = (0x00 << 5),

 /** Class */
 LIBUSB_REQUEST_TYPE_CLASS = (0x01 << 5),

 /** Vendor */
 LIBUSB_REQUEST_TYPE_VENDOR = (0x02 << 5),

 /** Reserved */
 LIBUSB_REQUEST_TYPE_RESERVED = (0x03 << 5)
};

/** \ingroup libusb_misc
 * Recipient bits of the
 * \ref libusb_control_setup::bmRequestType "bmRequestType" field in control
 * transfers. Values 4 through 31 are reserved. */
enum libusb_request_recipient {
 /** Device */
 LIBUSB_RECIPIENT_DEVICE = 0x00,

 /** Interface */
 LIBUSB_RECIPIENT_INTERFACE = 0x01,

 /** Endpoint */
 LIBUSB_RECIPIENT_ENDPOINT = 0x02,

 /** Other */
 LIBUSB_RECIPIENT_OTHER = 0x03,
};

#define LIBUSB_ISO_SYNC_TYPE_MASK 0x0C

/** \ingroup libusb_desc
 * Synchronization type for isochronous endpoints. Values for bits 2:3 of the
 * \ref libusb_endpoint_descriptor::bmAttributes "bmAttributes" field in
 * libusb_endpoint_descriptor.
 */
enum libusb_iso_sync_type {
 /** No synchronization */
 LIBUSB_ISO_SYNC_TYPE_NONE = 0,

 /** Asynchronous */
 LIBUSB_ISO_SYNC_TYPE_ASYNC = 1,

 /** Adaptive */
 LIBUSB_ISO_SYNC_TYPE_ADAPTIVE = 2,

 /** Synchronous */
 LIBUSB_ISO_SYNC_TYPE_SYNC = 3
};

#define LIBUSB_ISO_USAGE_TYPE_MASK 0x30

/** \ingroup libusb_desc
 * Usage type for isochronous endpoints. Values for bits 4:5 of the
 * \ref libusb_endpoint_descriptor::bmAttributes "bmAttributes" field in
 * libusb_endpoint_descriptor.
 */
enum libusb_iso_usage_type {
 /** Data endpoint */
 LIBUSB_ISO_USAGE_TYPE_DATA = 0,

 /** Feedback endpoint */
 LIBUSB_ISO_USAGE_TYPE_FEEDBACK = 1,

 /** Implicit feedback Data endpoint */
 LIBUSB_ISO_USAGE_TYPE_IMPLICIT = 2,
};

/** \ingroup libusb_desc
 * A structure representing the standard USB device descriptor. This
 * descriptor is documented in section 9.6.1 of the USB 3.0 specification.
 * All multiple-byte fields are represented in host-endian format.
 */
struct libusb_device_descriptor {
 /** Size of this descriptor (in bytes) */
 uint8_t bLength;

 /** Descriptor type. Will have value
	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE LIBUSB_DT_DEVICE in this
	 * context. */
 uint8_t bDescriptorType;

 /** USB specification release number in binary-coded decimal. A value of
	 * 0x0200 indicates USB 2.0, 0x0110 indicates USB 1.1, etc. */
 uint16_t bcdUSB;

 /** USB-IF class code for the device. See \ref libusb_class_code. */
 uint8_t bDeviceClass;

 /** USB-IF subclass code for the device, qualified by the bDeviceClass
	 * value */
 uint8_t bDeviceSubClass;

 /** USB-IF protocol code for the device, qualified by the bDeviceClass and
	 * bDeviceSubClass values */
 uint8_t bDeviceProtocol;

 /** Maximum packet size for endpoint 0 */
 uint8_t bMaxPacketSize0;

 /** USB-IF vendor ID */
 uint16_t idVendor;

 /** USB-IF product ID */
 uint16_t idProduct;

 /** Device release number in binary-coded decimal */
 uint16_t bcdDevice;

 /** Index of string descriptor describing manufacturer */
 uint8_t iManufacturer;

 /** Index of string descriptor describing product */
 uint8_t iProduct;

 /** Index of string descriptor containing device serial number */
 uint8_t iSerialNumber;

 /** Number of possible configurations */
 uint8_t bNumConfigurations;
};

/** \ingroup libusb_desc
 * A structure representing the standard USB endpoint descriptor. This
 * descriptor is documented in section 9.6.6 of the USB 3.0 specification.
 * All multiple-byte fields are represented in host-endian format.
 */
struct libusb_endpoint_descriptor {
 /** Size of this descriptor (in bytes) */
 uint8_t bLength;

 /** Descriptor type. Will have value
	 * \ref libusb_descriptor_type::LIBUSB_DT_ENDPOINT LIBUSB_DT_ENDPOINT in
	 * this context. */
 uint8_t bDescriptorType;

 /** The address of the endpoint described by this descriptor. Bits 0:3 are
	 * the endpoint number. Bits 4:6 are reserved. Bit 7 indicates direction,
	 * see \ref libusb_endpoint_direction.
	 */
 uint8_t bEndpointAddress;

 /** Attributes which apply to the endpoint when it is configured using
	 * the bConfigurationValue. Bits 0:1 determine the transfer type and
	 * correspond to \ref libusb_transfer_type. Bits 2:3 are only used for
	 * isochronous endpoints and correspond to \ref libusb_iso_sync_type.
	 * Bits 4:5 are also only used for isochronous endpoints and correspond to
	 * \ref libusb_iso_usage_type. Bits 6:7 are reserved.
	 */
 uint8_t bmAttributes;

 /** Maximum packet size this endpoint is capable of sending/receiving. */
 uint16_t wMaxPacketSize;

 /** Interval for polling endpoint for data transfers. */
 uint8_t bInterval;

 /** For audio devices only: the rate at which synchronization feedback
	 * is provided. */
 uint8_t bRefresh;

 /** For audio devices only: the address if the synch endpoint */
 uint8_t bSynchAddress;

 /** Extra descriptors. If libusb encounters unknown endpoint descriptors,
	 * it will store them here, should you wish to parse them. */
 const unsigned char *extra;

 /** Length of the extra descriptors, in bytes. */
 int extra_length;
};

/** \ingroup libusb_desc
 * A structure representing the standard USB interface descriptor. This
 * descriptor is documented in section 9.6.5 of the USB 3.0 specification.
 * All multiple-byte fields are represented in host-endian format.
 */
struct libusb_interface_descriptor {
 /** Size of this descriptor (in bytes) */
 uint8_t bLength;

 /** Descriptor type. Will have value
	 * \ref libusb_descriptor_type::LIBUSB_DT_INTERFACE LIBUSB_DT_INTERFACE
	 * in this context. */
 uint8_t bDescriptorType;

 /** Number of this interface */
 uint8_t bInterfaceNumber;

 /** Value used to select this alternate setting for this interface */
 uint8_t bAlternateSetting;

 /** Number of endpoints used by this interface (excluding the control
	 * endpoint). */
 uint8_t bNumEndpoints;

 /** USB-IF class code for this interface. See \ref libusb_class_code. */
 uint8_t bInterfaceClass;

 /** USB-IF subclass code for this interface, qualified by the
	 * bInterfaceClass value */
 uint8_t bInterfaceSubClass;

 /** USB-IF protocol code for this interface, qualified by the
	 * bInterfaceClass and bInterfaceSubClass values */
 uint8_t bInterfaceProtocol;

 /** Index of string descriptor describing this interface */
 uint8_t iInterface;

 /** Array of endpoint descriptors. This length of this array is determined
	 * by the bNumEndpoints field. */
 const struct libusb_endpoint_descriptor *endpoint;

 /** Extra descriptors. If libusb encounters unknown interface descriptors,
	 * it will store them here, should you wish to parse them. */
 const unsigned char *extra;

 /** Length of the extra descriptors, in bytes. */
 int extra_length;
};

/** \ingroup libusb_desc
 * A collection of alternate settings for a particular USB interface.
 */
struct libusb_interface {
 /** Array of interface descriptors. The length of this array is determined
	 * by the num_altsetting field. */
 const struct libusb_interface_descriptor *altsetting;

 /** The number of alternate settings that belong to this interface */
 int num_altsetting;
};

/** \ingroup libusb_desc
 * A structure representing the standard USB configuration descriptor. This
 * descriptor is documented in section 9.6.3 of the USB 3.0 specification.
 * All multiple-byte fields are represented in host-endian format.
 */
struct libusb_config_descriptor {
 /** Size of this descriptor (in bytes) */
 uint8_t bLength;

 /** Descriptor type. Will have value
	 * \ref libusb_descriptor_type::LIBUSB_DT_CONFIG LIBUSB_DT_CONFIG
	 * in this context. */
 uint8_t bDescriptorType;

 /** Total length of data returned for this configuration */
 uint16_t wTotalLength;

 /** Number of interfaces supported by this configuration */
 uint8_t bNumInterfaces;

 /** Identifier value for this configuration */
 uint8_t bConfigurationValue;

 /** Index of string descriptor describing this configuration */
 uint8_t iConfiguration;

 /** Configuration characteristics */
 uint8_t bmAttributes;

 /** Maximum power consumption of the USB device from this bus in this
	 * configuration when the device is fully operation. Expressed in units
	 * of 2 mA when the device is operating in high-speed mode and in units
	 * of 8 mA when the device is operating in super-speed mode. */
 uint8_t MaxPower;

 /** Array of interfaces supported by this configuration. The length of
	 * this array is determined by the bNumInterfaces field. */
 const struct libusb_interface *interface;

 /** Extra descriptors. If libusb encounters unknown configuration
	 * descriptors, it will store them here, should you wish to parse them. */
 const unsigned char *extra;

 /** Length of the extra descriptors, in bytes. */
 int extra_length;
};

/** \ingroup libusb_desc
 * A structure representing the superspeed endpoint companion
 * descriptor. This descriptor is documented in section 9.6.7 of
 * the USB 3.0 specification. All multiple-byte fields are represented in
 * host-endian format.
 */
struct libusb_ss_endpoint_companion_descriptor {

 /** Size of this descriptor (in bytes) */
 uint8_t bLength;

 /** Descriptor type. Will have value
	 * \ref libusb_descriptor_type::LIBUSB_DT_SS_ENDPOINT_COMPANION in
	 * this context. */
 uint8_t bDescriptorType;


 /** The maximum number of packets the endpoint can send or
	 *  receive as part of a burst. */
 uint8_t bMaxBurst;

 /** In bulk EP:	bits 4:0 represents the	maximum	number of
	 *  streams the	EP supports. In	isochronous EP:	bits 1:0
	 *  represents the Mult	- a zero based value that determines
	 *  the	maximum	number of packets within a service interval  */
 uint8_t bmAttributes;

 /** The	total number of bytes this EP will transfer every
	 *  service interval. valid only for periodic EPs. */
 uint16_t wBytesPerInterval;
};

/** \ingroup libusb_desc
 * A generic representation of a BOS Device Capability descriptor. It is
 * advised to check bDevCapabilityType and call the matching
 * libusb_get_*_descriptor function to get a structure fully matching the type.
 */
struct libusb_bos_dev_capability_descriptor {
 /** Size of this descriptor (in bytes) */
 uint8_t bLength;
 /** Descriptor type. Will have value
	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. */
 uint8_t bDescriptorType;
 /** Device Capability type */
 uint8_t bDevCapabilityType;
 /** Device Capability data (bLength - 3 bytes) */
 uint8_t dev_capability_data[];
};

/** \ingroup libusb_desc
 * A structure representing the Binary Device Object Store (BOS) descriptor.
 * This descriptor is documented in section 9.6.2 of the USB 3.0 specification.
 * All multiple-byte fields are represented in host-endian format.
 */
struct libusb_bos_descriptor {
 /** Size of this descriptor (in bytes) */
 uint8_t bLength;

 /** Descriptor type. Will have value
	 * \ref libusb_descriptor_type::LIBUSB_DT_BOS LIBUSB_DT_BOS
	 * in this context. */
 uint8_t bDescriptorType;

 /** Length of this descriptor and all of its sub descriptors */
 uint16_t wTotalLength;

 /** The number of separate device capability descriptors in
	 * the BOS */
 uint8_t bNumDeviceCaps;

 /** bNumDeviceCap Device Capability Descriptors */
 struct libusb_bos_dev_capability_descriptor *dev_capability[];
};

/** \ingroup libusb_desc
 * A structure representing the USB 2.0 Extension descriptor
 * This descriptor is documented in section 9.6.2.1 of the USB 3.0 specification.
 * All multiple-byte fields are represented in host-endian format.
 */
struct libusb_usb_2_0_extension_descriptor {
 /** Size of this descriptor (in bytes) */
 uint8_t bLength;

 /** Descriptor type. Will have value
	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. */
 uint8_t bDescriptorType;

 /** Capability type. Will have value
	 * \ref libusb_capability_type::LIBUSB_BT_USB_2_0_EXTENSION
	 * LIBUSB_BT_USB_2_0_EXTENSION in this context. */
 uint8_t bDevCapabilityType;

 /** Bitmap encoding of supported device level features.
	 * A value of one in a bit location indicates a feature is
	 * supported; a value of zero indicates it is not supported.
	 * See \ref libusb_usb_2_0_extension_attributes. */
 uint32_t bmAttributes;
};

/** \ingroup libusb_desc
 * A structure representing the SuperSpeed USB Device Capability descriptor
 * This descriptor is documented in section 9.6.2.2 of the USB 3.0 specification.
 * All multiple-byte fields are represented in host-endian format.
 */
struct libusb_ss_usb_device_capability_descriptor {
 /** Size of this descriptor (in bytes) */
 uint8_t bLength;

 /** Descriptor type. Will have value
	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. */
 uint8_t bDescriptorType;

 /** Capability type. Will have value
	 * \ref libusb_capability_type::LIBUSB_BT_SS_USB_DEVICE_CAPABILITY
	 * LIBUSB_BT_SS_USB_DEVICE_CAPABILITY in this context. */
 uint8_t bDevCapabilityType;

 /** Bitmap encoding of supported device level features.
	 * A value of one in a bit location indicates a feature is
	 * supported; a value of zero indicates it is not supported.
	 * See \ref libusb_ss_usb_device_capability_attributes. */
 uint8_t bmAttributes;

 /** Bitmap encoding of the speed supported by this device when
	 * operating in SuperSpeed mode. See \ref libusb_supported_speed. */
 uint16_t wSpeedSupported;

 /** The lowest speed at which all the functionality supported
	 * by the device is available to the user. For example if the
	 * device supports all its functionality when connected at
	 * full speed and above then it sets this value to 1. */
 uint8_t bFunctionalitySupport;

 /** U1 Device Exit Latency. */
 uint8_t bU1DevExitLat;

 /** U2 Device Exit Latency. */
 uint16_t bU2DevExitLat;
};

/** \ingroup libusb_desc
 * A structure representing the Container ID descriptor.
 * This descriptor is documented in section 9.6.2.3 of the USB 3.0 specification.
 * All multiple-byte fields, except UUIDs, are represented in host-endian format.
 */
struct libusb_container_id_descriptor {
 /** Size of this descriptor (in bytes) */
 uint8_t bLength;

 /** Descriptor type. Will have value
	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. */
 uint8_t bDescriptorType;

 /** Capability type. Will have value
	 * \ref libusb_capability_type::LIBUSB_BT_CONTAINER_ID
	 * LIBUSB_BT_CONTAINER_ID in this context. */
 uint8_t bDevCapabilityType;

 /** Reserved field */
 uint8_t bReserved;

 /** 128 bit UUID */
 uint8_t ContainerID[16];
};

/** \ingroup libusb_asyncio
 * Setup packet for control transfers. */
struct libusb_control_setup {
 /** Request type. Bits 0:4 determine recipient, see
	 * \ref libusb_request_recipient. Bits 5:6 determine type, see
	 * \ref libusb_request_type. Bit 7 determines data transfer direction, see
	 * \ref libusb_endpoint_direction.
	 */
 uint8_t bmRequestType;

 /** Request. If the type bits of bmRequestType are equal to
	 * \ref libusb_request_type::LIBUSB_REQUEST_TYPE_STANDARD
	 * "LIBUSB_REQUEST_TYPE_STANDARD" then this field refers to
	 * \ref libusb_standard_request. For other cases, use of this field is
	 * application-specific. */
 uint8_t bRequest;

 /** Value. Varies according to request */
 uint16_t wValue;

 /** Index. Varies according to request, typically used to pass an index
	 * or offset */
 uint16_t wIndex;

 /** Number of bytes to transfer */
 uint16_t wLength;
};

#define LIBUSB_CONTROL_SETUP_SIZE (sizeof(struct libusb_control_setup))

/* libusb */

struct libusb_context;
struct libusb_device;
struct libusb_device_handle;

/** \ingroup libusb_lib
 * Structure providing the version of the libusb runtime
 */
struct libusb_version {
 /** Library major version. */
 const uint16_t major;

 /** Library minor version. */
 const uint16_t minor;

 /** Library micro version. */
 const uint16_t micro;

 /** Library nano version. */
 const uint16_t nano;

 /** Library release candidate suffix string, e.g. "-rc4". */
 const char *rc;

 /** For ABI compatibility only. */
 const char* describe;
};

/** \ingroup libusb_lib
 * Structure representing a libusb session. The concept of individual libusb
 * sessions allows for your program to use two libraries (or dynamically
 * load two modules) which both independently use libusb. This will prevent
 * interference between the individual libusb users - for example
 * libusb_set_option() will not affect the other user of the library, and
 * libusb_exit() will not destroy resources that the other user is still
 * using.
 *
 * Sessions are created by libusb_init() and destroyed through libusb_exit().
 * If your application is guaranteed to only ever include a single libusb
 * user (i.e. you), you do not have to worry about contexts: pass NULL in
 * every function call where a context is required. The default context
 * will be used.
 *
 * For more information, see \ref libusb_contexts.
 */
typedef struct libusb_context libusb_context;

/** \ingroup libusb_dev
 * Structure representing a USB device detected on the system. This is an
 * opaque type for which you are only ever provided with a pointer, usually
 * originating from libusb_get_device_list().
 *
 * Certain operations can be performed on a device, but in order to do any
 * I/O you will have to first obtain a device handle using libusb_open().
 *
 * Devices are reference counted with libusb_ref_device() and
 * libusb_unref_device(), and are freed when the reference count reaches 0.
 * New devices presented by libusb_get_device_list() have a reference count of
 * 1, and libusb_free_device_list() can optionally decrease the reference count
 * on all devices in the list. libusb_open() adds another reference which is
 * later destroyed by libusb_close().
 */
typedef struct libusb_device libusb_device;


/** \ingroup libusb_dev
 * Structure representing a handle on a USB device. This is an opaque type for
 * which you are only ever provided with a pointer, usually originating from
 * libusb_open().
 *
 * A device handle is used to perform I/O and other operations. When finished
 * with a device handle, you should call libusb_close().
 */
typedef struct libusb_device_handle libusb_device_handle;

/** \ingroup libusb_dev
 * Speed codes. Indicates the speed at which the device is operating.
 */
enum libusb_speed {
 /** The OS doesn't report or know the device speed. */
 LIBUSB_SPEED_UNKNOWN = 0,

 /** The device is operating at low speed (1.5MBit/s). */
 LIBUSB_SPEED_LOW = 1,

 /** The device is operating at full speed (12MBit/s). */
 LIBUSB_SPEED_FULL = 2,

 /** The device is operating at high speed (480MBit/s). */
 LIBUSB_SPEED_HIGH = 3,

 /** The device is operating at super speed (5000MBit/s). */
 LIBUSB_SPEED_SUPER = 4,

 /** The device is operating at super speed plus (10000MBit/s). */
 LIBUSB_SPEED_SUPER_PLUS = 5,
};

/** \ingroup libusb_dev
 * Supported speeds (wSpeedSupported) bitfield. Indicates what
 * speeds the device supports.
 */
enum libusb_supported_speed {
 /** Low speed operation supported (1.5MBit/s). */
 LIBUSB_LOW_SPEED_OPERATION = 1,

 /** Full speed operation supported (12MBit/s). */
 LIBUSB_FULL_SPEED_OPERATION = 2,

 /** High speed operation supported (480MBit/s). */
 LIBUSB_HIGH_SPEED_OPERATION = 4,

 /** Superspeed operation supported (5000MBit/s). */
 LIBUSB_SUPER_SPEED_OPERATION = 8,
};

/** \ingroup libusb_dev
 * Masks for the bits of the
 * \ref libusb_usb_2_0_extension_descriptor::bmAttributes "bmAttributes" field
 * of the USB 2.0 Extension descriptor.
 */
enum libusb_usb_2_0_extension_attributes {
 /** Supports Link Power Management (LPM) */
 LIBUSB_BM_LPM_SUPPORT = 2,
};

/** \ingroup libusb_dev
 * Masks for the bits of the
 * \ref libusb_ss_usb_device_capability_descriptor::bmAttributes "bmAttributes" field
 * field of the SuperSpeed USB Device Capability descriptor.
 */
enum libusb_ss_usb_device_capability_attributes {
 /** Supports Latency Tolerance Messages (LTM) */
 LIBUSB_BM_LTM_SUPPORT = 2,
};

/** \ingroup libusb_dev
 * USB capability types
 */
enum libusb_bos_type {
 /** Wireless USB device capability */
 LIBUSB_BT_WIRELESS_USB_DEVICE_CAPABILITY = 1,

 /** USB 2.0 extensions */
 LIBUSB_BT_USB_2_0_EXTENSION = 2,

 /** SuperSpeed USB device capability */
 LIBUSB_BT_SS_USB_DEVICE_CAPABILITY = 3,

 /** Container ID type */
 LIBUSB_BT_CONTAINER_ID = 4,
};

/** \ingroup libusb_misc
 * Error codes. Most libusb functions return 0 on success or one of these
 * codes on failure.
 * You can call libusb_error_name() to retrieve a string representation of an
 * error code or libusb_strerror() to get an end-user suitable description of
 * an error code.
 */
enum libusb_error {
 /** Success (no error) */
 LIBUSB_SUCCESS = 0,

 /** Input/output error */
 LIBUSB_ERROR_IO = -1,

 /** Invalid parameter */
 LIBUSB_ERROR_INVALID_PARAM = -2,

 /** Access denied (insufficient permissions) */
 LIBUSB_ERROR_ACCESS = -3,

 /** No such device (it may have been disconnected) */
 LIBUSB_ERROR_NO_DEVICE = -4,

 /** Entity not found */
 LIBUSB_ERROR_NOT_FOUND = -5,

 /** Resource busy */
 LIBUSB_ERROR_BUSY = -6,

 /** Operation timed out */
 LIBUSB_ERROR_TIMEOUT = -7,

 /** Overflow */
 LIBUSB_ERROR_OVERFLOW = -8,

 /** Pipe error */
 LIBUSB_ERROR_PIPE = -9,

 /** System call interrupted (perhaps due to signal) */
 LIBUSB_ERROR_INTERRUPTED = -10,

 /** Insufficient memory */
 LIBUSB_ERROR_NO_MEM = -11,

 /** Operation not supported or unimplemented on this platform */
 LIBUSB_ERROR_NOT_SUPPORTED = -12,

 /* NB: Remember to update LIBUSB_ERROR_COUNT below as well as the
	   message strings in strerror.c when adding new error codes here. */

 /** Other error */
 LIBUSB_ERROR_OTHER = -99,
};

/* Total number of error codes in enum libusb_error */
#define LIBUSB_ERROR_COUNT 14

/** \ingroup libusb_asyncio
 * Transfer status codes */
enum libusb_transfer_status {
 /** Transfer completed without error. Note that this does not indicate
	 * that the entire amount of requested data was transferred. */
 LIBUSB_TRANSFER_COMPLETED,

 /** Transfer failed */
 LIBUSB_TRANSFER_ERROR,

 /** Transfer timed out */
 LIBUSB_TRANSFER_TIMED_OUT,

 /** Transfer was cancelled */
 LIBUSB_TRANSFER_CANCELLED,

 /** For bulk/interrupt endpoints: halt condition detected (endpoint
	 * stalled). For control endpoints: control request not supported. */
 LIBUSB_TRANSFER_STALL,

 /** Device was disconnected */
 LIBUSB_TRANSFER_NO_DEVICE,

 /** Device sent more data than requested */
 LIBUSB_TRANSFER_OVERFLOW,

 /* NB! Remember to update libusb_error_name()
	   when adding new status codes here. */
};

/** \ingroup libusb_asyncio
 * libusb_transfer.flags values */
enum libusb_transfer_flags {
 /** Report short frames as errors */
 LIBUSB_TRANSFER_SHORT_NOT_OK = 1<<0,

 /** Automatically free() transfer buffer during libusb_free_transfer().
	 * Note that buffers allocated with libusb_dev_mem_alloc() should not
	 * be attempted freed in this way, since free() is not an appropriate
	 * way to release such memory. */
 LIBUSB_TRANSFER_FREE_BUFFER = 1<<1,

 /** Automatically call libusb_free_transfer() after callback returns.
	 * If this flag is set, it is illegal to call libusb_free_transfer()
	 * from your transfer callback, as this will result in a double-free
	 * when this flag is acted upon. */
 LIBUSB_TRANSFER_FREE_TRANSFER = 1<<2,

 /** Terminate transfers that are a multiple of the endpoint's
	 * wMaxPacketSize with an extra zero length packet. This is useful
	 * when a device protocol mandates that each logical request is
	 * terminated by an incomplete packet (i.e. the logical requests are
	 * not separated by other means).
	 *
	 * This flag only affects host-to-device transfers to bulk and interrupt
	 * endpoints. In other situations, it is ignored.
	 *
	 * This flag only affects transfers with a length that is a multiple of
	 * the endpoint's wMaxPacketSize. On transfers of other lengths, this
	 * flag has no effect. Therefore, if you are working with a device that
	 * needs a ZLP whenever the end of the logical request falls on a packet
	 * boundary, then it is sensible to set this flag on <em>every</em>
	 * transfer (you do not have to worry about only setting it on transfers
	 * that end on the boundary).
	 *
	 * This flag is currently only supported on Linux.
	 * On other systems, libusb_submit_transfer() will return
	 * LIBUSB_ERROR_NOT_SUPPORTED for every transfer where this flag is set.
	 *
	 * Available since libusb-1.0.9.
	 */
 LIBUSB_TRANSFER_ADD_ZERO_PACKET = 1 << 3,
};

/** \ingroup libusb_asyncio
 * Isochronous packet descriptor. */
struct libusb_iso_packet_descriptor {
 /** Length of data to request in this packet */
 unsigned int length;

 /** Amount of data that was actually transferred */
 unsigned int actual_length;

 /** Status code for this packet */
 enum libusb_transfer_status status;
};

struct libusb_transfer;

/** \ingroup libusb_asyncio
 * Asynchronous transfer callback function type. When submitting asynchronous
 * transfers, you pass a pointer to a callback function of this type via the
 * \ref libusb_transfer::callback "callback" member of the libusb_transfer
 * structure. libusb will call this function later, when the transfer has
 * completed or failed. See \ref libusb_asyncio for more information.
 * \param transfer The libusb_transfer struct the callback function is being
 * notified about.
 */
typedef void ( *libusb_transfer_cb_fn)(struct libusb_transfer *transfer);

/** \ingroup libusb_asyncio
 * The generic USB transfer structure. The user populates this structure and
 * then submits it in order to request a transfer. After the transfer has
 * completed, the library populates the transfer with the results and passes
 * it back to the user.
 */
struct libusb_transfer {
 /** Handle of the device that this transfer will be submitted to */
 libusb_device_handle *dev_handle;

 /** A bitwise OR combination of \ref libusb_transfer_flags. */
 uint8_t flags;

 /** Address of the endpoint where this transfer will be sent. */
 unsigned char endpoint;

 /** Type of the endpoint from \ref libusb_transfer_type */
 unsigned char type;

 /** Timeout for this transfer in milliseconds. A value of 0 indicates no
	 * timeout. */
 unsigned int timeout;

 /** The status of the transfer. Read-only, and only for use within
	 * transfer callback function.
	 *
	 * If this is an isochronous transfer, this field may read COMPLETED even
	 * if there were errors in the frames. Use the
	 * \ref libusb_iso_packet_descriptor::status "status" field in each packet
	 * to determine if errors occurred. */
 enum libusb_transfer_status status;

 /** Length of the data buffer */
 int length;

 /** Actual length of data that was transferred. Read-only, and only for
	 * use within transfer callback function. Not valid for isochronous
	 * endpoint transfers. */
 int actual_length;

 /** Callback function. This will be invoked when the transfer completes,
	 * fails, or is cancelled. */
 libusb_transfer_cb_fn callback;

 /** User context data to pass to the callback function. */
 void *user_data;

 /** Data buffer */
 unsigned char *buffer;

 /** Number of isochronous packets. Only used for I/O with isochronous
	 * endpoints. */
 int num_iso_packets;

 /** Isochronous packet descriptors, for isochronous transfers only. */
 struct libusb_iso_packet_descriptor iso_packet_desc[];
};

/** \ingroup libusb_misc
 * Capabilities supported by an instance of libusb on the current running
 * platform. Test if the loaded library supports a given capability by calling
 * \ref libusb_has_capability().
 */
enum libusb_capability {
 /** The libusb_has_capability() API is available. */
 LIBUSB_CAP_HAS_CAPABILITY = 0x0000,
 /** Hotplug support is available on this platform. */
 LIBUSB_CAP_HAS_HOTPLUG = 0x0001,
 /** The library can access HID devices without requiring user intervention.
	 * Note that before being able to actually access an HID device, you may
	 * still have to call additional libusb functions such as
	 * \ref libusb_detach_kernel_driver(). */
 LIBUSB_CAP_HAS_HID_ACCESS = 0x0100,
 /** The library supports detaching of the default USB driver, using 
	 * \ref libusb_detach_kernel_driver(), if one is set by the OS kernel */
 LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER = 0x0101
};

/** \ingroup libusb_lib
 *  Log message levels.
 *  - LIBUSB_LOG_LEVEL_NONE (0)    : no messages ever printed by the library (default)
 *  - LIBUSB_LOG_LEVEL_ERROR (1)   : error messages are printed to stderr
 *  - LIBUSB_LOG_LEVEL_WARNING (2) : warning and error messages are printed to stderr
 *  - LIBUSB_LOG_LEVEL_INFO (3)    : informational messages are printed to stderr
 *  - LIBUSB_LOG_LEVEL_DEBUG (4)   : debug and informational messages are printed to stderr
 */
enum libusb_log_level {
 LIBUSB_LOG_LEVEL_NONE = 0,
 LIBUSB_LOG_LEVEL_ERROR = 1,
 LIBUSB_LOG_LEVEL_WARNING = 2,
 LIBUSB_LOG_LEVEL_INFO = 3,
 LIBUSB_LOG_LEVEL_DEBUG = 4,
};

int libusb_init(libusb_context **ctx);
void libusb_exit(libusb_context *ctx);
__attribute__((deprecated("Use " "libusb_set_option" " instead")))
void libusb_set_debug(libusb_context *ctx, int level);
const struct libusb_version * libusb_get_version(void);
int libusb_has_capability(uint32_t capability);
const char * libusb_error_name(int errcode);
int libusb_setlocale(const char *locale);
const char * libusb_strerror(enum libusb_error errcode);

ssize_t libusb_get_device_list(libusb_context *ctx,
 libusb_device ***list);
void libusb_free_device_list(libusb_device **list,
 int unref_devices);
libusb_device * libusb_ref_device(libusb_device *dev);
void libusb_unref_device(libusb_device *dev);

int libusb_get_configuration(libusb_device_handle *dev,
 int *config);
int libusb_get_device_descriptor(libusb_device *dev,
 struct libusb_device_descriptor *desc);
int libusb_get_active_config_descriptor(libusb_device *dev,
 struct libusb_config_descriptor **config);
int libusb_get_config_descriptor(libusb_device *dev,
 uint8_t config_index, struct libusb_config_descriptor **config);
int libusb_get_config_descriptor_by_value(libusb_device *dev,
 uint8_t bConfigurationValue, struct libusb_config_descriptor **config);
void libusb_free_config_descriptor(
 struct libusb_config_descriptor *config);
int libusb_get_ss_endpoint_companion_descriptor(
 struct libusb_context *ctx,
 const struct libusb_endpoint_descriptor *endpoint,
 struct libusb_ss_endpoint_companion_descriptor **ep_comp);
void libusb_free_ss_endpoint_companion_descriptor(
 struct libusb_ss_endpoint_companion_descriptor *ep_comp);
int libusb_get_bos_descriptor(libusb_device_handle *dev_handle,
 struct libusb_bos_descriptor **bos);
void libusb_free_bos_descriptor(struct libusb_bos_descriptor *bos);
int libusb_get_usb_2_0_extension_descriptor(
 struct libusb_context *ctx,
 struct libusb_bos_dev_capability_descriptor *dev_cap,
 struct libusb_usb_2_0_extension_descriptor **usb_2_0_extension);
void libusb_free_usb_2_0_extension_descriptor(
 struct libusb_usb_2_0_extension_descriptor *usb_2_0_extension);
int libusb_get_ss_usb_device_capability_descriptor(
 struct libusb_context *ctx,
 struct libusb_bos_dev_capability_descriptor *dev_cap,
 struct libusb_ss_usb_device_capability_descriptor **ss_usb_device_cap);
void libusb_free_ss_usb_device_capability_descriptor(
 struct libusb_ss_usb_device_capability_descriptor *ss_usb_device_cap);
int libusb_get_container_id_descriptor(struct libusb_context *ctx,
 struct libusb_bos_dev_capability_descriptor *dev_cap,
 struct libusb_container_id_descriptor **container_id);
void libusb_free_container_id_descriptor(
 struct libusb_container_id_descriptor *container_id);
uint8_t libusb_get_bus_number(libusb_device *dev);
uint8_t libusb_get_port_number(libusb_device *dev);
int libusb_get_port_numbers(libusb_device *dev, uint8_t* port_numbers, int port_numbers_len);
__attribute__((deprecated("Use " "libusb_get_port_numbers" " instead")))
int libusb_get_port_path(libusb_context *ctx, libusb_device *dev, uint8_t* path, uint8_t path_length);
libusb_device * libusb_get_parent(libusb_device *dev);
uint8_t libusb_get_device_address(libusb_device *dev);
int libusb_get_device_speed(libusb_device *dev);
int libusb_get_max_packet_size(libusb_device *dev,
 unsigned char endpoint);
int libusb_get_max_iso_packet_size(libusb_device *dev,
 unsigned char endpoint);

int libusb_open(libusb_device *dev, libusb_device_handle **dev_handle);
void libusb_close(libusb_device_handle *dev_handle);
libusb_device * libusb_get_device(libusb_device_handle *dev_handle);

int libusb_set_configuration(libusb_device_handle *dev_handle,
 int configuration);
int libusb_claim_interface(libusb_device_handle *dev_handle,
 int interface_number);
int libusb_release_interface(libusb_device_handle *dev_handle,
 int interface_number);

libusb_device_handle * libusb_open_device_with_vid_pid(
 libusb_context *ctx, uint16_t vendor_id, uint16_t product_id);

int libusb_set_interface_alt_setting(libusb_device_handle *dev_handle,
 int interface_number, int alternate_setting);
int libusb_clear_halt(libusb_device_handle *dev_handle,
 unsigned char endpoint);
int libusb_reset_device(libusb_device_handle *dev_handle);

int libusb_alloc_streams(libusb_device_handle *dev_handle,
 uint32_t num_streams, unsigned char *endpoints, int num_endpoints);
int libusb_free_streams(libusb_device_handle *dev_handle,
 unsigned char *endpoints, int num_endpoints);

unsigned char * libusb_dev_mem_alloc(libusb_device_handle *dev_handle,
 size_t length);
int libusb_dev_mem_free(libusb_device_handle *dev_handle,
 unsigned char *buffer, size_t length);

int libusb_kernel_driver_active(libusb_device_handle *dev_handle,
 int interface_number);
int libusb_detach_kernel_driver(libusb_device_handle *dev_handle,
 int interface_number);
int libusb_attach_kernel_driver(libusb_device_handle *dev_handle,
 int interface_number);
int libusb_set_auto_detach_kernel_driver(
 libusb_device_handle *dev_handle, int enable);

/* async I/O */

/** \ingroup libusb_asyncio
 * Get the data section of a control transfer. This convenience function is here
 * to remind you that the data does not start until 8 bytes into the actual
 * buffer, as the setup packet comes first.
 *
 * Calling this function only makes sense from a transfer callback function,
 * or situations where you have already allocated a suitably sized buffer at
 * transfer->buffer.
 *
 * \param transfer a transfer
 * \returns pointer to the first byte of the data section
 */
static inline unsigned char *libusb_control_transfer_get_data(
 struct libusb_transfer *transfer)
{
 return transfer->buffer + (sizeof(struct libusb_control_setup));
}

/** \ingroup libusb_asyncio
 * Get the control setup packet of a control transfer. This convenience
 * function is here to remind you that the control setup occupies the first
 * 8 bytes of the transfer data buffer.
 *
 * Calling this function only makes sense from a transfer callback function,
 * or situations where you have already allocated a suitably sized buffer at
 * transfer->buffer.
 *
 * \param transfer a transfer
 * \returns a casted pointer to the start of the transfer data buffer
 */
static inline struct libusb_control_setup *libusb_control_transfer_get_setup(
 struct libusb_transfer *transfer)
{
 return (struct libusb_control_setup *)(void *) transfer->buffer;
}

/** \ingroup libusb_asyncio
 * Helper function to populate the setup packet (first 8 bytes of the data
 * buffer) for a control transfer. The wIndex, wValue and wLength values should
 * be given in host-endian byte order.
 *
 * \param buffer buffer to output the setup packet into
 * This pointer must be aligned to at least 2 bytes boundary.
 * \param bmRequestType see the
 * \ref libusb_control_setup::bmRequestType "bmRequestType" field of
 * \ref libusb_control_setup
 * \param bRequest see the
 * \ref libusb_control_setup::bRequest "bRequest" field of
 * \ref libusb_control_setup
 * \param wValue see the
 * \ref libusb_control_setup::wValue "wValue" field of
 * \ref libusb_control_setup
 * \param wIndex see the
 * \ref libusb_control_setup::wIndex "wIndex" field of
 * \ref libusb_control_setup
 * \param wLength see the
 * \ref libusb_control_setup::wLength "wLength" field of
 * \ref libusb_control_setup
 */
static inline void libusb_fill_control_setup(unsigned char *buffer,
 uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex,
 uint16_t wLength)
{
 struct libusb_control_setup *setup = (struct libusb_control_setup *)(void *) buffer;
 setup->bmRequestType = bmRequestType;
 setup->bRequest = bRequest;
 setup->wValue = libusb_cpu_to_le16(wValue);
 setup->wIndex = libusb_cpu_to_le16(wIndex);
 setup->wLength = libusb_cpu_to_le16(wLength);
}

struct libusb_transfer * libusb_alloc_transfer(int iso_packets);
int libusb_submit_transfer(struct libusb_transfer *transfer);
int libusb_cancel_transfer(struct libusb_transfer *transfer);
void libusb_free_transfer(struct libusb_transfer *transfer);
void libusb_transfer_set_stream_id(
 struct libusb_transfer *transfer, uint32_t stream_id);
uint32_t libusb_transfer_get_stream_id(
 struct libusb_transfer *transfer);

/** \ingroup libusb_asyncio
 * Helper function to populate the required \ref libusb_transfer fields
 * for a control transfer.
 *
 * If you pass a transfer buffer to this function, the first 8 bytes will
 * be interpreted as a control setup packet, and the wLength field will be
 * used to automatically populate the \ref libusb_transfer::length "length"
 * field of the transfer. Therefore the recommended approach is:
 * -# Allocate a suitably sized data buffer (including space for control setup)
 * -# Call libusb_fill_control_setup()
 * -# If this is a host-to-device transfer with a data stage, put the data
 *    in place after the setup packet
 * -# Call this function
 * -# Call libusb_submit_transfer()
 *
 * It is also legal to pass a NULL buffer to this function, in which case this
 * function will not attempt to populate the length field. Remember that you
 * must then populate the buffer and length fields later.
 *
 * \param transfer the transfer to populate
 * \param dev_handle handle of the device that will handle the transfer
 * \param buffer data buffer. If provided, this function will interpret the
 * first 8 bytes as a setup packet and infer the transfer length from that.
 * This pointer must be aligned to at least 2 bytes boundary.
 * \param callback callback function to be invoked on transfer completion
 * \param user_data user data to pass to callback function
 * \param timeout timeout for the transfer in milliseconds
 */
static inline void libusb_fill_control_transfer(
 struct libusb_transfer *transfer, libusb_device_handle *dev_handle,
 unsigned char *buffer, libusb_transfer_cb_fn callback, void *user_data,
 unsigned int timeout)
{
 struct libusb_control_setup *setup = (struct libusb_control_setup *)(void *) buffer;
 transfer->dev_handle = dev_handle;
 transfer->endpoint = 0;
 transfer->type = LIBUSB_TRANSFER_TYPE_CONTROL;
 transfer->timeout = timeout;
 transfer->buffer = buffer;
 if (setup)
  transfer->length = (int) ((sizeof(struct libusb_control_setup))
   + libusb_cpu_to_le16(setup->wLength));
 transfer->user_data = user_data;
 transfer->callback = callback;
}

/** \ingroup libusb_asyncio
 * Helper function to populate the required \ref libusb_transfer fields
 * for a bulk transfer.
 *
 * \param transfer the transfer to populate
 * \param dev_handle handle of the device that will handle the transfer
 * \param endpoint address of the endpoint where this transfer will be sent
 * \param buffer data buffer
 * \param length length of data buffer
 * \param callback callback function to be invoked on transfer completion
 * \param user_data user data to pass to callback function
 * \param timeout timeout for the transfer in milliseconds
 */
static inline void libusb_fill_bulk_transfer(struct libusb_transfer *transfer,
 libusb_device_handle *dev_handle, unsigned char endpoint,
 unsigned char *buffer, int length, libusb_transfer_cb_fn callback,
 void *user_data, unsigned int timeout)
{
 transfer->dev_handle = dev_handle;
 transfer->endpoint = endpoint;
 transfer->type = LIBUSB_TRANSFER_TYPE_BULK;
 transfer->timeout = timeout;
 transfer->buffer = buffer;
 transfer->length = length;
 transfer->user_data = user_data;
 transfer->callback = callback;
}

/** \ingroup libusb_asyncio
 * Helper function to populate the required \ref libusb_transfer fields
 * for a bulk transfer using bulk streams.
 *
 * Since version 1.0.19, \ref LIBUSB_API_VERSION >= 0x01000103
 *
 * \param transfer the transfer to populate
 * \param dev_handle handle of the device that will handle the transfer
 * \param endpoint address of the endpoint where this transfer will be sent
 * \param stream_id bulk stream id for this transfer
 * \param buffer data buffer
 * \param length length of data buffer
 * \param callback callback function to be invoked on transfer completion
 * \param user_data user data to pass to callback function
 * \param timeout timeout for the transfer in milliseconds
 */
static inline void libusb_fill_bulk_stream_transfer(
 struct libusb_transfer *transfer, libusb_device_handle *dev_handle,
 unsigned char endpoint, uint32_t stream_id,
 unsigned char *buffer, int length, libusb_transfer_cb_fn callback,
 void *user_data, unsigned int timeout)
{
 libusb_fill_bulk_transfer(transfer, dev_handle, endpoint, buffer,
      length, callback, user_data, timeout);
 transfer->type = LIBUSB_TRANSFER_TYPE_BULK_STREAM;
 libusb_transfer_set_stream_id(transfer, stream_id);
}

/** \ingroup libusb_asyncio
 * Helper function to populate the required \ref libusb_transfer fields
 * for an interrupt transfer.
 *
 * \param transfer the transfer to populate
 * \param dev_handle handle of the device that will handle the transfer
 * \param endpoint address of the endpoint where this transfer will be sent
 * \param buffer data buffer
 * \param length length of data buffer
 * \param callback callback function to be invoked on transfer completion
 * \param user_data user data to pass to callback function
 * \param timeout timeout for the transfer in milliseconds
 */
static inline void libusb_fill_interrupt_transfer(
 struct libusb_transfer *transfer, libusb_device_handle *dev_handle,
 unsigned char endpoint, unsigned char *buffer, int length,
 libusb_transfer_cb_fn callback, void *user_data, unsigned int timeout)
{
 transfer->dev_handle = dev_handle;
 transfer->endpoint = endpoint;
 transfer->type = LIBUSB_TRANSFER_TYPE_INTERRUPT;
 transfer->timeout = timeout;
 transfer->buffer = buffer;
 transfer->length = length;
 transfer->user_data = user_data;
 transfer->callback = callback;
}

/** \ingroup libusb_asyncio
 * Helper function to populate the required \ref libusb_transfer fields
 * for an isochronous transfer.
 *
 * \param transfer the transfer to populate
 * \param dev_handle handle of the device that will handle the transfer
 * \param endpoint address of the endpoint where this transfer will be sent
 * \param buffer data buffer
 * \param length length of data buffer
 * \param num_iso_packets the number of isochronous packets
 * \param callback callback function to be invoked on transfer completion
 * \param user_data user data to pass to callback function
 * \param timeout timeout for the transfer in milliseconds
 */
static inline void libusb_fill_iso_transfer(struct libusb_transfer *transfer,
 libusb_device_handle *dev_handle, unsigned char endpoint,
 unsigned char *buffer, int length, int num_iso_packets,
 libusb_transfer_cb_fn callback, void *user_data, unsigned int timeout)
{
 transfer->dev_handle = dev_handle;
 transfer->endpoint = endpoint;
 transfer->type = LIBUSB_TRANSFER_TYPE_ISOCHRONOUS;
 transfer->timeout = timeout;
 transfer->buffer = buffer;
 transfer->length = length;
 transfer->num_iso_packets = num_iso_packets;
 transfer->user_data = user_data;
 transfer->callback = callback;
}

/** \ingroup libusb_asyncio
 * Convenience function to set the length of all packets in an isochronous
 * transfer, based on the num_iso_packets field in the transfer structure.
 *
 * \param transfer a transfer
 * \param length the length to set in each isochronous packet descriptor
 * \see libusb_get_max_packet_size()
 */
static inline void libusb_set_iso_packet_lengths(
 struct libusb_transfer *transfer, unsigned int length)
{
 int i;
 for (i = 0; i < transfer->num_iso_packets; i++)
  transfer->iso_packet_desc[i].length = length;
}

/** \ingroup libusb_asyncio
 * Convenience function to locate the position of an isochronous packet
 * within the buffer of an isochronous transfer.
 *
 * This is a thorough function which loops through all preceding packets,
 * accumulating their lengths to find the position of the specified packet.
 * Typically you will assign equal lengths to each packet in the transfer,
 * and hence the above method is sub-optimal. You may wish to use
 * libusb_get_iso_packet_buffer_simple() instead.
 *
 * \param transfer a transfer
 * \param packet the packet to return the address of
 * \returns the base address of the packet buffer inside the transfer buffer,
 * or NULL if the packet does not exist.
 * \see libusb_get_iso_packet_buffer_simple()
 */
static inline unsigned char *libusb_get_iso_packet_buffer(
 struct libusb_transfer *transfer, unsigned int packet)
{
 int i;
 size_t offset = 0;
 int _packet;

 /* oops..slight bug in the API. packet is an unsigned int, but we use
	 * signed integers almost everywhere else. range-check and convert to
	 * signed to avoid compiler warnings. FIXME for libusb-2. */
 if (packet > 0x7fffffff)
  return 
# 1689 "libusb/libusb/libusb.h" 3 4
        ((void *)0)
# 1689 "libusb/libusb/libusb.h"
            ;
 _packet = (int) packet;

 if (_packet >= transfer->num_iso_packets)
  return 
# 1693 "libusb/libusb/libusb.h" 3 4
        ((void *)0)
# 1693 "libusb/libusb/libusb.h"
            ;

 for (i = 0; i < _packet; i++)
  offset += transfer->iso_packet_desc[i].length;

 return transfer->buffer + offset;
}

/** \ingroup libusb_asyncio
 * Convenience function to locate the position of an isochronous packet
 * within the buffer of an isochronous transfer, for transfers where each
 * packet is of identical size.
 *
 * This function relies on the assumption that every packet within the transfer
 * is of identical size to the first packet. Calculating the location of
 * the packet buffer is then just a simple calculation:
 * <tt>buffer + (packet_size * packet)</tt>
 *
 * Do not use this function on transfers other than those that have identical
 * packet lengths for each packet.
 *
 * \param transfer a transfer
 * \param packet the packet to return the address of
 * \returns the base address of the packet buffer inside the transfer buffer,
 * or NULL if the packet does not exist.
 * \see libusb_get_iso_packet_buffer()
 */
static inline unsigned char *libusb_get_iso_packet_buffer_simple(
 struct libusb_transfer *transfer, unsigned int packet)
{
 int _packet;

 /* oops..slight bug in the API. packet is an unsigned int, but we use
	 * signed integers almost everywhere else. range-check and convert to
	 * signed to avoid compiler warnings. FIXME for libusb-2. */
 if (packet > 0x7fffffff)
  return 
# 1729 "libusb/libusb/libusb.h" 3 4
        ((void *)0)
# 1729 "libusb/libusb/libusb.h"
            ;
 _packet = (int) packet;

 if (_packet >= transfer->num_iso_packets)
  return 
# 1733 "libusb/libusb/libusb.h" 3 4
        ((void *)0)
# 1733 "libusb/libusb/libusb.h"
            ;

 return transfer->buffer + ((int) transfer->iso_packet_desc[0].length * _packet);
}

/* sync I/O */

int libusb_control_transfer(libusb_device_handle *dev_handle,
 uint8_t request_type, uint8_t bRequest, uint16_t wValue, uint16_t wIndex,
 unsigned char *data, uint16_t wLength, unsigned int timeout);

int libusb_bulk_transfer(libusb_device_handle *dev_handle,
 unsigned char endpoint, unsigned char *data, int length,
 int *actual_length, unsigned int timeout);

int libusb_interrupt_transfer(libusb_device_handle *dev_handle,
 unsigned char endpoint, unsigned char *data, int length,
 int *actual_length, unsigned int timeout);

/** \ingroup libusb_desc
 * Retrieve a descriptor from the default control pipe.
 * This is a convenience function which formulates the appropriate control
 * message to retrieve the descriptor.
 *
 * \param dev_handle a device handle
 * \param desc_type the descriptor type, see \ref libusb_descriptor_type
 * \param desc_index the index of the descriptor to retrieve
 * \param data output buffer for descriptor
 * \param length size of data buffer
 * \returns number of bytes returned in data, or LIBUSB_ERROR code on failure
 */
static inline int libusb_get_descriptor(libusb_device_handle *dev_handle,
 uint8_t desc_type, uint8_t desc_index, unsigned char *data, int length)
{
 return libusb_control_transfer(dev_handle, LIBUSB_ENDPOINT_IN,
  LIBUSB_REQUEST_GET_DESCRIPTOR, (uint16_t) ((desc_type << 8) | desc_index),
  0, data, (uint16_t) length, 1000);
}

/** \ingroup libusb_desc
 * Retrieve a descriptor from a device.
 * This is a convenience function which formulates the appropriate control
 * message to retrieve the descriptor. The string returned is Unicode, as
 * detailed in the USB specifications.
 *
 * \param dev_handle a device handle
 * \param desc_index the index of the descriptor to retrieve
 * \param langid the language ID for the string descriptor
 * \param data output buffer for descriptor
 * \param length size of data buffer
 * \returns number of bytes returned in data, or LIBUSB_ERROR code on failure
 * \see libusb_get_string_descriptor_ascii()
 */
static inline int libusb_get_string_descriptor(libusb_device_handle *dev_handle,
 uint8_t desc_index, uint16_t langid, unsigned char *data, int length)
{
 return libusb_control_transfer(dev_handle, LIBUSB_ENDPOINT_IN,
  LIBUSB_REQUEST_GET_DESCRIPTOR, (uint16_t)((LIBUSB_DT_STRING << 8) | desc_index),
  langid, data, (uint16_t) length, 1000);
}

int libusb_get_string_descriptor_ascii(libusb_device_handle *dev_handle,
 uint8_t desc_index, unsigned char *data, int length);

/* polling and timeouts */

int libusb_try_lock_events(libusb_context *ctx);
void libusb_lock_events(libusb_context *ctx);
void libusb_unlock_events(libusb_context *ctx);
int libusb_event_handling_ok(libusb_context *ctx);
int libusb_event_handler_active(libusb_context *ctx);
void libusb_interrupt_event_handler(libusb_context *ctx);
void libusb_lock_event_waiters(libusb_context *ctx);
void libusb_unlock_event_waiters(libusb_context *ctx);
int libusb_wait_for_event(libusb_context *ctx, struct timeval *tv);

int libusb_handle_events_timeout(libusb_context *ctx,
 struct timeval *tv);
int libusb_handle_events_timeout_completed(libusb_context *ctx,
 struct timeval *tv, int *completed);
int libusb_handle_events(libusb_context *ctx);
int libusb_handle_events_completed(libusb_context *ctx, int *completed);
int libusb_handle_events_locked(libusb_context *ctx,
 struct timeval *tv);
int libusb_pollfds_handle_timeouts(libusb_context *ctx);
int libusb_get_next_timeout(libusb_context *ctx,
 struct timeval *tv);

/** \ingroup libusb_poll
 * File descriptor for polling
 */
struct libusb_pollfd {
 /** Numeric file descriptor */
 int fd;

 /** Event flags to poll for from <poll.h>. POLLIN indicates that you
	 * should monitor this file descriptor for becoming ready to read from,
	 * and POLLOUT indicates that you should monitor this file descriptor for
	 * nonblocking write readiness. */
 short events;
};

/** \ingroup libusb_poll
 * Callback function, invoked when a new file descriptor should be added
 * to the set of file descriptors monitored for events.
 * \param fd the new file descriptor
 * \param events events to monitor for, see \ref libusb_pollfd for a
 * description
 * \param user_data User data pointer specified in
 * libusb_set_pollfd_notifiers() call
 * \see libusb_set_pollfd_notifiers()
 */
typedef void ( *libusb_pollfd_added_cb)(int fd, short events,
 void *user_data);

/** \ingroup libusb_poll
 * Callback function, invoked when a file descriptor should be removed from
 * the set of file descriptors being monitored for events. After returning
 * from this callback, do not use that file descriptor again.
 * \param fd the file descriptor to stop monitoring
 * \param user_data User data pointer specified in
 * libusb_set_pollfd_notifiers() call
 * \see libusb_set_pollfd_notifiers()
 */
typedef void ( *libusb_pollfd_removed_cb)(int fd, void *user_data);

const struct libusb_pollfd ** libusb_get_pollfds(
 libusb_context *ctx);
void libusb_free_pollfds(const struct libusb_pollfd **pollfds);
void libusb_set_pollfd_notifiers(libusb_context *ctx,
 libusb_pollfd_added_cb added_cb, libusb_pollfd_removed_cb removed_cb,
 void *user_data);

/** \ingroup libusb_hotplug
 * Callback handle.
 *
 * Callbacks handles are generated by libusb_hotplug_register_callback()
 * and can be used to deregister callbacks. Callback handles are unique
 * per libusb_context and it is safe to call libusb_hotplug_deregister_callback()
 * on an already deregisted callback.
 *
 * Since version 1.0.16, \ref LIBUSB_API_VERSION >= 0x01000102
 *
 * For more information, see \ref libusb_hotplug.
 */
typedef int libusb_hotplug_callback_handle;

/** \ingroup libusb_hotplug
 *
 * Since version 1.0.16, \ref LIBUSB_API_VERSION >= 0x01000102
 *
 * Flags for hotplug events */
typedef enum {
 /** Default value when not using any flags. */
 LIBUSB_HOTPLUG_NO_FLAGS = 0,

 /** Arm the callback and fire it for all matching currently attached devices. */
 LIBUSB_HOTPLUG_ENUMERATE = 1<<0,
} libusb_hotplug_flag;

/** \ingroup libusb_hotplug
 *
 * Since version 1.0.16, \ref LIBUSB_API_VERSION >= 0x01000102
 *
 * Hotplug events */
typedef enum {
 /** A device has been plugged in and is ready to use */
 LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED = 0x01,

 /** A device has left and is no longer available.
	 * It is the user's responsibility to call libusb_close on any handle associated with a disconnected device.
	 * It is safe to call libusb_get_device_descriptor on a device that has left */
 LIBUSB_HOTPLUG_EVENT_DEVICE_LEFT = 0x02,
} libusb_hotplug_event;

/** \ingroup libusb_hotplug
 * Wildcard matching for hotplug events */
#define LIBUSB_HOTPLUG_MATCH_ANY -1

/** \ingroup libusb_hotplug
 * Hotplug callback function type. When requesting hotplug event notifications,
 * you pass a pointer to a callback function of this type.
 *
 * This callback may be called by an internal event thread and as such it is
 * recommended the callback do minimal processing before returning.
 *
 * libusb will call this function later, when a matching event had happened on
 * a matching device. See \ref libusb_hotplug for more information.
 *
 * It is safe to call either libusb_hotplug_register_callback() or
 * libusb_hotplug_deregister_callback() from within a callback function.
 *
 * Since version 1.0.16, \ref LIBUSB_API_VERSION >= 0x01000102
 *
 * \param ctx            context of this notification
 * \param device         libusb_device this event occurred on
 * \param event          event that occurred
 * \param user_data      user data provided when this callback was registered
 * \returns bool whether this callback is finished processing events.
 *                       returning 1 will cause this callback to be deregistered
 */
typedef int ( *libusb_hotplug_callback_fn)(libusb_context *ctx,
      libusb_device *device,
      libusb_hotplug_event event,
      void *user_data);

/** \ingroup libusb_hotplug
 * Register a hotplug callback function
 *
 * Register a callback with the libusb_context. The callback will fire
 * when a matching event occurs on a matching device. The callback is
 * armed until either it is deregistered with libusb_hotplug_deregister_callback()
 * or the supplied callback returns 1 to indicate it is finished processing events.
 *
 * If the \ref LIBUSB_HOTPLUG_ENUMERATE is passed the callback will be
 * called with a \ref LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED for all devices
 * already plugged into the machine. Note that libusb modifies its internal
 * device list from a separate thread, while calling hotplug callbacks from
 * libusb_handle_events(), so it is possible for a device to already be present
 * on, or removed from, its internal device list, while the hotplug callbacks
 * still need to be dispatched. This means that when using \ref
 * LIBUSB_HOTPLUG_ENUMERATE, your callback may be called twice for the arrival
 * of the same device, once from libusb_hotplug_register_callback() and once
 * from libusb_handle_events(); and/or your callback may be called for the
 * removal of a device for which an arrived call was never made.
 *
 * Since version 1.0.16, \ref LIBUSB_API_VERSION >= 0x01000102
 *
 * \param[in] ctx context to register this callback with
 * \param[in] events bitwise or of events that will trigger this callback. See \ref
 *            libusb_hotplug_event
 * \param[in] flags hotplug callback flags. See \ref libusb_hotplug_flag
 * \param[in] vendor_id the vendor id to match or \ref LIBUSB_HOTPLUG_MATCH_ANY
 * \param[in] product_id the product id to match or \ref LIBUSB_HOTPLUG_MATCH_ANY
 * \param[in] dev_class the device class to match or \ref LIBUSB_HOTPLUG_MATCH_ANY
 * \param[in] cb_fn the function to be invoked on a matching event/device
 * \param[in] user_data user data to pass to the callback function
 * \param[out] callback_handle pointer to store the handle of the allocated callback (can be NULL)
 * \returns LIBUSB_SUCCESS on success LIBUSB_ERROR code on failure
 */
int libusb_hotplug_register_callback(libusb_context *ctx,
      libusb_hotplug_event events,
      libusb_hotplug_flag flags,
      int vendor_id, int product_id,
      int dev_class,
      libusb_hotplug_callback_fn cb_fn,
      void *user_data,
      libusb_hotplug_callback_handle *callback_handle);

/** \ingroup libusb_hotplug
 * Deregisters a hotplug callback.
 *
 * Deregister a callback from a libusb_context. This function is safe to call from within
 * a hotplug callback.
 *
 * Since version 1.0.16, \ref LIBUSB_API_VERSION >= 0x01000102
 *
 * \param[in] ctx context this callback is registered with
 * \param[in] callback_handle the handle of the callback to deregister
 */
void libusb_hotplug_deregister_callback(libusb_context *ctx,
      libusb_hotplug_callback_handle callback_handle);

/** \ingroup libusb_lib
 * Available option values for libusb_set_option().
 */
enum libusb_option {
 /** Set the log message verbosity.
	 *
	 * The default level is LIBUSB_LOG_LEVEL_NONE, which means no messages are ever
	 * printed. If you choose to increase the message verbosity level, ensure
	 * that your application does not close the stderr file descriptor.
	 *
	 * You are advised to use level LIBUSB_LOG_LEVEL_WARNING. libusb is conservative
	 * with its message logging and most of the time, will only log messages that
	 * explain error conditions and other oddities. This will help you debug
	 * your software.
	 *
	 * If the LIBUSB_DEBUG environment variable was set when libusb was
	 * initialized, this function does nothing: the message verbosity is fixed
	 * to the value in the environment variable.
	 *
	 * If libusb was compiled without any message logging, this function does
	 * nothing: you'll never get any messages.
	 *
	 * If libusb was compiled with verbose debug message logging, this function
	 * does nothing: you'll always get messages from all levels.
	 */
 LIBUSB_OPTION_LOG_LEVEL,

 /** Use the UsbDk backend for a specific context, if available.
	 *
	 * This option should be set immediately after calling libusb_init(), otherwise
	 * unspecified behavior may occur.
	 *
	 * Only valid on Windows.
	 */
 LIBUSB_OPTION_USE_USBDK,
};

int libusb_set_option(libusb_context *ctx, enum libusb_option option, ...);
# 183 "pifunk.c" 2
//#include "libusb/libusb.h"
//#include "libusb/libusb/libusbi.h"
//#include "libusb/libusb/hotplug.h"
//#include "libusb/libusb/version.h"
//#include "libusb/libusb/version_name.h"
//#include "libusb/libusb/os/linux_usbfs.h"
# 1 "libusb/libusb/os/poll_posix.h" 1

#define LIBUSB_POLL_POSIX_H 

#define usbi_write write
#define usbi_read read
#define usbi_close close
#define usbi_poll poll

int usbi_pipe(int pipefd[2]);
# 190 "pifunk.c" 2
# 1 "libusb/libusb/os/threads_posix.h" 1
/*
 * libusb synchronization using POSIX Threads
 *
 * Copyright © 2010 Peter Stuge <peter@stuge.se>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */


#define LIBUSB_THREADS_POSIX_H 

# 1 "/usr/include/pthread.h" 1 3 4

# 1 "/usr/include/pthread.h" 3 4
/* Copyright (C) 2002-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */
# 25 "libusb/libusb/os/threads_posix.h" 2




#define USBI_MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER

# 30 "libusb/libusb/os/threads_posix.h"
typedef pthread_mutex_t usbi_mutex_static_t;
static inline void usbi_mutex_static_lock(usbi_mutex_static_t *mutex)
{
 (void)pthread_mutex_lock(mutex);
}
static inline void usbi_mutex_static_unlock(usbi_mutex_static_t *mutex)
{
 (void)pthread_mutex_unlock(mutex);
}

typedef pthread_mutex_t usbi_mutex_t;
static inline int usbi_mutex_init(usbi_mutex_t *mutex)
{
 return pthread_mutex_init(mutex, 
# 43 "libusb/libusb/os/threads_posix.h" 3 4
                                 ((void *)0)
# 43 "libusb/libusb/os/threads_posix.h"
                                     );
}
static inline void usbi_mutex_lock(usbi_mutex_t *mutex)
{
 (void)pthread_mutex_lock(mutex);
}
static inline void usbi_mutex_unlock(usbi_mutex_t *mutex)
{
 (void)pthread_mutex_unlock(mutex);
}
static inline int usbi_mutex_trylock(usbi_mutex_t *mutex)
{
 return pthread_mutex_trylock(mutex);
}
static inline void usbi_mutex_destroy(usbi_mutex_t *mutex)
{
 (void)pthread_mutex_destroy(mutex);
}

typedef pthread_cond_t usbi_cond_t;
static inline void usbi_cond_init(pthread_cond_t *cond)
{
 (void)pthread_cond_init(cond, 
# 65 "libusb/libusb/os/threads_posix.h" 3 4
                              ((void *)0)
# 65 "libusb/libusb/os/threads_posix.h"
                                  );
}
static inline int usbi_cond_wait(usbi_cond_t *cond, usbi_mutex_t *mutex)
{
 return pthread_cond_wait(cond, mutex);
}
int usbi_cond_timedwait(usbi_cond_t *cond,
 usbi_mutex_t *mutex, const struct timeval *tv);
static inline void usbi_cond_broadcast(usbi_cond_t *cond)
{
 (void)pthread_cond_broadcast(cond);
}
static inline void usbi_cond_destroy(usbi_cond_t *cond)
{
 (void)pthread_cond_destroy(cond);
}

typedef pthread_key_t usbi_tls_key_t;
static inline void usbi_tls_key_create(usbi_tls_key_t *key)
{
 (void)pthread_key_create(key, 
# 85 "libusb/libusb/os/threads_posix.h" 3 4
                              ((void *)0)
# 85 "libusb/libusb/os/threads_posix.h"
                                  );
}
static inline void *usbi_tls_key_get(usbi_tls_key_t key)
{
 return pthread_getspecific(key);
}
static inline void usbi_tls_key_set(usbi_tls_key_t key, void *ptr)
{
 (void)pthread_setspecific(key, ptr);
}
static inline void usbi_tls_key_delete(usbi_tls_key_t key)
{
 (void)pthread_key_delete(key);
}

int usbi_get_tid(void);
# 191 "pifunk.c" 2

//custom header for pifunk (dummy for now)
# 1 "include/pifunk.h" 1
/*
header for pifunk.c (dummy for now)
*/


#define _PIFUNK_H_ 


void titel ()
{
printf ("\nWelcome to PiFunk!\n");

return;
}
# 194 "pifunk.c" 2

//------------------------------------------------------------------------------
//preproccessor definitions

  // || __unix__
  //printf ("Program runs under UNIX/LINUX");
        


  //printf ("Program runs under ARM-Architecture!");
  //#pragma ARM
  // same as -CODE32
  //#error



   //printf ("Using GNU C with ANSI C99!!");
   //#pragma GCC system_header


   /*#warning  string */
   //printf ("Using GNU C without C99 standard!! Please compile with flag -std=c99");

//------------------------------------------------------------------------------
// Definitions & Makros
#define VERSION "0.1.7.5"
#define VERSION_MAJOR (0)
#define VERSION_MINOR (1)
#define VERSION_BUILD (7)
#define VERSION_PATCHLEVEL (5)
#define VERSION_STATUS "e"

#define _GNU_SOURCE 
#define _POSIX_C_SOURCE = 200809L
#define _USE_MATH_DEFINES 

//---- PI specific stuff
#define IN (0)
#define OUT (1)
#define FALSE (0)
#define TRUE (1)
/*
predefine if needed when not using bcm header
#define LOW (0)
#define HIGH (1)
*/

//-------buffers
#define PAGE_SIZE (4*1024)
#define BLOCK_SIZE (4*1024)
#define BUFFER_LEN (8*1024)
#define BUFFERINSTRUCTIONS (65536)
//#define sleep [1000]
//#define usleep [1000]

//--------I-O access via GPIO
volatile unsigned *gpio;
volatile unsigned *allof7e;

// GPIO setup macros: Always use INP_GPIO (x) before using OUT_GPIO (x) or SET_GPIO_ALT(x, y)
#define ALLOF7ED (*allof7e - SUB_BASE)
#define PIN_GND 9
#define PIN17 RPI_GPIO_P17
#define INP_GPIO(g) *(gpio+((g)/10)) &= ~(7<<(((g)%10)*3))
#define OUT_GPIO(g) *(gpio+((g)/10)) |= (1<<(((g)%10)*3))
#define SET_GPIO_ALT(g,a) *(gpio+(((g)/10))) |= (((a)<=3?(a)+4:(a)==4?3:2)<<(((g)%10)*3))

#define GPIO_SET *(gpio+7)
#define GPIO_CLR *(gpio+10)
#define GPIO_GET *(gpio+13)
//-----






// Original Raspberry Pi 1

#define PERIPH_VIRT_BASE (0x20000000)
#define DRAM_PHYS_BASE (0x40000000)
#define MEM_FLAG (0x0C)
#define CURBLOCK (0x0C)
# 290 "pifunk.c"
//pi4 -> waiting for documentation from adafruit
# 308 "pifunk.c"
#define DRAM_PHYS_BASE (0x40000000)
#define MEM_FLAG (0x0C)
//#define CURBLOCK                       (0x04) //dec: 12

//---
#define GPIO_BASE (BCM2836_PERI_BASE + PERIPH_VIRT_BASE)
#define LENGTH (0x01000000)
#define SUB_BASE (0x7E000000)
#define CM_GP0CTL (0x7E101070)
#define CM_GP0DIV (0x7E101074)
#define DMABASE (0x7E007000)
#define CLKBASE (0x7E101000)
#define GPFSEL3 (0x7E200000)
#define PWMBASE (0x7E20C000)
#define FIFO (0x18)
#define CARRIER (0x5A)
#define DMAREF (0x7F)
#define MODULATE (0x4D72)
#define DMAC (0x0707)
//#define PWMCLK_CNTL                    (0x5A000016) // dec: 1509949462
//#define PWMCLK_DIV                     (0x5A002800) // dec: 1509959680
// possibility to give argv 0-4 an specific address or pointer
// addresses -> at least on my system-tests
#define CALLSIGN1_ADR (0x6052C0)
#define NAME_ADR (0x7FFFFFFEC08)
#define FILE_ADR (0x7FFFFFFFEC10)
#define CALLSIGN3_ADR (0x7FFFFFFFEAE8)
#define CALLSIGN2_ADR (0x7FFFFFFFEAEF)
#define FREQ_ADR (0x7FFFFFFFEC18)
#define SAMPLERATE_ADR (0x7FFFFFFFEC20)
#define MODULATION_ADR (0x7FFFFFFFEC28)
#define ARGC_ADR (0x7FFFFFFFEB0C)

// Pointers
#define FLOOR (0x0)
#define PWMADD1 (0x4)
#define ARGC_PTR (0x5)
#define PWMADD2 (0x8)
#define NAME_PTR (0x2F)
#define FREQ_PTR (0x31)
#define SAMPLERATE_PTR (0x32)
#define MODULATION_PTR (0x66)
#define CALLSIGN_PTR (0x6D)
#define FILE_PTR (0x73)

//mathematical stuff
#define ln(x) (log (x)/log (2.718281828459045235f))
#define PI (3.14159265358979323846)
#define PHASE (2*PI)
#define HALF_PERIOD (1/PI)
#define PERIOD (1/PHASE)

//----------from pifmadv -> helps to understand the things, the normal fm-script didnt specified
#define DMA_BASE_OFFSET (0x00007000)
#define PWM_BASE_OFFSET (0x0020C000)
#define PWM_LEN (0x28)
#define CLK_BASE_OFFSET (0x00101000)
#define CLK_LEN (0x1300)
#define GPIO_BASE_OFFSET (0x00200000)
#define GPIO_LEN (0x100)
#define PCM_BASE_OFFSET (0x00203000)
#define PCM_LEN (0x24)
#define PAD_BASE_OFFSET (0x00100000)
#define PAD_LEN (0x40/4)
#define PADGPIO (0x5A000018)

#define DMA_VIRT_BASE (PERIPH_VIRT_BASE + DMA_BASE_OFFSET)
#define PWM_VIRT_BASE (PERIPH_VIRT_BASE + PWM_BASE_OFFSET)
#define CLK_VIRT_BASE (PERIPH_VIRT_BASE + CLK_BASE_OFFSET)
#define GPIO_VIRT_BASE (PERIPH_VIRT_BASE + GPIO_BASE_OFFSET)
#define PAD_VIRT_BASE (PERIPH_VIRT_BASE + PAD_BASE_OFFSET)
#define PCM_VIRT_BASE (PERIPH_VIRT_BASE + PCM_BASE_OFFSET)

#define PCM_PHYS_BASE (PERIPH_PHYS_BASE + PCM_BASE_OFFSET)
#define PWM_PHYS_BASE (PERIPH_PHYS_BASE + PWM_BASE_OFFSET)
#define GPIO_PHYS_BASE (PERIPH_PHYS_BASE + GPIO_BASE_OFFSET)

// GPIO
#define GPFSEL0 (0x00/4)
#define GPFSEL1 (0x04/4)
#define GPFSEL2 (0x08/4)
#define GPPUD (0x94/4)
#define GPPUDCLK0 (0x98/4)
#define GPPUDCLK1 (0x9C/4)

#define CORECLK_CNTL (0x08/4)
#define CORECLK_DIV (0x0C/4)
#define GPCLK_CNTL (0x70/4)
#define GPCLK_DIV (0x74/4)
#define EMMCCLK_CNTL (0x1C0/4)
#define EMMCCLK_DIV (0x1C4/4)

#define CM_LOCK (0x114/4)
#define CM_LOCK_FLOCKA (1<<8)
#define CM_LOCK_FLOCKB (1<<9)
#define CM_LOCK_FLOCKC (1<<10)
#define CM_LOCK_FLOCKD (1<<11)
#define CM_LOCK_FLOCKH (1<<12)

#define CM_PLLA (0x104/4)
#define CM_PLLC (0x108/4)
#define CM_PLLD (0x10C/4)
#define CM_PLLH (0x110/4)
#define CM_PLLB (0x170/4)

#define A2W_PLLA_ANA0 (0x1010/4)
#define A2W_PLLC_ANA0 (0x1030/4)
#define A2W_PLLD_ANA0 (0x1050/4)
#define A2W_PLLH_ANA0 (0x1070/4)
#define A2W_PLLB_ANA0 (0x10F0/4)
#define A2W_PLL_KA_SHIFT (7)
#define A2W_PLL_KI_SHIFT (19)
#define A2W_PLL_KP_SHIFT (15)

#define PLLA_CTRL (0x1100/4)
#define PLLA_FRAC (0x1200/4)
#define PLLA_DSI0 (0x1300/4)
#define PLLA_CORE (0x1400/4)
#define PLLA_PER (0x1500/4)
#define PLLA_CCP2 (0x1600/4)

#define PLLB_CTRL (0x11E0/4)
#define PLLB_FRAC (0x12E0/4)
#define PLLB_ARM (0x13E0/4)
#define PLLB_SP0 (0x14E0/4)
#define PLLB_SP1 (0x15E0/4)
#define PLLB_SP2 (0x16E0/4)

#define PLLC_CTRL (0x1120/4)
#define PLLC_FRAC (0x1220/4)
#define PLLC_CORE2 (0x1320/4)
#define PLLC_CORE1 (0x1420/4)
#define PLLC_PER (0x1520/4)
#define PLLC_CORE0 (0x1620/4)

#define PLLD_CTRL (0x1140/4)
#define PLLD_FRAC (0x1240/4)
#define PLLD_DSI0 (0x1340/4)
#define PLLD_CORE (0x1440/4)
#define PLLD_PER (0x1540/4)
#define PLLD_DSI1 (0x1640/4)

#define PLLH_CTRL (0x1160/4)
#define PLLH_FRAC (0x1260/4)
#define PLLH_AUX (0x1360/4)
#define PLLH_RCAL (0x1460/4)
#define PLLH_PIX (0x1560/4)
#define PLLH_STS (0x1660/4)

// PWM
#define PWM_CTL (0x00/4)
#define PWM_DMAC (0x08/4)
#define PWM_RNG1 (0x10/4)
#define PWM_RNG2 (0x20/4)
#define PWM_FIFO (0x18/4)

#define PWMCLK_CNTL (40)
#define PWMCLK_DIV (41)

#define PWMCTL_PWEN1 (1<<0)
#define PWMCTL_MODE1 (1<<1)
#define PWMCTL_RPTL1 (1<<2)
#define PWMCTL_POLA1 (1<<4)
#define PWMCTL_USEF1 (1<<5)
#define PWMCTL_CLRF (1<<6)
#define PWMCTL_MSEN1 (1<<7)
#define PWMCTL_PWEN2 (1<<8)
#define PWMCTL_MODE2 (1<<9)
#define PWMCTL_RPTL2 (1<<10)
#define PWMCTL_USEF2 (1<<13)
#define PWMCTL_MSEN2 (1<<15)

#define PWMDMAC_ENAB (1<<31)
#define PWMDMAC_THRSHLD ((15<<8)|(15<<0))

// PCM
#define PCM_CS_A (0x00/4)
#define PCM_FIFO_A (0x04/4)
#define PCM_MODE_A (0x08/4)
#define PCM_RXC_A (0x0C/4)
#define PCM_TXC_A (0x10/4)
#define PCM_DREQ_A (0x14/4)
#define PCM_INTEN_A (0x18/4)
#define PCM_INT_STC_A (0x1C/4)
#define PCM_GRAY (0x20/4)

#define PCMCLK_CNTL (38)
#define PCMCLK_DIV (39)

// PAD
#define GPIO_PAD_0_27 (0x2C/4)
#define GPIO_PAD_28_45 (0x30/4)
#define GPIO_PAD_46_52 (0x34/4)

// DMA
#define DMA_CHANNEL (14)
#define DMA_CHANNEL_MAX (14)
#define DMA_CHANNEL_SIZE (0x100)

#define BCM2708_DMA_ACTIVE (1<<0)
#define BCM2708_DMA_END (1<<1)
#define BCM2708_DMA_INT (1<<2)
#define BCM2708_DMA_WAIT_RESP (1<<3)
#define BCM2708_DMA_D_DREQ (1<<6)
#define BCM2708_DMA_DST_IGNOR (1<<7)
#define BCM2708_DMA_SRC_INC (1<<8)
#define BCM2708_DMA_SRC_IGNOR (1<<11)
#define BCM2708_DMA_NO_WIDE_BURSTS (1<<26)
#define BCM2708_DMA_DISDEBUG (1<<28)
#define BCM2708_DMA_ABORT (1<<30)
#define BCM2708_DMA_RESET (1<<31)
#define BCM2708_DMA_PER_MAP(x) ((x)<<16)
#define BCM2708_DMA_PRIORITY(x) ((x)&0xF << 16)
#define BCM2708_DMA_PANIC_PRIORITY(x) ((x)&0xF << 20)

#define DMA_CS (0x00/4)
#define DMA_CONBLK_AD (0x04/4)
#define DMA_DEBUG (0x20/4)

#define DMA_CS_RESET (1<<31)
#define DMA_CS_ABORT (1<<30)
#define DMA_CS_DISDEBUG (1<<29)
#define DMA_CS_WAIT_FOR_WRITES (1<<28)
#define DMA_CS_INT (1<<2)
#define DMA_CS_ACTIVE (1<<0)
#define DMA_CS_END (1<<1)
#define DMA_CS_PRIORITY(x) ((x)&0xF << 16)
#define DMA_CS_PANIC_PRIORITY(x) ((x)&0xF << 20)

#define DREQ_PCM_TX (2)
#define DREQ_PCM_RX (3)
#define DREQ_SMI (4)
#define DREQ_PWM (5)
#define DREQ_SPI_TX (6)
#define DREQ_SPI_RX (7)
#define DREQ_SPI_SLAVE_TX (8)
#define DREQ_SPI_SLAVE_RX (9)

#define MEM_FLAG_DISCARDABLE (1 << 0)
#define MEM_FLAG_NORMAL (0 << 2)
#define MEM_FLAG_DIRECT (1 << 2)
#define MEM_FLAG_COHERENT (2 << 2)
#define MEM_FLAG_L1_NONALLOCATING (MEM_FLAG_DIRECT | MEM_FLAG_COHERENT)
#define MEM_FLAG_ZERO (1 << 4)
#define MEM_FLAG_NO_INIT (1 << 5)
#define MEM_FLAG_HINT_PERMALOCK (1 << 6)

#define BUS_TO_PHYS(x) ((x)&~0xC0000000)

#define PAGE_SHIFT (12)
#define NUM_PAGES ((sizeof (struct control_data_s) + PAGE_SIZE - 1) >> PAGE_SHIFT)

#define NUM_SAMPLES (64000)
#define NUM_CBS (NUM_SAMPLES * 2)

#define SUBSIZE (1)
#define DATA_SIZE (1000)

#define ACCESS(PERIPH_VIRT_BASE) (PERIPH_VIRT_BASE + ALLOF7ED)
#define SETBIT(PERIPH_VIRT_BASE,bit) ACCESS(PERIPH_VIRT_BASE)
#define CLRBIT(PERIPH_VIRT_BASE,bit) ACCESS(PERIPH_VIRT_BASE) == ~(1<<bit)
#define VOLUME_REFERENCE (1)
//----------------------------------
/* try a modprobe of i2C-BUS*/

//if (system ("/sbin/modprobe i2c_dev") == -1) {/* ignore errors */}
//if (system ("/sbin/modprobe i2c_bcm2835") == -1) {/* ignore errors */}
#define RTC_I2C_ADRESS (0x68)
//-----------------------------------
static char *description = "(experimental)"; // version-stage
static char *device = "default"; // playback device

//iterators for loops
int a;
int i;
int k;
int l;
char j;
float x;

//pi memorymap:
int mem_fd;
char *gpio_mem;
char *gpio_map;
char *spi0_mem;
char *spi0_map;

//-----------------------------------------
//arguments
int opt;
char *filename = "sound.wav";
double freq = 
# 599 "pifunk.c" 3 4
             (__extension__ ((sizeof (__real__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) == sizeof (double) || __builtin_classify_type (__real__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) != 8) ? ((sizeof (__real__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) == sizeof (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0)) == 8)))))) 0))) 0)) fabs (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0)) == 8)))))) 0))) 0)) cabs (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) : (sizeof (__real__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) == sizeof (float)) ? ((sizeof (__real__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) == sizeof (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0)) == 8)))))) 0))) 0)) fabsf (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0)) == 8)))))) 0))) 0)) cabsf (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) : ((sizeof (__real__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) == sizeof (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0)) == 8)))))) 0))) 0)) fabs (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             )) 0)) == 8)))))) 0))) 0)) cabs (
# 599 "pifunk.c"
             446.006250
# 599 "pifunk.c" 3 4
             ))))
# 599 "pifunk.c"
                              ;
double subfreq = 67.0;
double ctss_freq = 67.0;
uint32_t Timing;
char *mod;
char *fm = "fm";
char *am = "am";
char *callsign = "callsign";
float volume = 1.1f;
int power = abs (7);
int powerlevel = abs (7);
int samplerate = abs (22050);
int channels = 1;
double shift_ppm = 0.0;

//menu variables
int menuoption;
int channelnumbercb;
int channelnumberpmr;
int subchannelnumberpmr;
int channelmode;
int freqmode;
int modeselect;
int callnameselect;
time_t t;

// IQ & carrier
uint16_t pis = 0x1234; // dec: 4660
//double I = sin ((PERIOD*freq) + shift_ppm);
//double Q = cos ((PERIOD*freq) + shift_ppm);
//double RF_SUM = (I+Q);

//files
FILE *rfp, *wfp;
FILE FileFreqTiming;
FILE wavefile;
//SNDFILE *infile;
//SNDFILE *outfile;
//snd_output_t *output = NULL;
int fp = 
# 638 "pifunk.c" 3 4
        0
# 638 "pifunk.c"
                    ;
int filebit = abs (16);
int readcount;
int readBytes;
float datanew = 0;
float dataold = 0;
char data_name [1024];
char buffer [80];
float data [2*(8*1024)];
float data_filtered [2*(8*1024)];

//audio & sample control
// logarithmic modulation
//samples max. 10 kHz resolution for am / 14.5 kHz FM radio can be recorded
//volume in dB 0db = unity gain, no attenuation, full amplitude signal
//-20db = 10x attenuation, significantly more quiet
//float volbuffer [SAMPLES_PER_BUFFER];
//float volumeLevelDb = -6.f; //cut amplitude in half
//float volumeMultiplier = VOLUME_REFERENCE * pow (10, (volumeLevelDb/20.f) );
//SF_INFO sfinfo;
int nb_samples;
int excursion = 6000; // 32767 found another value but dont know on what this is based on
float A = 87.6f; // compression parameter
uint32_t carrier_freq = 87600000; // -> this might be the carrier too, why this value?
float FactAmplitude = 2.0; //maybe here amp-modulator type input?
float ampf;
float ampf2;
float factorizer;
float sampler;

//instructor for access
unsigned long frameinfo;
int instrs [(65536)]; // [1024];
int bufPtr = 0;
int instrCnt = 0;
int instrPage;
int constPage;
int reg = 0; //= gpio / 10;
int shift = 0; //= (gpio % 10) * 3;

//network sockets
//custom port via tcp/ip or udp
socklen_t addressLength;
char *localip = "127.0.0.1";
char *host = "localhost";
int port = 8080;

// GPS-coordinates
//default Frankfurt in decimal °grad (centigrade)
float longitude = 8.682127; // E
float latitude = 50.110924; // N
float altitude = 
# 689 "pifunk.c" 3 4
                (__extension__ ((sizeof (__real__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) == sizeof (double) || __builtin_classify_type (__real__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) != 8) ? ((sizeof (__real__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) == sizeof (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0)) == 8)))))) 0))) 0)) fabs (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0)) == 8)))))) 0))) 0)) cabs (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) : (sizeof (__real__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) == sizeof (float)) ? ((sizeof (__real__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) == sizeof (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0)) == 8)))))) 0))) 0)) fabsf (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0)) == 8)))))) 0))) 0)) cabsf (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) : ((sizeof (__real__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) == sizeof (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0)) == 8)))))) 0))) 0)) fabs (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                )) 0)) == 8)))))) 0))) 0)) cabs (
# 689 "pifunk.c"
                100.00
# 689 "pifunk.c" 3 4
                ))))
# 689 "pifunk.c"
                             ; // elevation in meter above see level  (u.N.N.)

//--------------------------------------------------
// Structs
struct tm *info;
struct sockaddr_in localAddress;
//struct client_addr.sin_addr;
//struct local.sin_addr;

struct PAGEINFO // should use here bcm intern funcs-> repair
{
  void *p; // physical address BCM2836_PERI_BASE
  void *v; // virtual address
  int instrPage;
  int constPage;
  int instrs [(65536)]; // [1024];
};

struct GPCTL
{
  char SRC : 4;
  char ENAB : 1;
  char KILL : 1;
  char IDKW : 1; // what is the blank char? gave it a dummyname for now
  char BUSY : 1;
  char FLIP : 1;
  char MASH : 2;
  unsigned int IDK : 13; // what is the blank int?
  char PASSWD : 8;
};

struct CB
{
  volatile unsigned int TI;
  volatile unsigned int SOURCE_AD;
  volatile unsigned int DEST_AD;
  volatile unsigned int TXFR_LEN;
  volatile unsigned int STRIDE;
  volatile unsigned int NEXTCONBK;
  volatile unsigned int RES1;
  volatile unsigned int RES2;
};

struct DMAREGS
{
  volatile unsigned int CS;
  volatile unsigned int CONBLK_AD;
  volatile unsigned int TI;
  volatile unsigned int SOURCE_AD;
  volatile unsigned int DEST_AD;
  volatile unsigned int TXFR_LEN;
  volatile unsigned int STRIDE;
  volatile unsigned int NEXTCONBK;
  volatile unsigned int DEBUG;
};

//program flag options
struct option long_opt [] =
{
  {"filename", 
# 748 "pifunk.c" 3 4
               1
# 748 "pifunk.c"
                                , 
# 748 "pifunk.c" 3 4
                                  ((void *)0)
# 748 "pifunk.c"
                                      , 'n'},
  {"freq", 
# 749 "pifunk.c" 3 4
               1
# 749 "pifunk.c"
                                , 
# 749 "pifunk.c" 3 4
                                  ((void *)0)
# 749 "pifunk.c"
                                      , 'f'},
    {"samplerate", 
# 750 "pifunk.c" 3 4
                   1
# 750 "pifunk.c"
                                    , 
# 750 "pifunk.c" 3 4
                                      ((void *)0)
# 750 "pifunk.c"
                                          , 's'},
    {"mod", 
# 751 "pifunk.c" 3 4
                 1
# 751 "pifunk.c"
                                  , 
# 751 "pifunk.c" 3 4
                                    ((void *)0)
# 751 "pifunk.c"
                                        , 'm'},
    {"callsign", 
# 752 "pifunk.c" 3 4
                  1
# 752 "pifunk.c"
                                   , 
# 752 "pifunk.c" 3 4
                                     ((void *)0)
# 752 "pifunk.c"
                                         , 'c'},
    {"power", 
# 753 "pifunk.c" 3 4
                1
# 753 "pifunk.c"
                                 , 
# 753 "pifunk.c" 3 4
                                   ((void *)0)
# 753 "pifunk.c"
                                       , 'p'},
    //{"gpio",	  		required_argument, NULL, 'g'},
    {"assistent", 
# 755 "pifunk.c" 3 4
                  0
# 755 "pifunk.c"
                             , 
# 755 "pifunk.c" 3 4
                                     ((void *)0)
# 755 "pifunk.c"
                                         , 'a'},
    {"help", 
# 756 "pifunk.c" 3 4
                0
# 756 "pifunk.c"
                           , 
# 756 "pifunk.c" 3 4
                                   ((void *)0)
# 756 "pifunk.c"
                                       , 'h'},
  {"menu", 
# 757 "pifunk.c" 3 4
              0
# 757 "pifunk.c"
                         , 
# 757 "pifunk.c" 3 4
                                 ((void *)0)
# 757 "pifunk.c"
                                     , 'u'}
};
//----------
/*
RTC (DS3231/1307 driver as bcm) stuff here if needed

*/

//--------basic functions specified one after another
void infos () //warnings and infos
{
  printf ("\n");
  /*red-yellow -> color:1 for "bright" / 4 for "underlined" and \0XX ansi colorcode //35 for Magenta, 33 red */
    printf ("\033[1;4;35mWelcome to the Pi-Funk! v%s %s for Raspian ARM!\033[0m", "0.1.7.5", description); //collor escape command for resetting
    printf ("\nRadio works with *.wav-file with 16-bit @ 22050 [Hz] Mono / 1-700.00000 MHz Frequency \nUse '. dot' as decimal-comma seperator! \n");
    printf ("\nPi oparates with square-waves (²/^2) PWM on GPIO 4 (Pin 7 @ ~500 mA & max. 3.3 V). \nUse power supply with enough specs only! \n=> Use Low-/Highpassfilters and/or ~10 uF-cap, isolators orresistors if needed! \nYou can smooth it out with 1:1 baloon. Do NOT shortcut if dummyload is used! \nCheck laws of your country! \n");
    printf ("\nFor testing (default settings) run: sudo ./pifunk -n sound.wav -f 100.0000 -s 22050 -m fm -c callsign -p 7\n");
  printf ("\nDevicename: %s\n", device);
   return;
}

int timer (time_t t)
{

  time (&t);
   //info = localtime (&rawtime);
  //strftime (buffer, 80, "%x - %I:%M%p", info);
   printf ("\nCurrent formated date & time : %s \n", ctime (&t));
   return 0;
}

int filecheck (char *filename, FILE wavefile) // expected int?
{
  printf ("\nPlease enter the full path including name of the *.wav-file you want to use: \n");
  scanf ("%s", &filename);
 printf ("\nTrying to play %s ... \n", filename);
 printf ("\nOpening file ... \n");
 printf ("\nallocating filename mem... \n");
 filename = (char *) malloc (128);// allocating memory for filename
 sprintf (filename, "\n%s\n", "file.ft");
 char *stdfile= "sound.wav";
  if (filename != stdfile)
 {
     fp = open (filename, 
# 800 "pifunk.c" 3 4
                         00 
# 800 "pifunk.c"
                                  | 
# 800 "pifunk.c" 3 4
                                    0100 
# 800 "pifunk.c"
                                            | 
# 800 "pifunk.c" 3 4
                                              01 
# 800 "pifunk.c"
                                                       | 
# 800 "pifunk.c" 3 4
                                                         01000
# 800 "pifunk.c"
                                                                , 0644); // O_RDWR
    return fp;
 }
 else
 {
    fp = open ("sound.wav", 
# 805 "pifunk.c" 3 4
                           00 
# 805 "pifunk.c"
                                    | 
# 805 "pifunk.c" 3 4
                                      0100 
# 805 "pifunk.c"
                                              | 
# 805 "pifunk.c" 3 4
                                                01 
# 805 "pifunk.c"
                                                         | 
# 805 "pifunk.c" 3 4
                                                           01000
# 805 "pifunk.c"
                                                                  , 0644); // sounds/sound.wav directory should be tested
    return fp;
 }
 return fp;
}

double freqselect () // gets freq by typing in
{
 printf ("\nYou selected 1 for Frequency-Mode \n");
 printf ("\nType in Frequency (0.1-1200.00000 MHz): \n"); // 1B+ for 700 MHz chip, pi3 1.2 GHz
 scanf ("%lf", &freq);
 printf ("\nYou chose: %lf MHz \n", freq);
  return freq;
}
//--------------------------------------------------
float step ()
{
 float steps;
 printf ("\nChoose PMR-Steps 6.25 / 12.5 kHz: \n");
 scanf ("%f", &steps);
 if (steps==6.25)
 {
 printf ("\nnSteps are %f kHz \n", steps);
  return steps;
 }
 else if (steps==12.5)
 {
 printf ("\nSteps are %f kHz \n", steps);
  return steps;
 }
  else
  {
  printf ("\nNO steps could be determined, wrong input! Using Standard 12.5\n");
  steps = 12.5;
  return steps;
  }
}

// Channel-mode
double channelmodepmr () //PMR
{
 char *type;
  char *analog = "a";
 char *digital = "d";
 printf ("\nChoose PMR-Type (a)nalog / (d)igital: \n");
 scanf ("%s", &type);

 if (type==analog)
 {
 printf ("\nChoose aPMR-Channel 1-16 (18 to exit): \n");
 scanf ("%d", &channelnumberpmr);
 switch (channelnumberpmr)
  {
  //---- Analog & DMR
  case 1: freq=446.00625; break; // Standard
  case 2: freq=446.01875; break; // Geocaching
  case 3: freq=446.03125; break; // Standard
  case 4: freq=446.04375; break; // at 3-chan-PMR-devices its ch. 2
  case 5: freq=446.05625; break; // Contest
  case 6: freq=446.06875; break; // Events
  case 7: freq=446.08125; break; // at 3-channel-PMR-devices it's ch. 3
  case 8: freq=446.09375; break; // Standard
  //-----Digital only
 // dmr (tier 1) digital new since 28.09.2016
 // extra 8 chan
 // 12.5 kHz steps
  case 9: freq=446.10312; break;
  case 10: freq=446.10625; break;
  case 11: freq=446.11875; break;
  case 12: freq=446.13125; break;
  case 13: freq=446.14375; break;
  case 14: freq=446.15625; break;
  case 15: freq=446.16875; break;
  case 16: freq=446.18125; break;
  case 17: freq=446.19375; break;

  case 18: exit (0);
  default: freq=446.00625;
       printf ("\nDefault channelnumber = 1 on freq = %lf \n", freq);
      break;
   }
  }
 else if (type==digital)
 {
 printf ("\nChoose dPMR-Channel 1-32 (33 to exit): \n");
 scanf ("%d", &channelnumberpmr);
 switch (channelnumberpmr)
  {
   //FD-PMR 6.25 kHz steps  & for DCDM devices: CC1 TG99 TS1 = Kontakt, CC1 TG9112 TS1 = EmCOM
  case 1: freq=446.003125; break;
  case 2: freq=446.009375; break;
  case 3: freq=446.015625; break;
  case 4: freq=446.021875; break;
  case 5: freq=446.028125; break;
  case 6: freq=446.034375; break;
  case 7: freq=446.040625; break;
  case 8: freq=446.046875; break;
  case 9: freq=446.053125; break;
  case 10: freq=446.059375; break;
  case 11: freq=446.065625; break;
  case 12: freq=446.071875; break;
  case 13: freq=446.078125; break;
  case 14: freq=446.084375; break;
  case 15: freq=446.090625; break;
  case 16: freq=446.096875; break;
  case 17: freq=446.103125; break;
  case 18: freq=446.109375; break;
  case 19: freq=446.115625; break;
  case 20: freq=446.121875; break;
  case 21: freq=446.128125; break;
  case 22: freq=446.134375; break;
  case 23: freq=446.140625; break;
  case 24: freq=446.146875; break;
  case 25: freq=446.153125; break;
  case 26: freq=446.159375; break;
  case 27: freq=446.165625; break;
  case 28: freq=446.171875; break;
  case 29: freq=446.178125; break;
  case 30: freq=446.184375; break;
  case 31: freq=446.190625; break;
  case 32: freq=446.196875; break;
  //normaly up to 32 chan in dpmr
  case 33: exit (0);
  default: freq=446.003125;
         printf ("\nDefault channelnumber = 1 on freq = %lf \n", freq);
        break;
  }
 }
  else
 {
  printf ("\nNO type could be determined, wrong input! Using analog as standard \n");
  type=analog;
 }
  printf ("\nChannelnumber = %d on freq = %lf \n", channelnumberpmr, freq);
 return freq;
}

double subchannelmodepmr () //Pilot-tone
{
 printf ("\nChoose Sub-Channel 0-38 (39 to exit): \n");
 scanf ("%d", &subchannelnumberpmr);
 switch (subchannelnumberpmr)
 {
  // FYI 19 (38)-kHz-Pilottone on UKW
  //---- Analog & digital
  case 0: subfreq=67.000; printf ("\nChannels (all) = 0 default CTSS-Chan 1 %lf \n", subfreq); break; // Scan all Chan till active , now chan1
  case 1: subfreq=67.900; break; //4.9 Hz step
  case 2: subfreq=71.900; break;
  case 3: subfreq=74.400; break;
  case 4: subfreq=77.000; break; // at 3-chan-PMR-devices its ch. 2
  case 5: subfreq=79.700; break; // Contest
  case 6: subfreq=82.500; break; // Events
  case 7: subfreq=85.400; break; // at 3-channel-PMR-devices it's ch. 3
  case 8: subfreq=88.500; break; // Standard
  case 9: subfreq=91.500; break;
  case 10: subfreq=94.800; break;
  case 11: subfreq=97.400; break;
  case 12: subfreq=100.000; break;
  case 13: subfreq=103.500; break;
  case 14: subfreq=107.200; break;
  case 15: subfreq=110.900; break;
  case 16: subfreq=114.800; break;
  case 17: subfreq=118.800; break;
  case 18: subfreq=123.000; break;
  case 19: subfreq=127.300; break;
  case 20: subfreq=131.800; break;
  case 21: subfreq=136.500; break;
  case 22: subfreq=141.300; break;
  case 23: subfreq=146.200; break;
  case 24: subfreq=151.400; break;
  case 25: subfreq=156.700; break;
  case 26: subfreq=162.200; break;
  case 27: subfreq=167.900; break;
  case 28: subfreq=173.800; break;
  case 29: subfreq=179.900; break;
  case 30: subfreq=186.200; break;
  case 31: subfreq=192.800; break;
  case 32: subfreq=203.500; break;
  case 33: subfreq=210.700; break;
  case 34: subfreq=218.100; break;
  case 35: subfreq=225.700; break;
  case 36: subfreq=233.600; break;
  case 37: subfreq=241.800; break;
  case 38: subfreq=250.300; break;
  case 39: exit (0);
  default: subfreq=67.000;
      printf ("\nDefault subchannel = 1 on subfreq = %lf \n", subfreq);
      break;
 }
  printf ("\nSubchannelnumber = %d on subfreq = %lf \n", subchannelnumberpmr, subfreq);
 return freq;
}

double channelmodecb () // CB
{
 printf ("\nChoose CB-Channel 0-80 (81 to exit): \n");
 scanf ("%d", &channelnumbercb);
 switch (channelnumbercb)
 {
   // --> translation of infos in english in future updates!
       case 0: freq=27.0450; break; //first digital channel
    case 1: freq=26.9650; break; //empfohlener Anrufkanal (FM)
    case 2: freq=26.9750; break; //inoffizieller Berg-DX-Kanal (FM)
    case 3: freq=26.9850; break;
    case 4: freq=27.0050; break; //empfohlener Anrufkanal (AM)/Anrufkanal Feststationen (AM)
    case 5: freq=27.0150; break; //Kanal wird von italienischen Fernfahrern in Deutschland und Italien benutzt.
    case 6: freq=27.0250; break; //Datenkanal (D)
     case 7: freq=27.0350; break; //Datenkanal (D)
    case 8: freq=27.0550; break;
    case 9: freq=27.0650; break; //Fernfahrerkanal (AM)/weltweiter Notrufkanal EMG
    case 10: freq=27.0750; break; //Antennen-Abgleich - halbe Channel-Anzahl!! ansonsten Chan 20 oder 40
    /*		 Unterschied der Nachbarkanaele nicht um 10 kHz, sondern um 20 kHz
			 Diese Kanaele sind in den meisten Laendern nicht fuer CB-Funk zugelassen.
			 Zwecke wie z. B. Funkfernsteuerungen, Babyphones, kabellose Tastaturen und Maeuse verwendet */
    case 11: freq=27.0850; break; //freigegeben zur Zusammenschaltung mehrerer CB-Funkgeraete ueber eine Internetverbindung in Deutschland
    case 1111: freq=27.0950; break; //Eurobalise-Energieversorgung
    case 12: freq=27.1050; break;
    case 13: freq=27.1150; break;
    case 14: freq=27.1250; break; //oft verwendet fuer Spielzeug-Fernsteuerungen (mittels Selektivton)
    case 15: freq=27.1350; break; //inoffizieller Anrufkanal SSB (USB)
    case 1515: freq=27.1450; break;
    case 16: freq=27.1550; break; //Funkverkehr mit und zwischen Wasserfahrzeugen
    case 17: freq=27.1650; break; //Kanal wird von daenischen Schwertransportfahrern in Deutschland und Daenemark benutzt
    case 18: freq=27.1750; break;
    case 19: freq=27.1850; break; //empfohlener Fernfahrerkanal (FM)/oft von Walkie-Talkies genutzt/teilweise auch als Notrufkanal angegeben/auch von Babyfonen genutzt
    case 1919: freq=27.1950; break;
    case 20: freq=27.2050; break; //zum Antennenabgleich genutzte Mitte bei 40-Kanal-Geraeten, wird in oesterreich sehr oft fuer Schwertransportfahrten benutzt

     // 40 chan devices
    case 21: freq=27.2150; break; //tuerkischer Anrufkanal in Deutschland und Europa (FM)
    case 22: freq=27.2250; break; //oft von Walkie-Talkies genutzt, auch von Babyfonen genutzt, wird auch als Anrufkanal fuer rumaenische Fernlastfahrer verwendet
    case 23: freq=27.2550; break; //Die Kanaele 23, 24, 25 sind sog. Dreher, sie folgen nicht dem aufsteigenden 10-kHz-Raster
    case 24: freq=27.2350; break; //Datenkanal (D)
    case 25: freq=27.2450; break; //Datenkanal (D), USB ROS Intern
    case 26: freq=27.2650; break;
    case 27: freq=27.2750; break;
    case 28: freq=27.2850; break; //Kanal wird von polnischen Fernfahrern in Deutschland benutzt, Anrufkanal in Polen, wobei allgemein die CB-Kanalfrequenz in Polen um 5 kHz niedriger ist
    case 29: freq=27.2950; break; //Freigegeben zur Zusammenschaltung mehrerer CB-Funkgeraete ber eine Internetverbindung in Deutschland
    case 30: freq=27.3050; break; //inoffizieller DX-Kanal (FM), Anrufkanal fuer Funker aus dem ehemaligen Jugoslawien
    case 31: freq=27.3150; break; //inoffizieller DX-Kanal (FM)
    case 32: freq=27.3250; break;
    case 33: freq=27.3350; break;
    case 34: freq=27.3450; break; //freigegeben zur Zusammenschaltung mehrerer CB-Funkgeraete ueber eine Internetverbindung in Deutschland
    case 35: freq=27.3550; break; //oeffentlicher Kanal
    case 36: freq=27.3650; break; //Datenkanal USB ROS international
    case 37: freq=27.3750; break; //Gateway-Kanal oesterreich, FM
    case 38: freq=27.3850; break; //inoffizieller internationaler DX-Kanal (LSB)
    case 39: freq=27.3950; break; //Freigegeben zur Zusammenschaltung mehrerer CB-Funkgeraete ueber eine Internetverbindung in Deutschland
    case 40: freq=27.4050; break; //ab Maerz 2016 freigegeben zur Zusammenschaltung mehrerer CB-Funkgeraete
     //ueber eine Internetverbindung in Deutschland (FM/AM/SSB in D)
    /* 80 chan devices
			 Auf den nationalen Zusatzkanaelen 41 bis 80 ist nur die Modulationsart FM erlaubt
			 Nachfolgend sind die Frequenzen der nationalen Zusatzkanaele, die im CB-Funk benutzt werden duerfen, aufgelistet: */
   case 41: freq=27.5650; break; //Ab Maerz 2016 Freigegeben zur Zusammenschaltung mehrerer CB-Funkgeraete ueber eine Internetverbindung in Deutschland (FM), inoffizieller DX-Kanal (FM)
   case 42: freq=27.5750; break; //inoffizieller DX-Kanal (FM)
   case 43: freq=27.5850; break;
   case 44: freq=27.5950; break;
   case 45: freq=27.6050; break;
   case 46: freq=27.6150; break;
   case 47: freq=27.6250; break;
   case 48: freq=27.6350; break;
   case 49: freq=27.6450; break;
   case 50: freq=27.6550; break;
   case 51: freq=27.6650; break;
   case 52: freq=27.6750; break; //Datenkanal (D)(FM)
   case 53: freq=27.6850; break; //Datenkanal (D)(FM)
   case 54: freq=27.6950; break;
   case 55: freq=27.7050; break;
   case 56: freq=27.7150; break;
   case 57: freq=27.7250; break;
   case 58: freq=27.7350; break;
   case 59: freq=27.7450; break;
   case 60: freq=27.7550; break;

      case 61: freq=26.7650; break; //Freigegeben zur Zusammenschaltung mehrerer CB-Funkgeraete ueber eine Internetverbindung in Deutschland
   case 62: freq=26.7750; break;
   case 63: freq=26.7850; break;
   case 64: freq=26.7950; break;
   case 65: freq=26.8050; break;
   case 66: freq=26.8150; break;
   case 67: freq=26.8250; break;
   case 68: freq=26.8350; break;
   case 69: freq=26.8450; break;
   case 70: freq=26.8550; break;
   case 71: freq=26.8650; break; //Freigegeben zur Zusammenschaltung mehrerer CB-Funkgeraete ueber eine Internetverbindung in Deutschland
   case 72: freq=26.8750; break;
   case 73: freq=26.8850; break;
   case 74: freq=26.8950; break;
   case 75: freq=26.9050; break;
   case 76: freq=26.9150; break; //Datenkanal (D)(FM)
   case 77: freq=26.9250; break; //Datenkanal (D)(FM)
   case 78: freq=26.9350; break;
   case 79: freq=26.9450; break;
   case 80: freq=26.9550; break; //Freigegeben zur Zusammenschaltung mehrerer CB-Funkgeraete ueber eine Internetverbindung in Deutschland */
   case 81: exit (0);

   default: freq=26.9650;
         printf ("\nDefault CB chan = 1 %lf \n", freq);
         break;

 }
  printf ("\nUsing channel = %d on freq =  %lf \n", channelnumbercb, freq);
 return freq;
}

void modselect (int argc, char **argv, char *mod)
{
 printf ("\nOpening Modulator... \n");
 if (mod == fm)
 {
  void modulationfm (int argc, char **argv);
 }
 else if (mod == am)
 {
  void modulationam (int argc, char **argv);
 }
 else
 {
  printf ("\nError selecting modulation! \n");
 }
  return;
}

char modulationselect ()
{
 printf ("\nChoose your Modulation [1] FM // [2] AM // [3] Exit : \n");
 scanf ("%d", &freqmode);
 switch (freqmode)
 {
  case 1: printf ("\nYou selected 1 for FM! \n");
      mod = "fm";
      void modselect (int argc, char **argv, char *mod);
          break;

  case 2: printf ("\nYou selected 2 for AM! \n");
      mod = "am";
      void modselect (int argc, char **argv, char *mod);
          break;

  case 3: printf ("\nExiting... \n");
      exit (-1);

  default: mod = "fm";
        printf ("\n Default = 1 \n");
        break;
 }
 return *mod;
}

void channelselect () // make a void
{
 printf ("\nYou selected 1 for Channel-Mode \n");
 printf ("\nChoose your Band: [1] PMR // [2] CB \n");
  scanf ("%d", &channelmode);
  switch (channelmode) // from here collecting infos and run it step by step, same for freq-mode
  {
     case 1: printf ("\nPMR CHAN-MODE \n");
         step ();
         channelmodepmr (); // gets freq from pmr list
         break;

       case 2: printf ("\nCB CHAN-MODE \n");
         channelmodecb ();
         break;

     default: printf ("\nDefault: PMR\n");
          step ();
          channelmodepmr (); // gets freq from pmr list
           break;
 }
 return;
}
//--------------LED stuff
//controlling via py possible but c stuff can be useful too by bcm funcs!
//turn on LED (with 100 kOhm pullup resistor while transmitting
int ledinactive (char *filename, double freq, int samplerate)
{
  //check if transmitting
 /*	while (!play_wav (char *filename, double freq, int samplerate))
		{
				//cm2835_gpio_write (PIN17, LOW);
				printf ("\nLED OFF - No Transmission! \n");
		}
    */
    return 0;
}

int ledactive ()
{
//simulation of gpio for debug
/*
  bcm2835_set_debug (1);
  if (!bcm2835_init ())
	{
		printf ("\nBCM 2835 init failed! \n");
  	return 1;
	}
	else if (1)
	{
    // Set the pin to be an outputannels
    //bcm2835_gpio_fsel (PIN17, BCM2835_GPIO_FSEL_OUTP);
  	printf ("\nBCM 2835 init done and PIN 4 activated \n");
    // LED is active during transmission
		while (play_wav (char *filename, double freq, int samplerate))
		{
			// Turn it on
			bcm2835_gpio_write (PIN17, HIGH);
			printf ("\nLED ON - Transmission...! \n");
			// wait a bit
			bcm2835_delay (500);
		}
	}
	else // if no transmission than turn it off // (ledactive != 0)
  {
		cm2835_gpio_write (PIN17, LOW);
		printf ("\nLED OFF - No Transmission \n");
	}
   //bcm2835_close ();
	 */
  printf ("\nBCM 2835 closing \n");
   return 0;
}

/*
float audiovol ()
{
	float datavalue = data [i] * 4 * volume; // modulation index (AKA volume) logarithmic hearing of human
	for (int i = 0; i < SAMPLES_PER_BUFFER; ++i)
	{
     volbuffer [i] *= volumeMultiplier;
     printf ("\nValues: i: %d, volbuffer: %f, volumeMultiplier: %f \n", i, volbuffer [i], volumeMultiplier);
		 printf ("\nAdresses: i: %p, volbuffer: %p, volumeMultiplier: %p \n", &i, &volbuffer [i], &volumeMultiplier);
     return volbuffer [i];
	}
	return volbuffer [i], volumeMultiplier;
}
*/
//--------------- Voids
void handSig () // exit func
{
  printf ("\nExiting... \n");
  exit (0);
}

void clearscreen ()
{
  printf ("\n\033[H\033[J\n");
  //fflush (stdin); // alterntives
  //clsscr ();
  //system ("clear");
}

void modulate (int l)
{
 printf ("\nModulate carrier... \n");
 //	ACCESS (CM_GP0DIV) == (CARRIER << 24) + MODULATE + l;  //
}

void getRealMemPage (void **vAddr, void **pAddr) // should work through bcm header!
{
  void *a = valloc (4096);

  ((int*) a) [0] = 1; // use page to force allocation

  mlock (a, 4096); // lock into ram

  *vAddr = a; // we know the virtual address now

  int fp = open ("/proc/self/pagemap", 
# 1273 "pifunk.c" 3 4
                                      00
# 1273 "pifunk.c"
                                              ); //"w"
  lseek (fp, ((int) a)/4096*8, 
# 1274 "pifunk.c" 3 4
                              0
# 1274 "pifunk.c"
                                      );
  read (fp, &frameinfo, sizeof (frameinfo));

  *pAddr = (void*) ((int) (frameinfo*4096));
}

void freeRealMemPage (void **vAddr)
{
  printf ("\nFreeing vAddr ... \n");
  munlock (vAddr, 4096); // unlock ram
  free (vAddr); // free the ram
}

void carrierhigh () // enables it
{
 printf ("\nSetting carrier high ... \n");
/* Added functions to enable and disable carrier */
// Set CM_GP0CTL.ENABLE to 1 HIGH (2nd number) // 0x5A-> CARRIER dec: 90
//struct GPCTL setupword = {6, 1, 0, 0, 0, 1, 0x5A};// set it to ! = LOW
//ACCESS (CM_GP0CTL) == *((int*) &setupword); //setting cm
}

void carrierlow () // disables it
{
 printf ("\nSetting carrier low ... \n");
//struct GPCTL setupword = {6, 0, 0, 0, 0, 1, 0x5A};// set it to 0 = LOW
//ACCESS (CM_GP0CTL) == *((int*) &setupword);
}

void setupfm ()
{
  printf ("\nSetting up FM... \n");
    // open /dev/mem
  if ((mem_fd = open ("/dev/mem", 
# 1307 "pifunk.c" 3 4
                                 02
# 1307 "pifunk.c"
                                       |
# 1307 "pifunk.c" 3 4
                                        04010000
# 1307 "pifunk.c"
                                              ) ) < 0)
 {
        printf ("\nCan't open /dev/mem ! \n"); // via bcm possible
        return;
  }

  allof7e = (unsigned*) mmap (
        
# 1314 "pifunk.c" 3 4
       ((void *)0)
# 1314 "pifunk.c"
           ,
        (0x01000000), // length
        
# 1316 "pifunk.c" 3 4
       0x1
# 1316 "pifunk.c"
                |
# 1316 "pifunk.c" 3 4
                 0x2
# 1316 "pifunk.c"
                           ,
        
# 1317 "pifunk.c" 3 4
       0x01
# 1317 "pifunk.c"
                 ,
        mem_fd,
        (0x20000000)); // base

  if ((int) allof7e == -1)
 {
  exit (-1);
 }

   //SETBIT (GPFSEL0, 14);
   //CLRBIT (GPFSEL0, 13);
   //CLRBIT (GPFSEL0, 12);
  carrierhigh ();
}
///------------------------------------
//relevant for transmitting stuff
void play_list () // exit func
{
  printf ("\nOpening playlist-folder (dummy) \n"); // in sounds/playlist

}

void play_wav (char *filename, double freq, int samplerate)
{

 /*wiki https://en.wikipedia.org/wiki/WAV
	  https://en.wikipedia.org/wiki/44,100_Hz
    NTSC: 44056 Hz
    245 × 60 × 3 = 44100
    245 active lines/field × 60 fields/second × 3 samples/line = 44100 samples/second
    (490 active lines per frame, out of 525 lines total)
    PAL:
    294 × 50 × 3 = 44100
    294 active lines/field × 50 fields/second × 3 samples/line = 44100 samples/second
    (588 active lines per frame, out of 625 lines total)
	*/
   // after getting filename insert then open
 printf ("\nAllocating file to mem for wave ... \n");
 play_list ();

 int sz = lseek (fp, 0L, 
# 1357 "pifunk.c" 3 4
                        2
# 1357 "pifunk.c"
                                );
 /* lseek: repositions the file offset of the open file description
    associated with the file descriptor fd to the argument offset
    according to the directive http://man7.org/linux/man-pages/man2/lseek.2.html
	SEEK_END: The file offset is set to the size of the file plus offset bytes. */
  short *data = (short*) malloc (sz);

  for (int i = 0; i < 22; i++) // why i less then 22?
  {
        read (fp, &data, 2); // read past header (or sz instead on 2 ?)
        printf ("\nReading fp \n");
  }

  while (readBytes == read (fp, &data, 1024))
  {
    //normally in 15 Hz bandwidth
        float fmconstant = (samplerate*50.0E-6); //1.1025 for pre-emphisis filter, 50us time constant
    printf ("\nfmconstant: %f \n", fmconstant);
        int clocksPerSample = (22050/samplerate*1400); // for timing if 22050 then 1400
    printf ("\nclocksPerSample: %d \n", clocksPerSample);
        // if samplerate > 15.75 then clocks per sample is negetive !! not good
        datanew = ((float) (*data)/excursion); //some constant for unsigned int excursion
    printf ("\ndatanew: %f \n", datanew);
        float sample = datanew + (dataold-datanew)/(1-fmconstant); // fir of 1 + s tau
    printf ("\nsample: %f \n", sample);
        float dval = sample*15.0; // actual transmitted sample, 15 is standard bandwidth (about 75 kHz) better 14.5
    printf ("\ndval: %f \n", dval);
        int intval = (int) (
# 1384 "pifunk.c" 3 4
                           (__extension__ ((sizeof (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           ) == sizeof (double) || __builtin_classify_type (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           ) != 8) ? (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           )) 0)) == 8)))))) 0))) round (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           ) : (sizeof (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           ) == sizeof (float)) ? (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           )) 0)) == 8)))))) 0))) roundf (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           ) : (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           )) 0)) == 8)))))) 0))) round (
# 1384 "pifunk.c"
                           dval
# 1384 "pifunk.c" 3 4
                           )))
# 1384 "pifunk.c"
                                       ); // integer component
    printf ("\nintval: %d \n", intval);
        float frac = ((dval - intval)/2 + 0.5);
    printf ("\nfrac: %f \n", frac);
        int fracval = (frac*clocksPerSample);
    printf ("\nfracval: %d \n", fracval);

        bufPtr++;
        //problem still with .v & .p endings for struct!!
        //while (ACCESS (DMABASE + CURBLOCK & ~ DMAREF) == (int) (instrs [bufPtr].p) ); // CURBLOCK of struct PageInfo
        //usleep (1000);

        //Create DMA command to set clock controller to output FM signal for PWM "LOW" time
        //(struct CB*) (instrs [bufPtr].v))->SOURCE_AD = ((int) constPage.p + 2048 + intval*4 - 4);

        bufPtr++;
        //while (ACCESS (DMABASE + 0x04) == (int) (instrs [bufPtr].p));
        //usleep (1000);

        //Create DMA command to delay using serializer module for suitable time
        //((struct CB*) (instrs [bufPtr].v))->TXFR_LEN = clocksPerSample-fracval;

        bufPtr++;
        //while (ACCESS (DMABASE + 0x04) == (int) (instrs [bufPtr].p));
        //usleep (1000);

        //Create DMA command to set clock controller to output FM signal for PWM "HIGH" time.
        //((struct CB*) (instrs [bufPtr].v))->SOURCE_AD = ((int) constPage.p + 2048 + intval*4+4);

        //while (ACCESS (DMABASE + 0x04) == (int) (instrs [bufPtr].p));
        //usleep (1000);

        //Create DMA command for more delay.
        //((struct CB*) (instrs [bufPtr].v))->TXFR_LEN = fracval;

        bufPtr = (bufPtr+1) % ((65536)); // [1024] for buffer

        dataold = datanew;
        //ss->consume (data, readBytes);// ss-> for stereo
        printf ("\nReading bytes from fp ... \n");
  }

   close (fp);
   //close (*filename);
   printf ("\nClosing file \n");
}

void unsetupDMA ()
{
 //struct DMAREGS* DMA0 = (struct DMAREGS*) ACCESS(DMABASE);
 //DMA0->CS = 1<<31; // reset dma controller
 printf ("\nUnsetting DMA done \n");
 exit (-1);
}

void setupDMA ()
{
 printf ("\nSetup of DMA starting... \n");
 atexit (unsetupDMA);
 signal (
# 1443 "pifunk.c" 3 4
        2
# 1443 "pifunk.c"
              , handSig);
 signal (
# 1444 "pifunk.c" 3 4
        15
# 1444 "pifunk.c"
               , handSig);
 signal (
# 1445 "pifunk.c" 3 4
        1
# 1445 "pifunk.c"
              , handSig);
 signal (
# 1446 "pifunk.c" 3 4
        3
# 1446 "pifunk.c"
               , handSig);

 // allocate a few pages of ram
  //getRealMemPage (&constPage.v, &constPage.p);
 int centerFreqDivider = (int) ((500.0/freq) * (float) (1<<12) + 0.5);
 printf ("\ncenterFreqDivider %d \n", centerFreqDivider);
 // make data page contents - it s essientially 1024 different commands for the
 // DMA controller to send to the clock module at the correct time
 for (int i = 0; i<1024; i++)
 {
    // ((int*) (constPage.v))[i] = (CARRIER << 24) + centerFreqDivider - 512 + i;
 }

 while (instrCnt < 1024) //BUFFERINSTRUCTIONS
 {
     //getRealMemPage (&instrPage.v, &instrPage.p);

     // make copy instructions
    //struct CB* instr0 = (struct CB*)instrPage.v;

     for (int i = 0; i<4096/sizeof (struct CB); i++)
     {
         /*
         instrs[instrCnt].v = (void*) ((int) instrPage.v + sizeof (struct CB)*i);
         instrs[instrCnt].p = (void*) ((int) instrPage.p + sizeof (struct CB)*i);
         instr0->SOURCE_AD = (unsigned int) constPage.p + 2048;

         instr0->DEST_AD = PWMBASE + (FIFO); //fifo
         instr0->TXFR_LEN = 4;
         instr0->STRIDE = 0;
         instr0->NEXTCONBK = (int) instrPage.p + sizeof (struct CB)*(i+1);

	      // DREQ then PWM then no-wide
         instr0->TI = (1<<6) | (5<<16) |  (1<<26);
         instr0->RES1 = 0;
         instr0->RES2 = 0;

        if (i%2)
	      {
         instr0->DEST_AD = CM_GP0DIV;
         instr0->STRIDE = 4;
         instr0->TI = (1<<26) ;
        }

       if (instrCnt!=0) ((struct CB*) (instrs [instrCnt-1].v))->NEXTCONBK = (int) instrs [instrCnt].p;
       instr0++;
       */
       instrCnt++;
     }

   }

   //((struct CB*) (instrs [1023].v))->NEXTCONBK = (int) instrs [0].p;

   // set up a clock for the base
   //ACCESS (CLKBASE + 40*4) == (PWMCLK_CNTL); // (dec: 1509949478)
   //usleep (1000);

   //ACCESS (CLKBASE + 41*4) == (PWMCLK_DIV); //
   //usleep (1000);

   // set up pwm
   //ACCESS (PWMBASE + 0x0) == 0;
   //usleep (1000);

   //ACCESS (PWMBASE + 0x4) == -1; // status: clear errors (0x4 in dec: 4)
   //usleep (1000);

   // Use fifo, repeat, serializer, enable ch
   //ACCESS (PWMBASE + 0x0) == -1 | (1<<13) | (1<<10) | (1<<9) | (1<<8);
   //usleep (1000);

   // DMAC then DMA enable in 0x8 dec:8 / pwmbase+8 = 7E20C008 (dec:2116075528) /
   //ACCESS (PWMBASE + 0x8) == (1<<31) | (DMAC);

   //activate dma
   //struct DMAREGS* DMA0 = (struct DMAREGS*)(ACCESS (DMABASE));
   //DMA0->CS = 1<<31; // reset
   //DMA0->CONBLK_AD = 0;
   //DMA0->TI = 0;

   //DMA0->CONBLK_AD = (int) (instrPage.p);
   //DMA0->CS = (1<<0) | (255 <<16);  // enable bit = 0, clear end flag = 1, prio=19-16
   printf ("\nSetup DMA done! \n");
}

//---------------------//
// main progs

int samplecheck (char *filename, int samplerate) // better name function: sample/bitchecker
{
 printf ("\nSamplerate/bit-checker starting \n");
  /*
  if (!(fp = open (filename, SFM_READ, &sfinfo))) //check wat SFM sfinfo does!?
  {   // Open failed so print an error message.
        printf ("\nNot able to open input file for samplecheck %s \n", filename);
				printf ("\nNot able to open filepointer for samplecheck %d \n", fp);
        // Print the error message from libsndfile.
        return 1;
  }
		//-----------------
	//sfinfo.samplerate = samplerate;
	if (sfinfo.samplerate == 22050) //44 or 48 khz needs testing
	{
		printf ("\nSamplerate is 22050! (%d)\n", sfinfo.samplerate);
		return sfinfo.samplerate;
	}
	else if (sfinfo.samplerate == 14500)
	{
			printf ("\nSamplerate is 14500! (%d)\n", sfinfo.samplerate);
			return sfinfo.samplerate;
	}
	else
  {
	printf ("\nInput samplerate must be at least 22.050 [kHz] for FM or 14.500 [kHz] for AM! \n");
	return 1;
} */
 //--------------------
 if (filebit != 16)
 {
  //read filebit here somehow
  printf ("\nInput must be 16 bit! \n");
  return 1;
 }
 // While there are frames in the input file, read them,
 //process them and write them to the output file
 //----------------------
 nb_samples = (readcount/channels);
  while (readcount == read (fp, data, (8*1024)))
  {
  // where to input the freq like in fm?
   for (k = 0; k < nb_samples; k++)
   {
    char b = data [k*channels];
   printf ("\nChannel buffer b = %c \n", b);
   if (channels == 0)
   {
    printf ("\nSample Error! NO (0) channels \n"); // >1 in stereo or dual mono with half samplerate
   }
   else if (channels == 1)
   {
    printf ("\n File has %d channel (MONO)! \nReading ... \n", channels);
    // stereo file, avg left + right --> should be mono at 22.05kHz
    b += data [k*channels+1];
    b /= 2; // maybe *2 to make a dual mono and not doing stereo in half!
    printf ("\nb = %c \n", b);
   }
   else if (channels == 2)
   {
    printf ("\nFile has 2 Channels (STEREO)! \n");// >1 in stereo or dual mono with half samplerate
   }
   else
   {
     printf ("\nError: File has %d Channels! (> 2 channels) \n", channels);
   }
    // was defined as global var above
   printf ("\nnb_samples: %d \n", nb_samples);
   printf ("\nCompression prameter A: %f \n", A);
   //maybe here am option for amplitude factor input!?
   printf ("\nFactamplitude: %f \n", FactAmplitude);

   ampf = (x/32767.0f);
   printf ("\nampf1: %f \n", ampf);

    ampf2 = (
# 1610 "pifunk.c" 3 4
            (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) == sizeof (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) : (sizeof (__real__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) == sizeof (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) == sizeof (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
            ampf
# 1610 "pifunk.c" 3 4
            )))) 
# 1610 "pifunk.c"
                        < 1.0f/A) ? A * 
# 1610 "pifunk.c" 3 4
                                        (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) == sizeof (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) == sizeof (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) == sizeof (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                        ampf
# 1610 "pifunk.c" 3 4
                                        ))))
# 1610 "pifunk.c"
                                                   /(1.0f+(
# 1610 "pifunk.c" 3 4
                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) ? (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0)) == 8)))))) 0))) log (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          ) : (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0)) == 8)))))) 0))) clog (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) ? (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0)) == 8)))))) 0))) logf (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          ) : (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0)) == 8)))))) 0))) clogf (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) ? (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0)) == 8)))))) 0))) log (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          ) : (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          )) 0)) == 8)))))) 0))) clog (
# 1610 "pifunk.c"
                                                          A
# 1610 "pifunk.c" 3 4
                                                          ))))
# 1610 "pifunk.c"
                                                          /
# 1610 "pifunk.c" 3 4
                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) ? (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0)) == 8)))))) 0))) log (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          ) : (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0)) == 8)))))) 0))) clog (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) ? (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0)) == 8)))))) 0))) logf (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          ) : (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0)) == 8)))))) 0))) clogf (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) ? (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0)) == 8)))))) 0))) log (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          ) : (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          )) 0)) == 8)))))) 0))) clog (
# 1610 "pifunk.c"
                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                          ))))
# 1610 "pifunk.c"
                                                          )) : (1.0f+(
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) == sizeof (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) ? (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0)) == 8)))))) 0))) log (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ))))) : (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0)) == 8)))))) 0))) clog (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) == sizeof (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) ? (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0)) == 8)))))) 0))) logf (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ))))) : (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0)) == 8)))))) 0))) clogf (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) == sizeof (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) ? (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0)) == 8)))))) 0))) log (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ))))) : (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )))))) 0)) == 8)))))) 0))) clog (
# 1610 "pifunk.c"
                                                                          A * 
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) fabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) 0)) cabs (
# 1610 "pifunk.c"
                                                                          ampf
# 1610 "pifunk.c" 3 4
                                                                          ))))))))
# 1610 "pifunk.c"
                                                                          /
# 1610 "pifunk.c" 3 4
                                                                          (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) log (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) clog (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) logf (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) clogf (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) == sizeof (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) ? (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) log (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          ) : (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          )) 0)) == 8)))))) 0))) clog (
# 1610 "pifunk.c"
                                                                          2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                          ))))
# 1610 "pifunk.c"
                                                                          ))/(1.0f + (
# 1610 "pifunk.c" 3 4
                                                                                                        (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) == sizeof (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) ? (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0)) == 8)))))) 0))) log (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        ) : (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0)) == 8)))))) 0))) clog (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) == sizeof (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) ? (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0)) == 8)))))) 0))) logf (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        ) : (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0)) == 8)))))) 0))) clogf (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) == sizeof (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) ? (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0)) == 8)))))) 0))) log (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        ) : (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0)) == 8)))))) 0))) clog (
# 1610 "pifunk.c"
                                                                                                        A
# 1610 "pifunk.c" 3 4
                                                                                                        ))))
# 1610 "pifunk.c"
                                                                                                        /
# 1610 "pifunk.c" 3 4
                                                                                                        (__extension__ ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) != 8) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) == sizeof (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) ? (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0)) == 8)))))) 0))) log (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        ) : (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0)) == 8)))))) 0))) clog (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) : (sizeof (__real__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) == sizeof (float)) ? ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) == sizeof (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) ? (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0)) == 8)))))) 0))) logf (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        ) : (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0)) == 8)))))) 0))) clogf (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) : ((sizeof (__real__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) == sizeof (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) ? (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0)) == 8)))))) 0))) log (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        ) : (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        )) 0)) == 8)))))) 0))) clog (
# 1610 "pifunk.c"
                                                                                                        2.718281828459045235f
# 1610 "pifunk.c" 3 4
                                                                                                        ))))
# 1610 "pifunk.c"
                                                                                                        )); //compand
   printf ("\ncompand ampf2: %f \n", ampf2);

   x = (int) (
# 1613 "pifunk.c" 3 4
             (__extension__ ((sizeof (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             ) == sizeof (double) || __builtin_classify_type (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             ) != 8) ? (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             )) 0)) == 8)))))) 0))) round (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             ) : (sizeof (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             ) == sizeof (float)) ? (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             )) 0)) == 8)))))) 0))) roundf (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             ) : (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             )) 0)) == 8)))))) 0))) round (
# 1613 "pifunk.c"
             ampf2 * 32767.0f
# 1613 "pifunk.c" 3 4
             )))
# 1613 "pifunk.c"
                                     );
   printf ("\nnew x: %f \n", x);

    factorizer = (x * 32767.0f * FactAmplitude);
   printf ("\nfactorizer: %f \n", factorizer);

   sampler = (1E9/samplerate); //44.000
   printf ("\nsampler: %f \n", sampler);
   printf ("\nNow writing tone in am ... \n");
   void WriteTone (double freq); // somehow input freq here ?!?
   //return channels, ampf, ampf2, x, factorizer, sampler;
   } // for loop
  printf ("\nwhile readcount ... \n");
  } // while loop
    // Close input and output files
    //fclose (FileFreqTiming);
  close (fp);
  printf ("\nFile saved! \n");
 return samplerate;
}
// return freqmode, channels, ampf, ampf2, x, factorizer, sampler;

// all subch. -> base/default case 0 -> channel 0
// if subchannels is 0 = all ch. then check special stuff -> maybe scan func ?
// squelch/treshhold to build in maybe -> scan function till signal?

//AM
void WriteTone (double freq)
{
 double Frequencies = freq;
 typedef struct
 {

  double Frequency;
  uint32_t WaitForThisSample;
 } samplerf_t;
 samplerf_t RfSample;
 RfSample.Frequency = Frequencies;
 RfSample.WaitForThisSample = Timing; //in 100 of nanoseconds
 printf ("\nFreq = %lf, Timing = %d \n", RfSample.Frequency, RfSample.WaitForThisSample);
 if (write (fp, &RfSample, sizeof (samplerf_t)) != sizeof (samplerf_t))
 {
  fprintf (
# 1655 "pifunk.c" 3 4
          stderr
# 1655 "pifunk.c"
                , "\nUnable to write sample! \n");
 }
 printf ("\nWriting tone \n");
}

char callname ()
{
    //if (*callsign == NULL){
  printf ("\nYou don't have specified a callsign yet!\nPress (1) for custom or (2) default 'callsign': \n");
  scanf ("%d", &callnameselect);
  switch (callnameselect)
   {
    case 1: printf ("\nType in your callsign: \n");
       scanf ("%s", &callsign);
       printf ("\nYour callsign is: %s \n", callsign);
       break;

   case 2: callsign = "callsign"; //default callsign
       printf ("\nUsing default callsign: %s \n", callsign);
       break;

   default: callsign = "callsign"; //default callsign
        printf ("\nError! Using default callsign: %s \n", callsign);
       break;
    }
   return callsign; //, &callsign, *callsign;
}

void modetype (double freq)
{
 printf ("\nChoose Mode: [1] Channelmode // [2] Frequencymode \n");
 scanf ("%d", &modeselect);

 switch (modeselect)
 {
  case 1: printf ("\n[1] Channelmode: \n");
       channelselect (freq); //undefined reference
       break;

  case 2: printf ("\n[2] Frequencymode: \n");
       freqselect (freq);
       break;

  default: printf ("\nError! \n");
       break;
 }
 return;
}

int powerselect ()
{
 printf ("\nType in powerlevel (0-7 from 2-14 mA): \n");
 scanf ("%d", &power);
 printf ("\nPowerlevel was set to: %d \n", power);
 return power;
}

// read / import csv for pmr
char csvreader ()
{
    printf ("\nChecking CSV-file for CTSS-Tones (Coded Tone Control Squelch System)... \n");
  printf ("\nOrder of the list: \nLocation, Name, Frequency, Duplex, Offset, Tone,\nrToneFreq, cToneFreq, DtcsCode, DtcsPolarity, Mode,\nTStep, Skip, Comment, URCALL, RPT1CALL, RPT2CALL\n");

    rfp = fopen ("ctsspmr.csv", "r"); //read-only!
    wfp = fopen ("ctsswriter.csv", "w+"); //with + it updates, if exists overwrites
    while (!feof (rfp))
    {
     //here check for semicolon or comma delimiter (default)
     j = fgetc (rfp);
     fputc (j, wfp);
    }
  printf ("\n%d\n", j);
    fclose (rfp);
    fclose (wfp);
    printf ("\nCSV-import of CTSS-list finished! \n");
    return j;
}

void modulationam (int argc, char **argv)
{
 /*{IQ (FileInput is a mono wav contains I on left channel, Q on right channel)}
		{IQFLOAT (FileInput is a Raw float interlaced I, Q)}
		{RF (FileInput is a (float) Frequency, Time in nanoseconds}
		{RFA (FileInput is a (float) Frequency, (int) Time in nanoseconds, (float) Amplitude}
		{VFO (constant frequency)} */
  printf ("\nam modulator starting \n");
  void WriteTone (double freq);// actual modulation stuff here for am -> wrrite tone?
  ledactive ();
   return;
}

void modulationfm (int argc, char **argv)//FM
{
   printf ("\nPreparing for FM... \n");
    setupfm (); // gets filename & path or done by filecheck () func
   printf ("\nSetting up DMA... \n");
  setupDMA (); //setupDMA (argc>2 ? atof (argv [2]):100.00000); // : default freq
    //play_wav (char *filename, double freq, int samplerate); // atof (argv [3]):22050)
  return;
}

int tx (int argc, char **argv)
{
  //pads need to be defined
  //Drive Strength (power 7 standard): 0 = 2mA, 7 = 16mA. Ref: https://www.scribd.com/doc/101830961/GPIO-Pads-Control2
  //pad_reg [GPIO_PAD_0_27]  = PADGPIO + power;
  //pad_reg [GPIO_PAD_28_45] = PADGPIO + power;
 //GPIO needs to be ALT FUNC 0 to output the clock
 //gpio_reg [reg] = (gpio_reg [reg] & ~(7 << shift));

 //play_wav (char *filename, double freq, int samplerate);
 void modselect (int argc, char **argv, char *mod);
 ledactive ();
 printf ("\nBroadcasting now ...! \n");

 return 0;
}

void cgimodule () // just a small test, not meant for pifunk
{
 printf ("\ncontext-type:text/html\n");
 printf ("<html>\n");
 printf ("<head>\n");
 printf ("PiFunk Project\n");
 printf ("</head>\n");
 printf ("<body>\n");
 printf ("PiFunk - CGI\n");
 printf ("</body>\n");
 printf ("</html>\n");
}

void assistent () //assistent
{
  printf ("\nStarting assistent for setting parameters! \n");
  filecheck (filename, wavefile);
  samplecheck (filename, samplerate);
  modetype (freq);
  callname ();
  powerselect ();

  printf ("\nPress all information gatherd, going back to main \n");
  //while (getchar () != '');

  return;
}

void menu ()
{
 printf ("\nChoose menu: [1] CMD // [2] CSV-Reader // [3] CGI-Page // [4] Exit: \n");
  scanf ("%d", &menuoption);
 switch (menuoption)
 {
  case 0: printf ("\nShell - Commandline (main): \n");
      int main (int argc, char **argv);//, const char *short_opt); // go back to cmd if you want
      break;

  case 1: printf ("\nReading CSV for PMR... \n");
      csvreader ();
      break;

  case 3: printf ("\nReading cgi via text/html for homepage... \n");
      cgimodule ();
      break;

  case 4: printf ("\nExiting... \n");
      exit (0);

  default: printf ("\nMenu: Error! \n");
        break;
 }
 return;
}

//--------- MAIN
int main (int argc, char **argv) // arguments for global use must! be in main! const char *short_opt
{
 const char *short_opt = "n:f:s:m:c:p:ahu"; // g:d:b:
 int options = 0;
 argv [0] = "pifunk";
 char *filename = "sound.wav"; // = argv [1];
 double freq = 
# 1835 "pifunk.c" 3 4
              (__extension__ ((sizeof (__real__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) == sizeof (double) || __builtin_classify_type (__real__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) != 8) ? ((sizeof (__real__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) == sizeof (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0)) == 8)))))) 0))) 0)) fabs (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0)) == 8)))))) 0))) 0)) cabs (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) : (sizeof (__real__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) == sizeof (float)) ? ((sizeof (__real__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) == sizeof (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0)) == 8)))))) 0))) 0)) fabsf (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0)) == 8)))))) 0))) 0)) cabsf (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) : ((sizeof (__real__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) == sizeof (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) ? (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0)) == 8)))))) 0))) 0)) fabs (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              ) : (__typeof__ (__real__ (__typeof__ (*(0 ? (__typeof__ (0 ? (double *) 0 : (void *) ((__builtin_classify_type ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0)) == 8))))) 0 : (__typeof__ (0 ? (__typeof__ ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) *) 0 : (void *) (!((__builtin_classify_type ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) == 8 || (__builtin_classify_type ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0) == 9 && __builtin_classify_type (__real__ ((__typeof__ (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              )) 0)) == 8)))))) 0))) 0)) cabs (
# 1835 "pifunk.c"
              446.006250
# 1835 "pifunk.c" 3 4
              ))))
# 1835 "pifunk.c"
                               ; // =strtof (argv [2], NULL); //float only accurate to .4 digits idk why, from 5 it will round ?!
 int samplerate = abs (22050);// =atof (argv [3]); //maybe check here on != 22050 on 16 bits as fixed value (eventually allow 48k)
 char *mod = "fm";// =argv [4];
 char *callsign = "callsign";// =argv [5];
 int power = 7;// =argv [6];
 int dmachannel = 0; // =argv [7];
 double bandwidth = 100.0; //=argv [8];
 int gpiopin = 4; //=argv [9];
 /* atoll () is meant for integers & it stops parsing when it finds the first non-digit
	/ atof () or strtof () is for floats. Note that strtof () requires C99 or C++11
	abs () for int
	fabs () for double must be constant
	fabsf () for float
	*/
 // for custom programname, default is the filename itself
 titel ();
 printf ("\nArguments: %d / internal name: %s \n", argc, argv [0]);
 printf ("\nProgram name is %s \n", "pifunk.c");
 printf ("\nProgram was processed on %s at %s \n", "Jul 25 2019", "23:42:21");
 printf ("\nshort_opt: %s \n", short_opt);
 infos (); //information, disclaimer
 int timer (time_t t); // date and time print

 while ((options = getopt (argc, argv, short_opt)) != -1) // short_opt must be constants
 {
  if (argc == 0)
  {
    fprintf (
# 1862 "pifunk.c" 3 4
            stderr
# 1862 "pifunk.c"
                  , "\nArgument-Error! Use Parameters 1-6 to run: [-n <filename>] [-f <freq>] [-s <samplerate>] [-m <mod (fm/am)>] [-c <callsign (optional)>] [-p <power (0-7>]\nThere is also an assistent [-a] or for help [-h]! The *.wav-file must be 16-bit @ 22050 [Hz] Mono \n");
  }
  /*else
		{ */
  switch (options)
  {

   case 'n':
       filename = optarg;
       printf ("\nFilename is %s \n", filename);
       //break;

   case 'f':
       freq = atof (optarg);
       printf ("\nFrequency is %f \n", freq);
       //break;

   case 's':
       samplerate = atoi (optarg);
       printf ("\nSamplerate is %d \n", samplerate);
       samplecheck (filename, samplerate);
       break;

   case 'm':
       mod = optarg;
       if (!
# 1887 "pifunk.c" 3 4
           __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (
# 1887 "pifunk.c"
           mod
# 1887 "pifunk.c" 3 4
           ) && __builtin_constant_p (
# 1887 "pifunk.c"
           "fm"
# 1887 "pifunk.c" 3 4
           ) && (__s1_len = __builtin_strlen (
# 1887 "pifunk.c"
           mod
# 1887 "pifunk.c" 3 4
           ), __s2_len = __builtin_strlen (
# 1887 "pifunk.c"
           "fm"
# 1887 "pifunk.c" 3 4
           ), (!((size_t)(const void *)((
# 1887 "pifunk.c"
           mod
# 1887 "pifunk.c" 3 4
           ) + 1) - (size_t)(const void *)(
# 1887 "pifunk.c"
           mod
# 1887 "pifunk.c" 3 4
           ) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((
# 1887 "pifunk.c"
           "fm"
# 1887 "pifunk.c" 3 4
           ) + 1) - (size_t)(const void *)(
# 1887 "pifunk.c"
           "fm"
# 1887 "pifunk.c" 3 4
           ) == 1) || __s2_len >= 4)) ? __builtin_strcmp (
# 1887 "pifunk.c"
           mod
# 1887 "pifunk.c" 3 4
           , 
# 1887 "pifunk.c"
           "fm"
# 1887 "pifunk.c" 3 4
           ) : (__builtin_constant_p (
# 1887 "pifunk.c"
           mod
# 1887 "pifunk.c" 3 4
           ) && ((size_t)(const void *)((
# 1887 "pifunk.c"
           mod
# 1887 "pifunk.c" 3 4
           ) + 1) - (size_t)(const void *)(
# 1887 "pifunk.c"
           mod
# 1887 "pifunk.c" 3 4
           ) == 1) && (__s1_len = __builtin_strlen (
# 1887 "pifunk.c"
           mod
# 1887 "pifunk.c" 3 4
           ), __s1_len < 4) ? (__builtin_constant_p (
# 1887 "pifunk.c"
           "fm"
# 1887 "pifunk.c" 3 4
           ) && ((size_t)(const void *)((
# 1887 "pifunk.c"
           "fm"
# 1887 "pifunk.c" 3 4
           ) + 1) - (size_t)(const void *)(
# 1887 "pifunk.c"
           "fm"
# 1887 "pifunk.c" 3 4
           ) == 1) ? __builtin_strcmp (
# 1887 "pifunk.c"
           mod
# 1887 "pifunk.c" 3 4
           , 
# 1887 "pifunk.c"
           "fm"
# 1887 "pifunk.c" 3 4
           ) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (
# 1887 "pifunk.c"
           "fm"
# 1887 "pifunk.c" 3 4
           ); int __result = (((const unsigned char *) (const char *) (
# 1887 "pifunk.c"
           mod
# 1887 "pifunk.c" 3 4
           ))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (
# 1887 "pifunk.c"
           mod
# 1887 "pifunk.c" 3 4
           ))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (
# 1887 "pifunk.c"
           mod
# 1887 "pifunk.c" 3 4
           ))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (
# 1887 "pifunk.c"
           mod
# 1887 "pifunk.c" 3 4
           ))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (
# 1887 "pifunk.c"
           "fm"
# 1887 "pifunk.c" 3 4
           ) && ((size_t)(const void *)((
# 1887 "pifunk.c"
           "fm"
# 1887 "pifunk.c" 3 4
           ) + 1) - (size_t)(const void *)(
# 1887 "pifunk.c"
           "fm"
# 1887 "pifunk.c" 3 4
           ) == 1) && (__s2_len = __builtin_strlen (
# 1887 "pifunk.c"
           "fm"
# 1887 "pifunk.c" 3 4
           ), __s2_len < 4) ? (__builtin_constant_p (
# 1887 "pifunk.c"
           mod
# 1887 "pifunk.c" 3 4
           ) && ((size_t)(const void *)((
# 1887 "pifunk.c"
           mod
# 1887 "pifunk.c" 3 4
           ) + 1) - (size_t)(const void *)(
# 1887 "pifunk.c"
           mod
# 1887 "pifunk.c" 3 4
           ) == 1) ? __builtin_strcmp (
# 1887 "pifunk.c"
           mod
# 1887 "pifunk.c" 3 4
           , 
# 1887 "pifunk.c"
           "fm"
# 1887 "pifunk.c" 3 4
           ) : -(__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (
# 1887 "pifunk.c"
           mod
# 1887 "pifunk.c" 3 4
           ); int __result = (((const unsigned char *) (const char *) (
# 1887 "pifunk.c"
           "fm"
# 1887 "pifunk.c" 3 4
           ))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (
# 1887 "pifunk.c"
           "fm"
# 1887 "pifunk.c" 3 4
           ))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (
# 1887 "pifunk.c"
           "fm"
# 1887 "pifunk.c" 3 4
           ))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (
# 1887 "pifunk.c"
           "fm"
# 1887 "pifunk.c" 3 4
           ))[3] - __s2[3]); } } __result; }))) : __builtin_strcmp (
# 1887 "pifunk.c"
           mod
# 1887 "pifunk.c" 3 4
           , 
# 1887 "pifunk.c"
           "fm"
# 1887 "pifunk.c" 3 4
           )))); })
# 1887 "pifunk.c"
                             )
       {
        mod = optarg;
        printf ("\nPushing args to fm Modulator... \n");
         //void modulationfm (int argc, char **argv); // idk if here to jump to the modulator or just parse it?!
        //break;
       }
       else if (!
# 1894 "pifunk.c" 3 4
                __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (
# 1894 "pifunk.c"
                mod
# 1894 "pifunk.c" 3 4
                ) && __builtin_constant_p (
# 1894 "pifunk.c"
                "am"
# 1894 "pifunk.c" 3 4
                ) && (__s1_len = __builtin_strlen (
# 1894 "pifunk.c"
                mod
# 1894 "pifunk.c" 3 4
                ), __s2_len = __builtin_strlen (
# 1894 "pifunk.c"
                "am"
# 1894 "pifunk.c" 3 4
                ), (!((size_t)(const void *)((
# 1894 "pifunk.c"
                mod
# 1894 "pifunk.c" 3 4
                ) + 1) - (size_t)(const void *)(
# 1894 "pifunk.c"
                mod
# 1894 "pifunk.c" 3 4
                ) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((
# 1894 "pifunk.c"
                "am"
# 1894 "pifunk.c" 3 4
                ) + 1) - (size_t)(const void *)(
# 1894 "pifunk.c"
                "am"
# 1894 "pifunk.c" 3 4
                ) == 1) || __s2_len >= 4)) ? __builtin_strcmp (
# 1894 "pifunk.c"
                mod
# 1894 "pifunk.c" 3 4
                , 
# 1894 "pifunk.c"
                "am"
# 1894 "pifunk.c" 3 4
                ) : (__builtin_constant_p (
# 1894 "pifunk.c"
                mod
# 1894 "pifunk.c" 3 4
                ) && ((size_t)(const void *)((
# 1894 "pifunk.c"
                mod
# 1894 "pifunk.c" 3 4
                ) + 1) - (size_t)(const void *)(
# 1894 "pifunk.c"
                mod
# 1894 "pifunk.c" 3 4
                ) == 1) && (__s1_len = __builtin_strlen (
# 1894 "pifunk.c"
                mod
# 1894 "pifunk.c" 3 4
                ), __s1_len < 4) ? (__builtin_constant_p (
# 1894 "pifunk.c"
                "am"
# 1894 "pifunk.c" 3 4
                ) && ((size_t)(const void *)((
# 1894 "pifunk.c"
                "am"
# 1894 "pifunk.c" 3 4
                ) + 1) - (size_t)(const void *)(
# 1894 "pifunk.c"
                "am"
# 1894 "pifunk.c" 3 4
                ) == 1) ? __builtin_strcmp (
# 1894 "pifunk.c"
                mod
# 1894 "pifunk.c" 3 4
                , 
# 1894 "pifunk.c"
                "am"
# 1894 "pifunk.c" 3 4
                ) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (
# 1894 "pifunk.c"
                "am"
# 1894 "pifunk.c" 3 4
                ); int __result = (((const unsigned char *) (const char *) (
# 1894 "pifunk.c"
                mod
# 1894 "pifunk.c" 3 4
                ))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (
# 1894 "pifunk.c"
                mod
# 1894 "pifunk.c" 3 4
                ))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (
# 1894 "pifunk.c"
                mod
# 1894 "pifunk.c" 3 4
                ))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (
# 1894 "pifunk.c"
                mod
# 1894 "pifunk.c" 3 4
                ))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (
# 1894 "pifunk.c"
                "am"
# 1894 "pifunk.c" 3 4
                ) && ((size_t)(const void *)((
# 1894 "pifunk.c"
                "am"
# 1894 "pifunk.c" 3 4
                ) + 1) - (size_t)(const void *)(
# 1894 "pifunk.c"
                "am"
# 1894 "pifunk.c" 3 4
                ) == 1) && (__s2_len = __builtin_strlen (
# 1894 "pifunk.c"
                "am"
# 1894 "pifunk.c" 3 4
                ), __s2_len < 4) ? (__builtin_constant_p (
# 1894 "pifunk.c"
                mod
# 1894 "pifunk.c" 3 4
                ) && ((size_t)(const void *)((
# 1894 "pifunk.c"
                mod
# 1894 "pifunk.c" 3 4
                ) + 1) - (size_t)(const void *)(
# 1894 "pifunk.c"
                mod
# 1894 "pifunk.c" 3 4
                ) == 1) ? __builtin_strcmp (
# 1894 "pifunk.c"
                mod
# 1894 "pifunk.c" 3 4
                , 
# 1894 "pifunk.c"
                "am"
# 1894 "pifunk.c" 3 4
                ) : -(__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (
# 1894 "pifunk.c"
                mod
# 1894 "pifunk.c" 3 4
                ); int __result = (((const unsigned char *) (const char *) (
# 1894 "pifunk.c"
                "am"
# 1894 "pifunk.c" 3 4
                ))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (
# 1894 "pifunk.c"
                "am"
# 1894 "pifunk.c" 3 4
                ))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (
# 1894 "pifunk.c"
                "am"
# 1894 "pifunk.c" 3 4
                ))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (
# 1894 "pifunk.c"
                "am"
# 1894 "pifunk.c" 3 4
                ))[3] - __s2[3]); } } __result; }))) : __builtin_strcmp (
# 1894 "pifunk.c"
                mod
# 1894 "pifunk.c" 3 4
                , 
# 1894 "pifunk.c"
                "am"
# 1894 "pifunk.c" 3 4
                )))); })
# 1894 "pifunk.c"
                                  )
       {
        printf ("\nPushing args to am Modulator... \n");
        //void modulationam (int argc, char **argv);
        //break;
       }
       else
       {
        printf ("\nError in -m \n");
        break;
        //return 1;
       }

   case 'c':
       callsign = optarg;
       printf ("\nCallsign is %s \n", callsign);
       //break;

    //power managment
   case 'p':
       power = atoi (optarg);
       printf ("\nPower is %d \n", power);
       //break;
   /*
			case 'd':
								dmachannel = atof (optarg);
								printf ("\nDMA-channel is %d \n", dmachannel);
								//break;

			case 'b':
								bandwidth = atoi (optarg);
								printf ("\nBandwith is %f \n", bandwidth);
								//break;
							*/
   case 'a':
       if (argc == 1)
       {
        printf ("\nAssistent activated! \n");
        assistent ();
        break;
       }
       else
       {
        printf ("\nError in -a \n");
        break;
        //return 1;
       }

   case 'h':
       if (argc == 1)
       {
        printf ("\nHELP: Use Parameters to run: \n[-n <filename (*.wav)>] [-f <freq>] [-s <samplerate>] [-m <mod (fm/am)>] \n[-c <callsign (optional)>] [-p <power (0-7>]\nThere is also an assistent [-a] \n");
        break;
       }
       else
       {
        printf ("\nError in -h \n");
        break;
       }

   case 'u':
       if (argc == 1)
       {
         printf ("\nOpening menu \n");
         menu (); // extra menu for csv
         break;
       }
       else
       {
         printf ("\nError in -u (menu) \n");
         break;
       }

   default:
        printf ("\nArgument-Error! Use Parameters to run: \n[-n <filename>] [-f <freq>] [-s <samplerate>] [-m <mod (fm/am)>] \n[-c <callsign (optional)>] [-p <power (0-7>]\n There is also an assistent [-a] or for help [-h]! The *.wav-file must be 16-bit @ 22050 [Hz] Mono \n");
        return 1;
  } // end of switch

  break;
 } // end of while
  //}//end of else
  //-- for debugging or information :)
 printf ("\n-----------------\n");
 printf ("\nshort_opt: %s \n", short_opt);
 printf ("\nChecking File: %s \n", filename);
 printf ("\nChecking Freq: %lf [MHz] \n", freq);
 printf ("\nChecking Samplerate: %d [Hz] \n", samplerate);
 printf ("\nChecking Modulation: %s \n", mod);
 printf ("\nChecking Callsign: %s \n", callsign);
 printf ("\nChecking Output-Power: %d \n", power);
 printf ("\n&Adresses: argc: %p / Name: %p / File: %p / Freq: %p \nSamplerate: %p / Modulation: %p / Callsign: %p / Power: %p \n", &argc, &argv [0], &filename, &freq, &samplerate, &mod, &callsign, &power);
 printf ("\nGPS-coordinates long: %f , lat: %f , alt: %f  \n", longitude, latitude, altitude);

 /*
		//printf ("\n GPS-Module (Neo-7M) %gps  \n", gps);
		//printf ("\n*Pointers-> argc: %p / Name: %p / File: %p / Freq: %p \nSamplerate: %p / Modulation: %p / Callsign: %p / Power: %p  \n", argc, *argv [0], *filename, freq, samplerate, *mod, *callsign, power);
		//printf ("\nArguments: argc: %d / argv(0): %s / argv(1): %s \nargv(2): %lf / argv(3): %d / argv(4): %s / argv(5): %s / argv(6): %d  \n", argc, argv [0], argv [1], argv [2], argv [3], argv [4], argv [5], argv [6]);
		//printf ("&Adresses-> argc: %p / Name: %p \nFile: %p / Freq: %p \nSamplerate: %p / Modulation: %p / Callsign: %p / Power: %p \n", &argc, &argv [0], &argv [1], &argv [2], &argv [3], &argv [4], &argv [5], &argv [6]);
		//printf ("*Pointers-> argc: %p / Name: %p / File: %p / Freq: %p / Samplerate: %p / Modulation: %p / Callsign: %p / Power: %p  \n", argc, *argv [0], *argv [1], *argv [2], *argv [3], *argv [4], *argv [5], *argv [6]);
		//printf ("\nHostname: %s , WAN+LAN-IP: %s , Port: %d \n", host, ip, port);
		//printf ("\nclient ip+port: %s:%d \n", inet_ntoa (client_addr.sin_addr), (int) ntohs (client_addr.sin_port));
		//printf ("local ip+port: %s:%d \n", inet_ntoa (local.sin_addr), ntohs (local.sin_port));
		*/

 // gathering and parsing all given arguments to parse it to player
 int tx (int argc, char **argv); //transmission

 printf ("\nEnd of Program! Closing... \n"); // EOF
 return 0;
}
